<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="OS - 프로세스" /><meta property="og:locale" content="en" /><meta name="description" content="프로세스" /><meta property="og:description" content="프로세스" /><link rel="canonical" href="https://issuh.github.io/posts/os-ch3/" /><meta property="og:url" content="https://issuh.github.io/posts/os-ch3/" /><meta property="og:site_name" content="My Technical Diary" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-02-14T07:58:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="OS - 프로세스" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2020-02-14T07:58:00+09:00","datePublished":"2020-02-14T07:58:00+09:00","description":"프로세스","headline":"OS - 프로세스","mainEntityOfPage":{"@type":"WebPage","@id":"https://issuh.github.io/posts/os-ch3/"},"url":"https://issuh.github.io/posts/os-ch3/"}</script><title>OS - 프로세스 | My Technical Diary</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="My Technical Diary"><meta name="application-name" content="My Technical Diary"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/img/profile.jpeg " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">My Technical Diary</a></div><div class="site-subtitle font-italic">ISSuh's tech blog</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/aboutme/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT ME</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/ISSuh" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['yoyus5','naver.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>OS - 프로세스</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>OS - 프로세스</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/ISSuh">ISSuh</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1581634680" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2020-02-14 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6021 words"> <em>33 min</em> read</span></div></div></div><div class="post-content"><h1 id="프로세스">프로세스</h1><ol><li><a href="#프로세스-개념"> 프로세스 개념 </a><li><a href="#프로세스-스케쥴링"> 프로세스 스케쥴링 </a><li><a href="#프로세스에-대한-연산"> 프로세스에 대한 연산 </a><li><a href="#프로세스간-통신"> 프로세스간 통신</a></ol><h2 id="프로세스-개념"><span class="mr-2">프로세스 개념</span><a href="#프로세스-개념" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><p>일괄저리 시스템은 <strong>잡(Job)</strong> 들을 실행하는 반면세, 시분할 시스템은 <strong>사용자 프로그램</strong> 또는 <strong>태스크(Task)</strong> 를 가진다. 이와같은 것들을 <strong>프로세스(Process)</strong> 라고 한다.</p><h3 id="프로세스process"><span class="mr-2">프로세스(Process)</span><a href="#프로세스process" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>프로세스란 실행중인 프로그램이다.</p><p>프로세스는 <strong>텍스트 세션</strong> 으로 알려진 프로그램 코드 영역과, <strong>프로그램 카운터</strong> 의 값과 처리지 레지스터의 내용으로 대표되는 현재 활동을 포함한다. 프로세스는 일반적으로 함수의 매개변수, 복귀주소, 로컬 변수와 같은 임시적인 자료를 가지는 프로세스 <strong>스택(Stack)</strong> 영역과 전역변수들을 수록하는 <strong>데이터 섹션</strong> 을 포함한다. 또한 프로세스 실행중 동적으로 할당되는 메모리인 <strong>힙(Heap)</strong> 을 포함한다.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center"><img data-src="https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter3/3_01_Process_Memory.jpg" alt="figure_3.1.1" data-proofer-ignore><tbody><tr><td style="text-align: center"><em>메모리상의 프로세스</em></table></div><ul><li>스택영역은 높은 주소로 부터 낮은 주소로 데이터가 기록한다.<li>힙역역은 낮은 주소로 부터 높은 주소로 데이터를 기록한다.<li>스택영역과 힙영역은 같은 영역을 공유하고 있으며 이는 가변적이다.<li>텍스트영역과 데이터역역은 크기가 고정적이다.</ul><h3 id="프로세스-상태process-state"><span class="mr-2">프로세스 상태(Process State)</span><a href="#프로세스-상태process-state" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>프로세스는 실행되면서 그 상태가 변경된다.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center"><img data-src="https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter3/3_02_ProcessState.jpg" alt="figure_3.1.2" data-proofer-ignore><tbody><tr><td style="text-align: center"><em>프로세스 상태도</em></table></div><ul><li><strong>New</strong><ul><li>프로세스가 생성 중이다.</ul><li><strong>Ready</strong><ul><li>프로세스가 처리기에 할당되기를 기다리는 중이다.</ul><li><strong>Running</strong><ul><li>프로세스가 실행되고 있는 중이다.</ul><li><strong>Waiting</strong><ul><li>프로세스가 어떠한 이벤트를 기다리는 중이다.</ul><li><strong>Terminated</strong><ul><li>프로세스의 실행이 종료된다.</ul></ul><p>어느 한 순간에 한 처리기상에서는 오직 하나의 프로세스만이 <em>실행</em> 된다. 즉 많은 프로세스가 <strong>Waiting</strong> 및 <strong>Ready</strong> 상태에 있다.</p><h3 id="프로세스-제어블록process-control-block"><span class="mr-2">프로세스 제어블록(Process Control Block)</span><a href="#프로세스-제어블록process-control-block" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><div class="table-wrapper"><table><thead><tr><th style="text-align: center"><img data-src="https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter3/3_03_PCB.jpg" alt="figure_3.1.3" data-proofer-ignore><tbody><tr><td style="text-align: center"><em>프로세스 제어 블록(PCB)</em></table></div><ul><li><strong>프로세스 상태(Process State)</strong><ul><li>상태는 <em>New</em>, <em>Ready</em>, <em>Running</em>, <em>Waiting</em>, <em>Terminated</em> 가 있다.</ul><li><strong>프로그램 카운터(Program Counter)</strong><ul><li>이 프로세스가 다음에 실행할 명령어의 주소를 가리킨다.<li>나중에 프로세스가 계속해서 정상적으로 실행될 수 있도록 인터럽트 발생 시, 저장되어야 한다.<li>추후 이 프로세스가 다시 실행 될때, 백업을 받은 후, 프로그램 카운터가 가리키는 부분부터 실행</ul><li><strong>CPU 레지스터들(CPU Registers)</strong><ul><li>누산기, 인덱스 레지스터, 스택 레지스터, 범용 레지스터등 다양한 타입의 CPU 레지스터의 상태 코드를 포함한다.<li>프로그램 카운터와 함께 이 상태 정보는 나중에 프로세스가 계속해서 정상적으로 실행될 수 있도록 인터럽트 발생시, 저장되어야 한다.<li>추후 이 프로세스가 다시 실행 될때, 백업을 받은 후, 중지한 부분부터 실행</ul><li><strong>CPU 스케쥴링 정보(CPU Scheduling Infomation)</strong><ul><li>프로세스 우선순위, 스케쥴 큐에 대한 포인터와 다른 스케쥴 매개변수들을 포함한다.</ul><li><strong>메모리 관리 정보(Memory Management Infomation)</strong><ul><li>OS에 의해 사용되는 메모리 관리 시스템에 따라 기준 레지스터와 한계 레지스터의 값과 같은 정보를 포함한다.<li>OS에 의해 사용되는 메모리 관리 시스템에 따라 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함한다.</ul><li><strong>회계 정보(Accounting Infomation)</strong><ul><li>CPU 사용 시간과 경과된 실시간, 시간 제한, 제정 정보, 프로세스 번호 등을 포함한다.</ul><li><strong>입출력 상태 정보(I/O State Infomation)</strong><ul><li>프로세스에 의해 할당된 입출력 장치들과 열린 파일의 목록 등을 포함한다.</ul></ul><div class="table-wrapper"><table><thead><tr><th style="text-align: center"><img data-src="https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter3/3_04_ProcessSwitch.jpg" alt="figure_3.1.4" data-proofer-ignore><tbody><tr><td style="text-align: center"><em>프로세스에서 다른 프로세스로 CPU가 전환되는 흐름도</em></table></div><h3 id="스레드thread"><span class="mr-2">스레드(Thread)</span><a href="#스레드thread" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>현대의 대부분의 OS는 프로세스의 개념을 확장하여 한 프로세스가 다수의 실행 스레드를 가질 수 있도록 허용한다. 즉, 하나의 프로세스가 다수의 스레드를 가짐으로서 하나 이상의 일을 수행 할 수 있도록 한다.</p><p>스레드를 지원하는 시스템에서의 <strong>PCB</strong> 는 각 스레드에 관한 정보를 포함하도록 확장된다.</p><h2 id="프로세스-스케쥴링"><span class="mr-2">프로세스 스케쥴링</span><a href="#프로세스-스케쥴링" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><p>다중 프로그래밍의 목적은 CPU 이용을 최대화 하기 위해 항상 어떤 프로세스가 실행되도록 하는데 있다. 시분할의 목적은 각 프로그램이 실행되는 동안 사용자가 상호 작용할 수 있도록 프로세스들 사이에서 CPU를 빈번하게 교체하는 것이다. 이러한 목적을 달성하기 위해 <strong>프로세스 스케쥴러(Process Scheduler)</strong> 는 CPU에서 실행 가능한 여러 프로세스등 중에서 하나의 프로세스를 선택하여 실행한다.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center"><img data-src="https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter3/3_05_LinuxProcesses.jpg" alt="figure_3.2.1" data-proofer-ignore><tbody><tr><td style="text-align: center"><em>Linux에서의 프로세스 표현</em></table></div><h3 id="스케쥴링-큐scheduling-queue"><span class="mr-2">스케쥴링 큐(Scheduling Queue)</span><a href="#스케쥴링-큐scheduling-queue" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>프로세스가 시스템에 들어오면, 이들은 <strong>잡 큐(Job Queue)</strong> 에 놓여진다. 이 큐는 시스템 안의 모든 프로세스로 구성되어 있다. 주 메모리에 존재하며, <em>준비 완료 상태(Ready State)</em>에서 실행을 대기하는 프로세스들은 <strong>준비 완료 큐(Ready Queue)</strong> 라 불리는 리스트 상에 유지된다.</p><p>Ready Queue는 일반적으로 Linked List로 저장되어 지며, Ready Queue의 헤더는 리스트의 첫번째와 마지막 PCB를 가리키는 포인터를 포함한다. 각 PCB는 Ready Queue에 있는 다음 프로세스를 가리키는 포인터 필드를 가진다.</p><p>특정 입출력 장치를 대기하는 프로세스들의 리스트를 <strong>장치 큐(Device Queue)</strong> 라고 한다.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center"><img data-src="https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter3/3_05_Queues.jpg" alt="figure_3.2.1" data-proofer-ignore><tbody><tr><td style="text-align: center"><em>Ready Queue와 다양한 Device Queue</em></table></div><p>프로세스 프케쥴링의 공통적인 표현 방신은 아래와 같은 <strong>큐잉 도표(Queueing Diagram)</strong> 이다.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center"><img data-src="https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter3/3_06_QueueingDiagram.jpg" alt="figure_3.2.2" data-proofer-ignore><tbody><tr><td style="text-align: center"><em>프로세스 스케쥴링을 표현하는 Queueing 도표</em></table></div><p>새로운 프로세스는 처름에 Ready Queue에 놓인다. 프로세스는 실행을 위해 선택될 때, 즉 CPU를 <strong>할당받을(Dispatch)</strong> 때 까지 Ready Queue에서 대기한다. 일단 프로세스에 CPU가 할당되어 실행되며느 여러가지 일중 하나가 발생할 수 잇다.</p><ul><li>프로세스가 입출력 요청을 하여 입출력 큐에 넣어질수 있다.<li>프로세스가 새로운 자식 프로세스를 생성하고 자식 프로세스의 종료를 기다릴 수 있다.<li>프로세스가 인터럽트의 결과에 의해 강제로 CPU로부터 제거되고, Ready Queue에 다시 놓여질 수 있다.</ul><p>프로세스는 종료될 때까지 이 주기를 반복하며, 종료되면 모든 큐에서 삭제되고 그 자신의 PCB와 자원을 반납한다.</p><h3 id="스케쥴러schedulers"><span class="mr-2">스케쥴러(Schedulers)</span><a href="#스케쥴러schedulers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>프로세스는 일생동안에 다양한 스케쥴링 큐들 사이를 여행한다. OS는 어떤 방식으로든지 스케쥴링 목적을 위해 프로세스들을 큐에서 반드시 선택해야 한다. 선택절차는 적절한 <strong>스케쥴러(Schedulers)</strong> 에 의해 선택된다.</p><p>프로세스들은 대용량 메모리(전형적으로 디스크)에 저장되어 나중에 실행될 때 까지 유지된다.</p><p><strong>장기 스케쥴러(Long-term Scheduler) 또는 잡 스케쥴러</strong> 는 이 디스크에서 프로세스들을 선택하여 실행 하기 위해 메모리로 적재한다. <strong>단기 스케쥴러(Short-term Scheduler) 또는 CPU 스케쥴러</strong> 는 실행 준비가 완료되어 있는 프로세스들 중에서 선택하여, 이들 중 하나에게 CPU를 할당한다.</p><p>장기 스케쥴러는 <strong>다중 프로그래밍 정도(메모리에 있는 프로세스들의 수)</strong> 를 제어한다. 즉 몇개의 프로세스를 메모리에 적재 시킬 것인지 제어한다.</p><p><strong>입출력 중심의 프로세스</strong> 는 연산보다 입출력 실행에 더 많은 시간을 소요하는 프로세스 이다. 반면에 <strong>CPU 중싱 프로세스</strong> 는 입출력 중심 프로세스보다 연산에 시간을 더 소요하여, 입출력 요청을 드물게 발생시키는 프로세스 이다.</p><p>장기 스케쥴러는 입출력 중심과 CPU 중심 프로세스들의 적절한 <em>프로세스 혼합(mix)</em> 을 선택하는 것이 중요하다.</p><p>UNIX와 Windows와 같은 시분할 시스템들은 장기 스케쥴러가 없으며, 모든 새로운 프로세스를 단기 스케쥴러를 위해 단순히 메모리에 넣는다.</p><p>시분할 시스템과 같은 일부 OS들은 추가로 중간수준의 스케쥴링, 즉 <strong>중기 스케쥴러(Medium-term Scheduler)</strong> 를 가진다.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center"><img data-src="https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter3/3_07_QueuingDiagram2.jpg" alt="figure_3.2.3" data-proofer-ignore><tbody><tr><td style="text-align: center"><em>Queueing 도표에 중기 스케쥴링을 포함</em></table></div><p>중기 스케쥴어의 핵심 아이디어는 메모리에서 프로세스들을 제거함으로써 다중 프로그래밍의 정도를 완화하는 것이 가끔 바람직할 수 있다는 것이다. 즉 차후에 다시 프로세스를 메모리로 불러와서 중단되었던 지점에서 실행을 재개한다. 이러한 기법을 <strong>스와핑(Swapping)</strong> 이라 한다. 프로세스는 중기 스케쥴러에 의해 스왑되어 다가고 다시 스왑되어 들어온다.</p><h3 id="문맥교환context-switch"><span class="mr-2">문맥교환(Context Switch)</span><a href="#문맥교환context-switch" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>인터럽트가 발생하면 시스템은 인터럽트 처리가 끝난 후에 <strong>문맥(Context)</strong> 을 복구할 수 있도록 현재 실행 중인 프로세스의 현재 문맥을 저장할 필요가 있다.</p><p>문맥은 프로세스의 PCB에 표현된다.</p><p>문맥은 CPU의 레지스터 값, 프로세스 상태, 메모리 관리 정보 등을 포함한다.</p><p>일반적으로 커널 모드이건, 사용자 모드이건 CPU의 현재 상태를 저장하는 작업을 수행하고(<strong>State Save</strong>), 나중에 연산을 재개하기 위해 상태 복구 작업을 수행한다(<strong>State Restore</strong>).</p><p>CPU를 다른 프로세스로 교환하려면 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 보관된 상태를 복구하는 작업이 필요하다. 이 작업을 <strong>문맥 교환(Context Switch)</strong> 라고 한다.</p><p>문맥 교환이 일어나면 커널은 과거 프로세스의 문맥을 PCB에 저장하고, 선택된 새로운 프로세스의 저장된 문맥을 복구한다.</p><p>문맥 교환이 진행될 동안 시스템이 아무런 유용한 일을 하지 못하기 때문에 문맥 교환 시간은 순수한 <em>오버헤드</em> 이다.</p><h2 id="프로세스에-대한-연산"><span class="mr-2">프로세스에 대한 연산</span><a href="#프로세스에-대한-연산" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><p>대부분 시스템 내의 프로세스들은 병행 실행될 수 있으며, 반드시 동적으로 생성되고 제거 되어야 한다.</p><p>기본적으로 부모 자식간의 프로세스라도 하더라도 프로세스는 서로 독립적이다.</p><h3 id="프로세스-생성process-creation"><span class="mr-2">프로세스 생성(Process Creation)</span><a href="#프로세스-생성process-creation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>생성하는 프로세스를 <em>부모 프로세스(Parent Process)</em>라고 하고, 생성되는 프로세스를 <em>자식 프로세스(Child Process)</em> 라고 한다. 즉 프로세스는 다른 프로세스를 생성할 수 있으며 그 결과, 프로세스의 트리를 형성한다.</p><p>대부분의 현대의 OS들은 유일한 <strong>프로세스 식별자(PID)</strong> 를 사용해 프로세스를 구분하는데, 일반적으로 특정 정수를 각 프로세스에 할달하여 프로세스에게 고유한 값을 가지도록 한다.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center"><img data-src="https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter3/3_08_ProcessTree.jpg" alt="figure_3.3.1" data-proofer-ignore><tbody><tr><td style="text-align: center"><em>일반적은 Linux 시스템의 프로세스 트리</em></table></div><p>일반적으로 프로세스가 자식 프로세스를 생성할 때, 그 자식 프로세스는 자신의 일을 달성하기 위해 어떤 자원(CPU 시간, 메모리, 파일, 입출력 장치 등)이 필요하다. 자식 프로세스는 이 자원을 OS로 부터 직접 얻거나, 부모 프로세스가 가진 자원의 부분 집합만을 사용하도록 제한될 수 있다. 부모 프로세스는 자원을 분할하여 자식 프로세스들에게 나우어 주거나 메모리나 파일과 같은 몇몇 자원들은 자식 프로세스들이 같이 사용하게 할 수도 있다.</p><p>프로세스가 새로운 프로세스를 생성할 때, 두 프로세스를 실행시키는 데 두 가지 가능한 방법이 존재한다.</p><ul><li>부모는 자식과 병행하게 실행을 계속한다.<li>부모는 일부 또는 모든 자식이 실행을 종료할 때까지 기다린다.</ul><p>새로운 프로세스들의 주소 공간 측면에서 볼대 아래와 같이 두가지 가능성이 있다.</p><ul><li>자식 프로세스는 부모 프로세스의 복사본이다.(자식 프로세스는 부모와 똑같은 프로그램과 데이터를 가진다.)<li>자식 프로세스가 자신에게 적재될 새로운 프로그램을 가지고 있다.</ul><div class="table-wrapper"><table><thead><tr><th style="text-align: center"><img data-src="https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter3/3_10_ProcessCreation.jpg" alt="figure_3.3.2" data-proofer-ignore><tbody><tr><td style="text-align: center"><em>Linux의 fork() 시스템 콜을 통한 프로세스 생성</em></table></div><h3 id="프로세스-종료process-termination"><span class="mr-2">프로세스 종료(Process Termination)</span><a href="#프로세스-종료process-termination" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>프로세스 종료에는 크게 두가지가 있다.</p><ul><li>프로세스가 마지막 문장의 실행을 끝내고, exit 시스템 호출을 사용하여 OS에게 자신의 삭제를 요청한다.<li>한 프로세스는 적당한 시스템 호출을 통해, 다른 프로세스의 종료를 유발할 수 있다. 일반적으로, 그런 시스템 호출은 단지 종료될 프로세스의 부모만이 호출할 수 있다.</ul><h2 id="프로세스간-통신"><span class="mr-2">프로세스간 통신</span><a href="#프로세스간-통신" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><p>OS내에서 실행되는 병행 프로세스들은 <em>독립적</em> 이거나 <em>협력적</em> 인 프로세스들 일수 있다.</p><p>프로세스 협렵을 허용하는 환경을 제공하는 데는 아래와 같은 이유가 있다.</p><ul><li><strong>정보 공유(Information Sharing)</strong><ul><li>여러 사용자가 동일한 정보(ex 공유 파일)에 접근할 경우가 있을수 있으므로, 그러한 정보를 병행적으로 접근할 수 있는 환경을 제공해야 한다.</ul><li><strong>계산 가속화(Computation Accelation)</strong><ul><li>특정한 태스크를 여러 서브 태스크로 나누어, 각각이 다른 서브 태스크들과 병렬로 실행되도록 한다.<li>다수의 처리 코어를 가져야만 가능하다.</ul><li><strong>모듈성(Modularity)</strong> -시스템의 기능을 별도의 프로세스들 또는 스레들로 나누어, 모듈식 형태로 시스템을 구성하도록 한다.<li><strong>편의성(Convenience)</strong><ul><li>개별 사용자들이 한 순간에 작업할 많은 태스크를 가질 수도 있다.</ul></ul><p>위와 같은 협렵적 프로세스들은 데이터와 정보를 교환할 수 있는 <strong>프로세스간 통신(InterProcess Communication)</strong> 기법을 필요로 한다.</p><p>프로세스간 통신에는 기본적으로 <strong>공유 메모리(Shared Memory)</strong> 와 <strong>메시지 전달(Message Passing)</strong>, 두가지 방식이 있다.</p><ul><li><strong>Shared Memory model</strong><ul><li>협력 프로세스들에 의해 공유되는 메모리 영역이 구축된다.<li>공유 메모리 영역을 구축할 때만 시스템 콜이 필요하다. 공유 메모리 영역이 구축되면, 모든 접근은 일반적인 메모리 접근으로 취급되어 커널의 도움이 필요없다.<li>메시지 전달 방식보다 빠르다.<li>멀티코어 시스템에서 공유 메모리는 공유 데이터가 여러 캐시 사이에서 이주하기 때문에 발생하는 캐시 일관성 문제로 인해 성능 저하가 발생한다.</ul><li><strong>Message Passing model</strong><ul><li>협력 프로세스들 사이에 통신을 통해 메시지를 교환하여 이루어 진다.<li>충돌을 회피할 필요가 없기 때문에 적은 양의 데이터를 교환하는데 유용하다.<li>공유 메모리 방식보다 구현이 용이하다.<li>메시지를 전달할때, 통상적으로 시스템 콜을 사용하여 구현되므로, 커널 간섭 등의 부가적인 시간 소비 작업이 필요하다.</ul></ul><div class="table-wrapper"><table><thead><tr><th style="text-align: center"><img data-src="https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter3/3_12_CommunicationsModels.jpg" alt="figure_3.4.1" data-proofer-ignore><tbody><tr><td style="text-align: center"><em>통신 모델. (a) 메시지 전달. (b) 공유 메모리</em></table></div><div class="table-wrapper"><table><thead><tr><th style="text-align: center"><img data-src="https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter3/3_ChromeBrowserArchitecture.jpg" alt="figure_3.4.2" data-proofer-ignore><tbody><tr><td style="text-align: center"><em>다중프로세스 구조 - Chrome 브라우저</em></table></div><h3 id="공유-메모리-시스템shared-memory-system"><span class="mr-2">공유 메모리 시스템(Shared Memory System)</span><a href="#공유-메모리-시스템shared-memory-system" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>통상 공유 메모리 영역은 공유 메모리 세그먼트를 생성하는 프로세스의 주소 공간에 위치한다. 이 공유 메모리 세그먼트를 이용하여 통신하고자 하는 다른 프로세스들은 이 세그먼트를 자신의 주소 공간에 추가하여야 한다.</p><p>프로세스들은 동시에 동일한 위치에 쓰지 않도록 책임져야 한다.</p><p>생산자와 소비자가 반드시 <em>동기화(Synchronize)</em> 되어야 생산되지도 않은 항목들을 소비자가 소비하려도 시도하지 않을 것이다.</p><p>일반적으로 두 가지 유형의 버퍼가 사용된다.</p><ul><li><strong>무한 버퍼(Unbounded Buffer)</strong><ul><li>생산자 소비자 문제 에서는 버퍼의 크기에 실질적인 한계가 없다.</ul><li><strong>유한 버퍼(Bounded Buffer)</strong><ul><li>버퍼의 크기가 고정되어 있으므로, 버퍼가 비어있다면 소비자는 반드시 대기하여야 하며, 버퍼가 가득 찼으면 생산자가 대기하여야 한다.</ul></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>    <span class="c1">// 공유 메모리 사이의 유한 버퍼</span>
    <span class="cp">#define BUFFER_SIZE 10
</span>
    <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
         <span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
    <span class="p">}</span> <span class="n">item</span><span class="p">;</span>

    <span class="n">item</span> <span class="n">buffer</span><span class="p">[</span> <span class="n">BUFFER_SIZE</span> <span class="p">];</span>
    <span class="kt">int</span> <span class="n">in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></table></code></div></div><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre>    <span class="c1">// 공유 메모리를 사용한 생산자 프로세스</span>
    <span class="n">item</span> <span class="n">nextProduced</span><span class="p">;</span>

    <span class="k">while</span><span class="p">(</span> <span class="nb">true</span> <span class="p">)</span> <span class="p">{</span>

        <span class="cm">/* Produce an item and store it in nextProduced */</span>
        <span class="n">nextProduced</span> <span class="o">=</span> <span class="n">makeNewItem</span><span class="p">(</span> <span class="p">.</span> <span class="p">.</span> <span class="p">.</span> <span class="p">);</span>

        <span class="cm">/* Wait for space to become available */</span>
        <span class="k">while</span><span class="p">(</span> <span class="p">(</span> <span class="p">(</span> <span class="n">in</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="o">%</span> <span class="n">BUFFER_SIZE</span> <span class="p">)</span> <span class="o">==</span> <span class="n">out</span> <span class="p">)</span>
              <span class="p">;</span> <span class="cm">/* Do nothing */</span>

        <span class="cm">/* And then store the item and repeat the loop. */</span>
        <span class="n">buffer</span><span class="p">[</span> <span class="n">in</span> <span class="p">]</span> <span class="o">=</span> <span class="n">nextProduced</span><span class="p">;</span>
        <span class="n">in</span> <span class="o">=</span> <span class="p">(</span> <span class="n">in</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="o">%</span> <span class="n">BUFFER_SIZE</span><span class="p">;</span>

    <span class="p">}</span>
</pre></table></code></div></div><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre>    <span class="c1">// 공유 메모리를 사용한 소비자 프로세스</span>

    <span class="n">item</span> <span class="n">nextConsumed</span><span class="p">;</span>

    <span class="k">while</span><span class="p">(</span> <span class="nb">true</span> <span class="p">)</span> <span class="p">{</span>

        <span class="cm">/* Wait for an item to become available */</span>
        <span class="k">while</span><span class="p">(</span> <span class="n">in</span> <span class="o">==</span> <span class="n">out</span> <span class="p">)</span>
              <span class="p">;</span> <span class="cm">/* Do nothing */</span>

        <span class="cm">/* Get the next available item */</span>
        <span class="n">nextConsumed</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span> <span class="n">out</span> <span class="p">];</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">(</span> <span class="n">out</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="o">%</span> <span class="n">BUFFER_SIZE</span><span class="p">;</span>

        <span class="cm">/* Consume the item in nextConsumed
             ( Do something with it ) */</span>

    <span class="p">}</span>
</pre></table></code></div></div><h3 id="메시지-전달-시스템message-passing-system"><span class="mr-2">메시지 전달 시스템(Message Passing System)</span><a href="#메시지-전달-시스템message-passing-system" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>메시지 전달 시스템은 최소한 두가지 연산을 제공한다.</p><ul><li>Send<li>Receive</ul><p>하나의 링크과 send()/receive() 연산을 논리적으로 구현하는 다수의 방법은 아래와 같다.</p><ul><li>직접 또는 간접 통신<li><strong>동기식(Sync)</strong> 도는 <strong>비동기식(Async)</strong> 통신<li>자동 도는 명시적 버퍼링</ul><h4 id="명명naming"><span class="mr-2">명명(Naming)</span><a href="#명명naming" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>통신을 원하는 프로세스들은 서로를 가리킬 수 있는 방법이 있어야 한다. 이들은 <em>간접통신</em> 또는 <em>직접통신</em>을 할 수 있다.</p><h5 id="직접-통신"><span class="mr-2">직접 통신</span><a href="#직접-통신" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>직접통신 하에서, 통신을 원하는 각 프로세스는 통신의 수신자 또는 송신자의 이름을 명시해야 한다.</p><ul><li>send(P, message)<ul><li>프로세스 P에게 메시지를 전송한다.</ul><li>receive(Q, message)<ul><li>프로세스 Q에게 메시지를 수신한다.</ul></ul><p>이 기법에서 통신 연결은 다음과 같은 특성을 가진다.</p><ul><li>통신을 원하는 각 프로세스의 쌍들 사이에 연결이 자동적으로 구축된다. 프로세스들은 통신하기 위해 서로 상대방의 신원만 알면 된다.<li>연결은 정확히 두 프로세스들 사이에만 연관된다.<li>통신하는 프로세스들의 각 쌍 사이에는 정확하게 하나의 연결이 존재해야 한다.</ul><p>이 기법은 주소 방식에서 <strong>대칭성</strong> 을 보인다. 즉, 송신자와 수신자 프로세스가 모두 통신 하려면 상대방의 이름을 제시하여야 한다.</p><p>이 기법의 변형으로서 주소 지정 시에 <strong>비대칭</strong> 을 사용할 수 있다. 송신자만 수신자 이름을 지명하며, 수신자는 송신자의 이름을 제시할 필요가 없다.</p><ul><li>send(P, message)<ul><li>메시지를 프로세스 P에 전송한다.</ul><li>receive(id, message)<ul><li>임의의 프로세스로 부터 메시지를 수신한다. 변수 id는 통신을 발생시킨 프로세스의 이름으로 설정된다.</ul></ul><h5 id="간접-통신"><span class="mr-2">간접 통신</span><a href="#간접-통신" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5></h5><p>메시지들은 <strong>메일 박스(Mailbox)</strong> 또는 <strong>포트(Port)</strong>로 송신되고, 그곳으로부터 수신된다.</p><p>메일박스는 추상적으로, 프로세스들에 의해 메시지들이 넣어지고, 메시지들이 제거될 수 있는 객체하라고도 볼 수 있다.</p><ul><li>send(A, message)<ul><li>메시지를 메일박스 A로 송신한다.</ul><li>receive(A, message)<ul><li>메시지를 메일박스 A로 부터 수신한다.</ul></ul><h4 id="동기화synchronization"><span class="mr-2">동기화(Synchronization)</span><a href="#동기화synchronization" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>프로세스간 통신은 send와 receive 프리미티브에 대한 호출에 의해 발생한다.</p><p>메시지 전달은 <strong>봉쇄형(Blocking)</strong> 이거나 <strong>비봉쇄형(Non Blocking)</strong> 방식으로 전달된다.</p><ul><li><strong>Blocking Send</strong><ul><li>송신하는 프로세스는 메시지가 수신 프로세스 또는 메일박스에 의해 수신될 때까지 block 된다.</ul><li><strong>Non Blocking Send</strong><ul><li>송신하는 프로세스가 메시지를 보내고 이후 작업을 재개 한다.</ul><li><strong>Blocking Receive</strong><ul><li>메시지가 이용 가능할 때까지 수신 프로세스가 block 된다.</ul><li><strong>Non Blocking Receive</strong><ul><li>송신하는 프로세스가 유효한 메시지 도는 null을 받는다.</ul></ul><div class="table-wrapper"><table><thead><tr><th style="text-align: center"><img data-src="https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter3/3_15_16_MessagePassing.jpg" alt="figure_3.4.2" data-proofer-ignore><tbody><tr><td style="text-align: center"><em>메시지 전달을 사용한 소비자 프로세스</em></table></div><h4 id="버퍼링buffering"><span class="mr-2">버퍼링(Buffering)</span><a href="#버퍼링buffering" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>통신하는 프로세스들에 의해 교환되는 메시지는 임시 큐에 들어 있다.</p><ul><li><strong>무용량(Zero Capacity)</strong><ul><li>링크는 자체 안에 대기하는 메시지들을 가질수 없다.<li>송신자는 수신자가 메시지를 수신할 때 까지 기다린다.</ul><li><strong>유한 용량(Bounded Capacity)</strong><ul><li>큐는 유한한 길이 n을 가진다.<li>큐가 가득 차게되면 송신자는 큐 안이 이용 가능할 때까지 봉쇄되어야 한다.</ul><li><strong>무한 용량(Unbounded Capacity)</strong><ul><li>큐는 잠재적으로 무한한 길이를 가진다.<li>송신자는 결코 봉쇄되지 않는다.</ul></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/operating-system/'>Operating System</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/os/" class="post-tag no-text-decoration" >OS</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=OS - 프로세스 - My Technical Diary&amp;url=https://issuh.github.io/posts/os-ch3/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=OS - 프로세스 - My Technical Diary&amp;u=https://issuh.github.io/posts/os-ch3/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://issuh.github.io/posts/os-ch3/&amp;text=OS - 프로세스 - My Technical Diary" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/educative-distributed-system-10/">Distributed Systems - Coordination Patterns</a><li><a href="/posts/educative-distributed-system-04/">Distributed Systems - CAP</a><li><a href="/posts/educative-distributed-system-03/">Distributed Systems - Replication</a><li><a href="/posts/my_project_simpledb/">simpleDB - 메모리</a><li><a href="/posts/ps-hackerrank-01/">HackerRandk - Fraudulent Activity Notifications</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ps/">PS</a> <a class="post-tag" href="/tags/leetcode/">Leetcode</a> <a class="post-tag" href="/tags/programmers/">Programmers</a> <a class="post-tag" href="/tags/spring-framework/">Spring Framework</a> <a class="post-tag" href="/tags/web/">Web</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/hash/">Hash</a> <a class="post-tag" href="/tags/database/">DataBase</a> <a class="post-tag" href="/tags/tree/">Tree</a> <a class="post-tag" href="/tags/array/">Array</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/os-ch1/"><div class="card-body"> <em class="timeago small" data-ts="1581370440" > 2020-02-11 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>OS - 개요</h3><div class="text-muted small"><p> 개요 운영체제가 하는 일 컴퓨터 시스템의 구성 컴퓨터 시스템의 구조 운영체제의 구조 운영체제의 연산 프로세스 관리 메모리 관리 저장장치 관리 운영체제가 하는 일 컴퓨터 시스템은 대게 네 가지 구성 요소인 하드웨어, 운영체제, 응용 프로그램, 사용자 로 구분할 수 있다. 하드웨어 는 ...</p></div></div></a></div><div class="card"> <a href="/posts/os-ch2/"><div class="card-body"> <em class="timeago small" data-ts="1581541740" > 2020-02-13 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>OS - 시스템 구조</h3><div class="text-muted small"><p> 시스템 구조 운영체제 서비스 시스템 호출 시스템 호출의 유형 시스템 프로그램 운영체제 설계 및 구현 운영체제 구조 운영체제 서비스 운영체제는 프로그램의 실행 환경을 제공한다. 운영체제가 사용자에게 제공하는 서비스의 종류 사용자 인터페이스(User Interface) Com...</p></div></div></a></div><div class="card"> <a href="/posts/os-ch4/"><div class="card-body"> <em class="timeago small" data-ts="1581973020" > 2020-02-18 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>OS - 스레드</h3><div class="text-muted small"><p> 스레드 개요 다중코어 프로그래밍 다중 스레드 모델 암묵적 스레딩 스레드 이슈 운영체제 사례 개요 스레드는 CPU 이용의 기본단위이다. 스레드는 스레드 ID, 프로그램 카운터, 레지스터 집합, 스택 으로 구성된다. 스레드는 같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션 그리고 열린 파일이...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/os-ch2/" class="btn btn-outline-primary" prompt="Older"><p>OS - 시스템 구조</p></a> <a href="/posts/ps-leetcode-1114/" class="btn btn-outline-primary" prompt="Newer"><p>LeetCode - 1114. Print in Order</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/ISSuh">ISSuh</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ps/">PS</a> <a class="post-tag" href="/tags/leetcode/">Leetcode</a> <a class="post-tag" href="/tags/programmers/">Programmers</a> <a class="post-tag" href="/tags/spring-framework/">Spring Framework</a> <a class="post-tag" href="/tags/web/">Web</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/hash/">Hash</a> <a class="post-tag" href="/tags/database/">DataBase</a> <a class="post-tag" href="/tags/tree/">Tree</a> <a class="post-tag" href="/tags/array/">Array</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-157715138-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-157715138-1'); }); </script>

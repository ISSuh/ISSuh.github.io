[ { "title": "Grokking Modern System Design - Load Balancer", "url": "/posts/educative-grokking-modern-system-design-04/", "categories": "System Design, Grokking Modern System Design", "tags": "System Design, Grokking Modern System Design", "date": "2024-06-18 22:20:00 +0900", "snippet": "Load Balancer 란 무엇인가?로드 밸런서의 임무는 사용 가능한 서버 풀에서 모든 클라이언트의 요청을 공정하게 나누는 것이다.로드 밸런서는 서버 과부하나 충돌을 방지하기 위해 이 작업을 수행한다.로드 밸런싱 계층은 방화벽 다음으로 데이터 센터 내에서 첫 번째 접촉 지점이다.서비스가 초당 수백 또는 수천 개의 요청을 처리하는 경우 로드 밸런서는 필요하지 않을 수 있다.그러나 증가하는 클라이언트 요청을 위해 로드 밸런서는 다음 기능을 제공한다. 확장성 서버 추가를 통해 애플리케이션/서비스의 용량을 원활하게 늘릴 수 있게 함 가용성 일부 서버가 다운되거나 장애가 발생하더라도 시스템은 계속 사용 가능하게 함 성능 로드가 적은 서버로 요청을 전달할 수 있으므로 사용자는 더 빠른 응답 시간을 얻을 수 있게 함 로드 밸런서 배치일반적으로 LB는 클라이언트와 서버 사이에 위치한다.그러나 로드 밸런서가 사용되는 유일한 지점은 아니다.로드 밸런서가 제공하는 서비스LB는 서비스의 확장성, 가용성 및 성능을 향상할 뿐만 아니라 다음과 같은 몇 가지 주요 서비스도 제공한다. 상태 확인 LB는 하트비트 프로토콜을 사용하여 최종 서버의 상태와 안정성을 모니터링 한다. TLS 종료 LB는 클라이언트와의 TLS 종료를 처리하여 최종 서버의 부담을 줄인다. 예측 분석 LB는 자신을 통과하는 트래픽에 대한 분석을 수행하거나 시간에 따라 얻은 트래픽 통계를 사용하여 트래픽 패턴을 예측할 수 있다. 인간 개입 감소 LB 자동화로 인해 장애 처리에 필요한 시스템 관리 노력이 줄어든다. 서비스 검색 LB의 장점은 서비스 레지스트리에 요청하여 클라이언트의 요청이 적절한 호스팅 서버로 전달된다는 것이다. 보안 LB는 OSI 모델의 여러 계층(3, 4, 7 계층) 에서 서비스 거부(DoS) 와 같은 공격을 완화하여 보안을 향상할 수도 있다. 전체적으로 로드 밸런서는 시스템의 전체 설계에 유연성, 신뢰성, 중복성 및 효율성을 제공한다.로드 밸런서의 알고리즘로드 밸런서는 알고리즘에 따라 클라이언트 요청을 분산하며 일부 잘 알려진 알고리즘은 다음과 같다. 라운드 로빈 스케줄링 : 이 알고리즘에서는 각 요청이 반복되는 순차적 방식으로 풀의 서버로 전달된다. 가중 라운드 로빈 : 일부 서버의 클라이언트 요청 처리 능력이 더 높은 경우 가중 라운드 로빈 알고리즘을 사용하는 것이 좋다. 가중치가 부여된 라운드 로빈 알고리즘에서는 각 노드에 가중치가 할당된다. LB는 노드의 가중치에 따라 클라이언트의 요청을 전달한다. 가중치가 높을수록 할당량이 많아진다. 최소 연결 : 어떤 경우에는 모든 서버가 클라이언트에 서비스를 제공할 수 있는 동일한 용량을 갖고 있더라도 특정 서버의 부하가 고르지 않을 수 있다. 예를 들어 일부 클라이언트에는 서비스를 제공하는 데 더 오랜 시간이 걸리는 요청이 있을 수 있으며 일부 클라이언트는 동일한 연결에 대한 후속 요청을 가질 수도 있다. 이 경우 새로운 도착 요청이 기존 연결 수가 적은 서버에 할당되는 최소 연결과 같은 알고리즘을 사용할 수 있다. LB는 이러한 시나리오에서 기존 연결의 수와 매핑 상태를 유지한다. 최소 응답 시간 : 성능에 민감한 서비스에서는 최소 응답 시간과 같은 알고리즘이 필요하다. 이 알고리즘은 응답 시간이 가장 짧은 서버가 클라이언트에 서비스를 제공하도록 요청한다. IP 해시 : 일부 애플리케이션은 IP 주소를 기반으로 사용자에게 다른 수준의 서비스를 제공한다. 이 경우 사용자의 요청을 서버에 할당하기 위해 IP 주소 해싱이 수행된다. URL 해시 : 애플리케이션 내의 일부 서비스는 특정 서버에서만 제공될 수 있다. 이 경우 URL에서 서비스를 요청하는 클라이언트는 특정 클러스터 또는 서버 집합에 할당된다. 이러한 시나리오에서는 URL 해싱 알고리즘이 사용된다.정적 알고리즘과 동적 알고리즘알고리즘은 시스템 상태에 따라 정적이거나 동적일 수 있다.정적 알고리즘은 서버의 상태 변경을 고려하지 않는다.따라서 작업 할당은 서버 구성에 대한 기존 지식을 기반으로 수행된다.당연히 이러한 알고리즘은 복잡하지 않으며 모든 요청이 도착하는 단일 라우터나 상용 시스템에서 구현된다.동적 알고리즘은 서버의 현재 또는 최근 상태를 고려하는 알고리즘이다.동적 알고리즘은 서버와 통신하여 상태를 유지하므로 통신 오버헤드가 추가된다.상태 유지 관리는 알고리즘 설계를 훨씬 더 복잡하게 만든다.상태 저장 및 상태 비저장 로드 밸런서세션 정보가 하위 계층(분산 캐시 또는 데이터베이스)에 보관되지 않는 경우 로드 밸런서를 사용하여 세션 정보를 유지한다.상태 저장 로드 밸런싱 에는 클라이언트와 호스팅 서버 간에 설정된 세션 상태를 유지하는 작업이 포함된다.기본적으로 상태 저장 LB는 수신 클라이언트를 호스팅 서버에 매핑하는 데이터 구조를 유지한다.상태 저장 LB는 모든 클라이언트의 세션 정보가 모든 로드 밸런서에서 유지 관리되므로 복잡성이 증가하고 확장성이 제한된다. 즉, 로드 밸런서는 전달 결정을 내리기 위해 상태 정보를 서로 공유한다.무상태 로드 밸런싱 에는 상태를 유지하지 않으므로 더 빠르고 가볍다.상태 비저장 LB는 일관된 해싱을 사용하여 전달 결정을 내린다.그러나 인프라가 변경되면(예: 새로운 애플리케이션 서버 합류) 일관된 해싱만으로는 요청을 올바른 애플리케이션 서버로 라우팅하는 데 충분하지 않기 때문에 상태 비저장 LB는 상태 저장 LB만큼 탄력적이지 않을 수 있다.따라서 일관된 해싱과 함께 로컬 상태가 여전히 필요할 수 있다.로드 밸런서 유형요구 사항에 따라 OSI(개방형 시스템 상호 연결) ​​계층 의 네트워크/전송 및 애플리케이션 계층에서 로드 밸런싱을 수행할 수 있다. 레이어 4 로드 밸런서 레이어 4는 TCP 및 UDP와 같은 전송 프로토콜을 기반으로 수행되는 로드 밸런싱을 나타냄 L4 LB는 클라이언트와의 연결/세션을 유지하고 동일한(TCP/UDP) 통신이 동일한 백엔드 서버로 전달되도록 함 레이어 7 로드 밸런서 레이어 7 로드 밸런서는 애플리케이션 레이어 프로토콜의 데이터를 기반으로 함 HTTP 헤더, URL, 쿠키 및 기타 애플리케이션별 데이터(예: 사용자 ID)를 기반으로 애플리케이션 인식 전달 결정을 내릴 수 있음 TLS 종료 수행 외에도 이러한 LB는 속도 제한 사용자, HTTP 라우팅, 헤더 재작성 등의 작업을 수행할 수 있음 참고 Grokking Modern System Design Interview for Engineers &amp;amp; Managers" }, { "title": "Grokking Modern System Design - DNS", "url": "/posts/educative-grokking-modern-system-design-03/", "categories": "System Design, Grokking Modern System Design", "tags": "System Design, Grokking Modern System Design", "date": "2024-06-18 22:20:00 +0900", "snippet": "DNS란 무엇인가?DNS(Domain Name System)는 인간에게 친숙한 도메인 이름을 기계가 읽을 수 있는 IP 주소에 매핑하는 인터넷의 이름 지정 서비스이다.사용자가 브라우저에 도메인 이름을 입력하면 브라우저는 DNS 인프라에 요청하여 도메인 이름을 IP 주소로 변환해야 한다.원하는 IP 주소를 얻으면 사용자의 요청이 대상 웹 서버로 전달된다.DNS에 대한 몇 가지 중요한 세부 사항은 아래와 같다. 이름 서버 DNS는 단일 서버가 아닌 수많은 서버를 갖춘 완벽한 인프라이며, 사용자의 쿼리에 응답하는 DNS 서버를 네임서버라고 함 리소스 레코드 DNS 데이터베이스는 도메인 이름과 IP 주소 매핑을 리소스 레코드(RR) 형식으로 저장 일반적인 유형의 리소스 레코드표는 아래와 같음 유형 설명 이름 값 예(유형, 이름, 값) A IP 주소 매핑에 대한 호스트 이름 제공 호스트 이름 IP 주소 (A, relay1.main.educative.io, 104.18.2.119) NS 도메인 이름에 대한 권한 있는 DNS인 호스트 이름 제공 도메인 이름 호스트 이름 (NS, educative.io, dns.educative.io) CNAME 별칭에서 정식 호스트 이름으로의 매핑 제공 호스트 이름 표준 이름 (CNAME, educative.io, server1.primary.educative.io) MX 별칭에서 정식 호스트 이름으로 메일 서버 매핑 제공 호스트 이름 표준 이름 (MX, mail.educative.io, mailserver1.backup.educative.io) 캐싱 DNS는 다양한 계층에서 캐싱을 사용하여 사용자의 요청 대기 시간을 줄임 계층 구조 DNS 서버는 계층 구조를 사용하여 확장성을 높임 참고 Grokking Modern System Design Interview for Engineers &amp;amp; Managers" }, { "title": "Grokking Modern System Design - 비기능적 시스템 특성", "url": "/posts/educative-grokking-modern-system-design-02/", "categories": "System Design, Grokking Modern System Design", "tags": "System Design, Grokking Modern System Design", "date": "2024-06-18 22:10:00 +0900", "snippet": "가용성이란 무엇인가?가용성은 클라이언트가 일부 서비스나 인프라에 액세스할 수 있고 정상적인 조건에서 작동되는 시간의 비율이다.예를 들어, 서비스 가용성이 100% 라면 해당 서비스가 항상 의도한 대로 작동하고 응답(정상적으로 작동)한다는 의미이다.가용성 측정수학적으로 가용성 $A$ 는 비율이다.$A$ 값이 높을수록 좋으며 이는 공식으로 나타낼 수 있다.$A = (총 시간 - 시스템이 멈춘 시간)/총시간 * 100$일반적으로 가용성을 9의 숫자로 측정한다.다음 표는 주어진 숫자 9를 사용할 때 허용되는 가동 중지 시간이다. 가용성(%) 연간 가동 중지 시간 월별 가동 중지 시간 주당 가동 중지 시간 90% 36.5일 72시간 16.5시간 99% 3.65일 7.20시간 1.68시간 99.5% 1.83일 3.60시간 50.4분 99.9% 8.76시간 43.8분 10.1분 99.99% 52.56분 4분 32초 1분 01초 99.999% 5분 26초 25.9초 6.05초 99.9999% 31.5초 2.59초 0.605초 99.99999% 3.15초 0.259초 0.0605초 신뢰성신뢰성(Reliability)은 서비스 $R$이 지정된 시간 동안 기능을 수행할 확률이다.$R$은 다양한 운영 조건에서 서비스가 어떻게 수행되는지 측정한다.우리는 종종 MTBF(평균 고장 간격) 와 MTTR(평균 수리 시간) 을 $R$을 측정할 지표로 사용한다.$MTBF = (총 경과 시간 - 시스템이 멈춘 시간의 합) / 전체 장애 횟수$$MTTR = 전체 수리 시간 / 전체 수리 횟수$우리는 더 높은 MTBF 값과 더 낮은 MTTR 값을 위해 노력해야 한다.신뢰성 및 가용성안정성과 가용성은 합의된 서비스 수준 목표(SLO)에 대한 서비스 규정 준수를 측정하는 두 가지 중요한 지표이다.가용성 측정은 시간 손실에 의해 결정되는 반면, 오류의 빈도와 영향은 안정성 측정에 영향을 미친다다.가용성과 안정성은 이해관계자가 서비스 상태를 평가할 수 있도록 하기 때문에 필수적이다.신뢰성($R$)과 가용성($A$)은 별개의 개념이지만 서로 연관되어 있다.수학적으로 $A$는 $R$의 함수이다.즉, $R$ 의 값은 독립적으로 변경될 수 있으며 $A$의 값은 $R$에 따라 달라진다.따라서 다음과 같은 상황이 발생할 수 있다. low $A$, low $R$ low $A$, high $R$ high $A$, low $R$ high $A$, high $R$확장성이란 무엇인가?확장성은 성능 저하 없이 증가하는 작업량을 처리할 수 있는 시스템의 능력이다.예를 들어, 검색 엔진은 늘어나는 사용자 수와 인덱싱하는 데이터의 양을 수용해야 한다.워크로드는 다음을 포함하여 다양한 유형일 수 있습니다. 요청 작업량 : 시스템에서 처리하는 요청 수 데이터/스토리지 작업량 : 시스템에 저장되는 데이터의 양Dimensions확장성의 다양한 차원은 다음과 같습니다. 크기 확장성 시스템에 사용자와 리소스를 추가하기만 하면 시스템 크기를 확장할 수 있어야 함 관리 확장성 점점 더 많은 조직이나 사용자가 단일 분산 시스템을 쉽게 공유할 수 있는 있어야 함 지리적 확장성 시스템은 더 작은 지역뿐만 아니라 넓은 지리적 지역에도 쉽게 서비스를 제공할 수 있어야 함 수용 가능한 성능 제약 조건을 유지하면서 프로그램이 다른 지역에 얼마나 쉽게 서비스를 제공할 수 있는지와 관련됨 확장성에 대한 다양한 접근 방식확장성을 구현하는 다양한 방법은 다음과 같다. 수직적 확장 기존 장치에 하드웨어적으로 컴퓨팅 파워를 올려서 확작하는 방법 수평적 확장 네트워크의 머신수를 늘려서 확장하는 방법 유지 관리성이란 무엇인가?시스템 구축 외에도 이후의 주요 작업 중 하나는 버그를 찾아서 수정하고, 새로운 기능을 추가하고, 시스템 플랫폼을 최신 상태로 유지하고, 원활한 시스템 운영을 보장하여 시스템을 계속 가동하는 것이다.시스템 설계의 이러한 요구 사항을 정의하는 두드러진 특징 중 하나는 유지 관리 가능성 이다.유지 관리 가능성의 개념을 세 가지 기본 측면으로 더 나눌 수 있다. 운용성 정상적인 상황에서 시스템의 원활한 작동을 보장하고 오류가 발생한 경우 쉽게 회복할 수 있어야 함 명료성(Lucidity) 코드의 단순성을 나타냄 코드 베이스가 단순할수록 이해하고 유지 관리하기가 더 쉬워짐 수정 가능성(Modifiability) 수정된 기능, 새로운 기능, 예상치 못한 기능을 번거로움 없이 통합할 수 있어야 함 유지보수성 측정유지보수성(Maintenanceability)은 서비스 $M$이 장애 발생 후 지정된 시간 내에 기능을 복원할 확률이다.서비스 $M$이 얼마나 편리하고 신속하게 정상적인 작동 상태를 회복하는지 측정한다.일반적으로 측정하는 지표로 MTTR(평균 수리 시간)을 사용한다.$MTTR = 전체 수리 시간 / 전체 수리 횟수$내결함성이란 무엇인가?실제 대규모 애플리케이션은 수백 대의 서버와 데이터베이스를 실행하여 수십억 명의 사용자 요청을 수용하고 중요한 데이터를 저장한다.이러한 애플리케이션에는 데이터 안전을 돕고 단일 실패 지점을 방지하여 계산 집약적인 작업의 재계산을 피하는 메커니즘이 필요하다.내결함성은 하나 이상의 구성 요소에 장애가 발생하더라도 시스템이 지속적으로 실행되는 능력을 나타낸다.여기서 구성요소는 소프트웨어일 수도 있고 하드웨어일 수도 있다.100% 내결함성을 갖춘 시스템을 구상하는 것은 사실상 매우 어려운 일이다.내결함성 기술내결함성은 시스템 구조를 고려하여 다양한 접근 방식을 통해 달성할 수 있다.복제가장 널리 사용되는 기술 중 하나는 복제 기반 내결함성 이다.이 기술을 사용하면 서비스와 데이터를 모두 복제할 수 있다.실패한 노드를 정상 노드로 교체하고 실패한 데이터 저장소를 복제본으로 교체할 수 있다.대규모 서비스는 최종 고객에게 영향을 주지 않고 투명하게 전환할 수 있다.별도의 저장소에 데이터의 여러 복사본을 만들고, 데이터 업데이트가 발생할 때 일관성을 위해 모든 복사본을 정기적으로 업데이트해야 한다.시스템에 강력한 일관성이 필요한 경우 복제본의 데이터를 동기식으로 업데이트할 수 있지만 이로 인해 시스템 가용성이 감소된다.또한 최종 일관성을 허용할 수 있는 경우 복제본의 데이터를 비동기식으로 업데이트할 수 있으므로 모든 복제본이 수렴될 때까지 오래된 읽기가 발생할 수 있다.두 일관성 접근 방식 간에는 상충 관계가 있으므로 장애 시 가용성혹은 일관성을 선택하여 적절히 타협해야한다.체크 포인트체크포인트는 오류나 서비스 중단으로 인해 장애가 발생한 경우 나중에 검색할 수 있도록 시스템 상태를 안정적인 저장소에 저장하는 기술이다.체크포인트는 다양한 시간 간격으로 여러 단계에서 수행되는 내결함성 기술이다.분산 시스템에 장애가 발생하면 이전 체크포인트에서 마지막으로 계산된 데이터를 가져와서 거기서부터 작업을 시작할 수 있다.체크포인트는 시스템의 실제 실행에 대한 전역 상태를 나타내는 방식으로 시스템의 다양한 개별 프로세스에 대해 수행되며 상태에 따라 체크포인트를 두 가지 유형으로 나눌 수 있다. 일관된 상태 시스템의 모든 개별 프로세스가 공유 상태 또는 시스템에서 발생한 이벤트 순서에 대해 일관된 보기를 갖는 상태 일관된 상태에서 생성된 스냅샷에는 일관된 상태의 데이터가 포함되어 시스템의 가능한 상황을 나타냄 불일치 상태 시스템의 여러 프로세스의 저장된 상태에 불일치가 있는 상태 서로 다른 프로세스에 걸친 체크포인트가 일관되고 조정되지 않음 참고 Grokking Modern System Design Interview for Engineers &amp;amp; Managers" }, { "title": "Grokking Modern System Design - 추상화", "url": "/posts/educative-grokking-modern-system-design-01/", "categories": "System Design, Grokking Modern System Design", "tags": "System Design, Grokking Modern System Design", "date": "2024-06-18 21:40:00 +0900", "snippet": "추상화란 무엇인가?추상화는 필요하지 않은 세부 사항을 난독화 하는 기술이다.츠상화는 내면의 복잡성을 숨겨서 우리가 설정한 목표에 대해 더 폭넓게 이해하고 그에 집중할 수 있게 해주기 때문에 매우 중요하다데이터베이스 추상화트랜잭션은 동시 사용자가 데이터를 읽거나 쓰거나 변경할 때 문제가 되는 많은 결과를 숨기고 성공할 경우 커밋하고 실패할 경우 중단하는 간단한 인터페이스를 제공하는 데이터베이스 추상화이다.어느 쪽이든 데이터는 하나의 일관된 상태에서 새로운 일관된 상태로 이동한다.트랜잭션을 통해 최종 사용자는 동시 데이터 변경의 미묘한 코너 케이스로 인해 꼼짝 못하게 되는 것이 아니라 비즈니스 논리에 집중할 수 있다.분산 시스템의 추상화분산 시스템의 추상화는 엔지니어가 작업을 단순화하고 분산 시스템의 기본 복잡성을 처리하는 부담을 덜어주는 데 도움이 된다.Amazon AWS, Google Cloud 및 Microsoft Azure와 같은 많은 대기업이 분산 서비스를 제공함에 따라 분산 시스템의 추상화가 인기를 얻었습니다. 이러한 분산 서비스 구현에 대한 세부 사항은 사용자에게 숨겨져 있으므로 개발자는 종종 매우 복잡한 분산 시스템의 깊이로 들어가지 않고 애플리케이션에 집중할 수 있다.일관성분산 시스템에서 일관성은 많은 것을 의미할 수 있다.하나는 각 복제본 노드가 특정 시점에 동일한 데이터 보기를 갖는다는 것이다.다른 하나는 각 읽기 요청이 최근 쓰기 값을 가져오는 것이다.일관성에는 다양한 형태가 있으므로 이것이 일관성에 대한 유일한 정의는 아니며 일반적으로 일관성 모델은 동시 데이터 읽기, 쓰기 및 변형을 수행하는 분산 시스템의 정확성을 추론하기 위한 추상화를 제공한다.일관성 스펙트럼의 두 끝은 다음과 같다. 가장 강력한 일관성 가장 약한 일관성ACID는 데이터베이스 일관성의 핵심이다.스키마에서 값이 고유해야 한다고 지정하는 경우 일관된 시스템은 모든 작업에서 값이 고유하도록 보장한다.외래 키가 한 행을 삭제하면 관련 행도 삭제됨을 나타내는 경우 일관된 시스템은 기본 행이 삭제된 후에 상태가 관련 행을 포함할 수 없도록 보장한다.CAP 일관성은 분산 시스템에서 동일한 논리 값의 모든 복제본이 항상 동일한 정확한 값을 갖도록 보장한다.이것이 물리적인 보장이 아니라 논리적인 보장이라는 점은 주목할 가치가 있다.클라이언트가 별도의 노드에서 다른 값에 액세스하는 것을 방지함으로써 클러스터는 논리적 그림을 제공할 수 있다.최종 일관성(Eventual consistency)최종 일관성은 가장 약한 일관성 모델이다.엄격한 주문 요구 사항이 없고 최신 쓰기를 반환하기 위해 읽기가 필요하지 않은 애플리케이션은 이 모델을 선택한다.최종 일관성은 유한한 시간이 지난 후 더 이상 쓰기가 들어오지 않을 때 모든 복제본이 최종 값으로 수렴되도록 보장한다. 새로운 쓰기가 계속 발생하면 최종적으로 일관된 시스템의 복제본은 결코 동일한 상태에 도달하지 못할 수 있다.복제본이 수렴될 때까지 서로 다른 복제본이 서로 다른 값을 반환할 수 있다.최종 일관성은 고가용성을 보장한다.인과적 일관성(Causal consistency)인과적 일관성은 작업을 종속 작업과 독립 작업으로 분류하여 작동한다.종속 연산은 인과관계 연산이라고도 한다.인과적 일관성은 인과적으로 관련된 작업의 순서를 유지한다.이 모델은 인과관계가 없는 작업의 순서를 보장하지 않는다.인과적 일관성은 전반적으로 약하지만 최종 일관성 모델보다 강력하다.직관적이지 않은 동작을 방지하는 데 사용된다.순차적 일관성(Sequential consistency)순차적 일관성은 각 클라이언트 프로그램에서 지정한 순서를 유지한다.그러나 순차적 일관성은 쓰기가 즉시 표시되거나 일부 글로벌 시계에 따라 발생한 것과 동일한 순서로 표시되도록 보장하지 않는다.순차적 일관성은 인과적 일관성 모델보다 강력하다.선형성(linearizability)엄격한 일관성 또는 선형성은 가장 강력한 일관성 모델이다.이 모델은 모든 복제본의 읽기 요청이 최신 쓰기 값을 얻도록 보장한다.클라이언트가 쓰기 작업이 수행되었다는 승인을 받으면 다른 클라이언트가 해당 값을 읽을 수 있다.선형화는 분산 시스템에서 달성하기 매우 어렵다.이러한 문제가 발생하는 이유 중 일부는 다양한 네트워크 지연 및 장애 때문이다.일반적으로 동기 복제는 강력한 일관성을 달성하기 위한 요소 중 하나이지만 그 자체만으로는 충분하지 않다.강력한 일관성을 달성하려면 Paxos 및 Raft와 같은 합의 알고리즘이 필요할 수 있다.실패 모델분산 시스템의 세계에서는 실패가 명백하며 다양한 방식으로 나타날 수 있다.실패는 순간적으로 발생하고 복구될 수도 있고, 장기간 지속될 수도 있습니다.Fail-stop이러한 유형의 오류에서는 분산 시스템의 노드가 영구적으로 중지된다.그러나 다른 노드는 여전히 통신을 통해 해당 노드를 감지할 수 있다.Crash이러한 유형의 오류에서는 분산 시스템의 노드가 자동으로 중지되고 다른 노드는 해당 노드의 작동이 중지되었음을 감지할 수 없다.Omission failures누락 실패 에서는 노드가 메시지를 보내거나 받지 못한다.누락 실패에는 두 가지 유형이 있습니다. 전송 누락 실패 노드가 들어오는 요청에 응답하지 못하는 경우 수신 누락 실패 노드가 요청 수신에 실패하여 이를 승인할 수 없는 경우 Temporal failures일시적인 오류 에서는 노드가 올바른 결과를 생성하지만 너무 늦어서 유용하지 않는 경우이다.이 오류는 잘못된 알고리즘, 잘못된 설계 전략 또는 프로세서 클럭 간의 동기화 손실로 인해 발생할 수 있다.Byzantine failures비잔틴 실패 에서 노드는 임의의 시간에 임의의 메시지를 전송하거나, 잘못된 결과를 생성하거나, 중간에 중지하는 등 임의의 동작을 나타낸다.이는 대부분 악의적인 실체의 공격이나 소프트웨어 버그로 인해 발생한다.비잔틴 실패는 처리하기 가장 어려운 실패 유형이다.참고 Grokking Modern System Design Interview for Engineers &amp;amp; Managers" }, { "title": "Distributed Systems - Sharing Problems and their Solution", "url": "/posts/educative-distributed-system-12/", "categories": "System Design, Distributed Systems", "tags": "System Design, Distributed Systems", "date": "2024-06-17 22:40:00 +0900", "snippet": "공유의 문제점공유는 고 가용성, 성능, 확장성을 저해하는 주요 요인 중 하나이다.예를 들어, 다양한 파티션이 독립적인 오류 모드를 가질 수 있으므로 파티셔닝을 통해 공유를 줄여 시스템의 전체 가용성을 높일 수 있다. 그리고 단일 데이터 항목을 볼 땐 복제를 통해 공유를 늘려 가용성을 높일 수 있다.공유 줄이기공유를 줄이는 것은 적절하게 적용하면 매우 유익할 수 있다.일부 시스템 아키텍처는 모든 요청이 시스템의 단일 노드 또는 단일 노드 그룹에 의해 독립적으로 처리될 수 있도록 조정과 경합을 줄이기 위해 이 원칙을 극단적으로 따른다.이를 일반적으로 비공유 아키텍처라고 합니다.시스템의 상태 저장과 상태 비저장 부분 분해공유를 줄이기 위해 기본적이고 널리 사용되는 기술은 시스템의 상태 저장 부분과 상태 비저장 부분을 분해하는 것 이다.이것의 주요 이점은 시스템의 무상태 부분이 완전히 대칭적이고 동질적인 경향이 있다는 것 이다.즉, 무상태 애플리케이션의 모든 인스턴스가 나머지 부분과 구별되지 않는다는 것을 의미한다.이들을 분리하면 확장이 훨씬 쉬워지게 된다.상태 저장 시스템 관리상태 저장 시스템은 시스템의 다양한 노드가 동일하지 않기 때문에 관리하기가 더 어렵다.각 노드에는 요청을 시스템의 적절한 부분으로 보내기 위한 적절한 라우팅을 수행하기 위한 다양한 데이터 조각이 포함되어 있습니다.이 상태는 고가용성이 필요한 경우 공유를 완전히 제거하지 못하게 하는 긴장감을 조성한다.균형을 유지하기 위해 분할 과 복제 의 조합이 사용됩니다.공유를 줄이고 독립성과 결함 격리를 생성하기 위해 데이터가 분할되지만, 모든 파티션은 내결함성이 있도록 여러 노드에 걸쳐 복제된다.비 공유 시스템의 이익비공유 아키텍처는 성능 및 내결함성 측면에서 더 많은 이점을 제공하며 확장성과 가용성을 보장한다.확장성애플리케이션의 모든 계층은 부하에 따라 점진적으로 확장되거나 축소될 수 있다.또한 상태 비저장 구성 요소에서는 데이터 전송이 덜 필요하므로 확장성을 더 쉽고 빠르게 달성할 수 있습니다 .가용성시스템은 단일 노드 및 다중 노드 오류에 대한 복원력을 갖추고 있다.보다 구체적으로, 이러한 두 가지 다른 형태의 오류는 유사한 방식으로 시스템의 상태 비저장 부분에 영향을 미치게 된다.예를 들어 나머지 노드는 더 큰 로드를 처리해야 하거나 더 많은 서버를 프로비저닝해야 할 수 있다.아키텍처의 상태 저장 부분 의 경우 단일 및 다중 노드 오류의 동작이 약간 다르다. 각 파티션은 대다수의 노드가 정상인 한 완전한 기능을 유지할 수 있는 합의 기반 복제 기술을 사용할 수 있으므로 단일 노드 오류를 처리하기가 훨씬 쉽다. 다중 노드 장애는 대다수에 영향을 미쳐 파티션을 사용할 수 없게 만들 수 있다.파티셔닝이 가능한 문제 지원비 공유 아키텍처는 세분화된 파티셔닝이 필요한 문제에 적합한 경향이 있다.이 분야에 대한 대표적인 예로는 아래와 같다. 사용자 세션 관리 카탈로그 제품 관리두 경우 모두 데이터 액세스 작업이 단일 데이터 항목에 액세스해야 하는 방식으로 데이터를 쉽게 분할할 수 있다. 세션에는 고유 식별자가 할당될 수 있으며 이 속성으로 세션을 분할할 수 있다. 제품은 유사한 제품 식별자에 따라 분할될 수 있다.동시성 제어파티션 범위에는 일종의 제한된 동시성 제어를 위한 공간도 있다.단일 항목 액세스가 일반적인 경우, 일반적인 기술은 낙관적 동시성 제어를 사용하여 오버헤드와 경합을 줄이는 것이다.이는 모든 데이터 항목에 버전 속성을 포함함으로써 달성된다.모든 작성자는 쓰기 전에 읽기를 수행하여 현재 버전을 찾은 다음 업데이트가 완료되기 위한 조건으로 업데이트에 현재 버전을 포함시킨다.이를 위해서는 조건부 업데이트를 지원하는 해당 데이터 저장소가 필요하다.동시 작성자가 그 동안 동일한 항목을 업데이트한 경우 첫 번째 작성자는 초기 쓰기가 여전히 적용되어야 하는지 확인하기 위해 새 읽기를 수행하여 중단하고 다시 시작해야 하며, 그렇다면 다시 시도해야 한다.비공유 아키텍처의 단점가장 큰 단점은 유연성이 감소 한다는 것이다.애플리케이션이 새로운 데이터 액세스 패턴에 효율적으로 액세스해야 하는 경우 시스템의 데이터가 특정 방식으로 분할되어 있으므로 이를 제공하기 어려울 수 있다.예를 들어, 분할 키가 아닌 보조 속성으로 쿼리를 시도하려면 시스템의 모든 노드에 대한 액세스가 필요할 수 있다.이러한 유연성 감소는 강력한 트랜잭션 의미 체계의 부족으로 나타날 수도 있다.강력한 격리를 통해 여러 항목 읽기를 수행하거나 단일 원자성 트랜잭션에서 여러 항목을 작성해야 하는 애플리케이션은 이러한 아키텍처 형식에서는 이 작업을 수행하지 못할 수 있다.과도한 추가 오버헤드가 발생하는 경우에만 가능할 수도 있다.참고 Distributed Systems for Practitioners" }, { "title": "Distributed Systems - Data Synchronisation", "url": "/posts/educative-distributed-system-11/", "categories": "System Design, Distributed Systems", "tags": "System Design, Distributed Systems", "date": "2024-06-17 22:35:00 +0900", "snippet": "여러 곳에 데이터를 저장해야 하는 필요성동일한 데이터를 여러 장소에 저장하고 잠재적으로 다른 형식을 저장해야 하는 경우가 있다.이를 구체화된 뷰(Materialized view) 라고 한다.다음 이러한 사계의 몇가지 에이다 영구 데이터 저장소에 있는 데이터도 별도의 인 메모리 저장소에 캐시해야 읽기 작업이 짧은 대기 시간으로 캐시에서 처리될 수 있다. 쓰기 작업은 영구 데이터 저장소와 메모리 내 저장소를 모두 업데이트해야 합니다. 분산된 키-값 저장소에 저장된 데이터는 ElasticSearch 또는 Solr 과 같은 효율적인 전체 텍스트 검색을 제공하는 별도의 데이터 저장소에도 저장되어야 한다. 읽기 작업의 형태에 따라 최적의 성능을 위해 적절한 데이터 저장소를 사용할 수 있습니다. 관계형 데이터베이스에 저장된 데이터도 그래프 데이터베이스에 저장해야 그래프 쿼리를 보다 효율적으로 수행할 수 있다.이중 쓰기를 통한 데이터 동기화한 가지 접근 방식은 업데이트 작업을 수신하는 단일 애플리케이션에서 연결된 모든 데이터 저장소에 쓰기를 수행하는 것이다.이 접근 방식을 이중 쓰기 라고도 한다.일반적으로 연결된 데이터 저장소에 대한 쓰기는 업데이트 작업이 성공했다는 확인으로 클라이언트에 응답하기 전에 모든 위치의 데이터를 업데이트하기 위해 동기식으로 수행된다.이중 쓰기의 단점과 해결책이중 쓰기에 대한 한가지 단점은 시스템이 부분오류가 발생하여 원자성을 잃어버릴수 있다는 것이다.애플리케이션이 첫 번째 데이터 저장소를 성공적으로 업데이트했지만 두 번째 데이터 저장소 업데이트 요청이 실패하면 원자성이 위반된다.이로 인해 전체 시스템이 일관성을 잃게 된다.또한 이 경우 데이터가 업데이트되었기 때문에 일부 클라이언트에 대한 응답이 무엇인지 명확하지 않을 수 있다.이러한 문제를 해결하기 위한 확실한 방법은 2단계 커밋 및 2단계 잠금의 조합과 같이 필요한 원자성 및 격리를 제공하는 분산 트랜잭션 프로토콜을 도입하는 것이다.이를 수행하려면 기본 데이터 저장소가 이에 대한 지원을 제공해야 한다.Event Sourcing이벤트 소싱은 데이터 동기화를 위한 또 다른 접근 방식이다.모든 업데이트 작업을 추가 전용 이벤트 로그에 기록한다.관심 있는 애플리케이션은 이 로그의 이벤트를 소비하고 관련 데이터를 기본 데이터 저장소에 저장한다.또힌 애플리케이션은 일반적으로 오류가 발생할 경우 전체 로그를 다시 사용할 필요가 없도록 상태의 주기적 스냅샷을 저장한다.이 경우 오류를 복구하는 애플리케이션은 최신 스냅샷 이후의 로그 이벤트만 재생하면 된다.이중 쓰기 문제 완화이벤트 소싱 접근 방식은 원자성을 위반하지 않는다.이는 원자성 커밋 프로토콜이 불필요 하다는 것을 뜻한다.그 이유는 모든 애플리케이션이 로그를 독립적으로 소비하고 결국 모든 이벤트를 성공적으로 처리하고 일시적인 오류가 발생할 경우 마지막으로 소비된 이벤트에서 다시 시작되기 때문이다.애플리케이션이 모든 이벤트를 동일한 순서로 소비하므로 이중 쓰기 접근 방식의 격리 문제도 해결 된다.이벤트 소싱 접근 방식의 주의 사항애플리케이션은 로그의 이벤트를 다양한 속도로 사용할 수 있다.이는 이벤트가 모든 애플리케이션에 즉시 반영되지 않음을 의미한다.이 현상은 애플리케이션 수준에서 처리할 수 있다. 예를 들어 캐시에서 항목을 사용할 수 없는 경우 애플리케이션은 다른 데이터 저장소를 쿼리할 수 있다.이 문제의 또 다른 문제는 신뢰할 수 있는 데이터 저장소에 아직 저장되지는 않았지만 성공적으로 인덱싱된 항목으로 인해 댕글링 포인터가 발생할 수 있다.끊어진 링크를 표시하는 대신 이러한 항목을 식별하고 삭제하면 애플리케이션 수준에서 이 문제를 해결할 수 있다.애플리케이션 수준에서 그러한 기술을 적용할 수 없는 경우 동시성 제어 프로토콜을 사용할 수 있다.Change Data Capture (CDC)변경 데이터 캡처(CDC)는 데이터 동기화에 사용되는 또 다른 접근 방식입니다.이전 단원에서 설명한 대로 이벤트 소싱 로그의 비동기식 사용을 해결한다.이벤트 소싱 문제 완화CDC 접근 방식에서 애플리케이션은 모든 업데이트 작업이 수행되는 신뢰할 수 있는 데이터 소스로 데이터 저장소를 선택한다.그런 다음 이벤트 소싱과 동일한 방식으로 나머지 모든 작업에서 사용되는 이 데이터 저장소에서 이벤트 로그를 생성한다.이 기본 데이터 저장소는 필요한 트랜잭션 의미 체계와 기본 데이터의 변경 사항을 모니터링하여 이벤트 로그를 생성하는 방법을 제공해야 한다.관계형 데이터베이스는 대부분 강력한 트랜잭션 보장을 제공하며 수행된 작업에 순서를 지정하고 주문 이벤트 로그를 제공할 수 있는 WAL(Write Ahead-Log)을 내부적으로 사용하므로 일반적으로 이에 적합하다.결과적으로 클라이언트는 현재 상태에 대해 조건부 업데이트를 수행할 수 있으며 나머지 애플리케이션은 해당 데이터 저장소에서 이러한 작업을 독립적으로 적용할 수 있다.참고 Distributed Systems for Practitioners" }, { "title": "Distributed Systems - Coordination Patterns", "url": "/posts/educative-distributed-system-10/", "categories": "System Design, Distributed Systems", "tags": "System Design, Distributed Systems", "date": "2024-06-17 22:31:00 +0900", "snippet": "Orchestration오케스트레이션은 단일 중앙 시스템이 다양한 다른 시스템의 실행을 조정하는 역할을 담당하므로 스타 토폴로지와 유사한 모습을 보인다.이때 중앙 시스템을 오케스트레이터 라고 부른다.ChoreographyChoreography 에서 시스템은 외부 코디네이터가 없어도 서로 조정된다.이들은 본질적으로 체인에 배치되며 각 시스템은 토폴로지의 이전 시스템과 다음 시스템을 인식한다.요청은 체인을 통해 각 시스템에서 다음 시스템으로 연속적으로 전달된다.The behavior of coordination patternsOrchestration과 Choreography 패턴 모두 원자성을 보장해야 한다.원자성을 달성하기 위해 아래와 같은 두가지 방법을 사용할 수 있다. 2단계 커밋 사가 트랜잭션첫 번째 접근 방식은 오케스트레이터가 2단계 커밋 프로토콜의 조정자 역할을 하는 오케스트레이터 패턴에 더 잘 맞는 반면, 두 번째 접근 방식은 두 패턴 모두에서 사용할 수 있다.참고 Distributed Systems for Practitioners" }, { "title": "Distributed Systems - Communication Patterns", "url": "/posts/educative-distributed-system-09/", "categories": "System Design, Distributed Systems", "tags": "System Design, Distributed Systems", "date": "2024-06-14 22:31:00 +0900", "snippet": "분산 시스템과 다른 시스템의 주요 차이점 중 하나는 다양한 노드가 네트워크 경계를 넘어 데이터를 교환해야 한다는 점이다.Serialization and Deserialization#모든 노드에는 메모리에 있는 데이터를 네트워크를 통해 전송할 수 있는 형식으로 변환하는 방법이 필요하며 네트워크에서 수신된 데이터를 다시 적절한 메모리 내의 표현으로 변환하는 방법도 필요하다. 이러한 과정을 직렬화(Serialization) 및 역직렬화(Deserialization) 하고 한다.Synchronous and asynchronous communication노드 A가 노드 B와 동기적으로 통신하는 경우 노드 A는 후속 작업을 진행하기 전에 노드 B로부터 응답을 받을 때까지 기다려야 한다.대신 노드 A가 비동기식으로 통신하는 경우 이는 해당 요청이 완료될 때까지 기다릴 필요가 없음을 의미한다.동시에 다른 작업을 진행하고 수행할 수 있다.Datastores for Asynchronous Communication비동기식 통신을 달성하려면 데이터 저장소에 요청을 저장해야 하며 이러한 데이터 저장소는 메시지 큐와 이벤트 로그라는 두 가지 주요 범주에 속한다.Message Queue메시지 큐 구성 방법에 따라 다음 두 가지 경우 중 하나에 해당하는 메시지가 삭제될 수 있다. 소비자에게 배송되자마자 소비자가 메시지를 받은 후 이를 확인하기 전에 실패할 수 있으므로 본질적으로 최대 한번 보장을 제공 소비자가 명시적으로 확인한 후에만 메시지를 성공적으로 처리 메시지가 대기열에서 제거되기 전에 적어도 단일 소비자가 메시지를 처리해야 하므로 최소 한 번 의미 체계를 제공. 대부분의 메시지 큐에는 활성 상태를 보장하는 실패한 소비자에 대처하기 위해 확인되지 않은 메시지에 대한 시간 초과 논리가 포함되어 있다.이는 확인되지 않은 메시지가 대기열에 다시 들어가고 새 소비자에게 다시 전달됨을 의미한다.결과적으로 메시지가 여러 소비자에게 두 번 이상 전달될 수 있는 경우가 존재한다. 대표 메세지 큐 ActiveMQ RabbitMQ Amazon SQS Event Log이벤트 로그는 메시지 큐와 약간 다른 추상화를 제공한다.메시지는 여전히 생성자에 의해 로그 끝에 삽입되고 순서대로 저장된다.그러나 소비자는 메시지를 소비하려는 로그 지점을 자유롭게 선택할 수 있으며 반드시 헤드일 필요는 없다.메시지는 일반적으로 소비자가 어디에서 소비할지 선언하는 데 사용할 수 있는 인덱스와 연결된다.메시지 큐와의 또 다른 차이점은 로그가 일반적으로 변경 불가능하므로 메시지가 처리된 후에도 제거되지 않는다는 점이다.대신 가비지 수집이 주기적으로 실행되어 로그 헤드에서 오래된 메시지를 제거한다.소비자는 동일한 메시지를 두 번 처리하는 것을 방지하여 정확히 한 번 처리 의미 체계를 달성하기 위해 이미 소비한 로그 부분을 나타내는 오프셋을 추적할 책임이 있다.이 오프셋은 앞에서 설명한 것과 유사하게 각 메시지에 대한 고유 식별자 역할을 한다. 대표 이벤트 로그 Apache Kafka Amazon Kinesis Azure Event Hubs Communication Models메시지 큐와 이벤트 로그를 사용하면 지점 간 통신(point-to-point) 과 게시-구독(publish-subscribe) 이라는 두 가지 서로 다른 형태의 통신을 사용할 수 있습니다 . 지점 간 통신(point-to-point) 지점 간 모델 은 두 개의 애플리케이션만 연결해야 할 때 사용됨 게시-구독(publish-subscribe) 게시 -구독 모델은 둘 이상의 애플리케이션이 단일 애플리케이션에서 보낸 메시지에 관심이 있을 때 사용됨 참고 Distributed Systems for Practitioners" }, { "title": "Distributed Systems - Ordering", "url": "/posts/educative-distributed-system-08/", "categories": "System Design, Distributed Systems", "tags": "System Design, Distributed Systems", "date": "2024-06-13 22:31:00 +0900", "snippet": "소프트웨어 시스템에서 시간의 주요 사용 사례 중 하나는 다양한 이벤트의 순서를 결정하는 것이다.중앙 집중형과 분산 시스템에서 이벤트의 순서를 지정하는데 있어 시계의 존재에 대해서 차이가 존재한다.중앙집중형에는 노드가 하나뿐 이므로 시계도 하나뿐이다.이는 보편적으로 단일한 시간 차원을 유지할 수 있기때문에 단일 노드에서의 다양한 이벤트의 순서를 결정 할 수 있다.반면 분산 시스템에서는 각 노드마다 자체 시계가 존재한다.즉, 분산 시스템에서는 여러 노드에서 발생하는 이벤트의 순서를 지정할 글로벌 시계가 존재하지 않는다.그러므로 분산 시스템을 구축할 때 시계 간의 차이를 고려해야 한다.전체 시스템은 이러한 모든 시계가 동일하고 단일 글로벌 시계로 작동한다는 가정 하에서 작동해서는 안된다.논리적 시게논리적 시계는 시간을 추적하기 위해 물리적 프로세스에 의존하지 않는 시계의 대체 범주이다.대신 시스템 노드 간에 교환되는 메시지를 활용한다.이는 앞서 논의한 바와 같이 분산 시스템 에서 정보 흐름의 주요 메커니즘이기도 하다.Total and Partial Ordering이벤트 순서를 결정하는 것은 소프트웨어 시스템에서 해결해야 하는 일반적인 문제이다.그러나 순서에는 전체 순서과 부분 순서라는 두가지 다른 유형의 순서가 있다.전체 순서(Total Ordering)전체 순서 는 집합의 두 요소를 서로 비교하는 이진 관계이다.이 관계를 사용하여 집합의 모든 요소에 대해 단일 순서만 파생할 수 있다. 이것이 바로 전체 주문 이라고 불리는 이유입니다.단일 노드로 구성된 시스템에서는 이벤트의 전체 순서를 결정하는 것이 쉽고 직관적이다.주된 이유는 모든 이벤트가 발생하는 단일 액터가 있으므로 이 액터가 이러한 이벤트가 발생할 때 전체 순서를 부과할 수 있기 때문이다.부분 순서(Partial Ordering)부분 순서 는 집합의 일부 요소만 서로 비교하는 데 사용할 수 있는 이진 관계이다.이 관계를 사용하여 집합의 모든 요소에 대해 여러 개의 유효한 순서를 도출할 수 있습니다.분산 시스템에는 여러 노드가 있고 이벤트가 여러 노드에서 동시에 발생할 수 있기 때문에 전체 순서가 꼭 필요하지 않은 경우 발생하는 이벤트의 유효한 부분 순서를 사용할 수 있다.Lamport Clocks램포트 시계에서의 논리 시계는 시스템의 모든 노드가 작동을 시작할 때 0부터 시작하는 숫자 카운터 형태의 논리 시계를 유지한다.프로토콜의 규칙은 아래와 같다. [R1]이벤트(전속, 수신, 로컬)를 실행 하기 전에 노드는 논리 시계의 카운터를 1 증가 시킨다. $C_i = C_i + 1$ [R2]전송된 모든 메시지는 전송 시간에 보낸 사람의 시계 값을 피기백하고 노드는 타임스탬프 값이 있는 메세지를 받고 다음 작업을 실행한다. 시계와 수신된 시계의 최대값을 사용하여 시계를 업데이트 함 $C_i = max(C_i, C_m)$ R1을 실행 메세지를 전달 Lamport 시계 는 서로 다른 노드의 시계가 동일한 값(예: 노드 ID)을 갖는 경우 연결을 끊는 임의의 메커니즘을 사용하여 분산 시스템에서 이벤트의 전체 순서를 생성하는 데 사용할 수 있다.주의할 점은 이 전체 순서가 다소 임의적이며 인과 관계를 추론할 수 없다는 것이다.이는 Lamport 시계가 가질 수 있는 실제 응용 프로그램의 수를 제한한다.Vector ClocksLamport 시계의 주요 한계 는 강력한 클럭 조건을 충족하지 못한다는 것이다.이는 사건 간의 인과 관계를 추론하는 데 사용할 수 없음을 의미한다.따라서 우리는 각 사건보다 먼저 발생하는 모든 사건의 집합을 유지해야 한다.벡터 클럭 은 논리 클럭의 또 다른 유형으로, 각 노드의 클럭 데이터 ​​구조는 다음의 벡터입니다. 시스템의 노드의 수 $N$ 만큼 clock의 벡터 $[c^0, c^1, …c^N]$ 구성프로토콜의 규칙은 아래와 같다. [R1]이벤트(전속, 수신, 로컬)를 실행 하기 전에 노드는 논리 시계의 카운터를 1 증가 시킨다. $C^i_i = C^i_i + 1$ [R2]전송된 모든 메시지는 전송 시간에 보낸 사람의 시계 값을 피기백하고 노드는 벡터 $[c^0_j, c^1_j, …c^N_j]$ 가 포함된 메세지를 받고 다음 작업을 실행한다. R1을 실행 자체 벡터 시계값과 수신된 메세지의 벡터 값중 최대값을 취하여 벡터의 각 요소를 업데이트 $C^k_i = max(C^k_i, C^k_j)$, $k$ in $[0, N]$ 메세지를 전달 벡터 클록은 두 이벤트가 인과적으로 연관되어 있는지 또는 동시에 발생하는지 감지하는 기능의 이점을 누릴 경우 사용할 수 있다.또한 시스템의 다양한 노드가 동기화 및 조정 병목 현상 없이 독립적이고 효율적으로 진행할 수 있도록 해준다.참고 Distributed Systems for Practitioners Why Vector Clocks Are Hard" }, { "title": "Distributed Systems - 원자성", "url": "/posts/educative-distributed-system-07/", "categories": "System Design, Distributed Systems", "tags": "System Design, Distributed Systems", "date": "2024-06-13 22:21:00 +0900", "snippet": "원자성 보장의 어려움원자성을 보장하는 것은 분산 시스템 뿐만 아니라 일반적으로 어려운 작업이다.구성요소가 소프트워에의 구성요소인지 하드웨어의 구성요소인지 관계없이 구성요소가 예기치 않게 실패할 수 있기 때문이다.원자성을 달성하는 일반적인 방법은 저널링(journalling) 또는 미리 쓰기(write-ahead logging) 방법이 있다.분산 시스템에서의 원자성 문제는 구성요소가 느리고 신뢰할 수 없는 네트워크로 분리되어 있기 때문에 더욱 복작해진다.분산 시스템에서의 원자성은 작업이 모든 노드에 대하여 적용되거나 적용되지 않아야 함을 의미한다. 이러한 문제를 원자적 커밋(Atomic commit) 이라고 부른다.2단계 커밋(2PC)2단계 커밋 프로토콜은 두가지 단계로 구성되며, 아래와 같은 두가지 다른역할이 포함되어 있다. 역할 코디네이터는 프로토콜의 여러 단계를 조정하는 역할을 담당 참가자는 트랜잭션에 참여하는 모든 노드에 해담 참가자중 한명이 코디네이터 역할을 맞을 수 있음 투표 단계이 단계에서 코디네이터는 모든 참가자에게 트랜잭션을 보낸다.참가자는 커밋해야 하는 지점까지 트랜잭션을 실행한다.이후 참가자는 태랜잭션 작업이 성공저으로 실행되었는지, 또는 트랜잭션을 커밋할 수 없는 오류 상태인지를 나타내는 투표로 코디네이터에게 응답한다.커밋 단게이 단계에서 코디네이터는 참가자로부터 모든 표를 수집한다.모든 투표가 “예” 이면 코디네이터는 참가자에게 트랜잭션을 커밋하라는 메시지를 다시 보낸다.그렇지 않고, 적어도 한 표가 “아니오” 이면 코디네이터는 참가자에게 트랜잭션을 중단하도록 지시한다.마지막으로 참가자는 승인으로 응답하고 이 단계를 끝낸다. 커밋에 만장일치의 긍정적 투표가 필요하다는 사실은 트랜잭션이 모든 참가자에게 커밋되거나 모든 참가자에 대해 중단된다는 것을 의미한다. (원자성)코디네이터와 참가자는 오류 발생 시 복구할 수 있도록 다양한 단계에서 결정을 유지하는 미리 쓰기 로그(write-ahead logging)를 사용한다.코디네이터는 첫 번째 단계의 응답을 기다릴 때도 시간 제한을 사용한다.시간 초과가 만료되면 코디네이터는 이 시간 초과를 투표 없음으로 해석하고 노드가 실패한 것으로 간주한다.반면에 참가자는 코디네이터의 메시지를 기다리는 동안 시간 초과를 적용하지 않는다.이는 타이밍 문제로 인해 참가자가 다른 결론에 도달할 수 있기 때문이다.2단계 커밋 프로토콜의 차단 특성프로토콜의 차단 특성으로 인해 프로토콜의 특정 단계에서 코디네이터가 실패하면 전체 시스템이 중단될 수 있다.코디네이터가 준비된 메시지를 참가자에게 보낸 후 실패하면 참가자는 차단되게 된다. 이후 참가자는 코디네이터가 트랜잭션의 결과를 복구하고 알아낼 때까지 기다리며 필요에 따라 트랜잭션을 커밋하거나 중단한다.이는 코디네이터의 장애로 인해 시스템의 가용성이 크게 저하될 수 있음을 의미한다.또한 코디네이터가 복구될수 없다면 보류중인 트랜잭션의 결과를 검색할수 없기 때문에 차단된 작업을 해제하기 위해 수동 개입이 필요해 진다.3단계 커밋(3PC)2단계 커밋 프로토콜의 주요 병목 현상은 시스템을 차단 상태로 이끄는 코디네이터의 실패이다.이러한 2단계 커밋 문제는 첫 번째 라운드(투표 단계)를 2개의 하위 라운드로 분할하여 해결할 수 있다.코디네이터는 먼저 투표 결과를 노드에 전달하고 승인을 기다린 다음 커밋 또는 중단 메시지를 진행한다.이 경우 참가자는 투표 결과를 알고 코디네이터가 실패할 경우 독립적으로 프로토콜을 완료한다.이 3PC 프로토콜의 주요 장점은 코디네이터가 단일 실패 지점이 되지 않는다는 점이다.코디네이터가 실패할 경우 참가자는 프로토콜을 인계받아 완료할 수 있다.인계받는 참가자는 모든 참가자가 “예”로 투표했음을 알고 커밋 준비를 수신하면 트랜잭션을 커밋할 수 있다.커밋 준비 메시지를 받지 못한 경우 모든 참가자가 커밋 준비 메시지를 먼저 받지 않고 커밋한 참가자가 없다는 사실을 알고 트랜잭션을 중단할 수 있다.결과적으로 3PC 프로토콜은 가용성을 높이고 코디네이터가 단일 실패 지점이 되는 것을 방지한다.Quorum-Based Commit3PC 프로토콜의 주요 문제는 두 번째 단계가 끝날 때 발생한다.두 번째 단계에서는 잠재적인 네트워크 분할로 인해 시스템이 일관되지 않은 상태로 이어질 수 있다.3PC의 위와같은 문제를 해결하기 위해 쿼럼 개념을 활용하여 파티션의 서로 다른 측면이 충돌하는 결과에 도달하지 않도록 한다.먼저 아래와 같은 기본 개념을 설정한다. 총 참가자($V$) 중단 정족수($V_a$) 커밋 쿼럼($V_c$)그리고 위와 같은 개념에 대하여 다음 속성이 유지되도록 중단 및 커밋 쿼럼 값을 선택한다.$V_a + V_c &amp;gt; V$위 개념을 유지한채로, 쿼럼 기반 커밋 프로토콜은 다양한 경우에 사용되는 세가지 하위 프로토콜들로 구성된다. 새로운 트랜잭션이 시작될 때 사용되는 커밋 프로토콜 네트워크 파티션이 있을 때 사용되는 종료 프로토콜 시스템 이 네트워크 파티션에서 복구될 때 사용되는 병합 프로토콜커밋 프로토콜이 프로토콜은 3PC 프로토콜과 매우 유사하다.유일한 차이점은 코디네이터가 대기한다는 것입니다.이 단계에서 커밋 쿼럼($V_c$)의 값은 트랜잭션 커밋을 진행하기 위한 세 번째 단계가 끝날 때의 승인 횟수이다.이 단계에서 네트워크 파티션이 있으면 코디네이터가 트랜잭션을 완료하지 못할 수 있다.이 경우 파티션 양쪽의 참가자는 다음 프로토콜을 사용하여 트랜잭션을 완료할 수 있는지 여부를 조사한다.종료 프로토콜처음에는 리더 선출을 통해 참가자 중에서 대리 코디네이터가 선택된다.선출된 코디네이터는 파티션의 노드에서 상태를 쿼리한다.이때 커밋(또는 중단)한 참가자가 적어도 한 명 이상 있으면 코디네이터는 원자성 속성을 유지하면서 트랜잭션을 커밋(또는 중단)한다.커밋 준비 상태인 참가자가 한 명 이상 있고, 중단 정족수($V_a$)의 값 이상의 투표 결과를 기다리는 참가자가 있으면 코디네이터 는 참가자에게 준비 완료 메시지를 보내고 다음 단계로 진행한다.또는 커밋 준비 상태에 참가자가 없고, 중단 정족수($V_a$)의 값 이상의 결과 투표를 기다리는 참가자가 있으면 코디네이터는 중단 준비 메시지를 보냅니다.종료 프로토콜의 마지막 단계는 승인을 기다리고 커밋 프로토콜과 유사한 방식으로 트랜잭션을 완료하려고 시도한다.병합 프로토콜여기에는 병합된 두 파티션의 리더 간의 리더 선택과 우리가 설명한 종료 프로토콜의 실행이 포함된다.참고 Distributed Systems for Practitioners" }, { "title": "Distributed Systems - concurrency control", "url": "/posts/educative-distributed-system-06/", "categories": "System Design, Distributed Systems", "tags": "System Design, Distributed Systems", "date": "2024-06-12 22:56:00 +0900", "snippet": "직렬화적절하게 격리되지 않은 동시 트랜잭션으로 인해 몇가지 잠재적인 이상이 발생한다.시스템을 이러한 이상 현상으로 부터 보호하기 위해 트랜잭션이 엄격히 직렬화가 되어야 한다.동시성 제어 메커니즘동시성 제어에는 두가지 주요 메커니즘이 존재한다. 비관적 동시성 제어(Pessimistic concurrency control) 직렬화 가능성을 위반할 것으로 에상되는 경우 트랜잭션을 차단하고 안전하게 수행할 수 있을때 트랜잭션을 재개한다. 일반적으로 다른 트랜잭션이 동일한 데이터를 동시에 처리하는 것을 방지하기 위해 트랜잭션이 처리하는 데이터에 대한 잠금을 획득함으로써 달성된다. 거래 간 충돌이 많지 않은 경우에 좋은 성능을 발휘한다. 읽기 전용 트랜잭션이 많고 쓰기 트랜잭션이 적은 경우나 대부분의 트랜잭션이 다른 데이터를 다루는 경우 낙관적 동시성 제어(Optimistic concurrency control) 트랜잭션이 끝날때 까지 트랜잭션이 규칙을 준수하는지 확인하는 것을 지연시킨다. 커밋이 직렬화 규칙을 위반하면 트랜잭션이 중단된 다음 다시 시작되어 처음부터 다시 실행된다. 잠금으로 인해 약간의 오버헤드를 발생하지만, 출동하는 트랜잭션이 많이 포함된 워크로드에서 더 나은 성능을 발휘한다. 비관적 동시성 제어의 2-Phase locking (2PL)2PL은 동시 트랜잭션이 방해받지 않도록 잠금을 사용하는 비관적 동시성 제어 프로토콜이다.이러한 잠금은 트랜잭션에서 레코드를 사용하고 있음을 나타내므로 다른 트랜잭션에서 해당 레코드를 사용해도 안전한지 여부를 확인할 수 있다.이 프로토콜에는 두가지 기본 유형의 잠금이 사용된다. 독점 쓰기 잠금(Write (exclusive) locks) 레코드가 기록(삽입, 업데이트, 삭제) 될때 잠금을 획득 공유 읽기 잠금(Read (shared) locks) 레코드를 읽을때 잠금 획득 독점 쓰기 잠금과 공유 읽기 잠금 간의 상호 작용읽기 잠금은 다른 트랜잭션의 읽기를 차단하지 않는다.동시에 여러 읽기 잠금을 획득할 수 있기 때문에 공유 라고도 한다.읽기 잠금은 다른 트랜잭션의 쓰기를 차단한다.다른 트랜잭션은 읽기 작업이 완료되고 읽기 잠금이 해제될 때까지 기다려야 하며 이후 다음 쓰기 잠금을 획득하고 쓰기 작업을 수행해야 한다.쓰기 잠금은 다른 트랜잭션의 읽기 및 쓰기를 모두 차단하므로 독점 잠금 이라고도 한다.다른 트랜잭션은 쓰기 작업이 완료되고 쓰기 잠금이 해제될 때까지 기다려야 하며 이후 적절한 잠금을 획득하고 진행하려고 시도한다.낙관적 동시성 제어낙관적 동시성 제어에서의 트랜잭션은 데이터 항목에 대한 잠금을 획득하지 않고도 데이터 항목에 접근할 수 있다.이 방법에는 트랜잭션이 다음 세가지 단계로 실행된다. 시작 읽기 및 수정 검증 및 커밋/롤백시작 단계이 단계에서는 트랜잭션에 시작 타임스탬프 라고 하는 트랜잭션의 시작을 표시하는 고유한 타임스탬프가 할당된다.읽기 및 수정이 단계에서 트랜잭션은 읽기 및 쓰기 작업을 잠정적으로 실행한다. 즉, 항목이 수정되면 해당 항목의 복사본이 임시 로컬 저장 위치에 기록된다.읽기 작업은 먼저 이 위치에 있는 항목의 복사본을 확인하고 해당 복사본이 있으면 반환한다.그렇지 않으면 데이터베이스에서 일반 읽기 작업을 수행한다.검증 및 커밋/롤백 단계모든 작업이 실행되면 트랜잭션이 이 단계로 들어갑니다.이 단계에서 트랜잭션은 이 트랜잭션이 액세스한 데이터를 수정하고 이 트랜잭션의 시작 시간 이후에 시작된 다른 트랜잭션이 있는지 확인한다.다른 트랜잭션이 있는 경우 트랜잭션이 중단되고 처음부터 다시 시작되어 새 타임스탬프를 획득한다.다른 트랜잭션이 없는 경우 트랜잭션이 커밋될 수 있습니다.트랜잭션 커밋은 쓰기 작업의 모든 값을 로컬 저장소에서 다른 트랜잭션이 액세스하는 공용 데이터베이스 저장소로 복사하여 수행된다.유효성 검사를 구현하는 방법트랜잭션의 유효성을 검사하기 위해 두가지 방법을 사용할 수 있다. 버전 확인 모든 데이터 항목에 버전을 할당하고 버전에 대한 확인을진행하는 방법 트랜잭션이 항목에 액세스할 때마다 해당 시점의 버전 번호를 추적 타임스탬프 순서 트랜잭션에 할당된 타임스탬프를 사용 각 트랜잭션은 읽기 또는 쓰기 작업으로 액세스되는 항목을 추적 트랜잭션은 유효하지 않으며 중단하고 새로운 타임스탬프를 사용하여 처음부터 다시 시작해야 함 트랜잭션은 유효하면 트랜잭션이 커밋되고 다음 타임스탬프를 할당 참고 Distributed Systems for Practitioners" }, { "title": "Distributed Systems - Distributed Transactions", "url": "/posts/educative-distributed-system-05/", "categories": "System Design, Distributed Systems", "tags": "System Design, Distributed Systems", "date": "2024-06-12 22:42:00 +0900", "snippet": "중앙 집중식 시스템에서 분산 시스템이로 변경할때 직면하는 가장 일반적인 문제중 하나는 여러 노드에 걸쳐 원자적으로 작업을 수행한다는 것이다. 이를 분산 트랜잭션 이라고 부른다.Transactions트랜잭션은 데이터베이스 시스템내에서 잠재적으로 여러 작업으로 구성되어 상태의 변경을 나타내는 작업 단위이다.ACID 는 트랜잭션 예상 동작에 대한 보장을 제공하는 데이터베이스의 트랜잭션의 속성 집합니다.이러한 ACID에 대한 내용을 분산 시스템에도 어느정도 대입할 수 있다.Atomicity (A)원자성은 여러 작업으로 구성된 트랜잭션이 단일 단위로 처리되도록 보장하며, 이는 트랜잭션의 모든 작업이 수행되거나 아무 것도 수행되지 않음을 의미한다.이러한 원자성 개념은 시스템의 여러 노드에서 동일한 작업을 실행해야 하는 분산 시스템으로 확장된다. 즉, 작업은 모든 노드에 대해 실행되거나 전혀 실행되지 않아야 한다.Consistency (C)일관성은 데이터베이스 불변성을 유지하면서 트랜잭션이 데이터베이스를 하나의 유효한 상태에서 다른 유효한 상태로만 전환하는 것을 보장한다.Isolation (I)격리는 트랜잭션이 동시에 실행되고 데이터 종속성이 있더라도 그 결과가 마치 트랜잭션 중 하나가 한 번에 실행되고 트랜잭션 간에 간섭이 없는 것처럼 보장한다.Durability (D)내구성은 한번 커밋된 트랜잭션이 실패하더라도 커밋된 상태를 유지하도록 보장한다.분산 시스템의 맥락에서 이는 트랜잭션이 여러 노드에 지속적으로 저장되어야 함을 의미한다.이는 저장 시설과 함께 노드 전체에 장애가 발생하는 경우에도 복구가 가능하게 한다.어플리케이션에서 ACID의 의미원자성은 어플리케이션이 가능한 모든 오류를 처리할 필요는 없지만, 발생해서는 안 되는 작업을 롤백하여 부분적인 오류가 발생한 경우 데이터베이스를 일관된 상태로 되돌리는 조건부 논리를 가지고 있음을 의미한다.일관성을 사용 하면 선언적 방식으로 어플리케이션의 불변성을 명시하고 어플리케이션에서 중복 코드를 제거하고 필요할 때마다 데이터베이스가 이러한 검사를 수행할 수 있다.격리를 통해 어플리케이션은 동시 실행을 활용하고 트랜잭션을 병렬로 실행하여 여러 요청을 처리할 수 있으며 데이터베이스가 동시 실행으로 인한 버그를 방지한다는 확신을 가질수 있게 된다.내구성은 데이터베이스가 커밋된 트랜잭션을 선언할 때 되돌릴 수 없는 최종 선언임을 보장한다.분산 트랜잭션분산 트랜잭션은 두 개 이상의 서로 다른 노드에서 발생하는 트랜잭션 이다.분산 트랜잭션에는 약간 다른 두 가지 변형이 있다. 동일한 데이터 조각이 여러 복제본에서 업데이트되어야 함 서로 다른 노드에 있는 서로 다른 데이터 조각을 원자적으로 업데이트해야 함참고 Distributed Systems for Practitioners" }, { "title": "Distributed Systems - CAP", "url": "/posts/educative-distributed-system-04/", "categories": "System Design, Distributed Systems", "tags": "System Design, Distributed Systems", "date": "2024-06-11 22:32:00 +0900", "snippet": "The CAP TheoremCAP 정리는 분산시스템 분야에서 가장 기본적인 정리중 하나이다. 이는 분산 시스템 설계의 본질적인 균형을 설명한다. 일관성(Consistency) 모든 읽기 요청이 마지막 쓰기 요청의 결과를 수신함 가용성(Availability) 모든 요청이 마지막 쓰기 요청을 반영하는지 여부는 보장하지 않지만 오류가 아닌 응답을 수신함 파티션 허용치(Partition Tolerance) 네트워크 단절 및 오류로 인해 네트워크에서 임의의 메세지들이 삭제되더라도 시스템이 지속적으로 작동해야 함 현실에서는 항상 네트워크 단절의 위험이 존재하기 때문에 시스템 설계자가 가용성와 일관성 사이에서 적절한 균형을 이루도록 적절한 시스템을 선택해야 한다.대기시간과 일관성 사이의 절충정상 작동중에 네트워크 파티션이 없다면 대기시간과 일관성 사이에 서로 다른 균형이 유지된다.데이터 일관성을 보장하기 위해 시스템은 데이터가 시스템 전체에 성공적으로 전파될 때까지 쓰기 작업을 지연해야 하므로 지연 시간 이 발생한다.이러한 절충안의 예로는 primary-backup replication 체계가 있다. 이 설정에서 동기식 복제 접근 방식은 대기 시간 보다 일관성을 선호하며 비동기 복제는 일관성을 희생하면서 대기 시간을 줄인다.PACELC 정리PACELC 정리는 CAP 정리의 확장이며 다음과 같이 설명된다. 네트워크 분할(P) 의 경우 시스템은 가용성(A)과 일관성(C) 중 하나를 선택해야 하지만, 그렇지 않은 경우(E), 즉 네트워크 분할 없이 시스템이 정상적으로 작동하는 경우에 시스템은 대기 시간(L)과 일관성(C) 중 하나를 선택해야 한다.Consistency ModelsCAP 정리 에 따르면 일관성은 모든 성공적인 읽기 요청이 가장 최근 쓰기 결과를 반환한다는 것을 의미한다.그러나 이는 일관성의 형태가 다양하기 때문에 지나치게 단순화된 표현이다.현실에서의 여러 일관성의 형태를 정확하게 정의하려면 형식 모델을 정의하고 이를 분산 시스템의 동작에 반영해야 한다.현대 시스템 설계 분야에는 다양한 일관성 모델이 존재하지만, 그중 다음과 같은 일관성 모델을 확인한다. 선형성(Linearizability) 순차적 일관성(Sequential Consistency) 인과적 일관성(Causal Consistency) 최종 일관성(Eventual Consistency)선형성(Linearizability)선형성 모델을 지원하는 시스템은 작업이 외부 클라이언트에게 즉각적으로 나타나는 시스템이다.기본 아이디어는 시스템에 데이터 복사본이 하나만 있고 시스템에 대한 모든 작업이 원자적으로 수행되는 것처럼 보이게 만드는 것이다.흔히 중앙 집중식 시스템에서 이러한 선형성이 나타난다.그러나 분산 시스템에서는 이러한 선형성이 명확하게 정의 될수 없다.분산 시스템에서는 요청에 대한 결과를 각 노드로 업데이트 할때 네트워크의 지연과 같은 이유로 결과의 반영이 지연될 수 있기 때문이다.동기식 복제 기술을 사용하면 시스템을 어느정도 선형화할 수 있다.그러나 이는 새 값이 나머지 노드에 전파될 때까지 첫 번째 쓰기 작업이 더 오래 걸린다는 것을 의미한다.순차적 일관성(Sequential Consistency)순차 일관성은 작업이 호출되기 전이나 완료 후에 적용되도록 허용되는 약한 일관성 모델이다.결과적으로 실시간 보장을 제공하지 않는다.그러나 다른 클라이언트의 작업은 다른 모든 클라이언트에서 동일한 순서로 표시되어야 하며 모든 단일 클라이언트의 작업은 해당 프로그램에서 지정한 순서(전역 순서)를 유지한다.인과적 일관성(Causal Consistency)어떤 경우에는 인과적으로 관련된 작업이 올바른 순서로 표시되는 한, 각 클라이언트 프로그램에서 지정한 순서를 유지할 필요가 없다.즉, 첫 번째 이벤트가 두 번째 이벤트의 결과에 영향을 미치는 경우 모든 노드는 이벤트 B보다 먼저 이벤트 A를 일관된 순서로 보게 된다.최종 일관성(Eventual Consistency)업데이트가 없는채로 일정 시간이 지나면 결국 모든 데이터 복제본이 결국 일관된 상태로 수렴한다는 일관성 모델이다.CAP Theorem’s Consistency ModelCAP 정리는 이러한 여러 일관성 모델들을 두 가지 주요 범주로 구분한다. 강력한 일관성 모델(Strong consistency models) 강력한 일관성 모델은 CAP 정리의 “C”에 해당하며 네트워크 분할 중에 사용 가능 해야 하는 시스템에서는 지원될 수 없다. 약한 일관성 모델(Weak consistency models) 약한 일관성 모델은 네트워크 파티션 중에 가용성을 유지하면서 지원할 수 있는 모델이다. 현재 널리 사용되는 여러 분산 시스템(예: Apache Cassandra, DynamoDB 등)에서 제공하는 일관성 고려하면 일반적으로 두 가지 모델이 지원된다. 강력한 일관성 선형성 약한 일관성 최종 일관성 참고 Distributed Systems for Practitioners" }, { "title": "Distributed Systems - Replication", "url": "/posts/educative-distributed-system-03/", "categories": "System Design, Distributed Systems", "tags": "System Design, Distributed Systems", "date": "2024-06-11 22:12:00 +0900", "snippet": "Replication분산 시스템을 사용함으로써 얻을 수 있는 또 다른 이점은 가용성(availability) 이다.가용성(availability) 은 시스템의 일부에 장애가 발생하더라도 시스템이 지속적으로 기능을 유지할수 있는 능력을 말한다.이러한 가용성을 달성하기 위해 사용되는 기술은 복제(Replication) 가 있다.복제 는 이름 그대로 특정 노드에 대한 복제본을 생성하여 동일한 데이터를 소유하도록 하여 노드에 장애가 발생하더라도 데이터가 손실되지 않고 다른 노드에서 요청을 처리할 수 있도록 구성한다.그러나 복제를 통해 가용성이 향상된다는 이점에는 여러 가지 새로운 문제가 발생할 수 있다.복제는 이제 시스템에 모든 데이터 조각의 여러 복사본이 있음을 의미한다. 그러므로 이러한 복사본은 업데이트할 때마다 서로 동기화되고 유지되어야 한다.이러한 복제를 구현하는데 크게 두가지 주요 전략이 존재한다. 비관적 복제(Pessimistic replication) 데이터 복사본이 하나만 있는 것처럼 처음부터 모든 복제본이 서로 동일함을 보장함 낙관적 복제(Optimistic replication) 서로 다른 복제본이 존재할 수 있음 Primary-Backup Replication AlgorithmPrimary-Backup Replication 알고리즘은 복제본 중 노드중 하나를 리더 또는 기본 으로 지정하는 방법이다.일반적으로 리더 이외의 나머지 복제본을 팔로워 혹은 슬레이브라고 부르며 이들은 읽기 요청만 처리하도록 한다. 장점 구현하기 간단함 리더 노드에 직렬화된 동시 작업을 사용하여 트랜잭션 작업을 쉽게 지원할 수 있음 읽기 복제본을 추가하여 읽기 위주의 워크로드에 맞게 확장이 용이함 단점 리더의 용량에 따라 쓰기 용량이 결정되므로 쓰기가 많은 워크로드에 대해선 확작성이 떨어짐 성능, 내구성, 일관성 사이에 균형이 필요함 팔로어 노드를 더 추가하여 읽기 용량을 확장하여 업데이트를 수신하는 팔로어 수가 많은 경우 리더 노드의 네트워크 대역폭에 병목 현상이 발생할 수 있음 복제본 업데이트를 각 팔로워들에게 전파하는 방법에는 동기식과 비동기식 두가지로 나눌수 있다.동기식 복제동기식 복제 에서 노드는 클라이언트에 응답하여 업데이트가 완료되었음을 알린다.이는 다른 복제본으로부터 로컬 스토리지에서도 업데이트를 수행했다는 승인을 받은 후에만 클라이언트에게 응답하도록 한다.동기식 복제를 통해 내구성이 향상될수 있다.리더가 충돌하더라도 이미 팔로워들은 데이터의 업데이트가 완료되어 데이터가 손실되지 않기 때문이다.그러나 팔로워에게 까지 데이터를 업데이트 하므로 쓰기 요청이 느려질 수 있다.리더는 모든 레플리카로부터 응답을 받을 때까지 기다려야 하기 때문이다.비동기식 복제비동기식 복제에서 노드는 다른 복제본의 응답을 기다리지 않고 로컬 저장소에서 업데이트를 수행하자마자 클라이언트에 응답한다.비동기식 복제는 클라이언트가 더 이상 다른 복제본에 대한 네트워크 요청을 기다리지 않기 때문에 쓰기 요청의 성능을 크게 향상시킬수 있다.그러나 이로인해 데이터의 일관성이 감소하고 내구성이 저하된다.Multi-Primary Replication AlgorithmMulti-Primary Replication는 데이터의 일관성 보다 높은 가용성이 중요할때 사용되는 방법이다.Multi-Primary Replication 에선 모든 노드들이 동일하며 쓰기 요청을 할수 있다.또한 데이터 수정시 이를 나머지 노드들에게 전파하는 작업도 수행한다.그러므로 쓰기 요청이 모든 노드에서 동시에 처리되므로 요청을 직렬화하고 단일 순서를 적용하는 단일 리더 노드가 존재하지 않는다.이는 노드에서 처리하는 일부 요청이 올바른 순서로 처리되지 않을 수 있음을 의미 한다.이러한 문제를 conflict 라고 부른다.이러한 conflict 해결에 대한 일반적인 접근 방식은 다음과 같다. 클라이언트에게 conflict 해경 발법 공개 conflict 발생시 사용 가능한 여러 버전의 데이터를 클라이언트에게 반환하고 클라이언트는 이중 올바른 버전을 선택하여 이를 시스템에 반영함 마지막 쓰기를 우선시 하여 conflict 해결 시스템의 각 노드는 로컬 시계를 사용하여 타임스탬프로 각 버전에 태그를 지정하고 가장 최신의 타임스탬프가 있는 버전을 선택함 여러 노드들의 시간이 전역적으로 동기화 되지않으면 예상치 못한 동작이 발생할 수 있음 인과관계 추적 알고리즘 두 쓰기(A, B) 사이에 충돌이 있고 하나가 다른 쓰기의 원인으로 판단되면(A가 B의 원인이라고 가정) 결과 쓰기(B)가 유지 요청이 동시 발생한다면 인과관계가 없는 쓰기가 존재할 수 있으며 이러한 경우 시스템은 쉽게 결정을 내릴수 없음 Quorums in Distributed Systems동기 복제에 장애가 발생하면 노드가 복구될 때까지 시스템이 쓰기를 처리할 수 없기 때문에 쓰기 작업의 가용성이 매우 떨어지게 된다.이러한 문제를 해결하기 위해 역방향 전략을 사용할 수 있다. 즉, 쓰기 작업을 담당하는 노드에만 데이터를 쓰지만, 읽기 작업은 모든 노드에서 최신 값을 반환하는 방식으로 처리 할 수 있다.이렇게 하면 쓰기 가용성이 크게 증가 하지만 동시에 읽기 가용성이 감소하게 된다.따라서 쓰기 가용성과 읽기 가용성간 균형을 이루기 위한 메커니즘이 존재하게 되는데, 쿼럼(Quorums) 을 사용하는 것이다.3개의 복제본으로 구성된 시스템에서 쓰기는 2개의 노드(2개의 쿼럼)에서 완료되어야 하고, 읽기는 2개의 노드에서 데이터를 검색되어야 한다.일반적으로 총 시스템의 복제본 $V$에 대하여 모든 읽기 요청에 대해 읽기 쿼럼 $V_r$ 을 얻어야 하여 쓰기 요청에 대해선 쓰기 쿼럼 $V_w$ 얻어야 하는데, 이때 쿼럼의 값은 다음과 같은 속성을 따른다. $V_r + V_w &amp;gt; V$ $V_w &amp;gt; V_/ 2$첫 번째 규칙은 두 작업을 통해 데이터 항목을 동시에 읽고 쓰지 않도록 보장한다.두 번째 규칙은 적어도 하나의 노드가 두 개의 쓰기 작업을 모두 수신하고 이에 대한 명령을 부과하도록 보장한다.이는 서로 다른 두 작업의 두 쓰기 작업이 동일한 데이터 항목에서 동시에 발생할 수 없음을 의미한다.두 규칙 모두 연관된 분산 데이터베이스가 중앙 집중식 단일 복제본 데이터베이스 시스템으로 작동하도록 보장한다.참고 Distributed Systems for Practitioners" }, { "title": "Distributed Systems - Partitioning", "url": "/posts/educative-distributed-system-02/", "categories": "System Design, Distributed Systems", "tags": "System Design, Distributed Systems", "date": "2024-06-11 22:02:00 +0900", "snippet": "Partitioning분산 시스템의 주요 이점중 하나는 확장성(Scalability) 이다.이러한 확장성을 달성하기 위한 주요 구현 방식중 하나는 파티셔닝(Partitioning) 이다.파티셔닝은 데이터 세트를 여러개의 작은 데이터 세트로 분할한 다음 이를 저장하고 처리하는 책임을 분산 시스템의 여러 노드에 각각 할당하는 방법을 말한다.파티셔닝에는 크게 두가지 변형이 존재한다. Vertical partitioning(수직 파티셔닝) Horizontal partitioning(수평 파티셔닝) 샤딩 Vertical partitioning수직 파티셔닝은 테이블을 더 적은 수의 열이 포함된 여러 테이블로 나누고 나뉘어진 테이블을 서로 연결하기 위해 추가적인 행을 별도로 추가한다.나뉜 두 테이블을 연결하는 작업을 일반적으로 조인작업이라고 부른다.정규화를 통해 수직 파티셔닝을 수행할 수 있다.이러한 수직 파티셔닝 시스템에선 서로다른 테이블의 데이터를 결합하는 요청에 대해 효율이 떨어지게 된다.Horizontal partitioning수평 파티셔닝은 테이블을 같은 행을 가진 여러개의 작은 테이블로 나누고 각 테이블에 일정한 수의 데이터가 반영되도록 하는 방법이다.수평 파티셔닝은 서로 다른 노드에 있는 데이터에 대해 데이터를 수평으로 분할할 때 원자성 작업을 수행하는 것이 훨씬 더 어렵다.Algorithms for Horizontal Partitioning수평 분할을 구현하기 위한 여러 알고리즘이 존재한다.Range partitioningRange partitioning은 특정 속성의 값에 따라 데이터 세트를 범위로 분할하는 방법이다. 장점 구현의 용이성 분할 키 값을 사용하여 범위 쿼리 수행 가능 쿼리된 범위가 작고 단일 노드에 있는 경우 분할 키를 사용하는 범위 쿼리에 대한 성능이 좋음 범위 조정(재 분할)이 더 쉽고 효율적임 단점 분할 키 이외의 키를 사용하여 범위 쿼리를 수행할 수 없음 쿼리된 범위가 크고 여러 노드에 상주하는 경우 분할 키를 사용하는 범위 쿼리의 성능이 저하됨 트래픽이나 데이터의 고르지 못한 분포로 인해 일부 노드에 과부하가 발생할 수 있음 Hash partitioningHash partitioning은 각 행의 특정 속성에 해시 함수를 적용하여 해당 행이 속하는 파티션을 결정하는 방법이다. 장점 키를 해시 함수를 통해 만드므로 런타임시 상대적으로 쉽게 분할 매핑을 계산 할 있음 해시 함수가 시스템 노드 전체에 데이터를 균일하게 배포하여 일부 노드의 과부하를 방지할 수 있음 단점 추가 데이터를 저장하거나 모든 노드를 쿼리하지 않으면 분할 키로 사용하는 속성에 대해서도 범위 쿼리를 수행할 수 없음 시스템에서 노드를 추가하거나 제거하면 다시 분할해야 하며 이로인해 시스템의 모든 노드에서 상당한 데이터 이동이 발생할 수 있음 Consistent hashingConsistent hashing은 Hash partitioning과 매우 유사한 분할 기술 이지만 해시 분할로 인해 발생하는 데이터 이동 문제를 해결한다.시스템은 링 이라고 불리우는 [0, L] 범위 값이 생성한다.(예: [0, 360]).각 노드는 링의 범위내 특정 값 s를 할당 받는다.그런 다음 시스템은 속성 값이 있는 레코드를 분할 키로 사용하여 hash(s) mod L 계산을 통해 링의 해당 지점 뒤에 있는 노드를 찾습니다.새로운 노드가 링에 진입하면 링의 다음 노드에서만 데이터를 받는다.이외 노드는 더이상 다른 데이터를 교환할 필요가 없다. 장점 시스템에 노드를 추가하거나 제거할때 데이터 이동을 감소할 수 있음 단점 링에 있는 노드의 무작위 할당으로 인해 데이터가 균일하지 않게 분포될 수 있음 노드가 추가되거나 제거됨에 따라 데이터 분포가 더 불균형해질 수 있음 참고 Distributed Systems for Practitioners" }, { "title": "Distributed Systems - 분산 시스템 소개", "url": "/posts/educative-distributed-system-01/", "categories": "System Design, Distributed Systems", "tags": "System Design, Distributed Systems", "date": "2024-06-10 22:02:00 +0900", "snippet": "Distributed Systems 이란?분산 시스템은 흔히 구성 요소가 서로다른 네트워크 컴퓨터에 위치하며 서로 메세지를 전달하여 작업을 통신하고 조정하는 시스템이다.이 시스템의 구성요소는 컴퓨터와 같은 물리적 하드웨어에서 실행되는 소프트웨어 프로그램으로 생각할 수 있다.이러한 구성 요소는 웹 서버, 라우터, 웹 브라우저와 같이 다양한 형태를 취할 수 있으며 일반적으로 이러한 각 머신을 노드 라고 부른다.Distributed Systems의 이점분산 시스템에는 성능, 확장성, 가용성와 같은 세가지 이점이 있다.성능두대 이상의 저사양 컴퓨터를 사용하여 고성능 컴퓨터 한대를 사용하는 것과 같은 성능을 얻을 수 있다.즉, 더 낮은 비용으로 더 나은 성능(요청당 지연시간 단축, 처리량 증가 등)을 얻을 수 있다.확장성여러 컴퓨터에 데이터를 분할하여 저장하고, 처리 작업을 분산 할 수 있다.즉, 수 많은 컴퓨터에 데이터를 분할하여 저장, 처리를 통해 단일 컴퓨터 시스템보다 크게 시스템을 확장 할 수 있다.가용성여러 컴퓨터에 중복된 데이터를 저장하여 한 컴퓨터의 오류 발생시 다른 컴퓨터로 전환 할 수 있게 되어 서비스를 지속적으로 운영할 수 있게 된다.Distributed Systems의 다양한 오류들분산 시스템은 단일 컴퓨터에서 실행되는 소프트웨어 시스템보다 더 많은 제약을 받게 된다.이러한 제약을 간과하고 개발을 하게 되면 여러 부분을 놓치게 되는데, 이러한 부분들을 정리한 것이 분산 컴퓨팅의 오류 라고 한다. The network is reliable 네트워크는 안정적이지 않을수 있다. Latency is zero 원격 시스템에 대한 호출에는 지연시간이 있다. Bandwidth is infinite 네트워크의 대역폭은 유한하다. The network is secure 네트워크는 안전(보안)하지 않을 수 있다. Topology doesn’t change 네트워크 구성이 변경될 수 있다. There is one administrator 관리의 권한이 여럿일 수 있다. Transport cost is zero 분산 시스템내의 두 지점간 통신에는 비용이 발생한다. The network is homogeneous 분산 시스템내의 각 노드들의 시간이 동일하지 않을 수 있다. 시간 동기화의 문제 Distributed Systems을 설계하기 어렵게 만드는 여러 이유네트워크 비동기성, 부분적인 실패 및 동시성은 분산 시스템 분야의 복잡성을 높이는 주요 원인이므로, 실생활에서 분산 시스템을 구축할 때 이를 염두에 두어야 한다. 네트워크 비동기(Network asynchrony) 분산 시스템내 여러 노드별로 각각 처리 작업을 처리하여 요청이 비동기적으로 처리될수 있어 직관적이지 못하다. 부분적인 실패(Partial failures) 분산 시스템의 일부 구성요소에만 오류가 발생 할수 있으므로, 분산 시스템의 구성 요소 전체에 원자성이 필요한 경우 복잡도가 크게 상승한다. 이러한 문제로 인해 시스템의 모든 노드에 작업을 적용하거나, 어느 노드에도 적용하지 않아야 한다. 동시성(Concurrency) 각 노드가 동시에 여러 계산을 진행하므로 서로 간섭하고 예상치 못한 동작을 하여 추가적은 복잡성이 발생한다. Distributed Systems 모델분산 시스템 모델을 생성하려면 모델이 충족해야 하는 몇 가지 속성을 정의해야 한다.알고리즘이 이 모델에 대해 정확하다는 것을 증명하면 이러한 속성을 충족하는 모든 시스템에 대해서도 알고리즘이 정확할 것이라고 확신할 수 있다.각 시스템에는 다음과 같은 주요한 속성이 있다. 분산 시스템의 노드가 서로 상호 작용하는 방법 분산 시스템의 노드가 실패하는 방법위와 같은 주요 속성에 대해, 네트워크 통신의 성격에 따라 두가지 범주로 나눌수 있다. 동기식 시스템 각 노드가 정확한 시계를 가지고 있고 메세지 전송 지연 및 처리 시간에 대해 상한이 존재하는 시스템 흔히, 하나의 노드가 작업을 처리할때 다른 노드는 해당 작업이 완료되어 메세지를 받을때 까지 잠금상태로 기다림 비동기식 시스템 각 노드에는 공통된 시간 개념이 없으므로 독립적이게 작업을 수행 하나의 노드가 적업을 처리할때, 다른 노드는 해당 작업이 완료되어 메세지를 받지 않더라도 다른 작업을 수행하고 있음 Distributed Systems 의 실패 유형실패에는 여러 유형이 있으며 가장 기본적인 범주는 아래와 같다. 장애 중지(Fail-stop) 노드가 영구적으로 정지된 상태로 유지됨 충돌(Crash) 노드가 조용히 정지됨 생략(Omission) 노드가 요청에 응답을 하지 못함 임의의 동작(Byzantine) 노드가 의도한 프로토콜, 알고리즘, 로직등에 따라 동작하지 않을때 발생 Exactly-Once 의미론분산 시스템에서 각 노드는 메세지 교환을 위해 서로 통신한다.이때 네트워크는 안정적이지 않을 수 있기 때문에 메세지가 손실될 가능성이 있다.이러한 경우, 아래 그림과 같이 아예 요청을 받지 못하는경우와 메세지가 여러번 전달될 수 있는 가능성이 존재하게 된다.이러한 문제를 방지하기 위해 여러 접근방식을 취할 수 있다. 멱등성 작업 접근 방식(Idempotent operations approach) 멱등성은 동일한 연산에 대해 결과가 변경되지 않는 성질을 말한다 즉, 멱등성 잡업에 대하여 결과를 값 집합에 포함시켜 작업에 대해 여러번 수행하더라도 첫번째 작업의 결과만 반영하도록 한다. 멱등성 연산은 시스템에 업격한 제약을 가정하므로 모든 작업에 대하여 본질적으로 멱등성을 가지도록 시스템을 구축하기엔 불가능하다. 중복 제거 접근 방석 모든 메세지에 고유 식별자를 부여하고, 재시도된 모든 메세지에는 원본과 동일한 식별자를 포함한다. 배송과 처리의 차이 인식 네트워크 통신을 통한 배송과 배송된 메세지에 대한 어플리케이션의 처리에 대하여 구분한다. 분산 시스템에서는 정확히 한번만 배송하는 것은 불가능하나, 정확히 한번만 처리 하는 것은 가능한 경우가 있다. Distributed Systems의 장애 감지흔히 시간초과(Time Out) 방식을 통해 분산 시스템내의 오류를 감지하는데,이는 분산 시스템에서 네트워크의 비동기적 특성으로 인해 충돌이 발생한 경우와 요청에 대한 응답이 느린경우를 구별하기가 쉽지 않다.Time Out의 시간값이 작게 설정되어 있을 경우시스템이 충돌한 노드를 기다리는데 더 적은 시간을 소비하게 된다.그러나 네트워크 지연으로 인해 응답이 Time Out의 시간값보다 늦게 되면 노드가 장애가 발생했다고 착각할수 있다.Time Out의 시간값이 크게 설정되어 있을 경우시스템이 네트워크 지연에 대해 관대해 진다.그러나 시스템은 충동한 노드를 식별하는 속도가 느려지게 되고 노드를 기다리는 동안의 시간을 낭비 할 수 있다.Stateless and Stateful Systems분산 시스템은 다은과 같은 두가지 범주중 하나에 속하게 된다. 무상태 시스템(Stateless) 과거에 발생한 일에 대해 상태를 유지하지 않으며 제공받은 입력을 기반으로 기능을 수행 상태 저장 시스템(Stateful Systems) 상태를 유지하고 변경하여, 상태에 따라 작업의 결과가 달라지게 됨 무상태 시스템의 모든 노드는 동일한 것으로 간주되어 지기 때문에 보통 무상태 시스템이 상태 저장 시스템에 비해 설계, 구축, 확장이 쉽다.상태 저장 시스템은 서로 다른 노드가 각각 다른 데이터를 보유할 수 있으므로 데이터의 동기화를 위해 별도의 작업이 필요하다.참고 Distributed Systems for Practitioners" }, { "title": "Programmers - 이진 변환 반복하기", "url": "/posts/ps-programmers-055/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, String", "date": "2024-05-16 23:20:00 +0900", "snippet": " 이진 변환 반복하기 - lv.2문제0과 1로 이루어진 어떤 문자열 x에 대한 이진 변환을 다음과 같이 정의합니다. x의 모든 0을 제거합니다. x의 길이를 c라고 하면, x를 “c를 2진법으로 표현한 문자열”로 바꿉니다.예를 들어, x = “0111010”이라면, x에 이진 변환을 가하면 x = “0111010” -&amp;gt; “1111” -&amp;gt; “100” 이 됩니다.0과 1로 이루어진 문자열 s가 매개변수로 주어집니다. s가 “1”이 될 때까지 계속해서 s에 이진 변환을 가했을 때, 이진 변환의 횟수와 변환 과정에서 제거된 모든 0의 개수를 각각 배열에 담아 return 하도록 solution 함수를 완성해주세요.제한사항 s의 길이는 1 이상 150,000 이하입니다. s에는 ‘1’이 최소 하나 이상 포함되어 있습니다.입출력 예 s result “110010101001” [3,8] “01110” [3,3] “1111111” [4,1] 입출력 예 #1 “110010101001”이 “1”이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다. 회차 이진 변환 이전 제거할 0의 개수 0 제거 후 길이 이진 변환 결과 1 “110010101001” 6 6 “110” 2 “110” 1 2 “10” 3 “10” 1 1 “1” 3번의 이진 변환을 하는 동안 8개의 0을 제거했으므로, [3,8]을 return 해야 합니다.입출력 예 #2 “01110”이 “1”이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다. 회차 이진 변환 이전 제거할 0의 개수 0 제거 후 길이 이진 변환 결과 1 “01110” 2 3 “11” 2 “11” 0 2 “10” 3 “10” 1 1 “1” 3번의 이진 변환을 하는 동안 3개의 0을 제거했으므로, [3,3]을 return 해야 합니다.입출력 예 #3 “1111111”이 “1”이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다. 회차 이진 변환 이전 제거할 0의 개수 0 제거 후 길이 이진 변환 결과 1 “1111111” 0 7 “111” 2 “111” 0 3 “11” 3 “11” 0 2 “10” 4 “10” 1 1 “1” 4번의 이진 변환을 하는 동안 1개의 0을 제거했으므로, [4,1]을 return 해야 합니다.풀이 String#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;bitset&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; solution(std::string s) { int count = 0; int count_erased_zero = 0; while (s != &quot;1&quot;) { std::string sub; for (const char&amp;amp; c : s) { if (c != &#39;0&#39;) { sub.push_back(c); } else { count_erased_zero++; } } uint64_t value = std::bitset&amp;lt;64&amp;gt;(sub.size()).to_ullong(); std::string temp = std::bitset&amp;lt;64&amp;gt;(value).to_string(); const auto first_digit = temp.find(&#39;1&#39;); if(first_digit != std::string::npos) { s = temp.substr(first_digit); } count++; } return {count, count_erased_zero};}" }, { "title": "Programmers - JadenCase 문자열 만들기", "url": "/posts/ps-programmers-054/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, String", "date": "2024-05-16 23:11:00 +0900", "snippet": " JadenCase 문자열 만들기 - lv.2문제JadenCase란 모든 단어의 첫 문자가 대문자이고, 그 외의 알파벳은 소문자인 문자열입니다. 단, 첫 문자가 알파벳이 아닐 때에는 이어지는 알파벳은 소문자로 쓰면 됩니다. (첫 번째 입출력 예 참고)문자열 s가 주어졌을 때, s를 JadenCase로 바꾼 문자열을 리턴하는 함수, solution을 완성해주세요.제한사항 s는 길이 1 이상 200 이하인 문자열입니다. s는 알파벳과 숫자, 공백문자(“ “)로 이루어져 있습니다. 숫자는 단어의 첫 문자로만 나옵니다. 숫자로만 이루어진 단어는 없습니다. 공백문자가 연속해서 나올 수 있습니다. 입출력 예 s return “3people unFollowed me” “3people Unfollowed Me” “for the last week” “For The Last Week” 풀이 String#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;sstream&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;cctype&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;string solution(string s) { std::string answer = &quot;&quot;; // 마지막 공백문자가 여러개일때 token으로 자르게 되면 // 마지막 공백이 누락되어 공백을 하나 무조건 추가 s.push_back(&#39; &#39;); std::vector &amp;lt;std::string&amp;gt; tokens; std::stringstream stream(s); std::string temp; while(std::getline(stream, temp, &#39; &#39;)) { std::transform(temp.begin(), temp.end(), temp.begin(), [](unsigned char c){ return std::tolower(c); }); tokens.push_back(temp); } for (std::string token : tokens) { if (&#39;a&#39; &amp;lt;= token[0] &amp;amp;&amp;amp; token[0] &amp;lt;= &#39;z&#39;) { token[0] = std::toupper(token[0]); } answer += token; answer.push_back(&#39; &#39;); } answer.pop_back(); return answer;}" }, { "title": "Programmers - 키패드 누르기", "url": "/posts/ps-programmers-053/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, SQL", "date": "2024-05-16 22:11:00 +0900", "snippet": " 한 해에 잡은 물고기 수 구하기 - lv.1문제낚시앱에서 사용하는 FISH_INFO 테이블은 잡은 물고기들의 정보를 담고 있습니다. FISH_INFO 테이블의 구조는 다음과 같으며 ID, FISH_TYPE, LENGTH, TIME은 각각 잡은 물고기의 ID, 물고기의 종류(숫자), 잡은 물고기의 길이(cm), 물고기를 잡은 날짜를 나타냅니다. Column name Type Nullable ID INTEGER FALSE FISH_TYPE INTEGER FALSE LENGTH FLOAT TRUE TIME DATE FALSE 단, 잡은 물고기의 길이가 10cm 이하일 경우에는 LENGTH 가 NULL 이며, LENGTH 에 NULL 만 있는 경우는 없습니다.FISH_INFO 테이블에서 2021년도에 잡은 물고기 수를 출력하는 SQL 문을 작성해주세요.이 때 컬럼명은 ‘FISH_COUNT’ 로 지정해주세요.입출력 예예시예를 들어 FISH_INFO 테이블이 다음과 같다면 ID FISH_TYPE LENGTH TIME 0 0 13.37 2021/12/04 1 0 50 2020/03/07 2 0 40 2020/03/07 3 1 43.33 2022/03/09 4 1 NULL 2022/04/08 5 2 NULL 2021/04/28 2021 년도에 잡은 물고기는 물고기의 ID 0, 5에 해당하는 물고기 2마리 입니다. 따라서 결과는 다음과 같아야 합니다. FISH_COUNT 2 풀이 SQLSELECT COUNT(ID) as FISH_COUNTFROM FISH_INFOWHERE DATE(TIME) BETWEEN &#39;2021-01-01&#39; AND &#39;2021-12-31&#39;;" }, { "title": "Data Intensive Application - 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 어플리케이션", "url": "/posts/data_intensive_application-01/", "categories": "Books, Data Intensive Application", "tags": "Books, Data Intensive Application", "date": "2024-05-13 22:27:00 +0900", "snippet": "데이터 시스템일반적으로 오늘날의 데이터 중심 어플리케이션들은 아래와 같은 부분들을 필요로 한다. 데이터 수집 및 저장(데이터베이스) 읽기 속도 향상을 위해 결과 기억(캐시) 사용자가 키워드로 데이터를 검색 하거나 필터링할 수 있게 제공(검색 색인(search index)) 비동기 처리를 위해 다른 프로세스로 메세지 전송(스트림 처리(stream processing)) 주기적으로 대량의 누적된 데이터 분석(일괄 처리(batch processing))대부분의 소프트웨어 시스템에서는 아래와 같은 세가지 관심사가 존재한다. 신뢰성(Reliability) 하드웨어나 소프트웨어 결함, 심지어 휴먼 에러와 같은 상황이더라도 시스템은 지속적으로 동작해야 함 확장성(Scalability) 시스템의 데이터 양, 트래픽 양, 복잡도가 증가하면서 이를 처리할 수 있는 적절한 방법이 있어야 함 유지보수성(Maintainability) 시간이 지남에 따라 여러 사람들이 시스템 상에서 작업하므로, 모든 사용자가 시스템 상에서 생산적으로 작업할 수 있어야 함 신뢰성(Reliability)잘못 될수 있는 일을 결함(fault) 이라 부른다. 그리고 결함을 예측하고 대처할 수 있는 시스템을 내결함성(fault-tolerant) 또는 탄력성(resilient) 을 지녔다고 말한다.결함은 장애(failure) 와 동일하지 않다. 일반적으로 결함은 사양에서 벗어난 시스템의 한 구성요소로 정의되지만, 장애는 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우을 말한다.결함 확률을 0으로 줄이는 것은 불가능 하므로 보통 결함으로 인한 장애가 발생하지 않게끔 내결함성 구조를 설계하는 것이 가장 좋다.확장성(Scalability)확장성은 증가하는 부하에 대처하는 시스템 능력을 성멸하는데 사용하는 용어지만 시스템에 부여하는 일차원적인 표식은 아니다. 즉, “시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가? 추가 부하를 다루기 위해 계산 자원을 어떻게 투입해야 하는가?” 와 같은 질문을 고려한다는 의미이다.확장성을 기술하기 위해선 먼저 시스템의 현재 부하를 기술해야한다. 그래야 부하 성장 질문(현재 시스템에서 부하가 두배로 되면 어떻게 되는가?)을 논의할 수 있다.부하는 부하 매개변수(load parameter) 라 부르는 몇개의 숫자로 나타낼수 있으며 아래와 같은 수치들을 부하 매개변수로 불수 있다. 웹 서버의 초당 요청수 데이터베이스의 읽기 대 쓰기 비율 대화방의 동시 활성 사용자(active user) 캐시 적중률성능 기술하기하둡과 같은 일괄처리 시스템은 보통 처리량(throughput)(초당 처리할 수 있는 레토드수나 일정 크기의 데이터 집합으로, 작업을 후행할 때 걸리는 전체 시간) 에 관심을 가지고, 일반적인 온라인 시스템에서 더 중요한 사항은 서비스의 응답 시간(response time). 즉 클라이언트가 요청을 보내고 응답을 받는 사이의 시간이다.클라이언트가 몇번이고 반복해서 동일한 요청을 보내더라도 실제로 다양한 요청을 다루는 시스템에서의 응답시간은 많이 변하므로 응답 시간은 단일 숫자가 아니라 측정 하능한 값의 분포 로 생각해야 한다.일반적으로는 평균 응답시간 보다는 백분위(percentile) 을 사용하는 편이 좋다. 응답 시간 목록을 가지고 가장 빠른 시간부터 제일 느린 시간까지 정렬하면 중간 지점인 중앙값(median) 이 되며 이는 사용자가 보통 얼마나 오랫동안 기다려야 하는지 알수 있는 좋은 지표가 된다.부하 대응 접근 방식사람들은 확장성과 관련해 용량 확장(scaling up)(수직 확장(vertival scaling)) 과 규모 확장(scaling out)(수평 확장(horizontal scaling)) 으로 구분해서 말한다.특정 어플리케이션에 적합한 확장성을 갖춘 아키텍처는 주요 동작이 무엇이고 잘 하지 않는 동작이 무엇인지에 대한 가정을 바탕으로 구축한다. 이 가정은 곧 부하 매개변수가 된다. 이 가정이 잘못되면 확장에 대한 엔지니어링 노력은 헛수고가 되고 오히려 역효과를 낳을수도 있다.유지보수성(Maintainability)유지보수를 위해 주의를 기울여야 할 소프트웨어 시스템 설계 원칙은 다음 세가지 이다. 운용성(operability) 운영팀이 시스템을 원활하게 운영할 수 있게 쉽게 만들어야 함 단순성(simplicity) 시스템에서 복잡도를 최대한 제거하여 새로운 개발자가 시스템을 이해하기 쉽게 만들어야 함 발전성(evolvability) 개발자가 이후에 시스템을 쉽게 변경할 수 있도록 만들어야 함 참고 Data Intensive Application - Martin Kieoomann" }, { "title": "LeetCode - 620. Not Boring Movies", "url": "/posts/ps-leetcode-620/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, SQL", "date": "2024-04-23 23:09:00 +0900", "snippet": " 620. Not Boring Movies - Easy문제Table: Cinema+----------------+----------+| Column Name | Type |+----------------+----------+| id | int || movie | varchar || description | varchar || rating | float |+----------------+----------+id is the primary key (column with unique values) for this table.Each row contains information about the name of a movie, its genre, and its rating.rating is a 2 decimal places float in the range [0, 10]Write a solution to report the movies with an odd-numbered ID and a description that is not “boring”.Return the result table ordered by rating in descending order.The result format is in the following example.입출력 예Example 1:Input:Cinema table:+----+------------+-------------+--------+| id | movie | description | rating |+----+------------+-------------+--------+| 1 | War | great 3D | 8.9 || 2 | Science | fiction | 8.5 || 3 | irish | boring | 6.2 || 4 | Ice song | Fantacy | 8.6 || 5 | House card | Interesting | 9.1 |+----+------------+-------------+--------+Output:+----+------------+-------------+--------+| id | movie | description | rating |+----+------------+-------------+--------+| 5 | House card | Interesting | 9.1 || 1 | War | great 3D | 8.9 |+----+------------+-------------+--------+Explanation:We have three movies with odd-numbered IDs: 1, 3, and 5. The movie with ID = 3 is boring so we do not include it in the answer.풀이select *from cinemawhere MOD(id, 2) = 1 and description not like &#39;boring&#39;order by rating DESC;" }, { "title": "LeetCode - 1768. Merge Strings Alternately", "url": "/posts/ps-leetcode-570/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Two Pointer, String", "date": "2024-04-23 22:28:00 +0900", "snippet": " 1768. Merge Strings Alternately - Easy문제You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append the additional letters onto the end of the merged string.Return the merged string.입출력 예Example 1:Input: word1 = &quot;abc&quot;, word2 = &quot;pqr&quot;Output: &quot;apbqcr&quot;Explanation: The merged string will be merged as so:word1: a b cword2: p q rmerged: a p b q c rExample 2:Input: word1 = &quot;ab&quot;, word2 = &quot;pqrs&quot;Output: &quot;apbqrs&quot;Explanation: Notice that as word2 is longer, &quot;rs&quot; is appended to the end.word1: a bword2: p q r smerged: a p b q r sExample 3:Input: word1 = &quot;abcd&quot;, word2 = &quot;pq&quot;Output: &quot;apbqcd&quot;Explanation: Notice that as word1 is longer, &quot;cd&quot; is appended to the end.word1: a b c dword2: p qmerged: a p b q c d제한사항 1 &amp;lt;= word1.length, word2.length &amp;lt;= 100 word1 and word2 consist of lowercase English letters.풀이 Two Pointer, Stringclass Solution {public: string mergeAlternately(string word1, string word2) { std::string word; int index = 0; while(index &amp;lt; word1.size() || index &amp;lt; word2.size()) { if (index &amp;lt; word1.size()) { word.push_back(word1[index]); } if (index &amp;lt; word2.size()) { word.push_back(word2[index]); } ++index; } return word; }};" }, { "title": "HackerRandk - Fraudulent Activity Notifications", "url": "/posts/ps-hackerrank-01/", "categories": "Problem Solving, HackerRandk", "tags": "PS, HackerRandk, Interview Preparation Kit, Sort", "date": "2023-12-22 18:19:00 +0900", "snippet": " Fraudulent Activity Notifications - Medium문제HackerLand National Bank has a simple policy for warning clients about possible fraudulent account activity. If the amount spent by a client on a particular day is greater than or equal to the client’s median spending for a trailing number of days, they send the client a notification about potential fraud. The bank doesn’t send the client any notifications until they have at least that trailing number of prior days’ transaction data.Given the number of trailing days and a client’s total daily expenditures for a period of days, determine the number of times the client will receive a notification over all days.입출력 예expenditure = [10, 20, 30, 40, 50]d = 3On the first three days, they just collect spending data. At day , trailing expenditures are . The median is and the day’s expenditure is . Because , there will be a notice. The next day, trailing expenditures are and the expenditures are . This is less than so no notice will be sent. Over the period, there was one notice sent.Note: The median of a list of numbers can be found by first sorting the numbers ascending. If there is an odd number of values, the middle one is picked. If there is an even number of values, the median is then defined to be the average of the two middle values. (Wikipedia)Function DescriptionComplete the function activityNotifications in the editor below.activityNotifications has the following parameter(s): int expenditure[n]: daily expenditures int d: the lookback days for median spendingReturns int: the number of notices sent풀이 Sortint activityNotifications(vector&amp;lt;int&amp;gt; expenditure, int d) { int count = 0; vector&amp;lt;int&amp;gt; sub(expenditure.begin(), expenditure.begin() + d); std::sort(sub.begin(), sub.end()); for (auto iter = expenditure.begin() + d ; iter != expenditure.end() ; ++iter) { double median = 0.0; if (d % 2 == 0) { int index1 = d / 2; int index2 = (d / 2) - 1; median = (*(sub.begin() + index1) + *(sub.begin() + index2)) / 2.0; } else { int index = d / 2; median = *(sub.begin() + index); } if (*iter &amp;gt;= (median * 2.0)) { ++count; } sub.insert( upper_bound(sub.begin(), sub.end(), *iter), *iter); sub.erase( lower_bound(sub.begin(), sub.end(), *(iter - d))); } return count;}" }, { "title": "simpleDB - 메모리", "url": "/posts/my_project_simpledb/", "categories": "Project, simpleDB", "tags": "project, skiplist", "date": "2023-11-08 12:00:00 +0900", "snippet": "SkipList구현하고 있는 simpleDB 프로젝트는 distribute key value storage 로,기본적으로는 LSM-tree 를 사용하여 storage를 구현했고, 분산처리를 위해 Raft 알고리즘을 구현한 프로젝트이다.여기서 LSM-tree 기반 storage를 구현하던 중 L0에 해당하는 메모리 영역에 데이터를 저장하기 위한 구조가 필요했었다.처음엔 단순히 map을 사용하여 메모리 영역인 L0을 구현했는데, 이왕 프로젝트 진행하는데 map은 너무 심심하다고 생각되어 적당한 데이터 구조가 없는지 여러 레퍼런스를 찾던도중 skiplist 가 적당할 것 같아 선택하게 되었다.SkipList 란?위키에 skiplist를 검색하여 어떤건지 설명을 보면 아래와 같다. In computer science, a skip list (or skiplist) is a probabilistic data structure that allows O(log n) average complexity for search as well as O(log n) average complexity for insertion within an ordered sequence of n elements.즉, skiplist는 linkedlist, tree와 같은 일종의 데이터구조의 한 종류로, 조회, 삽입의 시간복잡도가 O(log n)으로 예상되는 정렬된 확률적 데이터구조이다.왜 데이터구조에 확률적이라는 말이 붙었을까? 이는 skiplist의 기본적인 동작방식을 보면 이해할 수 있다.기본 동작방식skiplist는 기본적으로 여러 level이 존재하고 이 level은 linklist와 유사한 구조로 여러 node를 포함할 수 있도록 되어있다.구현# pseudocodemake all nodes level 1j ← 1while the number of nodes at level j &amp;gt; 1 do for each i&#39;th node at level j do if i is odd and i is not the last node at level j randomly choose whether to promote it to level j+1 else if i is even and node i-1 was not promoted promote it to level j+1 end if repeat j ← j + 1repeattype SkipList struct { // skiplist의 maxk level maxLevel int // 저장된 item 의 수 length int // 저장된 item(key, value)의 byte 크기 size uint64 // node의 head, tail head *SkipListNode tail *SkipListNode // insert시 level 추론을 위한 rand rand *rand.Rand // 조회한 node cache를 위한 임시 slice history []*SkipListNode mutex sync.RWMutex}참고 https://en.wikipedia.org/wiki/Skip_list" }, { "title": "Spring Framework - AOP 주의사항", "url": "/posts/spring-17/", "categories": "Backend, Spring Framework", "tags": "Web, Spring Framework, AOP", "date": "2023-11-08 12:00:00 +0900", "snippet": "프록시와 내부 호출 문제스프링은 프록시 방식의 AOP를 사용한다.따라서 AOP를 적용하려면 항상 프록시를 통해서 대상 객체(Target)을 호출해야 한다.이렇게 해야 프록시에서 먼저 어드바이스를 호출하고 이후 대상 객체를 호출한다.만약 프록시를 거치지 않고 대상 객체를 직접 호출하게되면 AOP가 적용되지 않고 어드바이스도 호출되지 않는다.스프링은 의존관계 주입시, AOP가 적용된 객체라면 대상 객체 대신에 프록시를 스프링 빈으로 등록하기 떄문에 외부에서 대상 객체를 직접 호출하는 문제는 발생하지 않는다.그러나 대상 객체의 내부에서 내부 메소드 호출이 발생하면 프록시를 거치치 않고 대상 객체를 직접 호출하는 문제가 발생한다.@Slf4j@Componentpublic class CallServiceV0 { public void external() { log.info(&quot;call external&quot;); // this.internal()로 호출됨 internal(); } public void internal() { log.info(&quot;call internal&quot;); }}@Slf4j@Aspectpublic class CallLogAspect { @Before(&quot;execution(* hello.aop.internalcall..*.*(..))&quot;) public void doLog(JoinPoint joinPoint) { log.info(&quot;aop={}&quot;, joinPoint.getSignature()); }}@Import(CallLogAspect.class)@SpringBootTestpublic class CallServiceV0Test { @Autowired CallServiceV0 callService; @Test void external() { callService.external(); }}# external() Test2023-11-08 14:17:10.280 INFO 60643 --- [ main] h.aop.internalcall.aop.CallLogAspect : aop=void hello.aop.internalcall.CallServiceV0.external()2023-11-08 14:17:10.289 INFO 60643 --- [ main] hello.aop.internalcall.CallServiceV0 : call external2023-11-08 14:17:10.289 INFO 60643 --- [ main] hello.aop.internalcall.CallServiceV0 : call internal# internal() Test2023-11-08 14:17:10.297 INFO 60643 --- [ main] h.aop.internalcall.aop.CallLogAspect : aop=void hello.aop.internalcall.CallServiceV0.internal()2023-11-08 14:17:10.297 INFO 60643 --- [ main] hello.aop.internalcall.CallServiceV0 : call internal실행 결과를 확인해보면 callService.external() 실행시 프록시가 호출되어 CallLogAspect의 어드바이스가 호출되었고,AOP Proxy는 실제 대상 객체인 target.external() 을 호출하여 로그가 출력되었다.그러나 이후 external() 메소드 내부에서 internal() 호출시 CallLogAspect의 어드바이스가 호출되지 않았다.이는 자바에서는 메소드 앞에 별도의 참조가 없나면 this라는 뜻으로 자기자신의 인스턴스를 가리키기 떄문이다.즉, 자기 자신의 내부 메소드를 호출하는 this.internal()이 되어 프록시를 거치지 않고 실제 대상 객체의 인스턴스의 internal() 메소드를 바로 호출하기 때문이다.스프링은 프록시 방식의 AOP를 사용하고, 프록시 방식의 AOP는 메소드 내부 호출에는 프록시를 적용할 수 없으므로 위와 같은 문제가 발생하게 된다.대안 1 - 자기 자신 주입내부 호출을 해결하는 가장 간단한 방법은 자기 자신을 의존관계 주입 받는 것이다./** * 참고: 생성자 주입은 순환 사이클을 만들기 때문에 실패한다. */@Slf4j@Componentpublic class CallServiceV1 { private CallServiceV1 callService; @Autowired public void setCallServiceV1(CallServiceV1 callService) { this.callService = callService; } public void external() { log.info(&quot;call external&quot;); // 자기 자신을 주입 받고 해당 객체로 메소드 호출 callService.internal(); } public void internal() { log.info(&quot;call internal&quot;); }}@Import(CallLogAspect.class)@SpringBootTest(properties = &quot;spring.main.allow-circular-references=true&quot;)public class CallServiceV1Test { @Autowired CallServiceV1 callService; @Test void external() { callService.external(); }}2023-11-08 14:41:18.835 INFO 61926 --- [ main] h.aop.internalcall.aop.CallLogAspect : aop=void hello.aop.internalcall.CallServiceV1.external()2023-11-08 14:41:18.843 INFO 61926 --- [ main] hello.aop.internalcall.CallServiceV1 : call external2023-11-08 14:41:18.843 INFO 61926 --- [ main] h.aop.internalcall.aop.CallLogAspect : aop=void hello.aop.internalcall.CallServiceV1.internal()2023-11-08 14:41:18.843 INFO 61926 --- [ main] hello.aop.internalcall.CallServiceV1 : call internal간편한 방법이지만,위 방법은 스프링 부트 2.6부터는 순환 참조를 기본적으로 금지하도록 정책이 변경되었기 떄문에 2.6 이상의 스프링 부트에서는 아래와 같이 스프링 옵션을 주어야 동작 가능하다. spring.main.allow-circular-references=true지연 조회위 예시에서 생성자 주입이 실패하는 이유는 자기 자신을 생성하면서 주입해야 하기 떄문이다.이 경우 setter 주입을 사용하거나 지연조회를 사용하면 된다.setter 주입의 경우 위 예시와 같은 방법이며 지연조회의 경우는 ObjectProvider(Provider), ApplicationContext를 사용하면 된다./** * ObjectProvider(Provider), ApplicationContext를 사용해서 지연(LAZY) 조회 */@Slf4j@Component@RequiredArgsConstructorpublic class CallServiceV2 { private final ObjectProvider&amp;lt;CallServiceV2&amp;gt; callServiceProvider; public void external() { log.info(&quot;call external&quot;); CallServiceV2 callService = callServiceProvider.getObject(); callService.internal(); } public void internal() { log.info(&quot;call internal&quot;); }}ObjectProvider는 객체를 스프링 컨테이너에서 조회하는 것을 스프링 빈 생성 시점이 아닌 실제 객체를 사용하는 지점으로 지연시킬 수 있다.대안 3 - 구조 변경앞의 방법은 자기 자신을 주입하는 방법으로 순환참조하는 형식이어서 권장되는 방법은 아니다.가장 나은 대한은 내부 호출이 발생하지 않도록 아예 클래스를 나눠 구조를 분리하는 것이다./** * 구조를 변경(분리) */@Slf4j@Component@RequiredArgsConstructorpublic class CallServiceV3 { private final InternalService internalService; public void external() { log.info(&quot;call external&quot;); internalService.internal(); }}@Slf4j@Componentpublic class InternalService { public void internal() { log.info(&quot;call internal&quot;); }}2023-11-08 15:52:20.143 INFO 63553 --- [ main] h.aop.internalcall.aop.CallLogAspect : aop=void hello.aop.internalcall.CallServiceV3.external()2023-11-08 15:52:20.149 INFO 63553 --- [ main] hello.aop.internalcall.CallServiceV3 : call external2023-11-08 15:52:20.149 INFO 63553 --- [ main] h.aop.internalcall.aop.CallLogAspect : aop=void hello.aop.internalcall.InternalService.internal()2023-11-08 15:52:20.152 INFO 63553 --- [ main] hello.aop.internalcall.InternalService : call internal내부 호출 자체가 사라지고 callService -&amp;gt; internalService를 호출하는 구조로 변경되었다.internalService가 별도의 클래스로 빠져나오면서 자연스럽게 AOP가 적용된다.여기서 구조를 변경한다는 것은 단순히 분리하는 것 뿐만 아니라 다양한 방법이 있을수 있다.예를 들면 다음과 같이 클라이언트에서 둘다 호출하는 방법도 있다.클라이언트 -&amp;gt; external()클라이언트 -&amp;gt; internal() 참고AOP는 주로 트랜잭션 적용이나 주요 컴포넌트의 로그 출력 기능에 사용된다.즉, 인터페이스에 메소드가 나올 정도의 규모에 AOP를 적용하는 것이 적당하다.풀어서 이야기 한다면 AOP는 public 메소드에만 적용하고 private 메소드 처럼 작은 단위에는 AOP를 적용하지 않는다.AOP를 적용하기 위해 private 메소드를 외부 클래스로 변경하고 public 으로 변경하는 일은 거의 없다.프록시 기술과 한계타입 캐스팅JDK 동적 프록시와 CGLIB을 사용해서 AOP 프록시를 만드는 방법에는 각각 장단점이 있다.JDK 동적 프록시는 인터페이스가 필수이고 인터페이스를 기반으로 프록시를 생성한다.CGLIB은 구체 클래스를 기반으로 프록시를 생성한다.즉, 인터페이스가 없고 구체 클래스만 있는 경우에는 CGLIB을 사용해야 하고 인터페이스가 있는 경우에는 JDK 동적 프록시나 CGLIB 둘중에 하나를 선택할 수 있다.JDK 동적 프록시의 한계인터페이스 기반으로 프록시를 생성하는 JDK 동적 프록시는 구체 클래스로 타입 캐스팅이 불가능한 한계가 있다.@Testvoid jdkProxy() { MemberServiceImpl target = new MemberServiceImpl(); ProxyFactory factory = new ProxyFactory(target); // JDK 동적 프록시 사용 설정 factory.setProxyTargetClass(false); // 프록시를 인터페이스로 캐스팅 성송 MemberService memberServiceProxy = (MemberService)factory.getProxy(); log.info(&quot;proxy class={}&quot;, memberServiceProxy.getClass()); // JDK 동적 프록시를 구현 클래스로 캐스팅 시도시 실패 // ClassCastException 예외 발생 Assertions.assertThrows(ClassCastException.class, () -&amp;gt; { MemberServiceImpl memberServiceImplProxy = (MemberServiceImpl)factory.getProxy(); });}JDK 동적 프록시 캐스팅JDK Proxy를 대상 클래스인 MemberServiceImpl 타입으로 캐스팅하려 하니 ClassCastException 예외가 발생한다.예외가 발생하는 이유는 JDK 동적 프록시는 인터페이스를 기반으로 프록시를 생성하기 떄문에 JDK Proxy는 MemberServiceImpl의 존재를 알 수 없기 떄문이다.이에 반해 CGLIB을 사용하는 경우는 아래와 같다.@Testvoid cglibProxy() { MemberServiceImpl target = new MemberServiceImpl(); ProxyFactory factory = new ProxyFactory(target); // CGLIB 프록시 사용 factory.setProxyTargetClass(true); // 프록시를 인터페이스로 캐스팅 성송 MemberService memberServiceProxy = (MemberService)factory.getProxy(); log.info(&quot;proxy class={}&quot;, memberServiceProxy.getClass()); // 구현 클래스로 캐스팅 성공 MemberServiceImpl memberServiceImplProxy = (MemberServiceImpl)factory.getProxy(); Assertions.assertInstanceOf(MemberService.class, memberServiceProxy); Assertions.assertInstanceOf(MemberServiceImpl.class, memberServiceImplProxy);}CGLIB 프록시 캐스팅이 경우에는 CGLIB Proxy를 대상 클래스인 MemberServiceImpl 타입으로 캐스팅이 가능하다.CGLIB은 구체 클래스인 MemberServiceImpl 기반으로 프록시를 생성하기 떄문에,구체 클래스인 MemberServiceImpl과 MemberServiceImpl의 인터페이스인 MemberService으로도 타입 캐스팅이 가능하다.이러한 캐스팅문제는 의존관계 주입시에 발생하게 된다.의존관계 주입JDK 동적 프록시 사용시 의존관계 주입을 할때 생기는 문제의 예시 코드를 보면 아래와 같다.@Slf4j@Aspectpublic class ProxyDIAspect { @Before(&quot;execution(* hello.aop..*.*(..))&quot;) public void doTrace(JoinPoint joinPoint) { log.info(&quot;[ProxyDIAspect] {}&quot;, joinPoint.getSignature()); }}@Slf4j@Import(ProxyDIAspect.class)// JDK 동적 프록시, DI 예외 발생@SpringBootTest(properties = {&quot;spring.aop.proxy-target-class=false&quot;})// CGLIB 프록시, 성공// @SpringBootTest(properties = {&quot;spring.aop.proxy-target-class=true&quot;})public class ProxyDITest { // JDK 동적 프록시 OK, CGLIB OK @Autowired MemberService memberService; // JDK 동적 프록시 X, CGLIB OK @Autowired MemberServiceImpl memberServiceImpl; @Test void go() { log.info(&quot;memberService class={}&quot;, memberService.getClass()); log.info(&quot;memberServiceImpl class={}&quot;, memberServiceImpl.getClass()); memberServiceImpl.hello(&quot;hello&quot;); }}위 예시 코드의 경우, 실행해보면 의존관계를 주입하는 시점에 타입과 관련된 에러가 발생하게 된다.BeanNotOfRequiredTypeException: Bean named &#39;memberServiceImpl&#39; is expected to be of type &#39;hello.aop.member.MemberServiceImpl&#39; but was actually of type &#39;com.sun.proxy.$Proxy54&#39;즉, memberSericeImpl에 주입되길 기대하는 타입은 ‘hello.aop.member.MemberServiceImpl’ 이지만, 실제 주입시 넘어온 타입은 ‘com.sun.proxy.$Proxy54’ 이여서 예외가 발생한 것이다.이에 대하여 동작에 대한 설명은 아래와 같다. @Autowired MemberService memberService JDK Proxy는 MemberService 인터페이스를 기반으로 만들어지기 때문에 해당 타입으로 캐스팅할 수 있으며 주입도 가능 @Autowired MemberService memberServiceImpl 해당 부분에서 예외 발생 JDK Proxy는 MemberService 인터페이스를 기반으로 만들어지기 때문에memberServiceImpl 타입에 대해 알지 못하므로 캐스팅할 수 없고, 주입 또한 불가능 위 상황에 대하여 CGLIB 프록시를 구체 클래스에 주입시에는 정상적으로 의존관계 주입이 동작하게 된다. @Autowired MemberService memberService CGLIB Proxy는 MemberServiceImpl 구체 클래스 기반으로 만들어지고, MemberServiceImpl 은 MemberService 인터페이스를 구현했기 때문에 타입 캐스팅 및 주입 가능 @Autowired MemberService memberServiceImpl CGLIB Proxy는 MemberServiceImpl 구체 클래스를 기반으로 만들어지기 때문에 해당 타입으로 캐스팅할 수 있으며 주입도 가능 위 내용에 대하여 정리하자면,JDK 동적 프록시는 인터페이스가 아닌 구현 객체 타입에 의존관계를 주입할 수 없다.반대로 CGLIB 프록시는 대상 객체(구현 객체) 타입에 의존관계를 주입할 수 있다.객체지향 관점으로 바라보게 되면, 실제로 개발할 떄는 인터페이스가 았다면 인터페이스를 기반으로 의존관계 주입을 받는 것이 맞다.인터페이스를 기반으로 의존관계를 주입받아야 DI 받는 클라이언트 코드의 변경 없이 구현 클래스를 변경할 수 있기 때문이다.구현 클래스에 의존관계를 주입받게 되면 향후 구현 클래스를 변경할떄 의존관계 주입을 받는 클라이언트 코드도 함꼐 변경해야 한다.그러므로 올바르게 잘 설계된 어플리케시연 이라면 위와 같은 문제가 자주 발생하지 않는다.그러나 가끔 테스트 또는 여러 이유로 AOP 프록시가 적용된 구체 클래스를 직접 의존관계 주입 받아야 하는 경우가 생기게 되는데,이떄는 CGLIB을 통하여 구체 클래스 기반으로 AOP 프록시를 적용하면 된다.CGLIB스프링에서 CGLIB은 구체 클래스를 상속 받아서 AOP 프록시를 생성할 때 사용한다.CGLIB은 구체 클래스를 상속 받기 때문에 아래와 같은 문게가 발생한다. 대상 클래스에 기본 생성자 필수 생성자 2번 호출 문제 final 키워드 클래스, 메소드 사용 불가대상 클래스에 기본 생성자 필수CGLIB은 구체 클래스를 상속 받는다.자바에서 상속을 받으면 자식 클래스의 생성자를 호출할떄 자식 클래스의 생성자에서 부모 클래스의 생성자도 호출해야 한다.(이 부분이 생략되어 있따면 자식 클래스의 생성자 첫줄에 부모 클래스의 기본 생성자를 호출하는 super()가 자동으로 들어간다.)CGLIB을 사용할 떄 CGLIB가 만드는 프록시의 생성자는 개발자가 호출하는 것이 아니다.CGLIB 프록시는 대상 클래스를 상속받고, 생성자에서 대상 클래스의 기본 생성자를 호출한다.그러므로 대상 클래스의 기본 생성자를 만들어야 CGLIB 프록시가 기본 생성자를 호출할 수 있다.생성자 2번 호출 문제CGLIB은 구체 클래스를 상속 받는다.자바에서 상속을 받으면 자식 클래스의 생성자를 호출할떄 자식 클래스의 생성자에서 부모 클래스의 생성자도 호출해야 한다.이떄 아래와 같이 두번의 생성자가 호출되어 진다. 실제 target 객체를 생성할 떄 프록시 객체를 생성할 떄 부모 클래스의 생성자 호출final 키워드 클래스, 메소드 사용 불가final 키워드가 클래스에 있다면 상속이 불가능하고, 메소드에 있다면 오버라이딩이 불가능하다.그러므로 상속을 기반으로 하는 CGLIB 프록시 방식은 두경우에는 프록시가 생성되지 않거나 정상동작 하지 않는다.그러나 실무에선 프레임워크와 같은 개발이 아닌 일반 어플리케이션을 개발할 떄는 보통 final 키워드를 잘 사용하지 않기 떄문에,이부분에 대해선 크게 문제되지 않는다.스프링의 해결책스프링 4.0 부터 objenesis 라는 라이브러리를 사용하여 기본생성자 없이 객체 생성이 가능해졌다.기본 생성자없이 객체 생성이 가능해 졌으므로 CGLIB의 기본생성자가 필수인 문제와 생성자 2번 호출 문제가 해결되었다.스프링 부트 2.0 부터는 CGLIB을 기본으로 사용하도록 되어서 구체 클래스 타입으로 의존관계를 주입하는 문제를 해결하였다.스프링 부트 2.0 버전부터는 별도의 설정이 없다면 AOP를 적용할떄 proxyTargetClass=true 으로 설정하여 사용한다.따라서 인터페이스가 있어도 JDK 동적 프록시를 사용하는 것이 아니라 항상 CGLIB을 사용하여 구체클래스를 기반으로 프록시를 생성한다.참고 스프링 핵심 원리 - 고급편(김영한)" }, { "title": "Spring Framework - AOP 구현 예시", "url": "/posts/spring-16/", "categories": "Backend, Spring Framework", "tags": "Web, Spring Framework, AOP", "date": "2023-11-08 12:00:00 +0900", "snippet": "Retry AOP 구현@Repositorypublic class ExamRepository { private static int seq = 0; /** * 5번에 1번 실패하는 요청 */ @Trace @Retry(value = 4) public String save(String itemId) { seq++; if (seq % 5 == 0) { throw new IllegalStateException(&quot;예외 발생&quot;); } return &quot;OK&quot;; }}@Service@RequiredArgsConstructorpublic class ExamService { private final ExamRepository examRepository; @Trace public void request(String itemId) { examRepository.save(itemId); }}@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Retry { int value() default 3;}@Slf4j@Aspectpublic class RetryAspect { // @annotaion(rety), Retry retry를 통해 어드바이스에 어노테이션을 파라미터로 전달 @Around(&quot;@annotation(retry)&quot;) public Object doRetry(ProceedingJoinPoint joinPoint, Retry retry) throws Throwable { log.info(&quot;[retry] {} retry={}&quot;, joinPoint.getSignature(), retry); int maxRetry = retry.value(); Exception execptionHolder = null; for (int retryCount = 1 ; retryCount &amp;lt;= maxRetry ; retryCount++) { try { log.info(&quot;[retry] try count={}/{}&quot;, retryCount, maxRetry); return joinPoint.proceed(); } catch (Exception e) { execptionHolder = e; } } throw execptionHolder; }}@Import(RetryAspect.class)@SpringBootTestpublic class ExamTest { @Autowired ExamService examService; @Test void test() { for (int i = 0; i &amp;lt; 5 ; i++) { examService.request(&quot;data&quot; + i); } }}2023-11-08 12:12:25.772 INFO 58418 --- [ main] hello.aop.exam.ExamTest : Started ExamTest in 0.659 seconds (JVM running for 1.463)2023-11-08 12:12:26.047 INFO 58418 --- [ main] hello.aop.exam.aop.RetryAspect : [retry] String hello.aop.exam.ExamRepository.save(String) retry=@hello.aop.exam.annotation.Retry(4)2023-11-08 12:12:26.047 INFO 58418 --- [ main] hello.aop.exam.aop.RetryAspect : [retry] try count=1/42023-11-08 12:12:26.051 INFO 58418 --- [ main] hello.aop.exam.aop.RetryAspect : [retry] String hello.aop.exam.ExamRepository.save(String) retry=@hello.aop.exam.annotation.Retry(4)2023-11-08 12:12:26.051 INFO 58418 --- [ main] hello.aop.exam.aop.RetryAspect : [retry] try count=1/42023-11-08 12:12:26.052 INFO 58418 --- [ main] hello.aop.exam.aop.RetryAspect : [retry] String hello.aop.exam.ExamRepository.save(String) retry=@hello.aop.exam.annotation.Retry(4)2023-11-08 12:12:26.052 INFO 58418 --- [ main] hello.aop.exam.aop.RetryAspect : [retry] try count=1/42023-11-08 12:12:26.052 INFO 58418 --- [ main] hello.aop.exam.aop.RetryAspect : [retry] String hello.aop.exam.ExamRepository.save(String) retry=@hello.aop.exam.annotation.Retry(4)2023-11-08 12:12:26.052 INFO 58418 --- [ main] hello.aop.exam.aop.RetryAspect : [retry] try count=1/42023-11-08 12:12:26.052 INFO 58418 --- [ main] hello.aop.exam.aop.RetryAspect : [retry] String hello.aop.exam.ExamRepository.save(String) retry=@hello.aop.exam.annotation.Retry(4)2023-11-08 12:12:26.052 INFO 58418 --- [ main] hello.aop.exam.aop.RetryAspect : [retry] try count=1/42023-11-08 12:12:26.052 INFO 58418 --- [ main] hello.aop.exam.aop.RetryAspect : [retry] try count=2/4참고 스프링 핵심 원리 - 고급편(김영한)" }, { "title": "Spring Framework - 포인트컷", "url": "/posts/spring-15/", "categories": "Backend, Spring Framework", "tags": "Web, Spring Framework, AOP", "date": "2023-11-06 16:00:00 +0900", "snippet": "포인트컷 지시자포인트컷 표현식은 AspectJ pointcut express 즉, AspectJ가 제공하는 포인트컷 표현식을 줄여서 말하는 것이다.포인트컷 표현식은 execution과 같은 포인트컷 지시자(Pointcut Designator)로 시작한다. execution 메소드 실행 조인 포인트를 매칭 스프링 AOP에서 가장 많이 사용하고, 기능도 복잡함 within 특정 타입 내의 조인 포인트를 매칭 args 인자가 주어진 타입의 인스턴스인 조인 포인트 this 스프링 빈 객체(스프링 AOP 프록시)를 대상으로 하는 조인 포인트 target Target 객체(스프링 AOP 프록시가 가르키는 실제 대상)를 대상으로 하는 조인 포인트 @target 실행 객체의 클래스에 주어진 타입의 애노테이션이 있는 조인 포인트 @within 주어진 애노테이션이 있는 타입 내 조인 포인트 @annotation 메서드가 주어진 애노테이션을 가지고 있는 조인 포인트를 매칭 @args 전달된 실제 인수의 런타임 타입이 주어진 타입의 애노테이션을 갖는 조인 포인트 bean 빈의 이름으로 포인트컷을 지정 스프링 전용 포인트컷 지시자 보통 execution을 가장 많이 사용하고 다른 지시자는 자주 사용되지 않는다.execution 기본 사용execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)throws-pattern?)execution(접근제어자? 반환타입 선언타입?메서드이름(파라미터) 예외?) 메소드 실행 조인 포인트를 매칭 ?는 생략가능 *과 같은 패턴 지정 가능가장 정확한 포인트컷 @Test void exactMatch() { //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String) pointcut.setExpression(&quot;execution(public String hello.aop.member.MemberServiceImpl.hello(String))&quot;); Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue(); } MemberServiceImpl.hello(String) 메소드와 가장 정확하게 모든 내용이 매칭되는 표현식 매칭 조건 접근제어자? : public 반환타입 : String 선언타입? : hello.aop.member.MemberServiceImpl 메소드이름 : hello 파라미터 : (String) 예외? : 생략 가장 많이 생략한 포인트컷@Testvoid allMatch() { pointcut.setExpression(&quot;execution(* *(..))&quot;); Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();} ’*‘은 아무 값이 들어와도 된다라는 표현으로, 위 표현식은 모든 메소드에 대해 매칭이 성공함 파라미터에서 ‘..’은 파라이터의 타입과 파라미터 수가 상관없타는 표현 매칭 조건 접근제어자? : 생략 반환타입 : * 선언타입? : 생략 메소드이름 : * 파라미터 : (..) 예외? : 생략 기본 매칭 예시@Testvoid nameMatch() { //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String) pointcut.setExpression(&quot;execution(* hello(..))&quot;); Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();}@Testvoid nameMatchStart1() { //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String) pointcut.setExpression(&quot;execution(* hel*(..))&quot;); Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();}@Testvoid nameMatchStart2() { //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String) pointcut.setExpression(&quot;execution(* *el*(..))&quot;); Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();}@Testvoid nameMatchFalse() { //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String) pointcut.setExpression(&quot;execution(* nono(..))&quot;); Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isFalse();}@Testvoid packageExactMatch1() { //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String) pointcut.setExpression(&quot;execution(* hello.aop.member.MemberServiceImpl.hello(..))&quot;); Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();}@Testvoid packageExactMatch2() { //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String) pointcut.setExpression(&quot;execution(* hello.aop.member.*.*(..))&quot;); Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();}@Testvoid packageExactMatchFalse() { //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String) pointcut.setExpression(&quot;execution(* hello.aop.*.*(..))&quot;); Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isFalse();}@Testvoid packageExactMatchSubPackage1() { //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String) pointcut.setExpression(&quot;execution(* hello.aop.member..*.*(..))&quot;); Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();}@Testvoid packageExactMatchSubPackage2() { //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String) pointcut.setExpression(&quot;execution(* hello.aop..*.*(..))&quot;); Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();} hello.aop.member.(1).(2) (1) : 타입 (2) : 메소드 이름 패키지에서 ‘.’ 과 ‘..’의 차이 ’.’ : 정학하게 해당 위치의 패키지 ’..’ : 해당 위치의 패키지와 그 하위 패키지도 포함 타입 매칭@Testvoid superTypeExactMatchInternalFalse() throws NoSuchMethodException, SecurityException { //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String) pointcut.setExpression(&quot;execution(* hello.aop.member.MemberService.*(..))&quot;); Method internalMethod = MemberServiceImpl.class.getMethod(&quot;internal&quot;, String.class); Assertions.assertThat(pointcut.matches(internalMethod, MemberServiceImpl.class)).isFalse();} 부모 타입에 있는 메서드만 허용 부모 타입을 표현식에 선언한 경우 부모 타입에서 선언한 메서드가 자식 타입에 있어야 매칭에 성공 파라미터 매칭// String 타입의 파라미터 허용// (String)@Testvoid argsMatch() { //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String) pointcut.setExpression(&quot;execution(* *(String))&quot;); Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();}// 파라미터가 없어야 함// ()@Testvoid argsMatchNoArgs() { //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String) pointcut.setExpression(&quot;execution(* *())&quot;); Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isFalse();}// 정확히 하나의 모든 타입인 파라미터 허용// (Xxx)@Testvoid argsMatchNoStar() { //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String) pointcut.setExpression(&quot;execution(* *(*))&quot;); Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();}// 숫자와 무관하게 모든 타입의 모든 파라미터 허용// 파라미터가 없어도 허용// (), (Xxx), (Xxx, Xxx), ...@Testvoid argsMatchNoAll() { //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String) pointcut.setExpression(&quot;execution(* *(..))&quot;); Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();}// String 타입으로 시작하고 이후 숫자와 무관하게 모든 타입의 모든 파라미터 허용// (String), (String, Xxx), (String, Xxx, Xxx), ...@Testvoid argsMatchNoComplex() { //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String) pointcut.setExpression(&quot;execution(* *(String, ..))&quot;); Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();} execution 파라미터 매칭 규칙 (String) : 정확하게 String 타입 파라미터 () : 파라미터가 없어야 함 (*) : 정확히 하나의 모든타입인 파라미터 (_, _) : 정확히 두개의 모든타입인 파라미터 (..) : 숫자와 무관하게 모든 타입인 모든 파라미터. 파라미터가 없어도 됨. (String, ..) : String 타입으로 시작하고 이후 숫자와 무관하게 모든 타입인 모든 파라미터 (String), (String, Xxx), (String, Xxx, Xxx) 허용 within특정 타입 내의 조인 포인트들로 매칭을 제한한다. 즉, 해당 타입이 매칭되면 그 안의 메서드(조인 포인트)들이 자동으로 매칭된다.기본 문법은 execution에서 타입부분과 사용한것과 유사하다.@Testvoid withinExact() { pointcut.setExpression(&quot;within(hello.aop.member.MemberServiceImpl)&quot;); Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();}주의 사항으로는 execution과는 달리 표현식에 부모 타입을 지정하면 안되고 정확하게 타입이 맞아야 한다.args인자가 주어진 타입의 인스턴스인 조인 포인트로 매칭한다.기본 문법은 execution의 args 부분과 같다.execution과 args의 차이점 execution은 파라미터 타입이 정확하게 매칭되어야 함 execution은 클래스에 선언된 정보를 기반으로 판당(정적) args는 부모 타입을 허용 함 args는 실제 넘어온 파라미터 객체 인스턴스를 보고 판단(동적) /** * execution(* *(java.io.Serializable)): 메서드의 시그니처로 판단 (정적) * args(java.io.Serializable): 런타임에 전달된 인수로 판단 (동적) */@Testvoid argsVsExecution() { //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String) // args Assertions.assertThat(pointcut(&quot;args()&quot;) .matches(helloMethod, MemberServiceImpl.class)).isFalse(); Assertions.assertThat(pointcut(&quot;args(..)&quot;) .matches(helloMethod, MemberServiceImpl.class)).isTrue(); Assertions.assertThat(pointcut(&quot;args(*)&quot;) .matches(helloMethod, MemberServiceImpl.class)).isTrue(); Assertions.assertThat(pointcut(&quot;args(String,..)&quot;) .matches(helloMethod, MemberServiceImpl.class)).isTrue(); Assertions.assertThat(pointcut(&quot;args(String)&quot;) .matches(helloMethod, MemberServiceImpl.class)).isTrue(); Assertions.assertThat(pointcut(&quot;args(java.io.Serializable)&quot;) .matches(helloMethod, MemberServiceImpl.class)).isTrue(); Assertions.assertThat(pointcut(&quot;args(Object)&quot;) .matches(helloMethod, MemberServiceImpl.class)).isTrue(); // execution Assertions.assertThat(pointcut(&quot;execution(* *(String))&quot;) .matches(helloMethod, MemberServiceImpl.class)).isTrue(); Assertions.assertThat(pointcut(&quot;execution(* *(java.io.Serializable))&quot;) //매칭 실패 .matches(helloMethod, MemberServiceImpl.class)).isFalse(); Assertions.assertThat(pointcut(&quot;execution(* *(Object))&quot;) //매칭 실패 .matches(helloMethod, MemberServiceImpl.class)).isFalse();}agrs 지시자는 단독으로 사용되기 보다는 파라미터 바인딩에서 주로 사용된다.@target, @within@target, @within은 다음과 같이 타입에 있는 어노테이션으로 AOP 정용 여부를 판단한다. @target 실행 객체의 클래스에 주어진 타입의 어노테이션이 있는 조인 포인트 인스턴스의 모든 메소드를 조인 포인트로 적용 부모 클래스의 메소드 까지 어드바이스를 적용 @target(MyAopAnnotation) 예시) @target(hello.aop.member.annotation.ClassAop) @within 주어진 어노테이션이 있는 타입 내 조인 포인트 해당 타입 내에 있는 메소드만 조인 포인트로 적용 자기 자신의 클래스에 정의된 메소드에만 어드바이스를 적용 @within(MyAopAnnotation) 예시) @within(hello.aop.member.annotation.ClassAop) @Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface ClassAop {}@Slf4j@SpringBootTestpublic class AtTargetAtWithinTest { ... static class Parent { public void parentMethod() {} //부모에만 있는 메서드 } @ClassAop static class Child extends Parent { public void childMethod() {} } @Slf4j @Aspect static class AtTargetAtWithinAspect { //@target: 인스턴스 기준으로 모든 메서드의 조인 포인트를 선정, 부모 타입의 메서드도 적용 @Around(&quot;execution(* hello.aop..*(..)) &amp;amp;&amp;amp; @target(hello.aop.member.annotation.ClassAop)&quot;) public Object atTarget(ProceedingJoinPoint joinPoint) throws Throwable { log.info(&quot;[@target] {}&quot;, joinPoint.getSignature()); return joinPoint.proceed(); } //@within: 선택된 클래스 내부에 있는 메서드만 조인 포인트로 선정, 부모 타입의 메서드는 적용되지 않음 @Around(&quot;execution(* hello.aop..*(..)) &amp;amp;&amp;amp; @within(hello.aop.member.annotation.ClassAop)&quot;) public Object atWithin(ProceedingJoinPoint joinPoint) throws Throwable { log.info(&quot;[@within] {}&quot;, joinPoint.getSignature()); return joinPoint.proceed(); } }}@target, @within 지시자는 파라미터 바인딩에서 함꼐 사용된다. 주의args, @args, @target은 보통 단독으로 사용하면 안된다.위 예제를 보면 execution(_ hello.app.._(..))을 통해 적용 대상을 제한하였다.그 이유는,args, @args, @target 지시자는 실제 객체 인스턴스가 생성되고 실행 될떄 어드바이스 적용 여부를 확인할 수 있다.실행 시점에 일어나는 포인트컷 적용 여부도 결국 프록시가 있어야 실행 시점에 판단할 수 있따.프록시가 없다면 판단 자체가 불가능 하다. 그런데 스프링 컨테이너가 프록시를 생성하는 시점은 스프링 컨테이너가 만들어지는어플리케이션 로딩 시점에 적용 할 수 있다. 따라서 args, @args, @target 같은 포인트컷 지시자가 있다면스프링은 모든 스프링 빈에 AOP를 적용하려고 시도한다.이와 같이 모든 스프링 빈에 AOP 프록시를 적용하려고 하면 스프링이 내부에서 사용하는 빈 중에서는 final로 지정된 빈들도 있기 떄문에오류가 발생할 수 있다.그러므로 args, @args, @target와 같은 표현식은 최대한 프록시 적용 대상을 축소하는 표현식과 함꼐 사용해야 한다.@annotation메소드가 주어진 어노테이션을 가지고 있는 조인 포인트를 매칭@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface MethodAop { String value();}public class MemberServiceImpl { @MethodAop(&quot;test value&quot;) public String hello(String param) { return &quot;ok&quot;; }}@Slf4j@Import(AtAnnotationTest.AtAnnotationAspect.class)@SpringBootTestpublic class AtAnnotationTest { @Slf4j @Aspect static class AtAnnotationAspect { @Around(&quot;@annotation(hello.aop.member.annotation.MethodAop)&quot;) public Object doAtAnnotation(ProceedingJoinPoint joinPoint) throws Throwable { log.info(&quot;[@annotation] {}&quot;, joinPoint.getSignature()); return joinPoint.proceed(); } } ...}@args전달된 실제 인수의 런타임이 주어진 타입의 어노테이션을 갖는 조인 포인트.전달된 인수의 런타임 타입에 @Check 어노테이션이 있는 경우에 매칭한다. @args(test.Check)@bean스프링 전용 포인트컷 지시자이며 빈의 이름으로 지정한다.스프링 비의 이름으로 AOP 적용 여부를 지정한다.@bean은 스프링에서만 사용할 수 있는 특별한 지시자 이다. bean(orderService)   bean(*Repository) 과 같은 패턴 사요 가능 @Slf4j@Import(BeanTest.BeanAspect.class)@SpringBootTestpublic class BeanTest { @Autowired OrderService orderService; @Aspect static class BeanAspect { @Around(&quot;bean(orderService) || bean(*Repository)&quot;) public Object doLog(ProceedingJoinPoint joinPoint) throws Throwable { log.info(&quot;[bean] {}&quot;, joinPoint.getSignature()); return joinPoint.proceed(); } } ...}매개변수 전달포인트컷 표현식을 사용하여 어드바이스에 매개변수를 전달할 수 있다. this target args @target @within @annotation @args일반적으로 아래와 같이 사용한다.@Before(&quot;allMember() &amp;amp;&amp;amp; args(arg, ..)&quot;)public void logArgs3(String arg) { log.info(&quot;[logArgs3] arg={}&quot;, arg);} 포인트컷의 이름과 매개변수의 이름을 맞추어야 함 위 예시에선 arg로 맞춤 타입이 메소드에 지정한 타입으로 제한됨 위 예시에선 String으로 매개변수가 선언되었으므로 아와 같이 정의됨 args(arg, ..) -&amp;gt; args(String, ..) 다양한 매개변수 전달 예시@Slf4j@Import(ParameterTest.ParameterAspect.class)@SpringBootTestpublic class ParameterTest { @Autowired MemberService memberService; @Slf4j @Aspect static class ParameterAspect { @Pointcut(&quot;execution(* hello.aop.member..*.*(..))&quot;) private void allMember() {} @Around(&quot;allMember()&quot;) public Object logArgs1(ProceedingJoinPoint joinPoint) throws Throwable { Object arg1 = joinPoint.getArgs()[0]; log.info(&quot;[logArgs1]{}, arg={}&quot;, joinPoint.getSignature(), arg1); return joinPoint.proceed(); } @Around(&quot;allMember() &amp;amp;&amp;amp; args(arg, ..)&quot;) public Object logArgs2(ProceedingJoinPoint joinPoint, Object arg) throws Throwable { log.info(&quot;[logArgs2]{}, arg={}&quot;, joinPoint.getSignature(), arg); return joinPoint.proceed(); } @Before(&quot;allMember() &amp;amp;&amp;amp; args(arg, ..)&quot;) public void logArgs3(String arg) { log.info(&quot;[logArgs3] arg={}&quot;, arg); } @Before(&quot;allMember() &amp;amp;&amp;amp; this(obj)&quot;) public void thisArgs(JoinPoint joinpoint, MemberService obj) { log.info(&quot;[thisArgs]{}, obj={}&quot;, joinpoint.getSignature(), obj.getClass()); } @Before(&quot;allMember() &amp;amp;&amp;amp; target(obj)&quot;) public void targetArgs(JoinPoint joinpoint, MemberService obj) { log.info(&quot;[targetArgs]{}, obj={}&quot;, joinpoint.getSignature(), obj.getClass()); } @Before(&quot;allMember() &amp;amp;&amp;amp; @target(annotation)&quot;) public void atTarget(JoinPoint joinpoint, ClassAop annotation) { log.info(&quot;[atTarget]{}, obj={}&quot;, joinpoint.getSignature(), annotation); } @Before(&quot;allMember() &amp;amp;&amp;amp; @within(annotation)&quot;) public void atWithin(JoinPoint joinpoint, ClassAop annotation) { log.info(&quot;[atWithin]{}, obj={}&quot;, joinpoint.getSignature(), annotation); } @Before(&quot;allMember() &amp;amp;&amp;amp; @annotation(annotation)&quot;) public void atAnnotation(JoinPoint joinpoint, MethodAop annotation) { log.info(&quot;[atAnnotation]{}, atAnnotation.value={}&quot;, joinpoint.getSignature(), annotation.value()); } } @Test void success() { log.info(&quot;memberService proxy={}&quot;, memberService.getClass()); memberService.hello(&quot;hello A&quot;); }}memberService Proxy=class hello.aop.member.MemberServiceImpl$$EnhancerBySpringCGLIB$$82[logArgs1]String hello.aop.member.MemberServiceImpl.hello(String), arg=helloA[logArgs2]String hello.aop.member.MemberServiceImpl.hello(String), arg=helloA[logArgs3] arg=helloA[this]String hello.aop.member.MemberServiceImpl.hello(String), obj=class hello.aop.member.MemberServiceImpl$$EnhancerBySpringCGLIB$$8[target]String hello.aop.member.MemberServiceImpl.hello(String), obj=class hello.aop.member.MemberServiceImpl[@target]String hello.aop.member.MemberServiceImpl.hello(String), obj=@hello.aop.member.annotation.ClassAop()[@within]String hello.aop.member.MemberServiceImpl.hello(String), obj=@hello.aop.member.annotation.ClassAop()[@annotation]String hello.aop.member.MemberServiceImpl.hello(String),annotationValue=test value this : 프록시 객체를 전달 받음 target : 실제 대상 객체를 전달 받음 @target, @within : 타입의 어노테이션을 전달 받음 @annotation : 메소드의 어노테이션을 전달 받음@this, @target@Around(&quot;this(hello.aop.member.MemberService)&quot;)...@Around(&quot;target(hello.aop.member.MemberService)&quot;)... this 스프링 빈 객체(스프링 AOP 프록시)를 대상으로 하는 조인 포인트 target Target 객체(스프링 AOP 프록시가 가르키는 실제 대상)를 대상으로 하는 조인 포인트 두가지 모두 * 과 같은 패턴을 사용할 수 없음 두가지 모두 부모 타입을 허용this vs target스프링에서 AOP를 적용하면 실제 target 객체 대신에 프록시 객체가 스프링 빈으로 등록된다. this는 스프링 빈으로 등록되어 있는 프록시 객체를 대상으로 포인트컷을 매칭 target은 실제 target 객체를 대상으로 포인트컷을 매칭프록시 생성 방식에 따른 차이스프링은 프록시를 생성할떄 JDK 동적 프록시와 CGLIB을 선택할 수 있다.서로 프록시를 생성하는 방식이 다르기 떄문에 차이가 발생 한다. JDK 동적 프록시는 인터페이스가 필수이고, 인터페이스를 구현한 프록시 객체를 생성 CGLIB은 인터페이스가 있더라도 구체 클래스를 상속 받아서 프록시 객체를 생성JDK 동적 프록시 일떄 this와 target 차이 MemberService 인터페이스 지정시 this(hello.aop.member.MemberService) proxy 객체를 보고 판단 this는 부모타입을 허용하기 떄문에 AOP가 적용 target(hello.aop.member.MemberService) proxy 객체를 보고 판단 target은 부모타입을 허용하기 떄문에 AOP가 적용 MemberServiceImpl 구체 클래스 지정시 this(hello.aop.member.MemberServiceImpl) proxy 객체를 보고 판단 JDK 동적 프록시로 만들어진 proxy 객체는 MemberService 인터페이스를 기반으로 구현된 새로운 클래스 이므로,MemberServiceImpl를 전혀 알지 못하여 AOP 적용 대상이 아님 target(hello.aop.member.MemberServiceImpl) proxy 객체를 보고 판단 target 객체가 MemberServiceImpl 타입이므로 AOP 적용 대상 CGLIB 일떄 this와 target 차이 MemberService 인터페이스 지정시 this(hello.aop.member.MemberService) proxy 객체를 보고 판단 this는 부모타입을 허용하기 떄문에 AOP가 적용 target(hello.aop.member.MemberService) proxy 객체를 보고 판단 target은 부모타입을 허용하기 떄문에 AOP가 적용 MemberServiceImpl 구체 클래스 지정시 this(hello.aop.member.MemberServiceImpl) proxy 객체를 보고 판단 CGLIB로 만들어진 proxy 객체는 MemberServiceImpl을 상속하여 구현된 클래스 이므로 AOP 적용 대상 this가 부모타입을 허용하기 떄문에 포인트컷의 대상이 됨 target(hello.aop.member.MemberServiceImpl) proxy 객체를 보고 판단 target 객체가 MemberServiceImpl 타입이므로 AOP 적용 대상 즉, 프록시를 대상으로 하는 this의 경우 구체 클래스를 지정하면 프록시 생성 전략에 따라 다른 결과가 나올 수 있음./** * application.properties * spring.aop.proxy-target-class=true CGLIB * spring.aop.proxy-target-class=false JDK 동적 프록시 */@Slf4j@Import(ThisTargetTest.ThisTargetAspect.class)@SpringBootTest(properties = &quot;spring.aop.proxy-target-class=false&quot;) //JDK 동적 프록시//@SpringBootTest(properties = &quot;spring.aop.proxy-target-class=true&quot;) //CGLIBpublic class ThisTargetTest { @Autowired MemberService memberService; @Slf4j @Aspect static class ThisTargetAspect { //부모 타입 허용 @Around(&quot;this(hello.aop.member.MemberService)&quot;) public Object doThisInterface(ProceedingJoinPoint joinPoint) throws Throwable { log.info(&quot;[this-interface] {}&quot;, joinPoint.getSignature()); return joinPoint.proceed(); } //부모 타입 허용 @Around(&quot;target(hello.aop.member.MemberService)&quot;) public Object doTargetInterface(ProceedingJoinPoint joinPoint) throws Throwable { log.info(&quot;[target-interface] {}&quot;, joinPoint.getSignature()); return joinPoint.proceed(); } //this: 스프링 AOP 프록시 객체 대상 //JDK 동적 프록시는 인터페이스를 기반으로 생성되므로 구현 클래스를 알 수 없음 //CGLIB 프록시는 구현 클래스를 기반으로 생성되므로 구현 클래스를 알 수 있음 @Around(&quot;this(hello.aop.member.MemberServiceImpl)&quot;) public Object doThis(ProceedingJoinPoint joinPoint) throws Throwable { log.info(&quot;[this-impl] {}&quot;, joinPoint.getSignature()); return joinPoint.proceed(); } //target: 실제 target 객체 대상 @Around(&quot;target(hello.aop.member.MemberServiceImpl)&quot;) public Object doTarget(ProceedingJoinPoint joinPoint) throws Throwable { log.info(&quot;[target-impl] {}&quot;, joinPoint.getSignature()); return joinPoint.proceed(); } }}# JDK 동적 프록시 시용시memberService Proxy=class com.sun.proxy.$Proxy53[target-impl] String hello.aop.member.MemberService.hello(String)[target-interface] String hello.aop.member.MemberService.hello(String)[this-interface] String hello.aop.member.MemberService.hello(String)# CGLIB 사용시memberService Proxy=class hello.aop.member.MemberServiceImpl$$EnhancerBySpringCGLIB$$7df96bd3[target-impl] String hello.aop.member.MemberServiceImpl.hello(String)[target-interface] String hello.aop.member.MemberServiceImpl.hello(String)[this-impl] String hello.aop.member.MemberServiceImpl.hello(String)[this-interface] String hello.aop.member.MemberServiceImpl.hello(String) 참고this, target 지시자는 단독으로 사용되기 보다는 파라미터 바인딩에서 주로 사용됨참고 스프링 핵심 원리 - 고급편(김영한)" }, { "title": "Spring Framework - 스프링 AOP 구현", "url": "/posts/spring-14/", "categories": "Backend, Spring Framework", "tags": "Web, Spring Framework, AOP", "date": "2023-11-06 15:00:00 +0900", "snippet": "스프링 AOP 구현기본 구현스프링 AOP를 구현하는 일반적인 방법은 @Aspect를 사용하는 방법이다.@Slf4j@Aspectpublic class AspectV1 { // hello.aop.order 패키지와 하위 패키지 @Around(&quot;execution(* hello.aop.order..*(..))&quot;) public Object doLog(ProceedingJoinPoint joinPoint) throws Throwable { // join point 시그니처 log.info(&quot;[log] {}&quot;, joinPoint.getSignature()); return joinPoint.proceed(); }} @Around 어노테이션의 문자열이 포인트컷 문자열의 형식은 AspectJ 포인트컷 표현식 @Around 어노테이션의 메소드인 doLog는 어드바이스 hello.aop.order 하위의 모든 패키지의 모든 메소드는 AOP 적용의 대상이 됨 스프링 AOP는 프록시를 사용하므로 프록시를 통하는 메소드만 적용 대상이 됨 @Slf4j@Import(AspectV1.class)@SpringBootTestpublic class AopTest { @Autowired OrderService orderService; @Autowired OrderRepository orderRepository; @Test void success() { orderService.orderItem(&quot;itemA&quot;); }}@Aspect는 에스펙트라는 표식이지 컴포넌트 스캔의 대상이 되는건 아니다.그러므로 위 예의 AspectV1을 AOP로 사용하기 위해선 스프링 빈으로 따로 등록해야 한다. @Bean 직접 등록 @Component를 컴포넌트 스캔을 통해 자동 등록 @Import 주로 설정 파일을 추가할 떄 사용(@Configurtion) 하지만 스프링 빈도 등록 가능 [log] void hello.aop.order.OrderService.orderItem(String)[orderService] 실행[log] String hello.aop.order.OrderRepository.save(String)[orderRepository] 실행포인트컷 분리@Around에 포인트컷 표현식을 직접 넣을수도 있지만 @Pointcut 어노테이션을 통해 별도로 분리할 수도 있다.@Slf4j@Aspectpublic class AspectV2 { // hello.aop.order 패키지와 하위 패키지 @Pointcut(&quot;execution(* hello.aop.order..*(..))&quot;) // pointcut expression private void allOrder() {} // pointcut signature @Around(&quot;allOrder()&quot;) public Object doLog(ProceedingJoinPoint joinPoint) throws Throwable { // join point 시그니처 log.info(&quot;[log] {}&quot;, joinPoint.getSignature()); return joinPoint.proceed(); }} @Pointcut @Pointcut 어노테이션에 포인트컷 표현식을 사용 메소드 이름과 파라미터를 합쳐서 포인트컷 시그니처(Pointcut Signature)라 함 메소드 반환 타입은 void 이여야 함 코드 내용은 비워야 함 @Arounc 어드바이스에는 포인트컷을 직접 지정해도 되지만 포인트컷 시그니처를 사용해도 됨 내부에서만 사용하려면 private을 사용해도 되지만, 외부에서 사용할 떈 public 으로 선언 하나의 포인트컷 표현식을 여러 어드바이스에서 함꼐 사용 가능 다른 클래스에 있는 외부 어드바이스에서도 포인트컷을 함께 사용 가능어드바이스 추가@Slf4j@Aspectpublic class AspectV3 { // hello.aop.order 패키지와 하위 패키지 @Pointcut(&quot;execution(* hello.aop.order..*(..))&quot;) // pointcut expression private void allOrder() {} // pointcut signature // 클래스 이름 패턴이 @Service @Pointcut(&quot;execution(* *..*Service.*(..))&quot;) private void allService() {} @Around(&quot;allOrder()&quot;) public Object doLog(ProceedingJoinPoint joinPoint) throws Throwable { // join point 시그니처 log.info(&quot;[log] {}&quot;, joinPoint.getSignature()); return joinPoint.proceed(); } //hello.aop.order 패키지와 하위 패키지 이면서 클래스 이름 패턴이 *Service @Around(&quot;allOrder() &amp;amp;&amp;amp; allService()&quot;) public Object doTx(ProceedingJoinPoint joinPoint) throws Throwable { try { log.info(&quot;[트랜잭션 시작] {}&quot;, joinPoint.getSignature()); Object result = joinPoint.proceed(); log.info(&quot;[트랜잭션 커밋] {}&quot;, joinPoint.getSignature()); return result; } catch (Exception e) { log.info(&quot;[트랜잭션 롤백] {}&quot;, joinPoint.getSignature()); throw e; } finally { log.info(&quot;[리소스 릴리즈] {}&quot;, joinPoint.getSignature()); } }} @Around(“allOrder() &amp;amp;&amp;amp; allService()”) 포인트컷은 &amp;amp;&amp;amp;(AND),   (OR) !(NOT)을 통해 조합이 가능 [log] void hello.aop.order.OrderService.orderItem(String)[트랜잭션 시작] void hello.aop.order.OrderService.orderItem(String)[orderService] 실행[log] String hello.aop.order.OrderRepository.save(String)[orderRepository] 실행[트랜잭션 커밋] void hello.aop.order.OrderService.orderItem(String)[리소스 릴리즈] void hello.aop.order.OrderService.orderItem(String)포인트컷 참조public class Pointcuts { // hello.aop.order 패키지와 하위 패키지 @Pointcut(&quot;execution(* hello.aop.order..*(..))&quot;) public void allOrder() {} // 클래스 이름 패턴이 @Service @Pointcut(&quot;execution(* *..*Service.*(..))&quot;) public void allService() {} // allOrder() &amp;amp;&amp;amp; allService() @Pointcut(&quot;allOrder() &amp;amp;&amp;amp; allService()&quot;) public void orderAndService() {}}@Slf4j@Aspectpublic class AspectV4Pointcut { // 포인트컷이 정의되어있는 클래스의 패키지명까지 기입 @Around(&quot;hello.aop.order.aop.Pointcuts.allOrder()&quot;) public Object doLog(ProceedingJoinPoint joinPoint) throws Throwable { log.info(&quot;[log] {}&quot;, joinPoint.getSignature()); return joinPoint.proceed(); } @Around(&quot;hello.aop.order.aop.Pointcuts.orderAndService()&quot;) public Object doTx(ProceedingJoinPoint joinPoint) throws Throwable { try { log.info(&quot;[트랜잭션 시작] {}&quot;, joinPoint.getSignature()); Object result = joinPoint.proceed(); log.info(&quot;[트랜잭션 커밋] {}&quot;, joinPoint.getSignature()); return result; } catch (Exception e) { log.info(&quot;[트랜잭션 롤백] {}&quot;, joinPoint.getSignature()); throw e; } finally { log.info(&quot;[리소스 릴리즈] {}&quot;, joinPoint.getSignature()); } }} 외부에 정의한 포인트컷의 패키지명을 포함한 클래스 이름과 포인트컷 시그니처를 모두 지정어드바이스 순서어드바이스는 기본적으로 순서를 보장하지 않는다.순서를 지정하고 싶다면 @Aspect 적용 단위로 org.springframework.core.annotation.@Order 어노테이션을 사용해야 한다.그러나 이는 어드바이스 단위가 아닌 클래스 단위로 적용할수 있는 문제가 있다.그러므로 하나의 에스펙트에 여러 어드바이스가 있다면 순서를 보장받을 수 없고, 애스펙트를 별도의 클래스로 분리해야 한다.@Slf4jpublic class AspectV5Order { @Aspect @Order(2) public static class LogAspect { @Around(&quot;hello.aop.order.aop.Pointcuts.allOrder()&quot;) public Object doLog(ProceedingJoinPoint joinPoint) throws Throwable { log.info(&quot;[log] {}&quot;, joinPoint.getSignature()); return joinPoint.proceed(); } } @Aspect @Order(1) public static class TxAspect { @Around(&quot;hello.aop.order.aop.Pointcuts.orderAndService()&quot;) public Object doTx(ProceedingJoinPoint joinPoint) throws Throwable { try { log.info(&quot;[트랜잭션 시작] {}&quot;, joinPoint.getSignature()); Object result = joinPoint.proceed(); log.info(&quot;[트랜잭션 커밋] {}&quot;, joinPoint.getSignature()); return result; } catch (Exception e) { log.info(&quot;[트랜잭션 롤백] {}&quot;, joinPoint.getSignature()); throw e; } finally { log.info(&quot;[리소스 릴리즈] {}&quot;, joinPoint.getSignature()); } } }} TxAspect -&amp;gt; LogAspect 순으로 Aspect 적용 doTx() -&amp;gt; doLog() 순으로 어드바이스 수행 [트랜잭션 시작] void hello.aop.order.OrderService.orderItem(String)[log] void hello.aop.order.OrderService.orderItem(String)[orderService] 실행[log] String hello.aop.order.OrderRepository.save(String)[orderRepository] 실행[트랜잭션 커밋] void hello.aop.order.OrderService.orderItem(String)[리소스 릴리즈] void hello.aop.order.OrderService.orderItem(String)어드바이스 종류어드바이스의 종류는 @Around 외에도 여러 종류가 존재한다. @Around 메소드 호출 전후에 수행 조인 포인트 실행 여부 선택, 반환값 변환, 예외 변환등 가장 강력한 어드바이스 @Before 조인 포인트 실행 이전에 수행 @AfterReturning 조인 포인트가 정상 완료후 수행 @AfterThrowing 메소드가 예외를 던지는 경우 수행 @After 조인 포인트가 정상 또는 예외에 관계없이 수행(finally) @Slf4j@Aspectpublic class AspectV6Advice { @Around(&quot;hello.aop.order.aop.Pointcuts.orderAndService()&quot;) public Object doTx(ProceedingJoinPoint joinPoint) throws Throwable { try { // @Before log.info(&quot;[트랜잭션 시작] {}&quot;, joinPoint.getSignature()); Object result = joinPoint.proceed(); // @AfterReturning log.info(&quot;[트랜잭션 커밋] {}&quot;, joinPoint.getSignature()); return result; } catch (Exception e) { // @AfterThrowing log.info(&quot;[트랜잭션 롤백] {}&quot;, joinPoint.getSignature()); throw e; } finally { // @After log.info(&quot;[리소스 릴리즈] {}&quot;, joinPoint.getSignature()); } } @Before(&quot;hello.aop.order.aop.Pointcuts.orderAndService()&quot;) public void doBefore(JoinPoint joinPoint) { log.info(&quot;[before] {}&quot;, joinPoint.getSignature()); } @AfterReturning(value = &quot;hello.aop.order.aop.Pointcuts.orderAndService()&quot;, returning = &quot;result&quot;) public void doReturn(JoinPoint joinPoint, Object result) { log.info(&quot;[return] {} return={}&quot;, joinPoint.getSignature(), result); } @AfterThrowing(value = &quot;hello.aop.order.aop.Pointcuts.orderAndService()&quot;, throwing = &quot;ex&quot;) public void doThrowing(JoinPoint joinPoint, Exception ex) { log.info(&quot;[ex] {} message={}&quot;, joinPoint.getSignature(), ex.getMessage()); } @After(value = &quot;hello.aop.order.aop.Pointcuts.orderAndService()&quot;) public void doAfter(JoinPoint joinPoint) { log.info(&quot;[after] {}&quot;, joinPoint.getSignature()); }}모든 어드바이스는 org.aspectj.lang.JoinPoint 를 첫번째 파라미터에 사용할 수 있다.(생략 가능)단, @Around는 ProceedingJoinPoint을 사용해야 한다.참고로 ProceedingJoinPoint는 org.aspectj.lang.JoinPoint의 하위 타입이다JoinPoint 인터페이스의 주요 기능 getArgs() 메서드 인수를 반환 getThis() 프록시 객체를 반환 getTarget() 대상 객체를 반환 getSignature() 조언되는 메서드에 대한 설명을 반환 toString() 조언되는 방법에 대한 유용한 설명을 인쇄 ProceedingJoinPoint 인터페이스의 주요 기능 proceed() 다음 어드바이스나 타겟을 호출 어드바이스 종류@Before조인 포인트 실행전 수행@Before(&quot;hello.aop.order.aop.Pointcuts.orderAndService()&quot;)public void doBefore(JoinPoint joinPoint) { log.info(&quot;[before] {}&quot;, joinPoint.getSignature());}@Around와 다르게 작업 흐름을 변경할 수 없다.@Around는 ProceedingJoinPoint.proceed()를 호출해야 다음 대상이 호출되며 만약 호출하지 않으면 다음 대상이 호출되지 않는다.반면에 @Before는 ProceedingJoinPoint.proceed() 자체를 사용하지 않고 메소드 종료시 자동으로 다음 타겟이 호출된다.@AfterReturning메소드 실행이 정상적으로 반환되면 수행@AfterReturning(value = &quot;hello.aop.order.aop.Pointcuts.orderAndService()&quot;, returning = &quot;result&quot;)public void doReturn(JoinPoint joinPoint, Object result) { log.info(&quot;[return] {} return={}&quot;, joinPoint.getSignature(), result);} returning 속성에 사용된 이름은 어드바이스 메소드의 매개변수 이름과 일치해야 함 returning 절에 지정된 타입의 값을 반환하는 베소드만 대상으로 실행됨 부모 타입을 지정하면 모든 자식 타입은 인정됨 @Around와는 다르게 반환되는 객체를 변경할수는 없음@AfterThrowing메소드 실행이 예외를 던져서 종료될떄 수행@AfterThrowing(value = &quot;hello.aop.order.aop.Pointcuts.orderAndService()&quot;, throwing = &quot;ex&quot;)public void doThrowing(JoinPoint joinPoint, Exception ex) { log.info(&quot;[ex] {} message={}&quot;, joinPoint.getSignature(), ex.getMessage());} throwing 속성에 사용된 이름은 어드바이스 메소드의 매개변수 이름과 일치해야 함 throwing 절에 지정된 타입의 값을 반환하는 베소드만 대상으로 실행됨 부모 타입을 지정하면 모든 자식 타입은 인정됨 @After메소드 실행이 종료되면 수행됨 정상 및 예외 반환 조건을 모두 처리 보통 리소스를 해제하는 데 사용@Around메소드 실행 전후에 작업을 수행 가장 강력한 어드바이스 조인 포인트 실행 여부 선택 전달 값 변경 반환 값 변환 예외 변환 트랜잭션 처럼 try ~ catch ~ finally 모두 들어가는 구문 처리 가능 어드바이스의 첫번쨰 파라미터는 ProceedingJoinPoint를 사용해야 함 proceed()를 통해 다음 대상을 실행 proceed()를 여러번 실행할 수도 있음(재시도)순서스프링은 5.2.7 버전부터 동일한 @Aspect안에서 동일한 조인 포인트의 우선순위를 정했다. 실행순서 @Around -&amp;gt; @Before -&amp;gt; @After -&amp;gt; @AfterReturing or @AfterThrowing 호출순서와 리턴순서는 반대@Aspect안에 동일한 종류의 어드바이스가 2개 있다면 순서가 보장되지 않는다.이경우에는 @Aspect를 분리하고 @Order를 적용해야 한다.@Around 외에 다른 어드바이스가 존재하는 이유사실상 @Around 하나의 어드바이스만 있어도 모든처리가 가능하지만 여타 다른 어드바이스의 종류가 존재한다.그 이유는 @Around는 가장 넓은 기능을 제공하긴 하지만 실수할 가능성이 있다.예를 들어 @Around의 어드바이스 안에 proceed()를 호출하지 않는다면 다음 타겟을 실행되지 않지만,@Before, @After의 경우 proceed()를 호출여부를 상관하지않고 로직만 구현하면 된다.제약을 통해 @Around 사용시의 실수를 미연에 방지하고자 좀더 좁은 범위의 기능을 가진 다른 어드바이스가 존재한다.참고 스프링 핵심 원리 - 고급편(김영한)" }, { "title": "Spring Framework - 스프링 AOP 개념", "url": "/posts/spring-13/", "categories": "Backend, Spring Framework", "tags": "Web, Spring Framework, AOP", "date": "2023-11-06 11:30:00 +0900", "snippet": "핵심 기능과 부가 기능어플리케이션의 로직은 크게 핵심 기능과 부가 기능으로 나눌 수 있다. 핵심 기능 해당 객체가 제공하는 고유의 기능 예를 들면 OrderService의 핵심 기능인 주문 로직과 같은 경우 부가 기능 핵심 기능을 보조하기 위해 제공되는 기능 단독으로 사용되지 않고 핵심 기능과 함꼐 사용됨 예를 들면 로그 추적 로직, 트랜잭션 기능 등 주문 로직을 실행하기 직전에 로그 추적 기능을 사용해야 한다면 핵심 기능인 주문 로직과 부가 기능인 로그 추적 로직이 하나의 객체 안에 섞여 들어가게 된다.보통 부가 기능은 여러 클래스에 걸쳐 사용된다.이러한 부가 기능은 횡단 관심사(cross-cutting concerns)가 되며 하나의 부가 기능이 여러 곳에 동일하게 사용된다.이러한 부가 기능을 여러곳에 적용하려면 매우 번거롭게 되는데,만약 부가 기능을 적용해야 하는 클래스가 100개면 100개 모두 동일한 코드를 추가해야한다.또한 수정이 필요할시 수많은 클래스를 모두 수정해야 하는 문제도 존재 한다.이렇게 부가 기능처럼 특정 로직을 어플리케이션 전반에 적용하는 문제는 일반적인 OOP 방식으로는 해결이 어렵다.Aspect부가 기능 도입의 문제점을 해결하기 위해서,부가 기능을 핵심 기능에서 분리하고 한곳에서 관리하도록 하고 해당 부가 기능을 어디에 적용할지 선택하는 기능이 개발되었다.이러한 부가 기능과 부가 기능을 어디에 적용할지 선택하는 기능을 합쳐 하나의 모듈이 개발되었는데, 이것이 바로 Aspect 이다.즉, Aspect는 부가 기능과 부가 기능을 어디에 적용할지 정의하는 것이다.Aspect는 이름 그대로 어플리케이션을 바라보는 관점을 하나하나 기능에서 횡단 관심사(cross-cutting concerns) 관점으로 달리 보는 것이다.이렇게 Aspect를 사용한 프로그래밍 방식을 관점 지향 프로그래밍인 AOP(Aspect Oriented Programming) 이라 한다.AOP는 OOP를 대체한다기 보단 횡단 관심사를 처리하기 어려운 OOP를 보조하는 목적으로 개발되었다.AspectJ 프레임워크AOP의 대표적인 구현으로 AspectJ 프레임워크가 있다.스프링도 AOP를 지원하지만 대부분 AspectJ의 문법을 차용하고, AspectJ가 제공하는 기능의 일부만 제공한다.AspectJ 프레임워크는 스스로를 다음과 같이 설명한다. 자바 프로그래밍 언어에 대한 완벽한 관점 지향 확장 횡단 관심사의 깔끔한 모듈화 오류 검사 및 처리 동기화 성능 최적화(캐싱) 모니터링 및 로깅 AOP 적용 방식AOP를 사용하면 핵심 기능과 부가 기능이 코드상 완전히 분리되어 관리되는데,이렇게 AOP를 사용할떄 부가 기능이 로직이 실제 로직에 추가가되는 방식은 크게 3가지가 있다. 컴파일 시점 클래스 로딩 시점 런타임 시점(프록시)이렇게 원본 로직에 부가 기능 로직이 추가되는 것을 위빙(Weaving)이라 한다.컴파일 시점.java 소스코드를 컴파일러를 사용해서 .class를 만드는 시점에 부가 기능 로직을 추가할 수 있다.이때는 AspectJ가 제공하는 특별한 컴파일러를 사용해야 하는 단점이 있다.클래스 로딩 시점자바를 실행하면 자바 언어는 .class파일을 JVM 내부의 클래스 로더에 보관한다.이때 중간에서 .class파일을 조작한 다음 JVM에 올릴수 있다.자바 언어는 .class를 JVM에 저장하기 전에 조작할 수 있는 기능(Java Instrumentation)을 제공한다.자바를 실행할 때 특별한 옵션을 통해 클래스 로더 조작기를 지정해야 하는데, 이는 번거롭고 운영하기 어려운 단점이 있다.런타임 시점런타임 시점은 컴파일 및 클래스 로더에 클래스도 다 올라가서 이미 자바가 실행되고 난 다음을 말한다.이미 실행되고 난 이후 이므로 자바 언어가 제공하는 범위 내에서 부가기능을 적용해야 하는데,보통 스프링과 같은 컨테이너의 도움을 받고 프록시와 DI, Bean PostProcessor와 같은 개념을 사용하여 최종적으로 프록시를 통해 스프링 빈에 부가 기능을 적용할 수 있다.프록시를 사용하기 때문에 AOP 기능에 일부 제약이 있지만 특별한 컴파일러나 자바를 실행할때 복잠한 옵션과 클래스 로더 조작기를 설정하지 않아도 된다.부가기능이 적용되는 차이를 정리하면 아래와 같다. 컴파일 시점 실제 대상 코드에 Aspect를 통한 부가 기능 호출 코드가 포함 됨 AspectJ를 직접 사용해야 함 클래스 로딩 시점 실제 대상 코드에 Aspect를 통한 부가 기능 호출 코드가 포함 됨 AspectJ를 직접 사용해야 함 런타임 시점 실제 대상 코드는 그대로 유지되는 대신 프록시를 사용하여 부가 기능이 적용 됨 항상 프록시를 통해야 부가 기능을 사용 가능 스프링 AOP가 사용하는 방식 AOP 적용 위치AOP는 메소드 실행 위치 뿐만 아니라 다음과 같은 다양한 위치에 적용할 수 있다. 적용 가능 지점(Join Point) 생성자, 필드 값 접근, static 메서드 접근, 메서드 실행 AspectJ를 사용해서 컴파일 시점과 클래스 로딩 시점에 적용하는 AOP는 바이트코드를 조작하기 떄문에 해당 기능을 모든 지점에 다 적용 가능하다.그러나 프록시 방식을 사용하는 스프링 AOP는 메서드 실행 지점에만 AOP를 적용할 수 있다. 프록시는 메소드 오버라이딩 방식으로 동작하므로 생성자나 static 메소드, 필드 값 접근에는 프록시 개념이 적용 될 수 없음 프록시를 사용하는 스프링 AOP의 Join Point는 메소드 실행으로 제한됨 프록시 방식을 사용하는 스프링 AOP는 스프링 컨테이너가 관리 할 수 있는 스프링 빈에만 AOP를 적용할 수 있음스프링이 제공하는 AOP는 프록시를 사용한다. 그러므로 프록시를 통해 메소드를 실행하는 시점에만 AOP가 적용된다.AspectJ를 사용하면 더 다양한 기능을 사용할 수 있지만, 스프링 AOP는 별도의 추가 자바 설정 없이 스프링만 있다면 AOP를 편리하게 사용할 수 있으며,실무에서는 스프링이 제공하는 AOP 기능 만으로도 대부분의 문제를 해결할 수 있으므로 주로 스프링 AOP가 사용된다.AOP 용어 정리 조인 포인트(Join Point) 어드바이스가 적용될 수 있는 위치 메소드 실행, 생성자 호출, 필드값 접근, static 메서드 접근 같은 프로그램 실행 중 지점 조인 포인트를 추상적인 개념으로 AOP를 적용할 수 있는 모든 지점 스프링 AOP는 프록시 방색을 사용하므로 스프링 AOP의 조인 포인트는 항상 메소드 실행 지점 포인트컷(Pointcut) 조인 포인트 중에서 어드바이스가 적용될 위치를 선별하는 기능 주로 AspectJ 표현식을 사용하여 지정 프록시를 사용하는 스프링 AOP는 메소드 실행 지점만 포인트컷으로 선별 가능 타겟(Target) 어드바이스를 받는 객체 핵식 로직이 있는 객체 또는 다른 프록시 객체가 될 수 있음 포인트컷으로 결졍 어드바이스(Advice) 부가 기능 특정 조인 포인트에서 Aspect에 의해 실행되는 로직 Around, Before, After와 같은 다양한 종류의 어드바이스가 있음 어드바이저(Advisor) 하나의 어드바이스와 하나의 포인트컷으로 구성 스프링 AOP에서만 사용되는 특별한 용어 에스펙트(Aspect) 어드바이스와 포인트컷을 모듈화 한 것 여러 어드바이스와 포인트 컷이 함께 존재 @Aspect 위빙(Weaving) 포인트컷으로 결정한 타겟의 조인 포인트에 어드바이스를 적용하는 것 위빙을 통해 핵심 기능 코드에 영향을 주지 않고 부가 기능을 추가 할 수 있음 AOP 적용을 위해 Aspect를 객체에 연결한 상태 컴파일 타임 클래스 로드 타임 런타임 스프링 AOP는 런타임, 프록시 방식 AOP 프록시 AOP 기능을 구현하기 위해 만든 프록시 객체 스프링에서 AOP 프록시는 JDK 동적 프록시 또는 CGLIB 프록시로 구현됨 참고 스프링 핵심 원리 - 고급편(김영한)" }, { "title": "Spring Framework - 자동 프록시 생성기와 @Aspect", "url": "/posts/spring-12/", "categories": "Backend, Spring Framework", "tags": "Web, Spring Framework, AOP", "date": "2023-11-06 11:00:00 +0900", "snippet": "자동 프록시 생성기와 @Aspect자동 프록시 생성기(AnnotationAwareAspectJAutoProxyCreator)는 Advisor를 자동으로 찾아와서 필요한 곳에 프록시를 생성하고 적용한다.그리고 추가로 하나의 역할을 더 하는데, @Aspect를 찾아서 이것을 Advisor로 만드는 일이다.즉, 자동 프록시 생성기는 크게 두가지 일을 수행한다. @Aspect를 보고 Advisor로 변환하여 저장 어드바이저를 기반으로 프록시를 생성// 어드바이저(Advisor)@Aspectpublic class LogTraceAspect { // 포인트컷(Pointcut) 어노테이션 선언 @Around(&quot;execution(* hello.proxy.app..*(..))&quot;) // 어드바이스(Advice) 구현부 public Object execute(ProceedingJoinPoint joinPoint) throws Throwable { }}@Aspect를 어드바이저로 변환하여 저장하는 과정 실행 스프링 어플리케이션 로딩 시점에 자동 프록시 생성기 호출 모든 @Aspect 빈 조회 자동 프록시 생성기는 스프링 컨테이너에서 @Aspect 어노테이션이 붙은 스프링 빈을 모두 조회 어드바이저 생성 @Aspect 어드바이저 빌더를 통해 @Aspect 어노테이션 정보를 기반으로 어드바이저 생성 @Aspect 기반 어드바이저 저장 생성한 어드바이저를 @Aspcect 어드바이저 빌더 내부에 저장 @Aspect 어드바이저 빌더@Aspect의 정보를 기반으로 포인트컷, 어드바이스, 어드바이저를 생성하고 보관하는 것을 담당.@Aspect의 정보를 기반으로 어드바이저를 만들고, @Aspect 어드바이저 빌더 내부 저장소에 캐시한다.어드바이저를 기반으로 프록시 생성 과정 생성 스프링 빈 대상이 되는 객체 생성 @Bean, 컴포넌트 스캔 모두 포함 전달 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달 Advisor 빈 조회 스프링 컨테이너에서 Advisor 빈을 모두 조회 @Aspect Adisor 조회 @Aspect 어드바이저 빌더 내부에 저장된 Advisor를 모두 조회 프록시 적요 대상 체크 앞서 조회한 Advisor에 포함된 포인트컷을 사용하여 해당 객체가 프록시를 적용할 대상인지 아닌지 판단 판단시 객체의 클래스 정보와 해당 객체의 모든 메서드를 포인트컷에 하나하나 모두 매칭 조건이 하나라도 만족시 프록시 적용대상으로 판단 프록시 생성 프록시 적용 대상이면 프록시를 생성하고 프록시를 반환후, 프록시를 스프링 빈으로 등록 프록시 적용 대상이 아니면 원본 객체를 스프링 빈으로 등록 빈 등록 반환된 객체는 스프링 빈으로 등록 참고 스프링 핵심 원리 - 고급편(김영한)" }, { "title": "Spring Framework - 빈 후처리기", "url": "/posts/spring-11/", "categories": "Backend, Spring Framework", "tags": "Web, Spring Framework, AOP", "date": "2023-11-03 16:00:00 +0900", "snippet": "빈 후처리기일반적인 빈 등록@Bean이나 컴포넌트 스캔으로 스프링 빈을 등록하면, 스프링은 대상 객체를 생성하고 스프링 컨테이터 내부의 빈 저장소에 등록한다.그리고 이후에는 스프링 컨테이너를 통해 등록한 스프링 빈을 조죄해서 사용하면 된다.빈 후처리기(BeanPostProcessor)스프링이 빈 저장소에 등록할 목적으로 생성한 객체를 빈 저장소에 등록하기 직전에 조작하고 싶다면 빈 후처리기를 사용하면 된다.빈 후처리기(BeanPostProcessor)는 이름 그래도 빈을 생성한 후에 무언가를 처리하는 용도로 사용된다.객체를 조작하거나 완전히 다른 객체로 다꿔치기하는 것도 가능하다.빈 후처리기 과정 생성 스프링 빈 대상이 되는 객체를 생성 @Bean, 컴포넌트 스캔 모두 포함 전달 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달 후 처리 작업 빈 후처리기는 전달된 스프링 빈 객체를 조작하거나 다른 객체로 바꿔치기 가능 등록 빈 후처리기에서 빈을 그대로 반환하면 해당 빈이 등록되고, 바꿔치기 하면 다른 객체가 빈 저장소에 등록됨 빈 후처리기 적용빈 후처리기를 적용하기 위해선 BeanPostProcessor 인터페이스를 구현하고, 스프링 빈으로 등록하면 된다.public interface BeanPostProcessor { Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException; Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;} postProcessBeforeInitialization 객체 생성 이후에 @PostConstruct 같은 초기화가 발생하기전에 호출되는 포스트 프로세서 postProcessAfterInitialization 객체 생성 이후에 @PostConstruct 같은 초기화가 발생한 다음에 호출되는 포스트 프로세서 빈 후처리기 적용 예시아래 그림과 같은 객체 바꿔치기 구현 예시public class BeanPostProcessorTest { @Test void postProcessor() { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(BeanPostProcessorConfig.class); // beanA 이름으로 B 객체가 빈으로 등록 B b = applicationContext.getBean(&quot;beanA&quot;, B.class); b.helloB(); // A는 빈으로 등록되지 않음 Assertions.assertThrows( NoSuchBeanDefinitionException.class, () -&amp;gt; applicationContext.getBean(A.class)); } @Slf4j @Configuration static class BeanPostProcessorConfig { @Bean(name = &quot;beanA&quot;) public A a() { return new A(); } @Bean AToBPostProcessor helloPostProcessor() { return new AToBPostProcessor(); } } @Slf4j static class A { public void helloA() { log.info(&quot;hello A&quot;); } } @Slf4j static class B { public void helloB() { log.info(&quot;hello B&quot;); } } @Slf4j static class AToBPostProcessor implements BeanPostProcessor { @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { log.info(&quot;beanName={} bean={}&quot;, beanName, bean); if (bean instanceof A) { return new B(); } return bean; } }} AToBPostProcessor 빈 후처리기 인터페이스인 BeanPostProcessor를 구현하고 스프링 빈으로 등록하면 스프링 컨테이너가 빈 후처리기로 인식하고 동작함 빈 후처리기 적용 정리빈 후처리기는 빈을 조작하고 변경할 수 있는 후킹 포인트 이다.이것은 빈 객체를 조작하거나 심지어 다른 객체로 바꿀수도 있을정도로 막강한 기능이다. @PostConstruct의 비밀@PostConstruct는 스프링 빈 생성 이후에 빈을 초기화하는 역할을 한다.동작을 생각해보면 빈의 초기화라는 것이 단순히 @PostConstruct 어노테이션이 붙은 초기화 메소드를 한번 호출만 하면 된다.이러한 동작을 수행하기 위해스프링은 CommonAnnotationBeanPostProcessor라는 빈 후처리기를 자동으로 등록하고, 여기서 @PostConstruct 어노테이션이 붙은 메소드를 호출한다.그러므로 스프링은 스스로도 스프링 내부의 기능을 확장하기 위해 빈 후처리기를 사용한다. 빈 후처리기로 프록시 샐성시 포인트컷포인트컷은 이미 클래스, 메소드 단위의 필터기능을 가지고 있기 떄문에 프록시 적용 대상 여부를 정밀하게 설정 가능하다.어드바이저는 포인트컷을 가지고 있으므로 어드바이저를 통해 포인트컷을 확인할 수 있다. 결과적으로 포인트컷은 다음 두곳에 사용된다. 프록시 적용 대상 여부를 체크하여 꼭 필요한 곳에만 프록시를 적용(빈 후처리기 - 자동 프록시 생성) 프록시의 어떤 메소드가 호출되었을 때 어드바이저를 적용할지 판단(프록시 내부) 스프링이 제공하는 빈 후처리기자동 프록시 생성기(AutoProxyCreator) 자동으로 프록시를 생성해주는 빈 후처리기 자동 프록시 생성기는 스프링 빈으로 등록된 Advisor들을 자동으로 찾아서 프록시가 필요한 곳에 자동으로 프록시를 적용 Advisor안에는 Pointcut과 Advice가 이미 모두 포함되어 있으므로,Advisor만 알고 있으면 그 안에 있는 Pointcut으로 어떤 스프링 빈에 프록시를 적용해야 할지 알 수 있음관련 기능을 사용하기 위해선 아래와 같이 추가 필요// build.gradleimplementation &#39;org.springframework.boot:spring-boot-starter-aop&#39; 해당 라이브러리를 추ㅏ하면 aspectjweaver라는 aspectJ관련 라이브러리를 등록하고, 스프링 부트가 AOP 관련 클래스를 자동으로 스프링 빈에 등록 함자동 프록시 생성기 작동 과정 생성 스프링이 스프링 빈 대상이 되는 객체를 생성 @Bean, 컴포넌트 스캔 모두 포함 전달 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달 모든 Advisor 빈 조회 자동 프록시 생성기(빈 후처리기)는 스프링 컨테이너에서 모든 Advisor를 조회 프록시 적용 대상 체크 앞서 조회한 Advisor에 포함되어 있는 포인트컷을 사용하여 해당 객체가 프록시를 적용할 대상인지 판단 이때 객체의 클래스 정보는 물록이고 해당 객체의 모든 메소드를 포인트컷에 하나하나 모두 매칭 함 조건이 하나라고 만족하면 프록시 적용 대상 예를 들어 10개의 메소드 중에 하나만 포인트컷 조건에 만족해도 프록시 적용 대상이 됨 프록시 생성 프록시 적용 대상이면 프록시를 생성하고 반환하여 프록시를 스프링 빈으로 등록 만약 프록시 적용 대상이 아니라면 원본 객체를 반환하여 원본 객체를 스프링 빈으로 등록 빈 등록 반환된 객체는 스프링 빈으로 등록 자동 프록시 생성기와 포인트 컷중요한 내용으로, 포인트컷은 2가지에 사용된다. 프록시 적용 여부 판단 - 생성 단계 자동 프록시 생성기는 포인트컷을 사용하여 해당 빈이 프록시를 생성할 필요가 있는지 없는지 체크 클래스 + 메소드 조건을 모두 비교 모든 메소드를 체크하는데, 포인트컷 조건에 하나하나 매칭함 만약 조건에 맞는것이 하나라도 있다면 프록시를 생성 예) orderController에 포인트컷 조건을 만족하는 request() 메소드와,포인트컷 조건을 불만족하는 noLog() 메소드가 있을떄 하나라도 만족하는 메소드가 있으므로 프록시를 생성 조건에 맞는 것이 하나도 없다면 프록시를 생성할 필요가 없으므로 프록시를 생성하지 않음 어드바이스 적용 여부 판단 - 사용 단계 프록시가 호출되었을떄 부가 기능인 어드바이스를 적용할지 말지 포인트컷을 보고 판단 예) orderController에 포인트컷 조건을 만족하는 request() 메소드와, 포인트컷 조건을 불만족하는 noLog() 메소드가 있을 떄 orderController의 reqeust()는 포인트컷 조건에 만족하므로 프록시는 어드바이스를 먼저 호출하고 target을 호출 orderController의 noLog()는 포인트컷 조건에 불만족하므로 target만 호출 프록시를 모든 곳에 생성하는 것은 비용낭비이므로 꼭 필요한 곳에만 적용해야 한다.그러므로 자동 프록시 생성기는 모든 스프링 빈에 프록시를 적용하는 것이 아닌 포인트컷으로 한번 필터링하여 어드바이스가 사용될 가능성이 있는 곳에만 프록시를 생성한다.하나의 프록시, 여러 Advisor 적용예를 들어 어떤 스프링 빈이 advisor1, advisor2가 제공하는 포인트컷의 조건을 모두 만족하면 프록시 자동 생성기는 몇개의 프록시를 생성할까?정답은 자동 프록시 생성기는 하나의 프록시만 생성한다.왜냐하면 프록시 팩토리가 생성하는 프록시는 내부에 여러 Advisor를 포함할 수 있기 때문에, 불필요하게 여러개의 프록시를 생성할 필요가 없기 때문이다.이는 스프링 AOP도 동일한 방식으로 동작한다.프록시 자동 생성기 상황별 정리 advisor1의 포인트컷만 만족 프록시 1개 생성 프록시에 advisor1만 포함 advisor1, advisor2의 포인트컷 모두 만족 프록시 1개 생성 프록시에 advisor1, advisor2 포함 advisor1, advisor2의 포인트컷 모두 불만족 프록시가 생성되지 않음 참고 스프링 핵심 원리 - 고급편(김영한)" }, { "title": "Spring Framework - 스프링이 지원하는 프록시", "url": "/posts/spring-10/", "categories": "Backend, Spring Framework", "tags": "Web, Spring Framework, AOP", "date": "2023-11-03 14:00:00 +0900", "snippet": "프록시 팩토리스프링은 동적 프록시를 통합해서 편리하게 만들어주는 프록시 팩토리(ProxyFactory)라는 기능을 제공한다.과거에는 상황에 따라서 JDK 동적 프록시를 사용하거나 CGIL을 사용해야 했다면, 이제는 프록시 팩토리 하나로 편리하게 동적 프록시를 생성 할 수 있다.인터페이스, 구체 클래스별 사용 기술프록시 팩토리는 인터페이스가 있으면 JDK 동적프록시를 사용하고, 구체 클라스만 있다면 CGLIB을 사용한다.그리고 이 설정또한 변경할 수 있다.Handler 구현 방식JDK 동적 프록시에는 InvocationHandler 인터페이스를, CGLIB은 MethodInterceptor 인터페이스를 구현하여프록시의 handler를 구현 하였는데, 프록시 팩토리에서는 Advice라는 개념을 도입하여 이 두개의 인터페이스를 별도로 구현하지 않도록 하였다.즉, 프록시 팩토리는 내부적으로 Advice를 호출하는 전용 InvocationHandler나 MethodInterceptor를 사용하고 있기 때문에개발자는 InvocationHandler나 MethodInterceptor를 신경쓰지 않고 Advice만 구현하면 된다.프록시 팩토리 사용 예시public interface AInterface() { void call();}public class AImpl() implements AInterface { void call() { log.info(&quot;Interface&quot;); }}public class Concrete { void Call() { log.info(&quot;Concrete&quot;); }}public class TimeAdvice implements MethodInterceptor { @Override public Object invoke(MethodInvocation invocation) throws Throwable { log.info(&quot;TimeProxy 실행&quot;); long startTime = System.currentTimeMillis(); Object result = invocation.proceed(); long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(&quot;TimeProxy 종료 resultTime={}ms&quot;, resultTime); return result; }}@Testvoid interfaceProxy() { AInterface target = new AImpl(); ProxyFactory proxyFactory = new ProxyFactory(target); proxyFactory.addAdvice(new TimeAdvice()); AInterface proxy = (AInterface)proxyFactory.getProxy(); proxy.call(); Assertions.assertThat(AopUtils.isAopProxy(proxy)).isTrue(); Assertions.assertThat(AopUtils.isJdkDynamicProxy(proxy)).isTrue(); Assertions.assertThat(AopUtils.isCglibProxy(proxy)).isFalse();}@Testvoid concreteProxy() { Concrete target = new Concrete(); ProxyFactory proxyFactory = new ProxyFactory(target); proxyFactory.addAdvice(new TimeAdvice()); Concrete proxy = (Concrete)proxyFactory.getProxy(); proxy.call(); Assertions.assertThat(AopUtils.isAopProxy(proxy)).isTrue(); Assertions.assertThat(AopUtils.isJdkDynamicProxy(proxy)).isFalse(); Assertions.assertThat(AopUtils.isCglibProxy(proxy)).isTrue();}@Testvoid proxyTargetClass() { AInterface target = new AImpl(); ProxyFactory proxyFactory = new ProxyFactory(target); // interface 가 존재하지만 // JDK 동적 프록시가 아닌 CGLIB을 사용하도록 옵션 설정 proxyFactory.setProxyTargetClass(true); proxyFactory.addAdvice(new TimeAdvice()); AInterface proxy = (AInterface)proxyFactory.getProxy(); proxy.call(); Assertions.assertThat(AopUtils.isAopProxy(proxy)).isTrue(); Assertions.assertThat(AopUtils.isJdkDynamicProxy(proxy)).isFalse(); Assertions.assertThat(AopUtils.isCglibProxy(proxy)).isTrue();} 스프링 부트는 AOP를 적용할떄 기본적으로 proxyTargetClass=true로 설정해서 사용한다.그러므로 인터페이스가 있어도 항상 CGLIB을 사용하여 구체 클래스를 기반으로 프록시를 생성한다.포인트컷, 어드바이스, 어드바이저 포인트컷(Pointcut) 어디에 부가 기능을 적용할지, 적용하지 않을지 판단하는 필터링 로직 주로 클래스와 메소드 이름으로 필터링함 어드바이스(Advice) 프록시가 홏출하는 부가 기능(프록시 로직) 어드바이저(Advisor) 하나의 포인트컷과 하나의 어드바이스를 가지고 있는 인스턴스(포인트컷 1 + 어드바이스 1) 위와 같이 구분한 것은 역할과 책임을 명확하게 분리한 것이다. 포인트컷은 대상 여부를 확인하는 필터 역할만 담당 어드바이스는 부가 기능 로직만을 담당 이 둘을 합쳐 어드바이저를 구성함어드바이저 사용 코드 예시@Testvoid advisorTest() { AInterface target = new AImpl(); ProxyFactory proxyFactory = new ProxyFactory(target); DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(Pointcut.TRUE, new TimeAdvice()); proxyFactory.addAdvisor(advisor); AInterface proxy = (AInterface)proxyFactory.getProxy(); proxy.call();} Pointcut.TRUE 항상 true를 반환하는 포인트컷 proxyFactory.addAdvisor(advisor) 프록시 팩토리에 적용할 어드자이저 지정 어드바이저는 내부에 포인트컷과 어드바이스를 모두 가지고 있기 때문에 어디에 어떤 부가기능을 적용해야 할지 어드바이저 하나로 알 수 있음 프록시 팩토리를 사용할 떄 어드바이저는 필수 스프링이 제공하는 포인트컷@Testvoid adAdvisorTest3() { AInterface target = new AImpl(); ProxyFactory proxyFactory = new ProxyFactory(target); NameMatchMethodPointcut pointcut = new NameMatchMethodPointcut(); pointcut.setMappedName(&quot;callx&quot;); DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(pointcut, new TimeAdvice()); proxyFactory.addAdvisor(advisor); AInterface proxy = (AInterface)proxyFactory.getProxy(); proxy.call();}위 예시 코드에서의 NameMatchMethodPointcut 뿐만 아니라 다른 여러 포인트컷들도 지원한다. NameMatchMethodPointcut 메서드 이름을 기반으로 매칭 내부에서는 PatternMatchUtils를 사용 JdkRegexpMethodPointcut JDK 정규 표현식을 기반으로 포인트컷을 매칭 TruePointcut 항상 참을 반환 AnnotationMatchingPointcut 애노테이션으로 매칭 AspectJExpressionPointcut aspectJ 표현식으로 매칭 실무에서 사용하기 편하고 기능도 가장 많음 주로 많이 사용됨 여러 어드바이저 함께 적용스프링은 하나의 어드바이저당 프록시를 생성하는것이 아닌, 하나의 프록시에 여러 어드바이저를 적용할 수 있게 구현되어 있다.@Testvoid advisorTest() { DefaultPointcutAdvisor advisor1 = new DefaultPointcutAdvisor(Pointcut.TRUE, new MyAdvisor1()); DefaultPointcutAdvisor advisor2 = new DefaultPointcutAdvisor(Pointcut.TRUE, new MyAdvisor2()); AInterface target = new AImpl(); ProxyFactory proxyFactory = new ProxyFactory(target); proxyFactory.addAdvisor(advisor2); proxyFactory.addAdvisor(advisor1); AInterface proxy = (AInterface)proxyFactory.getProxy(); proxy.call();} 등록된 어드바이저 순으로 호출됨 advisor2, advisor1 순으로 등록되었으므로 advisor2 -&amp;gt; advisor1 -&amp;gt; target 순으로 호출됨 스프링 AOP를 처음 공부하다보면 AOP 적용 수 만큼 프록시가 생성된다고 생각할 수 있다.그러나 스프링은 AOP를 적용할 때 최적화를 진행하여 프록시는 하나만 만들고, 하나의 프록시에 여러 어드바이저를 적용한다.즉, 하나의 target 에 여러 AOP가 동시에 적용되더라도, 스프링의 AOP는 target 마다 하나의 프록시만 생성한다.참고 스프링 핵심 원리 - 고급편(김영한)" }, { "title": "Java - JDK 동적 프록시", "url": "/posts/java-04/", "categories": "Java", "tags": "Java, Reflection", "date": "2023-11-03 11:50:00 +0900", "snippet": "JDK 동적 프록시동적 프록시 기술을 사용하면 개발자가 직접 프록시 클래스를 만들지 않고 동적으로 프록시 객체를 런타임에 생성 할 수 있다.또한 동적 프록시에 원하는 실행 로직을 지정하는것도 가능하다.JDK 동적 프록시 구현JDK 동적 프록시는 인터페이스를 기반으로 프록시를 동적으로 만들기 떄문에 인터페이스가 필수 이다.public interface AInterface { String call();}public class AImpl implements AInterface {@Override public String call() { log.info(&quot;A 호출&quot;); return &quot;a&quot;; }}@Slf4jpublic class TimeInvocationHandler implements InvocationHandler { private final Object target; public TimeInvocationHandler(Object target) { this.target = target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { log.info(&quot;TimeProxy 실행&quot;); long startTime = System.currentTimeMillis(); Object result = method.invoke(target, args); long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(&quot;TimeProxy 종료 resultTime={}&quot;, resultTime); return result; }}@Testvoid dynamicA() { AInterface target = new AImpl(); TimeInvocationHandler handler = new TimeInvocationHandler(target); AInterface proxy = (AInterface)Proxy.newProxyInstance( AInterface.class.getClassLoader(), new Class[]{AInterface.class}, handler); proxy.call(); log.info(&quot;targetClass={}&quot;, target.getClass()); log.info(&quot;proxyClass={}&quot;, proxy.getClass());}TimeInvocationHandler - TimeProxy 실행AImpl - A 호출TimeInvocationHandler - TimeProxy 종료 resultTime=0JdkDynamicProxyTest - targetClass=class hello.proxy.jdkdynamic.code.AImplJdkDynamicProxyTest - proxyClass=class com.sun.proxy.$Proxy1로그를 보면 proxyClass=class com.sun.proxy.$Proxy1 이 부분이 동적으로 생성된 프록시 클래스 이다.이는 개발자가 직접 만든 클래스가 아닌 JDK 동적 프록시가 이름 그래도 동적으로 만들어준 프록시 이다.이 프록시는 TimeInvocationHandler 로직을 실행한다.실행 순서 클라이언트는 JDK 동적 프록시의 call() 을 실행 JDK 동적 프록시는 InvocationHandler.invoke()를 호출 TimeInvocationHandler가 구현체 이므로 TimeInvocationHandler.invoke()가 호출 TimeInvocationHandler가 내부 로직을 수행하고, method.invoke(target, args)를 호출해서 target인 실제 객체(AImpl)를 호출 AImpl 인스턴스의 call()이 실행 AImpl 인스턴스의 call() 종료후 TimeInvocationHandler로 응답이 반환되고 그 응답을 외부로 반환정리JDK 동적 프록시 기술로 인하여 적용 대상 만클 프록시 객체를 만들지 않아도 된며, 같은 부가 기능로직을 한번만 개발해서 공통으로 적용할 수 있다.결과적으로 프록시 클래스를 수 없이 만들어야 하는 문제도 해결하고 부가 기능 로직도 하나의 클래스에 모아서 단일 책임 원칙(SRP)도 지킬 수 있다.JDK 동적 프록시 도입 전 - 직접 프록시 생성JDK 동적 프록시 도입 후 $Proxy1는 개발자가 직접 만드는 클래스가 아님참고 스프링 핵심 원리 - 고급편(김영한)" }, { "title": "Java - Reflection", "url": "/posts/java-03/", "categories": "Java", "tags": "Java, Reflection", "date": "2023-11-03 11:00:00 +0900", "snippet": "Reflection자바가 기본으로 제공하는 JDK 동적 프록시 기술이나 CGIB과 같은 프록시 생성 오픈소스 기술을 활용하면, 프록시 객체를 동적으로 만들어 낼 수 있다.이러한 JDK 동적 프록시 기술이나 CGIB을 이해하기 위해선 리플렉션이라는 기술이 필수이다.리프렉션은 클래스나 메소드의 메타정보를 동적으로 획득하고, 코드를 동적으로 호출할 수 있게 해주는 기술을 말한다.package hello.proxy.jdkdynamic;import java.lang.reflect.Method;import org.junit.jupiter.api.Test;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class ReflectionTest { @Slf4j static class Hello { public String callA() { log.info(&quot;callA&quot;); return &quot;A&quot;; } public String callB() { log.info(&quot;callB&quot;); return &quot;B&quot;; } } @Test void reflection1() throws Exception { // 클래스 정보 Class classHello = Class.forName(&quot;hello.proxy.jdkdynamic.ReflectionTest$Hello&quot;); Hello target = new Hello(); Method methodCallA = classHello.getMethod(&quot;callA&quot;); Object result1 = methodCallA.invoke(target); log.info(&quot;result1={}&quot;, result1); Method methodCallB = classHello.getMethod(&quot;callB&quot;); Object result2 = methodCallB.invoke(target); log.info(&quot;result@={}&quot;, result2); }} Class.forName(…) 클래스의 메타정보를 획득 내부 클래스는 구분을 위해 $ 를 사용 함 classHello.getMethod(…) 클래스의 메소드이름을 통해 해당 클래스의 메소드 메타정보를 획득 methodCallA.invoke(target) 획득한 메소드 메타정보로 실제 인스턴스의 메소드를 호출 위 예에서 methodCallA는 Hello 클래스의 callA() 라는 메소드 메타정보 이며,methodCallA.invoke(인스턴스)를 호출하면서 인스턴스를 넘겨주면 해당 인스턴스의 callA() 메소드를 찾아서 실행 함 target.callA()나 target.callB()와 같이 메소드를 직접 호출하지 않고,위와 같은 방식으로 메소드 정보를 획득하여 메소드르 호출하는 주요 이슈는 클래스나 메소드 정보를 동적으로 변경할 수 있다는 점 때문이다.아래와 같이 target.callA()나 target.callB() 처럼 메소드를 직접 호출하는 부분을 리플렉션을 통하여 메소드 호출 부분을 공통 로직으로 변경 할 수 있다.@Testvoid reflection2() throws Exception { Class classHello = Class.forName(&quot;hello.proxy.jdkdynamic.ReflectionTest$Hello&quot;); Hello target = new Hello(); Method methodCallA = classHello.getMethod(&quot;callA&quot;); dynamicCall(methodCallA, target);; Method methodCallB = classHello.getMethod(&quot;callB&quot;); dynamicCall(methodCallB, target);;}private void dynamicCall(Method method, Object target) throws Exception { log.info(&quot;start&quot;); Object result = method.invoke(target); log.info(&quot;result@={}&quot;, result);}리플렉션 주의사항리플렉션을 사용하면 클래스와 메소드의 메타정보를 사용하여 어플리케이션을 동적으로 유연하게 만들 수 있다.그러나 리플레션 기술은 런타임에 동작하기 떄문에 컴파일 시점에 오류를 잡아낼 수 없다.지금까지 프로그래밍 언어가 발전 하면서 타입정보를 기반으로 컴파일 시점에 오류를 잡는 좋은 오류탐지 방법을 사용하지 못하는 셈이다.그러므로 리플렉션은 일반적으로 사용하면 안되고, 프레임워크 개발이나 또는 매우 일반적인 공통처리가 필요할때 부분적으로 주의해서 사용해야 한다.참고 스프링 핵심 원리 - 고급편(김영한)" }, { "title": "Java - ThreadLocal", "url": "/posts/java-02/", "categories": "Java", "tags": "Java, Thread", "date": "2023-11-02 16:00:00 +0900", "snippet": "ThreadLocal쓰레드 로컬은 해당 쓰레드만 접근할 수 있는 특별한 저장소를 말함.간단한 예로 들면 물건 보관 창구와 비슷함.여러 사함이 같은 물건 보관 창구를 사용하더라도 창구 직원은 사용자를 인식하여 사용자별로 확실히 물건을 구분해 줌.즉, 사용자A, 사용자B 모두 창구 직원을 통하여 물건을 보관하고 꺼내지만 창구 직원이 사용자에 따라 보관한 물건을 구분해 주는 식.일반적인 변수 필드여러 쓰레드가 같은 인스턴스의 필드에 접근하면 처음 쓰레드가 보관한 데이터가 사라질 수 있음. thread-A가 userA라는 값을 저장 thread-B가 userB라는 값을 저장하면 직전에 thread-A가 저장한 userA라는 값이 사라짐쓰레드 로컬쓰레드 로컬을 사용하면 각 쓰레드마다 별도의 내부 저장소를 제공하여,같은 인스턴스의 쓰레드 로컬 필드에 접근해도 데이터에 대한 동시성 문제가 발생하지 않음 thread-A가 userA라는 값을 저장하면 쓰레드 로컬은 thread-A 전용 저장소에 데이터 저장 thread-B가 userB라는 값을 저장하면 쓰레드 로컬은 thread-A 전용 저장소에 데이터 저장 쓰레드 로컬을 통해 데이터를 조회할 떄도,thread-A가 조회하면 thread-A 전용 보관소에 있는 데이터를 반환하고,thread-B가 조회하면 thread-B 전용 보관소에 있는 데이터를 반환 함.자바는 언어 차원에서 쓰레드 로컬을 지원하는 클래스를 제공 함. java.lang.ThreadLocalThreadLocal 예시@Slf4jpublic class ThreadLocalService { private ThreadLocal&amp;lt;String&amp;gt; nameStore = new ThreadLocal&amp;lt;&amp;gt;(); public void save(String name) { log.info(&quot;저장 name={} -&amp;gt; nameStore={}&quot;, name, nameStore.get()); nameStore.set(name); } public String load() { log.info(&quot;조회 nameStore={}&quot;,nameStore.get()); return nameStore.get(); } public void remove() { log.info(&quot;제거 nameStore={}&quot;,nameStore.get()); return nameStore.remove(); }} 값 저장 ThreadLocal.set(…) 값 조회 ThreadLocal.get() 값 제거 ThreadLocal.remove() 해당 쓰레드가 쓰레드 로컬을 모두 사용하고 나면 ThreadLocal.remove()를 호출하여쓰레드 로컬에 저장된 값을 제거해 주어야 함.ThreadLocal 주의사항쓰레드 로컬의 값을 사용후 제거하지 않고 그냥 두게 되면,WAS(톰캣)처럼 쓰레드 풀을 사용하는 경우 심각한 문제가 발생 할 수 있음.사용자 A 저장 요청 사용자A가 저장 HTTP 요청 WAS는 쓰레드 풀에서 쓰레드를 하나 조회 쓰레드 Thread-A 할당 Thread-A는 사용자A의 데이터를 쓰레드 로컬에 저장 쓰레드 로컬의 Thread-A 전용 보관소에 사용자A 데이터 보관사용자 A 저장 요청 종료 사용자A의 HTTP 응답 종료 WAS는 사용이 끝난 Thread-A를 쓰레드 풀에 반환 쓰레드를 생성하는 비용은 비싸기 때문에 쓰레드를 제거하지 않고 보통 쓰레드 풀을 통해 쓰레드를 재사용 함 Thread-A는 쓰레드풀에 존재하ㄴ므로 Thread-A는 소멸되지 않은 상태이므로, 쓰레드 로컬의 Thread-A 전용 보관소에는 아직 사용자A의 데이터가 남아있게 됨사용자 B 조회 요청 사용자B가 조회를 위한 새로운 HTTP 요청 WAS는 쓰레드 풀에서 쓰레드를 하나 조회 쓰레드 Thread-A가 할당 쓰레드 풀의 쓰레트 할당 전략에 따라 다른 쓰레드가 할당 될수도 있음 조회하는 요청이므로 Thread-A는 쓰레드 로컬에서 데이터를 조회 쓰레드 로컬은 Thread-A 전용 보관소에 있는 사용자A 값을 반환 결과적으로 사용자B에게 사용자A의 값이 반환됨 사용자B는 사용자A의 정보를 조회하게 됨결과적으로 사용자B는 사용자A의 데이터를 확인하게 되는 심각한 문제가 발생 할 수 있음.그러므로 사용자A의 요청이 끝날때 쓰레드 로컬의 값을 ThreadLocal.remove()를 통해 반드시 제거해야 함.참고 스프링 핵심 원리 - 고급편(김영한)" }, { "title": "QueryDSL - 중급 문법", "url": "/posts/spring-querydsl-02/", "categories": "Backend, QueryDSL", "tags": "Web, Spring Framework, DataBase, JPA, QueryDSL", "date": "2023-11-01 14:30:00 +0900", "snippet": "프로젝션과 결과 반환 - 기본 프로젝션 : select 대상 지정List&amp;lt;Tuple&amp;gt; result = queryFactory .select(member.username, member.age) .from(member) .fetch();for (Tuple tuple : result) { String username = tuple.get(member.username); Integer age = tuple.get(member.age); System.out.println(&quot;username=&quot; + username); System.out.println(&quot;age=&quot; + age);} 프로젝션 대상이 둘 시상일떄 com.querydsl.core.Tuple 타입 사용 결국 querydsl의 타입이므로 리포지토리 밖의 서비스나 컨트롤러에서 이 Tuple을 사용하는건 좋지 않음 프로젝션과 결과 반환 - DTO 조회JPA에서 DTO를 조회할 떄는 new 명령머 및 DTO의 패키지 이름까지 다 적고, 생성자 방식만 가능하다는 단점이 있음.Querydsl에서는 조회 결과를 DTO로 변환할떄 아래와 같은 3가지 방식을 지원함. 프로퍼티 접근 필드 직접 접근 생성자 사용@Datapublic class MemberDto { private String username; private int age; public MemberDto() { } public MemberDto(String username, int age) { this.username = username; this.age = age; }}// setter를 이용한 프로퍼티 접근List&amp;lt;MemberDto&amp;gt; result = queryFactory .select(Projections.bean( MemberDto.class, QMember.member.username, QMember.member.age)) .from(QMember.member) .fetch();// 필드 직접 접근List&amp;lt;MemberDto&amp;gt; result = queryFactory .select(Projections.fields( MemberDto.class, QMember.member.username, QMember.member.age)) .from(QMember.member) .fetch();// 생성자 사용List&amp;lt;MemberDto&amp;gt; result = queryFactory .select(Projections.constructor( MemberDto.class, QMember.member.username, QMember.member.age)) .from(QMember.member) .fetch();만약 다른 필드의 이름이 달라 별칭을 따로 사용해야 할경우 아래와 같이 사용 가능.@Datapublic class UserDto { private String name; private int age; public UserDto() { } public UserDto(String name, int age) { this.name = name; this.age = age; }}QMember memberSub = new QMember(&quot;memberSub&quot;);// name 이라는 별칭 사용// 서브쿼리를 age라는 별칭으로 사용List&amp;lt;UserDto&amp;gt; result = queryFactory .select(Projections.fields( UserDto.class, QMember.member.username.as(&quot;name&quot;), ExpressionUtils.as( JPAExpressions .select(memberSub.age.max()) .from(memberSub) , &quot;age&quot;))) .from(QMember.member) .fetch(); ExpressionUtils.as(source,alias) 필드나, 서브 쿼리에 별칭 적용 username.as(“memberName”) 필드에 별칭 적용 프로젝션과 결과 반환 - @QueryProjection생성자 + @QueryProjection 을 사용하는 방법@Datapublic class MemberDto { private String username; private int age; public MemberDto() { } @QueryProjection public MemberDto(String username, int age) { this.username = username; this.age = age; }}List&amp;lt;MemberDto&amp;gt; result = queryFactory .select(new QMemberDro(QMember.member.username, QMember.member.age)) .from(QMember.member) .fetch(); DTO의 생성자에 @QueryProjection 선언후, 재빌드하여 Q파일을 생성해야 함 컴파일떄 타입 에러를 체크할 수 있으므로 안전한 방법 기존 DTO 조회(setter, 필드, 생성자 세가지 방식)는 컴파일때 타입에러를 체크할 수 없고 런타임이에 에러 발생 DTO에 QueryDSL 어노테이션으로 인하여 DTO가 QueryDSL에 의존하게 되어 아키텍처면으로 선택하기 어려울 떄가 있음동적 쿼리동적 쿼리를 해결하기 위해 아래 두가지 방식이 존재 BooleanBuilder Where 다중 파라미터BooleanBuilder 사용 방식@Testpublic void dynamic_query() throws Exception { String usernameParam = &quot;member1&quot;; Integer ageParam = 10; List&amp;lt;Member&amp;gt; result = searchMember(usernameParam, ageParam);}private List&amp;lt;Member&amp;gt; searchMember(String username, Integer age) { BooleanBuilder builder = new BooleanBuilder(); if (username != null) { builder.and(QMember.member.username.eq(username)); } if (age != null) { builder.and(QMember.member.age.eq(age)); } return queryFactory .selectFrom(QMember.member) .where(builder) .fetch();}Where 다중 파라미터 사용 방식@Testpublic void dynamic_query() throws Exception { String usernameParam = &quot;member1&quot;; Integer ageParam = 10; List&amp;lt;Member&amp;gt; result = searchMember(usernameParam, ageParam);}private List&amp;lt;Member&amp;gt; searchMember(String username, Integer age) { return queryFactory .selectFrom(QMember.member) .where(usernameEq(username), ageEq(age)) .fetch();}private BooleanExpression usernameEq(String username) { return username != null ? QMember.member.username.eq(username) : null;}private BooleanExpression ageEq(Integer age) { return age != null ? QMember.member.age.eq(age) : null;} where 조건에 null 값은 무시됨 메소드를 다른 쿼리에서도 재활용 가능 쿼리 자체의 가독성이 높아짐아래와 같이 조합도 가능 함.private BooleanExpression allEq(String usernameCond, Integer ageCond) { return usernameEq(usernameCond).and(ageEq(ageCond));} null 체크는 주의해서 처리해야 함수정, 삭제 벌크 연산쿼리 한번으로 대량의 데이터 수정// 쿼리 한번으로 이름 수정long count = queryFactory .update(member) .set(member.username, &quot;비회원&quot;) .where(member.age.lt(28)) .execute();// 쿼리 한번으로 기존 숫자에 1 더하기long count = queryFactory .update(member) .set(member.age, member.age.add(1)) .execute();// 쿼리 한번으로 대량 데이터 삭제long count = queryFactory .delete(member) .where(member.age.gt(18)) .execute(); JPQL의 배치와 마찬가지로 영속성 컨텍스트에 있는 엔티티를 무시하고 실행 되기 때문에배치쿼리를 실행하고 나면 영속성 컨텍스트를 초기화 하는것이 안전함참고 실전! Querydsl(김영한)" }, { "title": "QueryDSL - 기본 문법", "url": "/posts/spring-querydsl-01/", "categories": "Backend, QueryDSL", "tags": "Web, Spring Framework, DataBase, JPA, QueryDSL", "date": "2023-11-01 10:40:00 +0900", "snippet": "기본 QTypq 활용//별칭 직접 지정QMember qMember = new QMember(&quot;m&quot;);//기본 인스턴스 사용QMember qMember = QMember.member;//기본 인스턴스를 static import와 함께 사용import static study.querydsl.entity.QMember.*;@Testpublic void startQuerydsl3() { Member findMember = queryFactory .select(member) .from(member) .where(member.username.eq(&quot;member1&quot;)) .fetchOne(); ...} 같은 테이블을 조인하는 경우가 아니면 되도록이면 기본 인스턴스를 사용검색 조건 쿼리@Testpublic void search() { Member findMember = queryFactory .selectFrom(QMember.member) .where(QMember.member.username.eq(&quot;member1&quot;) .and(QMember.member.age.eq(10))) .fetchOne(); ...} 검색 조건은 .and(), .or()를 메소드 체인으로 연결 가능JPQL이 제공하는 모든 검색조건들을 제공 함.member.username.eq(&quot;member1&quot;) // username = &#39;member1&#39;member.username.ne(&quot;member1&quot;) //username != &#39;member1&#39;member.username.eq(&quot;member1&quot;).not() // username != &#39;member1&#39;member.username.isNotNull() //이름이 is not nullmember.age.in(10, 20) // age in (10,20)member.age.notIn(10, 20) // age not in (10, 20)member.age.between(10,30) //between 10, 30member.age.goe(30) // age &amp;gt;= 30member.age.gt(30) // age &amp;gt; 30member.age.loe(30) // age &amp;lt;= 30member.age.lt(30) // age &amp;lt; 30member.username.like(&quot;member%&quot;) //like 검색member.username.contains(&quot;member&quot;) // like ‘%member%’ 검색member.username.startsWith(&quot;member&quot;) //like ‘member%’ 검색...결과 조회//ListList&amp;lt;Member&amp;gt; fetch = queryFactory .selectFrom(member) .fetch();//단 건Member findMember1 = queryFactory .selectFrom(member) .fetchOne();//처음 한 건 조회Member findMember2 = queryFactory .selectFrom(member) .fetchFirst();//페이징에서 사용QueryResults&amp;lt;Member&amp;gt; results = queryFactory .selectFrom(member) .fetchResults();//count 쿼리로 변경long count = queryFactory .selectFrom(member) .fetchCount(); fetch() 리스트 조회 데이터가 없으면 빈 리스트 반환 fetchOne() 단건 조회 결과가 없으면 null 결과가 둘 이상이면 com.querydsl.core.NonUniqueResultException fetchFirst() limit(1).fetchOne() 과 동일 fetchResuls() 페이징 정보 포함 total count 쿼리가 추가 실행 fetchCount() count 쿼리로 변경해서 count 수 조회 정렬List&amp;lt;Member&amp;gt; result = queryFactory .selectFrom(QMember.member) .where(QMember.member.age.eq(100)) .orderBy(QMember.member.age.desc(), QMember.member.username.asc().nullsLast()) .fetch(); desc(), asc() 일반 정렬 nullLast(), nullFirst() null 데이터 순서 부여 페이징// 조회 건수 제한List&amp;lt;Member&amp;gt; result = queryFactory .selectFrom(QMember.member) .orderBy(QMember.member.username.desc()) .offset(1) // 0부터 시작(zero index) .limit(2) // 최대 2건 조회 .fetch();// 전체 조회QueryResults&amp;lt;Member&amp;gt; result = queryFactory .selectFrom(QMember.member) .orderBy(QMember.member.username.desc()) .offset(1) // 0부터 시작(zero index) .limit(2) // 최대 2건 조회 .fetchResults(); count 쿼리가 실행되어 성능상 주의가 필요 실무에서 페이징 쿼리를 작성할 떄, 데이터를 조회하는 쿼리는 여러 테이블을 조회해야 하지만,count 쿼리는 조인이 필요없는 경우도 있음. 그러나 자동화된 count 쿼리는원본 쿼리와 같이 모두 조인을 하기 떄문에 성능이 안나올 수 있음. count 쿼리에 조인이 필요없는 성능 최적화가 필요하다면 count 전용 쿼리를 별도로 작성해야 함. 집합/** * JPQL * select * COUNT(m), //회원수 * SUM(m.age), //나이 합 * AVG(m.age), //평균 나이 * MAX(m.age), //최대 나이 * MIN(m.age) //최소 나이 * from Member m */@Testpublic void aggregation() throws Exception { List&amp;lt;Tuple&amp;gt; result = queryFactory .select(QMember.member.count(), QMember.member.age.sum(), QMember.member.age.avg(), QMember.member.age.max(), QMember.member.age.min()) .from(QMember.member) .fetch(); Tuple tuple = result.get(0); Assertions.assertThat(tuple.get(QMember.member.count())).isEqualTo(4); Assertions.assertThat(tuple.get(QMember.member.age.sum())).isEqualTo(100); Assertions.assertThat(tuple.get(QMember.member.age.avg())).isEqualTo(25); Assertions.assertThat(tuple.get(QMember.member.age.max())).isEqualTo(40); Assertions.assertThat(tuple.get(QMember.member.age.min())).isEqualTo(10);} JPQL이 제공하는 모든 집합 함수 제공 Querydsl의 Tuple 타입으로 반환GroupBy 사용/** * 팀의 이름과 각 팀의 평균 연령을 구해라. */@Testpublic void group() { List&amp;lt;Tuple&amp;gt; result = queryFactory .select(QTeam.team.name, QMember.member.age.avg()) .from(QMember.member) .join(QMember.member.team, QTeam.team) .groupBy(QTeam.team.name) .fetch(); Tuple teamA = result.get(0); Tuple teamB = result.get(1); Assertions.assertThat(teamA.get(QTeam.team.name)).isEqualTo(&quot;teamA&quot;); Assertions.assertThat(teamA.get(QMember.member.age.avg())).isEqualTo(15); Assertions.assertThat(teamB.get(QTeam.team.name)).isEqualTo(&quot;teamB&quot;); Assertions.assertThat(teamB.get(QMember.member.age.avg())).isEqualTo(35);} 그룹화된 결과를 제한하려면 having 사용조인 - 기본 조인조인의 기본 문법은 첫번쨰 파라미터에 조인 대상을 지정하고, 두번쨰 파라미터에 별칭으로 사용할 QType을 지정join(조인 대상, 별칭으로 사용할 Q타입)// 팀 A에 소속된 모든 회원List&amp;lt;Member&amp;gt; result = queryFactory .selectFrom(QMember.member) .join(QMember.member.team, QTeam.team) .where(QTeam.team.name.eq(&quot;teamA&quot;)) .fetch();//세타 조인(연관관계가 없는 필드로 조인)//회원의 이름이 팀 이름과 같은 회원 조회List&amp;lt;Member&amp;gt; result = queryFactory .select(QMember.member) .from(QMember.member, QTeam.team) .where(QMember.member.username.eq(QTeam.team.name)) .fetch(); join(), innerJoin() 내부 조인(inner join) leftJoin() left 외부 조인(left outer join) rightJoin() right 외부 조인(right outer join) JPQL의 ON과 성능 최적화를 위한 fetch 조인 제공조인 - on절조인 대상 필터링/** * 예) 회원과 팀을 조인하면서, 팀 이름이 teamA인 팀만 조인, 회원은 모두 조회 * JPQL: SELECT m, t FROM Member m LEFT JOIN m.team t on t.name = &#39;teamA&#39; * SQL: SELECT m.*, t.* FROM Member m LEFT JOIN Team t ON m.TEAM_ID=t.id and t.name=&#39;teamA&#39;*/List&amp;lt;Tuple&amp;gt; result = queryFactory .select(QMember.member, QTeam.team) .from(QMember.member) .leftJoin(QMember.member.team, QTeam.team) .on(QTeam.team.name.eq(&quot;teamA&quot;)) .fetch(); on 절을 활용해 조인 대상을 필터링 할 떄, 외부조인이 아닌 내부조인을 사용하면,where 절에서 필터링 한 것과 동일 함.연관관계 없는 엔티티 외부 조인/** * 2. 연관관계 없는 엔티티 외부 조인 * 예) 회원의 이름과 팀의 이름이 같은 대상 외부 조인 * JPQL: SELECT m, t FROM Member m LEFT JOIN Team t on m.username = t.name * SQL: SELECT m.*, t.* FROM Member m LEFT JOIN Team t ON m.username = t.name */List&amp;lt;Tuple&amp;gt; result = queryFactory .select(QMember.member, QTeam.team) .from(QMember.member) .leftJoin(QTeam.team) .on(QMember.member.username.eq(QTeam.team.name)) .fetch(); 하이버네이트 5.1 부터 ON을 사용하여 서로 관계없는 필드로 외부 조인하는 기능이 추가 됨 leftJoin() 부분에 일반 조인과 다르게 헨티티 하나만 들어감. 문법에 주의 필요 일반 조인 : leftJoin(QMember.member.team, QTeam.team) on조인 : from(QMember.member).leftJoin(QTeam.team).on(…) 조인 - 페치 조인페치조인은 SQL에서 제공하는 기능이 아닌 JPA에서 SQL 조인을 활용하여 연관된 엔티티를 SQL 한번에 조회하는 기능.주로 최적화에 사용하는 방법.// 패치 조인 미적용// 지연로딩으로 Member, Team SQL 쿼리 각각 실행@Testpublic void fetchJoinNo() throws Exception { em.flush(); em.clear(); Member findMember = queryFactory .selectFrom(QMember.member) .where(QMember.member.username.eq(&quot;member1&quot;)) .fetchOne(); boolean loaded = emf.getPersistenceUnitUtil().isLoaded(findMember.getTeam()); Assertions.assertThat(loaded).as(&quot;페치 조인 미적용&quot;).isFalse();}// 패치 조인 적용// 즉시로딩으로 Member, Team SQL 쿼리 한번으로 조회@Testpublic void fetchJoinUse() throws Exception { em.flush(); em.clear(); Member result = queryFactory .selectFrom(QMember.member) .join(QMember.member.team, QTeam.team).fetchJoin() .where(QMember.member.username.eq(&quot;member1&quot;)) .fetchOne(); boolean loaded = emf.getPersistenceUnitUtil().isLoaded(result.getTeam()); Assertions.assertThat(loaded).as(&quot;페치 조인 적용&quot;).isTrue();} join(), leftJoin() 등 조인 기능 뒤에 fetchJoin() 이라고 추가하면 됨서브 쿼리com.querydsl.jpa.JPAExpressions 사용// 나이가 평균 나이 이상인 회원QMember memberSub = new QMember(&quot;memberSub&quot;);List&amp;lt;Member&amp;gt; result = queryFactory .selectFrom(QMember.member) .where(QMember.member.age.eq( JPAExpressions .select(memberSub.age.max()) .from(memberSub) )) .fetch();// 서브쿼리 여러 건 처리, in 사용QMember memberSub = new QMember(&quot;membersub&quot;);List&amp;lt;Member&amp;gt; result = queryFactory .selectFrom(QMember.member) .where(QMember.member.age.in( JPAExpressions .select(memberSub.age) .from(memberSub) .where(memberSub.age.gt(10)) )) .fetch(); select 절에도 사용 가능 from 절에는 서브쿼리 사용 불가능 JPA JPQL 서브쿼리의 한계점으로 from 절의 서브쿼리는 지원하지 않기 떄문에 Querydsl도 지원하지 않음 from 절에 서브쿼리를 써야한다면 다음과 같이 서브쿼리대신 풀어서 사용해야 함. 서브쿼리를 join으로 변경하는 방법 어플리케이션에서 쿼리를 분리하여 실행하는 방법 nativeSQL을 사용하는 방법Case 문select, where, order by에서 case문 사용 가능// 간단한 조건List&amp;lt;String&amp;gt; result = queryFactory .select(QMember.member.age .when(10).then(&quot;열살&quot;) .when(20).then(&quot;스무살&quot;) .otherwise(&quot;기타&quot;)) .from(QMember.member) .fetch();// 복잡한 조건List&amp;lt;String&amp;gt; result = queryFactory .select(new CaseBuilder() .when(QMember.member.age.between(0, 20)).then(&quot;0~20살&quot;) .when(QMember.member.age.between(21, 30)).then(&quot;21~30살&quot;) .otherwise(&quot;기타&quot;)) .from(QMember.member) .fetch();상수, 문자 더하기상수가 필요하면 Expressions.constant(xxx) 사용// 상수 사용Tuple result = queryFactory .select(QMember.member.username, Expressions.constant(&quot;A&quot;)) .from(QMember.member) .fetchFirst();// 문자 더하기 concatString result = queryFactory .select(QMember.member.username.concat(&quot;_&quot;).concat(QMember.member.age.stringValue())) .from(QMember.member) .where(QMember.member.username.eq(&quot;member1&quot;)) .fetchOne(); 문자가 아닌 다른 타입들은 stringValue()로 문자로 변환할 수 있음. 이 방법은 Enum을 처리할때 자주 사용 참고 실전! Querydsl(김영한)" }, { "title": "Spring Data JPA - 스프링 데이터 JPA 구현체 분석", "url": "/posts/spring-data-jpa-04/", "categories": "Backend, JPA", "tags": "Web, Spring Framework, DataBase, JPA, Spring Data JPA", "date": "2023-10-31 16:10:00 +0900", "snippet": "스프링 데이터 JPA 구현체 분석 스프링 데이터 JPA가 제공하는 공통 인터페이스의 구현체 org.springframework.data.jpa.repository.support.SimpleJpaRepository @Repository@Transactional(readOnly = true)public class SimpleJpaRepository&amp;lt;T, ID&amp;gt; ...{ @Transactional public &amp;lt;S extends T&amp;gt; S save(S entity) { if (entityInformation.isNew(entity)) { em.persist(entity); return entity; } else { return em.merge(entity); } } ...} @Repository 적용 JPA 예외를 스프링이 추상화한 예외로 변환 @Transactional 적용 JPA의 모든 변경은 트랜잭션 안에서 동작 스프링 데이터 JPA는 변경(등록, 수정, 삭제) 메소드를 트랜잭션 처리 서비스 계층에서 트랜잭션을 시작하지 않으면 리포지토리에서 트랜잭션 시작 서비스 계층에서 트랜잭션을 시작하면 리포지토리는 해당 트랜잭션을 전파 받아서 사용 클래스에 @Transactional(readOnly = true) 적용 데이터를 단순히 조회만 하고 변경하지 않는 트랜잭션에서 readOnly = true 옵션을 사용하면,내부적으로 flush를 생략하기 떄문에 약간의 성능향상을 얻을 수 있음 save 메소드 새로운 엔티티면 저장(persist()) 새로운 엔티티가 아니면 병합(merge()) 병합은 엔티티의 값을 강제로 엎어 적용하는 것이기 떄문에 의도치 않게 값이 null이 될수도 있음 새로운 엔티티를 구별하는 방법 새로운 엔티티를 판단하는 기본 전략 식별자가 객체일떄는 null 인지 판단 식별자가 자바 기본 타입일때는 0으로 판단 Persistable 인터페이스를 구현해서 판단 로직 변경 가능 package org.springframework.data.domain;public interface Persistable&amp;lt;ID&amp;gt; { ID getId(); boolean isNew();}JPA 식별자 생성 전략이 @GenerateValue면 save() 호출 시점에 식별자가 없으므로 새로운 엔티티로 인식해서 정상 독작 함.그러나 JPA 식별자 생성 전략이 @Id 만 사용하여 직접 할당하는 경우엔 이미 식별자 값이 있는 상태로 save()를 호출하므로,이 경우에는 merge()가 호출 됨.merge()는 우선 데이터베이스를 호출하여 값을 확인하고, 데이터베이스에 값이 없다면 새로운 엔티티로 인지하므로 비효율적임.따라서 Persistable을 사용하여 새로운 엔티티 확인 여부를 직접 구현하는 것이 효과적 임.예를 들어 등록시간(@CreateDate)을 조합하여 사용하면 이 필드로 새로운 엔티티 여부를 편리하게 확인할 수 있음.(@CreateDate에 값이 없으면 새로운 엔티티로 판단)@Entity@EntityListeners(AuditingEntityListener.class)@NoArgsConstructor(access = AccessLevel.PROTECTED)public class Item implements Persistable&amp;lt;String&amp;gt; { @Id private String id; @CreatedDate private LocalDateTime createdDate; public Item(String id) { this.id = id; } @Override public String getId() { return id; } @Override public boolean isNew() { return createdDate == null; }}참고 실전! 스프링 데이터 JPA(김영한)" }, { "title": "Spring Data JPA - 확장 기능", "url": "/posts/spring-data-jpa-03/", "categories": "Backend, JPA", "tags": "Web, Spring Framework, DataBase, JPA, Spring Data JPA", "date": "2023-10-31 14:10:00 +0900", "snippet": "사용자 정의 리포지토리 구현 스프링 데이터 JPA 리포지토리는 인터페이스만 정의하고 구현체는 스프링이 자동 생성 스프링 데이터 JPA가 제공하는 인터페이스를 직접 구현하면 구현해야하는 기능이 너무 많음스프링이 생성해주는 구현이외에 사용자가 직접 구현하고자 할 때는 다음과 같은 방멉이 있음.// 사용자 정의 인터페이스public interface MemberRepositoryCustom { List&amp;lt;Member&amp;gt; findMemberCustom();}// 사용자 정의 인터페이스 구현@RequiredArgsConstructorpublic class MemberRepositoryCustomImpl implements MemberRepositoryCustom { private final EntityManager em; @Override public List&amp;lt;Member&amp;gt; findMemberCustom() { return em.createQuery(&quot;select m from Member m&quot;, Member.class) .getResultList(); }}// 사용자 정의 인터페이스 상속public interface MemberRepository extends JpaRepository&amp;lt;Member, Long&amp;gt;, MemberRepositoryCustom {} 사용자 정의 구현 클래스 규칙 : 리포지토리 인터페이스 이름 + Impl 스프링 데이터 JPA가 인식하여 스프링 빈으로 등록 실무에서는 주로 QueryDSL이나 SpringJdbcTemplate을 함께 사용할 떄 사용자 정의 리포지토리 기능 사용항상 사용자 정의 리포지토리가 필요한 것은 아니고 그냥 임의의 리포지토리를 만들어도 됨.예를들어 MemberQueryRepository를 인터페이스가 아닌 클래스로 만들고 스프링 빈으로 등록해서그냥 직접 사용해도 됨. 물론 이 경우 스프링 데이터 JPA와는 아무런 관계 없이 별도로 동작 함.Auditing엔티티를 생성, 변경할 떄 자동으로 시간 및 변경자 추척하는 방법@EntityListeners(AuditingEntityListener.class)@MappedSuperclass@Getterpublic class BaseTimeEntity { @CreatedDate @Column(updatable = false) private LocalDateTime createdDate; @LastModifiedDate private LocalDateTime lastModifiedDate;}@EntityListeners(AuditingEntityListener.class)@MappedSuperclass@Getterpublic class BaseEntity extends BaseTimeEntity { @CreatedBy @Column(updatable = false) private String createdBy; @LastModifiedBy private String lastModifiedBy;}public class Member extends BaseEntity { ...}@EnableJpaAuditing@SpringBootApplicationpublic class DataJpaApplication { public static void main(String[] args) { SpringApplication.run(DataJpaApplication.class, args); } // 생성자, 변경자의 이름을 생성하기 위한 메소드 @Bean public AuditorAware&amp;lt;String&amp;gt; auditorProvider() { return () -&amp;gt; Optional.of(UUID.randomUUID().toString()); }} @EnableJpaAuditing 어노테이션을 스프링 부트 설정 클래스에 적용해야 함 EntityListeners(AuditingEntityListener.class) 어노테이션은 엔티티에 적용 해야함 실무에서는 보통 세션 정보나, 스프링 시큐리티 로그인 정보에서 ID를 받음EntityListeners(AuditingEntityListener.class) 어노테이션을 생략하고 스프링 데이터 JPA가 제공하는 이벤트를엔티티 전체에 적용하려면 orm.xml에 다음과 같이 등록하면 됨&amp;lt;!-- META-INF/orm.xml --&amp;gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;entity-mappings xmlns=&quot;http://xmlns.jcp.org/xml/ns/persistence/orm&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/persistence/orm http://xmlns.jcp.org/xml/ns/persistence/orm_2_2.xsd&quot; version=&quot;2.2&quot;&amp;gt; &amp;lt;persistence-unit-metadata&amp;gt; &amp;lt;persistence-unit-defaults&amp;gt; &amp;lt;entity-listeners&amp;gt; &amp;lt;entity-listener class=&quot;org.springframework.data.jpa.domain.support.AuditingEntityListener&quot;/&amp;gt; &amp;lt;/entity-listeners&amp;gt; &amp;lt;/persistence-unit-defaults&amp;gt; &amp;lt;/persistence-unit-metadata&amp;gt;&amp;lt;/entity-mappings&amp;gt;Web 확장 - 페이징과 정렬스프링 데이터가 제공하는 페이징과 정렬 기능을 스프링 MVC에서 편하게 사용 가능@GetMapping(&quot;/members&quot;)public Page&amp;lt;Member&amp;gt; list(Pageable pageable) { Page&amp;lt;Member&amp;gt; page = memberRepository.findAll(pageable); return page;} 파라미터로 Pageable을 받을 수 있음 Pageable은 인터페이스로, 실제로는 org.springframework.data.domain.PageRequest 객체 생성요청 파라미터 예시 : /members?page=0&amp;amp;size=3&amp;amp;sort=id,desc&amp;amp;sort=username,desc page : 현재 페이지. 0부터 시작함. size : 한 페이지에 노출할 데이터 건수. sort : 정렬 조건을 정의. (ASC DESC) 기본값에 대한 설정은 아래와 같이 글로벌, 개별 설정 두가지 방법 존재 기본 값spring.data.web.pageable.default-page-size=20 /# 기본 페이지 사이즈/spring.data.web.pageable.max-page-size=2000 /# 최대 페이지 사이즈/ 개별 설정@GetMapping(&quot;/members&quot;)public Page&amp;lt;Member&amp;gt; list( @PageableDefault(size = 12, sort = &quot;username&quot;, direction = Sort.Direction.DESC) Pageable pageable) { Page&amp;lt;Member&amp;gt; page = memberRepository.findAll(pageable); return page;}Page 내용을 DTO로 변환엔티티를 API로 노출하면 다양한 문제가 생김. 그러므로 엔티티는 반드시 DTO로 변환해서 반환해야 함.Page는 map()을 지원하여 내부 데이터를 다른것으로 변경 가능@Datapublic class MemberDto { private Long id; private String username; public MemberDto(Member m) { this.id = m.getId(); this.username = m.getUsername(); }}// Page.map() 사용@GetMapping(&quot;/members&quot;)public Page&amp;lt;MemberDto&amp;gt; list(Pageable pageable) { Page&amp;lt;Member&amp;gt; page = memberRepository.findAll(pageable); Page&amp;lt;MemberDto&amp;gt; pageDto = page.map(member -&amp;gt; new MemberDto(member)); return pageDto;}// Page.map() 코드 최적화@GetMapping(&quot;/members&quot;)public Page&amp;lt;MemberDto&amp;gt; list(Pageable pageable) { return memberRepository.findAll(pageable).map(MemberDto::new);}Page를 1부터 시작하기스프링 데이터는 Page를 0부터 시작 함.만약 1부터 시작하려면 아래와 같은 두가지 방법이 있음 Pageable, Page를 파라미터와 응답 값으로 사용하지 않고, 직접 클래스를 만들어서 처리하고,직접 PageReqeust(Pageable 구현체)를 생성하여 리포지토리에 전달. 응답값도 Page 대신 직접 만들어서 제공해야 함 spring.data.web.pageable.one-indexed-parameters을 true로 설정 이 방법은 web에서 page 파라미터를 -1 할뿐이며,응답값인 page 이외 다른 필드는 모두 0 페이지 인덱스를 기준으로 값을 설정하는 한계가 있음 참고 실전! 스프링 데이터 JPA(김영한)" }, { "title": "Spring Data JPA - 쿼리 메소드 기능", "url": "/posts/spring-data-jpa-02/", "categories": "Backend, JPA", "tags": "Web, Spring Framework, DataBase, JPA, Spring Data JPA", "date": "2023-10-30 17:50:00 +0900", "snippet": "메소드 이름으로 쿼리 생성메소드 이름을 분석해서 JPQL 쿼리 실행public interface MemberRepository extends JpaRepository&amp;lt;Member, Long&amp;gt; { // 이름이 username과 같고 나이가 age 보다 많은 Member의 리스트 반환 List&amp;lt;Member&amp;gt; findByUsernameAndAgeGreaterThan(String username, int age);} 쿼리 메소드 필터 조건 스프링 데이터 JPA 공식 문서 참고 스프링 데이터 JPA가 제공하는 쿼리 메소드 기능 조회: find…By ,read…By ,query…By get…By, Query Creation 문서 참고 findHelloBy 처럼 …에 식별하기 위한 내용(설명)이 들어가도 됨 COUNT: count…By 반환타입 long EXISTS: exists…By 반환타입 boolean 삭제: delete…By, remove…By 반환타입 long DISTINCT: findDistinct, findMemberDistinctBy LIMIT: findFirst3, findFirst, findTop, findTop3 Limiting Query Results 문서 참고 이 기능은 엔티티의 필드명이 변경되면 인터페이스에 정의한 메소드 이름도 꼭 함꼐 변경해야 함.그렇지 않으면 어플리케이션 실행 시점에 오류 발생.JPA NamedQueryJPA의 NamedQuery를 호출할 수 있음// Entity에 NameQuery 정의@Entity@NamedQuery( name=&quot;Member.findByUsername&quot;, query=&quot;select m from Member m where m.username = :username&quot;)public class Member { ...}// JPA를 직접 사용하여 NamedQuery 호출public class MemberRepository { public List&amp;lt;Member&amp;gt; findByUsername(String username) { ... List&amp;lt;Member&amp;gt; resultList = em.createNamedQuery(&quot;Member.findByUsername&quot;, Member.class) .setParameter(&quot;username&quot;, username) .getResultList(); }}public interface MemberRepository extends JpaRepository&amp;lt;Member, Long&amp;gt; { // 스프링 데이터 JPA로 NamedQuery 호출 @Query(name = &quot;Member.findByUsername&quot;) List&amp;lt;Member&amp;gt; findByUsername(@Param(&quot;username&quot;) String username); ...} 스프링 데이터 JPA는 선언한 “도메인 클래스 + . + 메소드 이름” 으로 NamedQuery를 찾아서 실행 만약 실행할 NamedQuery가 없다면 메소드 이름으로 쿼리 생성 전략을 사용 어플리케이션 로딩시점에 정의한 NamedQuery를 파싱하여 검사함 문법오류가 있다면 로딩 시점에 예외 발생 스프링 데이터 JPA를 사용하면 실무에서 NamedQuery를 직접 등록하여 사용할 일은 거의 없음 NamedQuery대신 @Query를 사용하여 리포지토리 메소드에 쿼리를 직접 정의 @Query. 리포지토리 메소드에 쿼리 정의public interface MemberRepository extends JpaRepository&amp;lt;Member, Long&amp;gt; { @Query(&quot;select m from Member m where m.username= :username and m.age = :age&quot;) List&amp;lt;Member&amp;gt; findUser(@Param(&quot;username&quot;) String username, @Param(&quot;age&quot;) int age);} @org.springframework.data.jpa.repository.Query 어노테이션 사용 실행할 메소드에 정적 쿼리를 직접 작성하므로 이름없는 NamedQuery라고 할 수 있음 JPA NamedQuery처럼 어플리케이션 실행 시점에 문법 오류를 발견 할 수 있음 보통 실무에서는 메소드 이름으로 쿼리 생성 기능은 파라미터가 증가하면메소드 이름이 매우 길어지므로 @Query 기능을 자주 사용함@Query로 값, DTO 조회@Datapublic class MemberDto { private Long id; private String username; private String teamName; public MemberDto(Long id, String username, String teamName) { this.id = id; this.username = username; this.teamName = teamName; }}public interface MemberRepository extends JpaRepository&amp;lt;Member, Long&amp;gt; { // DTO로 직접 조회 @Query(&quot;select new study.datajpa.dto.MemberDto(m.id, m.username, t.name) &quot; + &quot;from Member m join m.team t&quot;) List&amp;lt;MemberDto&amp;gt; findMemberDto(); // 단순히 값 하나를 조회 @Query(&quot;select m.username from Member m&quot;) List&amp;lt;String&amp;gt; findUsernameList();} DTO로 직접 조회하려면 JPA의 new 명령어를 사용해야함 DTO에는 생성자를 정의해주고 그 생성자에 맞춰 필드를 넣어주어야 함파라미터 바인딩-- 위치 기반select m from Member m where m.username = ?0-- 이름 기반select m from Member m where m.username = :namepublic interface MemberRepository extends JpaRepository&amp;lt;Member, Long&amp;gt; { @Query(&quot;select m from Member m where m.username = :name&quot;) Member findMembers(@Param(&quot;name&quot;) String username); @Query(&quot;select m from Member m where m.username in :names&quot;) List&amp;lt;Member&amp;gt; findByNames(@Param(&quot;names&quot;) List&amp;lt;String&amp;gt; names);} 보통 코드의 가독성과 유지보수를 위해 이름기반 파라미터 바인딩을 사용 Collection 타입으로 IN 정도 지원 함반환 타입public interface MemberRepository extends JpaRepository&amp;lt;Member, Long&amp;gt; { // 컬렉션 반환 List&amp;lt;Member&amp;gt; findByUsername(String name); // 단건 반환 Member findByUsername(String name); // 단건 Optional 반환 Optional&amp;lt;Member&amp;gt; findByUsername(String name);} 스프링 데이터 JPA 공식 문서 참고 조회 결과가 많거나 없으면 아래와 같이 처리 컬렉션 결과 없음 : 빈 컬렉션 반환 단건 조회 결과 없음 : null 반환 결과가 2건 이상 : javax.persistence.NonUniqueResultException 예외 발생 페이징과 정렬 페이징 및 정렬 기능 org.springframework.data.domain.Sort 정렬 기능 org.springframework.data.domain.Pageable 페이징 기능 내부에 Sort 포함 반환 타입 org.springframework.data.domain.Page 추가 count 쿼리 결과를 포함하는 페이징 org.springframework.data.domain.Slice 추가 count 쿼리 없이 다음 페이지만 학인 가능 내부적으로 limit + 1 조회 List 추가 count 쿼리 없이 결과만 반환 public interface MemberRepository extends JpaRepository&amp;lt;Member, Long&amp;gt; { // count 쿼리 사용 Page&amp;lt;Member&amp;gt; findByAge(int age, Pageable pageable); // count 쿼리 사용 안함 Slice&amp;lt;Member&amp;gt; findByAge(int age, Pageable pageable); // count 쿼리 사용 안함 List&amp;lt;Member&amp;gt; findByAge(int age, Pageable pageable); List&amp;lt;Member&amp;gt; findByAge(int age, Sort sort);}@Testpublic void paging() throws Exception { //given memberRepository.save(new Member(&quot;member1&quot;, 10)); memberRepository.save(new Member(&quot;member2&quot;, 10)); memberRepository.save(new Member(&quot;member3&quot;, 10)); memberRepository.save(new Member(&quot;member4&quot;, 10)); memberRepository.save(new Member(&quot;member5&quot;, 10)); int age = 10; int offset = 0; int limit = 3; //when PageRequest pageRequest = PageRequest.of(offset, limit, Sort.by(Sort.Direction.DESC, &quot;username&quot;)); Page&amp;lt;Member&amp;gt; page = memberRepository.findByAge(age, pageRequest); //then List&amp;lt;Member&amp;gt; content = page.getContent(); Assertions.assertThat(content.size()).isEqualTo(3); //조회된 데이터 수 Assertions.assertThat(page.getTotalElements()).isEqualTo(5); //전체 데이터 수 Assertions.assertThat(page.getNumber()).isEqualTo(0); //페이지 번호 Assertions.assertThat(page.getTotalPages()).isEqualTo(2); //전체 페이지 번호 Assertions.assertThat(page.isFirst()).isTrue(); //첫번째 항목인가? Assertions.assertThat(page.hasNext()).isTrue(); //다음 페이지가 있는가?}생성되는 SQL 로그 2023-10-31 10:44:00.902 DEBUG 36924 --- [ main] org.hibernate.SQL : select member0_.member_id as member_i1_0_, member0_.age as age2_0_, member0_.team_id as team_id4_0_, member0_.username as username3_0_ from member member0_ where member0_.age=? order by member0_.username desc limit ?...2023-10-31 10:44:00.911 DEBUG 36924 --- [ main] org.hibernate.SQL : select count(member0_.member_id) as col_0_0_ from member member0_ where member0_.age=? 두번쨰 파라미터로 받은 Pageable은 인터페이스 이므로 실제 사용할 떄는 해당 인터페이스를 구현한 org.springframework.data.domain.PageRequest 객체를 사용 PageRequest 생성자의 첫번쨰 파라미터는 현재 페이지를, 두번쨰 파라미터는 조회할 데이터의 수를 입력. 그리고 추가로 정렬 정보도 파라미터로 사용 가능 페이지는 0부터터 시작 함페이지를 유지하면서 엔티티를 DTO로 변환엔티티를 바로 클라이언트에게 전달하는것은 피하는 것이 좋으므로, 엔티티를 별도의 DTO로 재구성할 필요가 있음@Testpublic void paging() throws Exception { ... //when PageRequest pageRequest = PageRequest.of(offset, limit, Sort.by(Sort.Direction.DESC, &quot;username&quot;)); Page&amp;lt;Member&amp;gt; page = memberRepository.findByAge(age, pageRequest); Page&amp;lt;MemberDto&amp;gt; dtoPage = page.map(m -&amp;gt; new MemberDto(m.getId(), m.getUsername())); ...}count 쿼리 분리다음과 같이 count 쿼리를 별도로 지정하여 살행할 수 있음public interface MemberRepository extends JpaRepository&amp;lt;Member, Long&amp;gt; { @Query(value = &quot;select m from Member m&quot;, countQuery = &quot;select count(m.username) from Member m&quot;) Page&amp;lt;Member&amp;gt; findMemberAllCountBy(Pageable pageable);}생성되는 SQL 로그 2023-10-31 10:57:56.716 DEBUG 37534 --- [ main] org.hibernate.SQL : select member0_.member_id as member_i1_0_, member0_.age as age2_0_, member0_.team_id as team_id4_0_, member0_.username as username3_0_ from member member0_ order by member0_.username desc limit ?...2023-10-31 10:57:56.722 DEBUG 37534 --- [ main] org.hibernate.SQL : select count(member0_.username) as col_0_0_ from member member0_... 데이터베이스의 전체 row의 수를 반한하는 count 쿼리는 매우 무겁기 떄문에 최적화 필요. 복잡한 SQL에서는 데이터를 Left Join으로 조회할때, 자동으로 생성되는 count 쿼리도 동일하게 Left Join을 사용하여 전체 수를 조회함. 그러나 단순 count 쿼리에서 까지 Left Join할 필요가 없으므로 최적화를 위해 별도의 count 쿼리를 지정 필요. 스프링부트3 - 하이버네이트6에서는 의미없는 Left Join을 최적화 하여위 예시의 경우 Left Join을 추가하지 않음벌크성 수정 쿼리public interface MemberRepository extends JpaRepository&amp;lt;Member, Long&amp;gt; { @Modifying(clearAutomatically = true) @Query(&quot;update Member m set m.age = m.age + 1 where m.age &amp;gt;= :age&quot;) int bulkAgePlus(@Param(&quot;age&quot;) int age);} 벌크성 수정, 삭제 쿼리는 @Modifying 어노테이션 사용 사용하지 않으면 다음과 같은 예외 발생 org.hibernate.hql.internal.QueryExecutionRequestException: Not supported for DML operations 벌크성 쿼리를 실행하고 나서 영속성 컨텍스트 초기화 @Modifying(clearAutomatically = true) 이 옵션 없다면 영속성 컨텍스트에 과거 값이 남아서 재조회시 문제가 될수 있음 벌크 연산은 영속성 컨텍스트를 무시하고 실행되기 떄문에 영속성 컨텍스트에 있는 엔티티 상태와 데이터베이스에 엔티티 상태가 달라질 수 있음 권장하는 방안으로는 아래와 같이 두가지가 있음 영속성 컨텍스트에 엔티티가 없는 상태에서 벌크 연산을 먼저 실행 부득이하게 영속성 컨텍스트에 엔티티가 있다면 벌크 연산 직후 영속성 컨텍스트를 초기화 entityManager.clear() @EntityGraph관련된 엔티티들을 SQL 한번에 조회하는 방법public interface MemberRepository extends JpaRepository&amp;lt;Member, Long&amp;gt; { // 공통 메소드 오버라이드 @Override @EntityGraph(attributePaths = {&quot;team&quot;}) List&amp;lt;Member&amp;gt; findAll(); // 메소드 이름으로 쿼리 + 엔티티 그래프 @EntityGraph(attributePaths = {&quot;team&quot;}) List&amp;lt;Member&amp;gt; findByUsername(String username); // JPQL + 엔티티 그래프 @EntityGraph(attributePaths = {&quot;team&quot;}) @Query(&quot;select m from Member m&quot;) List&amp;lt;Member&amp;gt; findMemberEntityGraph(); 사실상 패치조인의 간편버전 내부적으로 LEFT OUTER JOIN 사용JPA HintJPA 쿼리 힌트(SQL 힌트가 아니라 JPA 구현체에게 제공하는 힌트)public interface MemberRepository extends JpaRepository&amp;lt;Member, Long&amp;gt; { // read only 로 힌트 적용 @QueryHints(value = @QueryHint(name = &quot;org.hibernate.readOnly&quot;, value = &quot;true&quot;)) Member findReadOnlyByUsername(String username); // read only 로 힌트 적용 @QueryHints(value = { @QueryHint(name = &quot;org.hibernate.readOnly&quot;, value = &quot;true&quot;)}, forCounting = true) Page&amp;lt;Member&amp;gt; findByUsername(String username, Pageable pageable);}@Testpublic void queryHint() throws Exception { //given memberRepository.save(new Member(&quot;member1&quot;, 10)); em.flush(); em.clear(); //when Member member = memberRepository.findReadOnlyByUsername(&quot;member1&quot;); member.setUsername(&quot;member2&quot;); // 쿼리 힌트로 인하여 read only로 설정되었으므로 // Update Query를 실행하지 않음 em.flush();} org.springframework.data.jpa.repository.QueryHints 어노테이션 사용 forCounting 반환 타입으로 Page 인터페이스를 적용하면 추가로 호출하는 페이징을 위한 count 쿼리도 쿼리 힌트 적용 기본값 true Lock연관된 엔티티에 대하여 Lock을 걸어 다른 세션에서 접근하지 못하도록 함public interface MemberRepository extends JpaRepository&amp;lt;Member, Long&amp;gt; { @Lock(LockModeType.PESSIMISTIC_WRITE) List&amp;lt;Member&amp;gt; findLockByUsername(String username);}생성되는 SQL 로그 2023-10-31 12:29:08.176 DEBUG 40588 --- [ main] org.hibernate.SQL : select member0_.member_id as member_i1_0_, member0_.age as age2_0_, member0_.team_id as team_id4_0_, member0_.username as username3_0_ from member member0_ where member0_.username=? for update org.springframework.data.jpa.repository.Lock 어노테이션을 사용 내부적으로 SQL의 for update와 같은 구문 사용 어플리케이션이 실시간이 중요하다면 사용에 주의 필요참고 실전! 스프링 데이터 JPA(김영한)" }, { "title": "Spring Data JPA - 공통 인터페이스 기능", "url": "/posts/spring-data-jpa-01/", "categories": "Backend, JPA", "tags": "Web, Spring Framework, DataBase, JPA, Spring Data JPA", "date": "2023-10-30 17:00:00 +0900", "snippet": "공통 인터페이스 구성import org.springframework.data.jpa.repository.JpaRepository;public interface ItemRepository extends JpaRepository&amp;lt;Item, Long&amp;gt; {} 스프링 데이터 JPA가 구현 클래스 대신 생성 org.springframework.data.repository.Repository를 구현한 클래스는 스캔 대상 memberRepository.getClass() class com.sun.proxy.$ProxyXXX @Repository 어노테이션 생략 가능 컴포넌트 스캔을 스프링 데이터 JPA가 대신 처리 JPA 예외를 스프링 예외로 변환하는 과정도 자동으로 처리 공통인터페이스 분석// JpaRepository 공통 기능 인터페이스public interface JpaRepository&amp;lt;T, ID extends Serializable&amp;gt; extends PagingAndSortingRepository&amp;lt;T, ID&amp;gt;{ ...}// JpaRepository를 사용하는 인터페이스import org.springframework.data.jpa.repository.JpaRepository;public interface ItemRepository extends JpaRepository&amp;lt;Item, Long&amp;gt; {} JpaRepository 인터페이스 공통 CRUD 제공 제네릭은 &amp;lt;엔티티 타입, 식별자 타입&amp;gt; 설정 제네릭 타입 T 엔티티 ID 엔티티의 식별자 타입 S 엔티티와 그 자식 타입 주요 메소드 save(S) 새로운 엔티티는 저장하고 이미 있는 엔티티는 병합 delete(T) 엔티티 하나를 삭제 내부에서 EntityManger.remove() 호출 findById(ID) 엔티티 하나를 조회 내부에서 EntityManger.find() 호출 getOne(ID) 엔티티를 프록시로 조회 내부에서 EntityManger.getReference() 호출 findAll(…) 모든 엔티티를 조회 정렬(Sort)이나 페이징(Pageable) 조건을 파라미터로 제공 가능 JpaRepository는 대부분의 공통 메소드를 제공 함.참고 실전! 스프링 데이터 JPA(김영한)" }, { "title": "JPA - OSIV(Open Session In View)와 성능 최적화", "url": "/posts/spring-jpa-14/", "categories": "Backend, JPA", "tags": "Web, Spring Framework, DataBase, JPA", "date": "2023-10-30 12:00:00 +0900", "snippet": "OSIV와 성능 최적화 OSIV는 트랜잭션이 종료되어도 영속성 컨텍스트와 데이터베이스 커넥션을 반환하지 않고 유지하여이후 Controller나 View Template에서도 영속성 컨텍스트를 사용할 수 있게끔 해주는 옵션 Open Session In View : 하이버네이트 Open EntityManager in View : JPA 관계상 OSIV 라고 함 # src/main/resources/application.ymlspring: jpa: open-in-view: false spring.jpa.open-in-view true가 기본값 OSIV OnOSIV 전략은 트랜잭션 시작처럼 최초 데이터베이스 커넥션 시작 시점부터 API 응답이 끝날때 까지 영속성 컨텍스트와 데이터베이스 커넥션을 유지 함.그래서 View Template이나 API 컨트롤러에서도 지연로딩이 가능하게 함.지연로딩은 영속성 컨텍스트가 살아 있어야 가능하고, 영속성 컨텍스트는 기본적으로 터에터베이스 커넥션을 유지함.그러나 이 전략은 너무 오랜시간동안 데이터베이스 커넥션 리소스를 사용하기 떄문에,실시간 트래픽이 중요한 어플리케이션에서는 데이터베이스 커넥션이 모자랄 수 있고 결국 이는 장애로 이어지게 됨.예를 들어 컨트롤러에서 외부 API를 호출하면 외부 API 대기 시간만큼 데이터베이스 커넥션 리소스를 반환하지 못하고 유지해야 함.이러한 이유로 인하여 OSIV가 활성화 되면 어플리케이션 시작 시점에 warn 로그를 남김2023-10-30 14:26:04.329 WARN 20905 --- [ restartedMain] JpaBaseConfiguration$JpaWebConfiguration : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warningOSIV OffOSIV를 끄면 트랜잭션을 종료할 때 영속성 컨텍스트를 닫고, 데이터베이스 커넥션도 반환하여 리소스 낭비를 하지 않음.그러나 트랜잭션 이후 영속성 컨텍스트를 닫고, 데이터베이스 커넥션도 반환되기 때문에 지연로딩을 사용하지 못함.그러므로 일반적으로 트랜잭션의 외부인 View Template이나 API 컨트롤러에서는 지연로딩을 사용하지 못하기 때문에,트랜잭션이 끝나기 전에 지연로딩을 강제로 호출해 두어야 함. OSIV를 키고 끌지 선택결국 고객서비스와 같이 실시간 및 트래픽이 많다고 예상되는곳은 OSIV를 끄고,Admin과 같이 커넥션을 많이 사용하지 않는 곳에서는 OSIV를 키면 됨.커맨드와 쿼리 분리실무에서 OSIV를 끈 상태로 복잡성을 관리하는 좋은 방법은 바로 Command와 Query를 분리하는 방법.보통 비지니스 로직은 특정 엔티티 몇개를 등록하거나 수정하는 것이므로 성능에 크게 문제가 되지 않음.그런데 복잡한 화면을 출력하기 위한 쿼리는 화면에 맞추어 성능을 최적화하는 것이 중요 함.하지만 그 복잡성에 비해 핵심 비지니스에 영향을 주는것은 아님.그러므로 크고 복잡한 어플리케이션을 개발한다면 이 둘의 관심사를 명확하게 분리하는 선택은 유지보수 관점에서 충분한 의미가 있음.즉, 아래와 같이 비지니스 로직부분과 화면및 API위한 부분을 서로 분리하는 것 OrderService OrderService : 핵심 비지니스 로직 담당 OrderQueryService : 화면이나 API에 맞춘 서비스(주로 읽기 관련 트랜잭션 사용) 보통 서비스 계층에서 트랜잭션을 유지하므로 두 서비스 모두 트랜잭션을 유지하면서 지연로딩을 사용할 수 있음.참고 실전! 스프링 부트와 JPA 활용2 - 웹 애플리케이션 개발(김영한) https://en.wikipedia.org/wiki/Command–query_separation" }, { "title": "JPA - 컬렉션 조회 최적화", "url": "/posts/spring-jpa-13/", "categories": "Backend, JPA", "tags": "Web, Spring Framework, DataBase, JPA", "date": "2023-10-27 14:00:00 +0900", "snippet": "OneToMany 관계에서의 성능 최적화 예시를 위해 간단한 주문조회 API 컨트롤러와 엔티티를 구현하고 단계별로 어떻게 최적화 하는지 확인엔티티 예시@Entitypublic class Order { @Id @GeneratedValue @Column(name = &quot;order_id&quot;) private Long id; @OneToMany(mappedBy = &quot;order&quot;, cascade = CascadeType.ALL) private List&amp;lt;OrderItem&amp;gt; orderItems = new ArrayList&amp;lt;&amp;gt;(); ...}@Entitypublic class OrderItem { @Id @GeneratedValue @Column(name = &quot;order_item_id&quot;) private Long Id; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = &quot;item_id&quot;) private Item item; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = &quot;order_id&quot;) private Order order; ...}@Entitypublic class Item { @Id @GeneratedValue @Column(name = &quot;item_id&quot;) private Long id; private String name; private int price; private int stockQuantity; ...}주문조회 V1 - 엔티티 직접 노출/** * V1. 엔티티 직접 노출 * - Hibernate5Module 모듈 등록, LAZY=null 처리 * - 양방향 관계 문제 발생 -&amp;gt; @JsonIgnore */@GetMapping(&quot;/api/v1/orders&quot;)public List&amp;lt;Order&amp;gt; ordersV1() { List&amp;lt;Order&amp;gt; orders = orderRepository.findAllByString(new OrderSearch()); for (Order order : orders) { // Lazy 강제 초기화 order.getMember().getName(); // Lazy 강제 초기화 order.getDelivery().getAddress(); // 컬렉션 내의 각 Item에 대하여 Lazy 강제 초기화 List&amp;lt;OrderItem&amp;gt; orderItems = order.getOrderItems(); orderItems.stream().forEach(o -&amp;gt; o.getItem().getName()); } return orders;} orderItem, item 관계를 직접 초기화 하면 Hibernate5Module 설정에 의해 엔티티를 Json으로 생성함 양방향 연관관계면 무한 루프에 걸리지 않도록 한쪽에 @JsonIgnore를 추가해야 함 엔티티를 직접 노출하므로 좋은 방법이 아님주문조회 V2 - 엔티티를 DTO로 반환@Datapublic static class OrderDto { private Long orderId; private String name; private LocalDateTime orderDate; private OrderStatus orderStatus; private Address address; private List&amp;lt;OrderItemDto&amp;gt; orderItems; public OrderDto(Order order) { orderId = order.getId(); name = order.getMember().getName(); orderDate = order.getOrderDate(); orderStatus = order.getStatus(); address = order.getDelivery().getAddress(); orderItems = order.getOrderItems() .stream() .map(orderItem -&amp;gt; new OrderItemDto(orderItem)) .collect(Collectors.toList()); }}@Datastatic class OrderItemDto { private String itemName; private int orderPrice; private int count; public OrderItemDto(OrderItem orderItem) { itemName = orderItem.getItem().getName(); orderPrice = orderItem.getOrderPrice(); count = orderItem.getCount(); }}@Datastatic class Result&amp;lt;T&amp;gt; { private T data; public Result(T data) { this.data = data; }}/** * V2. 엔티티를 조회해서 DTO로 변환(fetch join 사용X) * - 트랜잭션 안에서 지연 로딩 필요 */@GetMapping(&quot;/api/v2/orders&quot;)public Result&amp;lt;List&amp;lt;OrderDto&amp;gt;&amp;gt; ordersV2() { List&amp;lt;Order&amp;gt; orders = orderRepository.findAllByString(new OrderSearch()); List&amp;lt;OrderDto&amp;gt; orderDtos = orders.stream() .map(o -&amp;gt; new OrderDto(o)) .collect(Collectors.toList()); return new Result&amp;lt;&amp;gt;(orderDtos);}생성되는 SQL 로그 2023-10-27 15:58:40.546 DEBUG 89095 --- [nio-8080-exec-1] org.hibernate.SQL : select order0_.order_id as order_id1_6_, order0_.delivery_id as delivery4_6_, order0_.member_id as member_i5_6_, order0_.order_date as order_da2_6_, order0_.status as status3_6_ from orders order0_ inner join member member1_ on order0_.member_id=member1_.member_id limit ?...2023-10-27 15:58:40.559 DEBUG 89095 --- [nio-8080-exec-1] org.hibernate.SQL : select member0_.member_id as member_i1_4_0_, member0_.city as city2_4_0_, member0_.street as street3_4_0_, member0_.zipcode as zipcode4_4_0_, member0_.name as name5_4_0_ from member member0_ where member0_.member_id=?...2023-10-27 15:58:40.568 DEBUG 89095 --- [nio-8080-exec-1] org.hibernate.SQL : select delivery0_.delivery_id as delivery1_2_0_, delivery0_.city as city2_2_0_, delivery0_.street as street3_2_0_, delivery0_.zipcode as zipcode4_2_0_, delivery0_.status as status5_2_0_ from delivery delivery0_ where delivery0_.delivery_id=?...2023-10-27 15:58:40.570 DEBUG 89095 --- [nio-8080-exec-1] org.hibernate.SQL : select orderitems0_.order_id as order_id5_5_0_, orderitems0_.order_item_id as order_it1_5_0_, orderitems0_.order_item_id as order_it1_5_1_, orderitems0_.count as count2_5_1_, orderitems0_.item_id as item_id4_5_1_, orderitems0_.order_id as order_id5_5_1_, orderitems0_.order_price as order_pr3_5_1_ from order_item orderitems0_ where orderitems0_.order_id=?...2023-10-27 15:58:40.574 DEBUG 89095 --- [nio-8080-exec-1] org.hibernate.SQL : select item0_.item_id as item_id2_3_0_, item0_.name as name3_3_0_, item0_.price as price4_3_0_, item0_.stock_quantity as stock_qu5_3_0_, item0_.artist as artist6_3_0_, item0_.etc as etc7_3_0_, item0_.author as author8_3_0_, item0_.isbn as isbn9_3_0_, item0_.actor as actor10_3_0_, item0_.director as directo11_3_0_, item0_.dtype as dtype1_3_0_ from item item0_ where item0_.item_id=?...2023-10-27 15:58:40.576 DEBUG 89095 --- [nio-8080-exec-1] org.hibernate.SQL : select item0_.item_id as item_id2_3_0_, item0_.name as name3_3_0_, item0_.price as price4_3_0_, item0_.stock_quantity as stock_qu5_3_0_, item0_.artist as artist6_3_0_, item0_.etc as etc7_3_0_, item0_.author as author8_3_0_, item0_.isbn as isbn9_3_0_, item0_.actor as actor10_3_0_, item0_.director as directo11_3_0_, item0_.dtype as dtype1_3_0_ from item item0_ where item0_.item_id=?...2023-10-27 15:58:40.577 DEBUG 89095 --- [nio-8080-exec-1] org.hibernate.SQL : select member0_.member_id as member_i1_4_0_, member0_.city as city2_4_0_, member0_.street as street3_4_0_, member0_.zipcode as zipcode4_4_0_, member0_.name as name5_4_0_ from member member0_ where member0_.member_id=?...2023-10-27 15:58:40.579 DEBUG 89095 --- [nio-8080-exec-1] org.hibernate.SQL : select delivery0_.delivery_id as delivery1_2_0_, delivery0_.city as city2_2_0_, delivery0_.street as street3_2_0_, delivery0_.zipcode as zipcode4_2_0_, delivery0_.status as status5_2_0_ from delivery delivery0_ where delivery0_.delivery_id=?...2023-10-27 15:58:40.580 DEBUG 89095 --- [nio-8080-exec-1] org.hibernate.SQL : select orderitems0_.order_id as order_id5_5_0_, orderitems0_.order_item_id as order_it1_5_0_, orderitems0_.order_item_id as order_it1_5_1_, orderitems0_.count as count2_5_1_, orderitems0_.item_id as item_id4_5_1_, orderitems0_.order_id as order_id5_5_1_, orderitems0_.order_price as order_pr3_5_1_ from order_item orderitems0_ where orderitems0_.order_id=?...2023-10-27 15:58:40.582 DEBUG 89095 --- [nio-8080-exec-1] org.hibernate.SQL : select item0_.item_id as item_id2_3_0_, item0_.name as name3_3_0_, item0_.price as price4_3_0_, item0_.stock_quantity as stock_qu5_3_0_, item0_.artist as artist6_3_0_, item0_.etc as etc7_3_0_, item0_.author as author8_3_0_, item0_.isbn as isbn9_3_0_, item0_.actor as actor10_3_0_, item0_.director as directo11_3_0_, item0_.dtype as dtype1_3_0_ from item item0_ where item0_.item_id=?...2023-10-27 15:58:40.583 DEBUG 89095 --- [nio-8080-exec-1] org.hibernate.SQL : select item0_.item_id as item_id2_3_0_, item0_.name as name3_3_0_, item0_.price as price4_3_0_, item0_.stock_quantity as stock_qu5_3_0_, item0_.artist as artist6_3_0_, item0_.etc as etc7_3_0_, item0_.author as author8_3_0_, item0_.isbn as isbn9_3_0_, item0_.actor as actor10_3_0_, item0_.director as directo11_3_0_, item0_.dtype as dtype1_3_0_ from item item0_ where item0_.item_id=?... 지연 로딩으로 인하여 너무 많은 SQL 실행 SQL 실행 수 order 1번 member, address N번(order 조회 수 만큼) orderItem N번(order 조회 수 만큼) item N번(order 조회 수 만큼) 지연로딩은 영속성 컨텍스트에 있으면 영속성 컨텍스트에 있는 엔티티를 사용하고, 없으면 SQL을 실행함.그러므로 같은 영속성 컨텍스트에서 이미 로딩한 회원 엔티티를 추가로 조회하면 SQL을 실행하지 않음.주문조회 V3 - 엔티티를 DTO로 변환하고 페치조인으로 최적화@Repositorypublic class OrderRepository { ... public List&amp;lt;Order&amp;gt; findAllItems() { String jpql = &quot;select distinct o &quot; + &quot;from Order o &quot; + &quot;join fetch o.member m &quot; + &quot;join fetch o.delivery d &quot; + &quot;join fetch o.orderItems oi &quot; + &quot;join fetch oi.item i&quot;; return entityManager.createQuery(jpql, Order.class) .getResultList(); } ...}/** * V3. 엔티티를 조회해서 DTO로 변환(fetch join 사용O) * - 페이징 시에는 N 부분을 포기해야함(대신에 batch fetch size? 옵션 주면 N -&amp;gt; 1 쿼리로 변경 가능)*/@GetMapping(&quot;/api/v3/orders&quot;)public Result&amp;lt;List&amp;lt;OrderDto&amp;gt;&amp;gt; ordersV3() { List&amp;lt;Order&amp;gt; orders = orderRepository.findAllItems(); List&amp;lt;OrderDto&amp;gt; orderDtos = orders.stream() .map(o -&amp;gt; new OrderDto(o)) .collect(Collectors.toList()); return new Result&amp;lt;&amp;gt;(orderDtos);}생성되는 SQL 로그 2023-10-27 16:22:35.892 DEBUG 90627 --- [nio-8080-exec-1] org.hibernate.SQL : select distinct order0_.order_id as order_id1_6_0_, member1_.member_id as member_i1_4_1_, delivery2_.delivery_id as delivery1_2_2_, orderitems3_.order_item_id as order_it1_5_3_, item4_.item_id as item_id2_3_4_, order0_.delivery_id as delivery4_6_0_, order0_.member_id as member_i5_6_0_, order0_.order_date as order_da2_6_0_, order0_.status as status3_6_0_, member1_.city as city2_4_1_, member1_.street as street3_4_1_, member1_.zipcode as zipcode4_4_1_, member1_.name as name5_4_1_, delivery2_.city as city2_2_2_, delivery2_.street as street3_2_2_, delivery2_.zipcode as zipcode4_2_2_, delivery2_.status as status5_2_2_, orderitems3_.count as count2_5_3_, orderitems3_.item_id as item_id4_5_3_, orderitems3_.order_id as order_id5_5_3_, orderitems3_.order_price as order_pr3_5_3_, orderitems3_.order_id as order_id5_5_0__, orderitems3_.order_item_id as order_it1_5_0__, item4_.name as name3_3_4_, item4_.price as price4_3_4_, item4_.stock_quantity as stock_qu5_3_4_, item4_.artist as artist6_3_4_, item4_.etc as etc7_3_4_, item4_.author as author8_3_4_, item4_.isbn as isbn9_3_4_, item4_.actor as actor10_3_4_, item4_.director as directo11_3_4_, item4_.dtype as dtype1_3_4_ from orders order0_ inner join member member1_ on order0_.member_id=member1_.member_id inner join delivery delivery2_ on order0_.delivery_id=delivery2_.delivery_id inner join order_item orderitems3_ on order0_.order_id=orderitems3_.order_id inner join item item4_ on orderitems3_.item_id=item4_.item_id... 페치조인으로 인하여 SQL이 1번만 실행 됨 1대다 조인이 있으므로 데이터베이스의 row가 증가하고, 그 결과로 order 엔티티의 조회 수도 증가하게됨 JPA의 distinct는 SQL에 distinct 구문을 추가하고 더해서 같은 엔티티가 조회되면 어플리케이션에서 중복을 걸러줌 위 예에선 order가 컬렉션 페치조인으로 중복 조회되는 것을 막아줌 페이징이 불가능함 컬렉션 패치조인을 사용하면 페이징이 불가능 함. 하이버네이트는 경고 로그를 남기면서 모든 데이터를 데이터베이스에서 읽어오고 메모리에서 페이징 수행(매후 위험한 작업) 컬렉션 페치조인은 1개만 사용 가능 데이터가 부정합하게 조회될 수 있으므로 컬렉션 둘 이상의 페치조인을 사용하면 안됨 주문조회 V3.1 - 엔티티를 DTO로 변환 및 페이징 한계 돌파 컬렉션은 페치조인하면 페이징이 불가능 컬렉션을 페치조인하면 일대다 조인이 발생하므로 데이터가 예측할 수 없이 증가 함 일대다에서 일(1)을 기준으로 페이징을하는 것이 목적이나 데이터는 다(N)를 기준으로 Row가 생성됨 위 예시를 보면 Order를 기준으로 페이징하려 했지만, 다(N)인 OrderItem을 조인하면 OrderItem이 기준이 되어버림 이 결우 하이버네이트는 경고 로그를 남기고 모든 데이터베이스 데이터를 읽어서 메모리에서 페이징을 시도 함 out of memory 가 발생할 수 있는 매우 위험한 작업 위와같은 페이징 + 컬렉션 엔티티를 함께 조회하기 위해선 아래와 같은 방법이 있음.해당 방법은 성능 최적화도 보장하고 코드도 단순하며 대부분의 페이징 + 컬렉션 엔티티 조회 문제도 해결할 수 있음 먼저 ToOne(@OneToOne, @ManyToOne) 관계를 모두 페치조인 하도록 함 ToOne관계는 row수를 증가시키지 않으므로 페이징 쿼리에 영향을 주지 않음 컬렉션은 지연로딩으로 조회 지연 로딩 성능 최적화를 위해 hibernate.default_batch_fetch_size 옵션 혹은 @BatchSize 어노테이션을 적용 hibernate.default_batch_fetch_size : 글로벌 설정 @BatchSize : 개별 최적화 해당 옵션을 사용하면 컬렉션이나 프록시 객체를 한번에 설정한 size만큼 IN 쿼리로 조회 함 # src/main/resources/application.ymlspring: jpa: properties: default_batch_fetch_size: 1000@Repositorypublic class OrderRepository { ... public List&amp;lt;Order&amp;gt; findAllItemsWithPaging(int offset, int limit) { String jpql = &quot;select o &quot; + &quot;from Order o &quot; + &quot;join fetch o.member m &quot; + &quot;join fetch o.delivery d&quot;; return entityManager.createQuery(jpql, Order.class) .setFirstResult(offset) .setMaxResults(limit) .getResultList(); } ...}/** * V3.1 엔티티를 조회해서 DTO로 변환 페이징 고려 * - ToOne 관계만 우선 모두 페치 조인으로 최적화 * - 컬렉션 관계는 hibernate.default_batch_fetch_size, @BatchSize로 최적화 */@GetMapping(&quot;/api/v3.1/orders&quot;)public Result&amp;lt;List&amp;lt;OrderDto&amp;gt;&amp;gt; ordersV3_1( @RequestParam(value = &quot;offset&quot;, defaultValue = &quot;0&quot;) int offset, @RequestParam(value = &quot;offset&quot;, defaultValue = &quot;100&quot;) int limit) { List&amp;lt;Order&amp;gt; orders = orderRepository.findAllItemsWithPaging(offset, limit); List&amp;lt;OrderDto&amp;gt; orderDtos = orders.stream() .map(o -&amp;gt; new OrderDto(o)) .collect(Collectors.toList()); return new Result&amp;lt;&amp;gt;(orderDtos);}생성되는 SQL 로그 2023-10-27 17:45:50.213 DEBUG 92869 --- [nio-8080-exec-1] org.hibernate.SQL : select order0_.order_id as order_id1_6_0_, member1_.member_id as member_i1_4_1_, delivery2_.delivery_id as delivery1_2_2_, order0_.delivery_id as delivery4_6_0_, order0_.member_id as member_i5_6_0_, order0_.order_date as order_da2_6_0_, order0_.status as status3_6_0_, member1_.city as city2_4_1_, member1_.street as street3_4_1_, member1_.zipcode as zipcode4_4_1_, member1_.name as name5_4_1_, delivery2_.city as city2_2_2_, delivery2_.street as street3_2_2_, delivery2_.zipcode as zipcode4_2_2_, delivery2_.status as status5_2_2_ from orders order0_ inner join member member1_ on order0_.member_id=member1_.member_id inner join delivery delivery2_ on order0_.delivery_id=delivery2_.delivery_id limit ?...2023-10-27 17:45:50.229 DEBUG 92869 --- [nio-8080-exec-1] org.hibernate.SQL : select orderitems0_.order_id as order_id5_5_1_, orderitems0_.order_item_id as order_it1_5_1_, orderitems0_.order_item_id as order_it1_5_0_, orderitems0_.count as count2_5_0_, orderitems0_.item_id as item_id4_5_0_, orderitems0_.order_id as order_id5_5_0_, orderitems0_.order_price as order_pr3_5_0_ from order_item orderitems0_ where orderitems0_.order_id in ( ?, ? )2023-10-27 17:45:50.231 INFO 92869 --- [nio-8080-exec-1] p6spy : #1698396350231 | took 0ms | statement | connection 6| url jdbc:h2:mem:6a16d813-a863-46b8-9894-4e710e815fdfselect orderitems0_.order_id as order_id5_5_1_, orderitems0_.order_item_id as order_it1_5_1_, orderitems0_.order_item_id as order_it1_5_0_, orderitems0_.count as count2_5_0_, orderitems0_.item_id as item_id4_5_0_, orderitems0_.order_id as order_id5_5_0_, orderitems0_.order_price as order_pr3_5_0_ from order_item orderitems0_ where orderitems0_.order_id in (?, ?)select orderitems0_.order_id as order_id5_5_1_, orderitems0_.order_item_id as order_it1_5_1_, orderitems0_.order_item_id as order_it1_5_0_, orderitems0_.count as count2_5_0_, orderitems0_.item_id as item_id4_5_0_, orderitems0_.order_id as order_id5_5_0_, orderitems0_.order_price as order_pr3_5_0_ from order_item orderitems0_ where orderitems0_.order_id in (4, 11);...2023-10-27 17:45:50.240 DEBUG 92869 --- [nio-8080-exec-1] org.hibernate.SQL : select item0_.item_id as item_id2_3_0_, item0_.name as name3_3_0_, item0_.price as price4_3_0_, item0_.stock_quantity as stock_qu5_3_0_, item0_.artist as artist6_3_0_, item0_.etc as etc7_3_0_, item0_.author as author8_3_0_, item0_.isbn as isbn9_3_0_, item0_.actor as actor10_3_0_, item0_.director as directo11_3_0_, item0_.dtype as dtype1_3_0_ from item item0_ where item0_.item_id in ( ?, ?, ?, ? )2023-10-27 17:45:50.242 INFO 92869 --- [nio-8080-exec-1] p6spy : #1698396350242 | took 0ms | statement | connection 6| url jdbc:h2:mem:6a16d813-a863-46b8-9894-4e710e815fdfselect item0_.item_id as item_id2_3_0_, item0_.name as name3_3_0_, item0_.price as price4_3_0_, item0_.stock_quantity as stock_qu5_3_0_, item0_.artist as artist6_3_0_, item0_.etc as etc7_3_0_, item0_.author as author8_3_0_, item0_.isbn as isbn9_3_0_, item0_.actor as actor10_3_0_, item0_.director as directo11_3_0_, item0_.dtype as dtype1_3_0_ from item item0_ where item0_.item_id in (?, ?, ?, ?)select item0_.item_id as item_id2_3_0_, item0_.name as name3_3_0_, item0_.price as price4_3_0_, item0_.stock_quantity as stock_qu5_3_0_, item0_.artist as artist6_3_0_, item0_.etc as etc7_3_0_, item0_.author as author8_3_0_, item0_.isbn as isbn9_3_0_, item0_.actor as actor10_3_0_, item0_.director as directo11_3_0_, item0_.dtype as dtype1_3_0_ from item item0_ where item0_.item_id in (2, 3, 9, 10);... 장점 쿼리 호출 수가 (N + 1) -&amp;gt; (1 + 1) 로 최적화 됨 조인보다 데이터베이스 전송량이 최적화 됨 위 코드의 예에서 Order와 OrderItem을 조인하면 Order가 OrderItem 만큼 중복해서 조회되지만,이 방법은 각각 조회하므로 전송해야할 중복 데이터가 없음 패치조인 방식과 비교하여 쿼리 호풀 수가 약간 증가하지만 데이터베이스의 데이터 전송량이 감소 컬렉션 패치조인은 페이징이 불가능하지만 이 방법으로는 페이징이 가능 결론은 ToOne 관계는 페치조인해도 페이징에 영향을 주지 않기 때문에,ToOne 관계는 페치조인으로 쿼리 수를 줄여서 해결하고 나머지 지연로딩을 하는 엔티티들은 hibernate.default_batch_fetch_size로 최적화를 해야 함.default_batch_fetch_size의 크기default_batch_fetch_size의 크기는 적당한 사이즈를 골라야 하는데 보통 100 ~ 1000 사이를 선택해서 사용.이 전략은 SQL IN 절을 사용하는데 데이터베이스에 따라 IN 절 파라미터를 1000으로 제한하기도 함.1000으로 잡으면 한번에 1000개를 데이터베이스에서 어플리케이션으로 불러오므로 데이터베이스에 순산 부하가 증가 할 수 있음.반면에 어플리케이션은 100이든 1000이든 결국 데이터 전체를 로딩해야 하므로 메모리 사용량은 같음.1000으로 설정하는 것이 성능상 가장 좋지만 결국 데이터베이스든 어플리케이션이든 순간 부하를 어디까지 견딜수 있는지도 결정하면 됨. 참고스프링 부트 3.1 및 하이버네이트 6.2 에서는 default_batch_fetch_size 옵션으로 인하여생성되는 SQL에 where … in 문법을 사용하지 않고 where … array_contains 을 사용함주문조회 V4 - JPA메서 DTO 직접 조회@Datapublic class OrderItemQueryDto { @JsonIgnore private Long orderId; private String itemName; private int orderPrice; private int count; public OrderItemQueryDto(Long orderId, String itemName, int orderPrice, int count) { this.orderId = orderId; this.itemName = itemName; this.orderPrice = orderPrice; this.count = count; }}@Data@EqualsAndHashCode(of = &quot;orderId&quot;)public class OrderQueryDto { private Long orderId; private String name; private LocalDateTime orderDate; private OrderStatus orderStatus; private Address address; private List&amp;lt;OrderItemQueryDto&amp;gt; orderItems; public OrderQueryDto(Long orderId, String name, LocalDateTime orderDate, OrderStatus orderStatus, Address address) { this.orderId = orderId; this.name = name; this.orderDate = orderDate; this.orderStatus = orderStatus; this.address = address; }}@Repository@RequiredArgsConstructorpublic class OrderQueryRepository { private final EntityManager entityManager; /** * 컬렉션은 별도로 조회 * Query: 루트 1번, 컬렉션 N 번 * 단건 조회에서 많이 사용하는 방식 */ public List&amp;lt;OrderQueryDto&amp;gt; findOrderQueryDtos() { // 루트 조회(toOne 코드를 모두 한번에 조회) List&amp;lt;OrderQueryDto&amp;gt; orders = findOrders(); // 루프를 돌면서 컬렉션 추가(추가 쿼리 실행) orders.forEach(order -&amp;gt; { List&amp;lt;OrderItemQueryDto&amp;gt; orderItems = findOrderItems(order.getOrderId()); order.setOrderItems(orderItems); }); return orders; } /** * 1:N 관계(컬렉션)를 제외한 나머지를 한번에 조회 */ private List&amp;lt;OrderQueryDto&amp;gt; findOrders() { String jpql = &quot;select new jpabook.jpashop.repository.order.query.OrderQueryDto(o.id, m.name, o.orderDate, o.status, d.address) &quot; + &quot;from Order o &quot; + &quot;join o.member m &quot; + &quot;join o.delivery d&quot;; return entityManager.createQuery(jpql, OrderQueryDto.class).getResultList(); } /** * 1:N 관계인 orderItems 조회 */ private List&amp;lt;OrderItemQueryDto&amp;gt; findOrderItems(Long orderId) { String jpql = &quot;select new jpabook.jpashop.repository.order.query.OrderItemQueryDto(oi.order.id, i.name, oi.orderPrice, oi.count) &quot; + &quot;from OrderItem oi &quot; + &quot;join oi.item i &quot; + &quot;where oi.order.id = :orderId&quot;; return entityManager.createQuery(jpql, OrderItemQueryDto.class) .setParameter(&quot;orderId&quot;, orderId) .getResultList(); }}/** * V4. JPA에서 DTO로 바로 조회, 컬렉션 N 조회 (1 + N Query) * - 페이징 가능 */@GetMapping(&quot;/api/v4/orders&quot;)public Result&amp;lt;List&amp;lt;OrderQueryDto&amp;gt;&amp;gt; ordersV4() { List&amp;lt;OrderQueryDto&amp;gt; orders = orderQueryRepository.findOrderQueryDtos(); return new Result&amp;lt;&amp;gt;(orders);}생성되는 SQL 로그 2023-10-27 18:20:38.752 DEBUG 95140 --- [nio-8080-exec-1] org.hibernate.SQL : select order0_.order_id as col_0_0_, member1_.name as col_1_0_, order0_.order_date as col_2_0_, order0_.status as col_3_0_, delivery2_.city as col_4_0_, delivery2_.street as col_4_1_, delivery2_.zipcode as col_4_2_ from orders order0_ inner join member member1_ on order0_.member_id=member1_.member_id inner join delivery delivery2_ on order0_.delivery_id=delivery2_.delivery_id...2023-10-27 18:20:38.767 DEBUG 95140 --- [nio-8080-exec-1] org.hibernate.SQL : select orderitem0_.order_id as col_0_0_, item1_.name as col_1_0_, orderitem0_.order_price as col_2_0_, orderitem0_.count as col_3_0_ from order_item orderitem0_ inner join item item1_ on orderitem0_.item_id=item1_.item_id where orderitem0_.order_id=?...2023-10-27 18:20:38.770 DEBUG 95140 --- [nio-8080-exec-1] org.hibernate.SQL : select orderitem0_.order_id as col_0_0_, item1_.name as col_1_0_, orderitem0_.order_price as col_2_0_, orderitem0_.count as col_3_0_ from order_item orderitem0_ inner join item item1_ on orderitem0_.item_id=item1_.item_id where orderitem0_.order_id=?... Query : 루트 1번, 컬렉션 N번 실행 ToOne(N:1, 1:1) 관계들을 먼저 조회하고, ToMany(1:N) 관계는 각각 별도로 처리 ToOne 관계는 조인해도 데이터 row 수가 증가하지 않음 ToMany(1:N) 관계는 조인하면 row 수가 증가 row 수가 증가하지 안는 ToOne 관계는 조인으로 최적화 하기 쉬우므로 한번에 조회하고,ToMany 관계는 최적화하기 어려우므로 findOrderItems() 같은 별도의 메소드로 조회주문조회 V5 - JPA메서 DTO 직접 조회후 컬렉션 조회 최적화@Repository@RequiredArgsConstructorpublic class OrderQueryRepository { private final EntityManager entityManager; ... /** * 1:N 관계(컬렉션)를 제외한 나머지를 한번에 조회 */ private List&amp;lt;OrderQueryDto&amp;gt; findOrders() { String jpql = &quot;select new jpabook.jpashop.repository.order.query.OrderQueryDto(o.id, m.name, o.orderDate, o.status, d.address) &quot; + &quot;from Order o &quot; + &quot;join o.member m &quot; + &quot;join o.delivery d&quot;; return entityManager.createQuery(jpql, OrderQueryDto.class).getResultList(); } /** * 최적화 * Query: 루트 1번, 컬렉션 1번 * 데이터를 한꺼번에 처리할 때 많이 사용하는 방식 * */ public List&amp;lt;OrderQueryDto&amp;gt; findAllByDto_optimization() { // 루트 조회(toOne 코드를 모두 한번에 조회) List&amp;lt;OrderQueryDto&amp;gt; result = findOrders(); // orderItem 컬렉션을 map 한번에 조회 Map&amp;lt;Long, List&amp;lt;OrderItemQueryDto&amp;gt;&amp;gt; orderItemMap = findOrdeItemMap(toOrderIds(result)); // 루프를 돌면서 컬렉션 추가(추가 쿼리 실행 x) result.forEach( o -&amp;gt; o.setOrderItems(orderItemMap.get(o.getOrderId()))); return result; } private List&amp;lt;Long&amp;gt; toOrderIds(List&amp;lt;OrderQueryDto&amp;gt; result) { return result.stream() .map(o -&amp;gt; o.getOrderId()) .collect(Collectors.toList()); } private Map&amp;lt;Long, List&amp;lt;OrderItemQueryDto&amp;gt;&amp;gt; findOrdeItemMap(List&amp;lt;Long&amp;gt; orderIds) { String jpql = &quot;select new jpabook.jpashop.repository.order.query.OrderItemQueryDto(oi.order.id, i.name, oi.orderPrice, oi.count) &quot; + &quot;from OrderItem oi &quot; + &quot;join oi.item i &quot; + &quot;where oi.order.id in :orderIds&quot;; List&amp;lt;OrderItemQueryDto&amp;gt; orderItems = entityManager.createQuery(jpql, OrderItemQueryDto.class) .setParameter(&quot;orderIds&quot;, orderIds) .getResultList(); return orderItems.stream() .collect(Collectors.groupingBy(OrderItemQueryDto::getOrderId)); }}/** * V5. JPA에서 DTO로 바로 조회, 컬렉션 1 조회 최적화 버전 (1 + 1 Query) * - 페이징 가능 */@GetMapping(&quot;/api/v5/orders&quot;)public Result&amp;lt;List&amp;lt;OrderQueryDto&amp;gt;&amp;gt; ordersV5() { List&amp;lt;OrderQueryDto&amp;gt; orders = orderQueryRepository.findAllByDto_optimization(); return new Result&amp;lt;&amp;gt;(orders);}생성되는 SQL 로그 2023-10-30 10:25:48.096 DEBUG 16091 --- [nio-8080-exec-1] org.hibernate.SQL : select order0_.order_id as col_0_0_, member1_.name as col_1_0_, order0_.order_date as col_2_0_, order0_.status as col_3_0_, delivery2_.city as col_4_0_, delivery2_.street as col_4_1_, delivery2_.zipcode as col_4_2_ from orders order0_ inner join member member1_ on order0_.member_id=member1_.member_id inner join delivery delivery2_ on order0_.delivery_id=delivery2_.delivery_id...2023-10-30 10:25:48.116 DEBUG 16091 --- [nio-8080-exec-1] org.hibernate.SQL : select orderitem0_.order_id as col_0_0_, item1_.name as col_1_0_, orderitem0_.order_price as col_2_0_, orderitem0_.count as col_3_0_ from order_item orderitem0_ inner join item item1_ on orderitem0_.item_id=item1_.item_id where orderitem0_.order_id in ( ? , ? )... Query : 루트 1번, 컬렉션 1번 ToOne 관계들을 먼저 조회하고 여기서 얻은 실별자 orderId로 ToMany 관계인 OrderItem을 한번에 조회 Map을 이용하여 매칭 성능 향상(O(1))주문조회 V6 - JPA메서 DTO 직접 조회후 플렛 데이터로 최적화@Datapublic class OrderFlatDto { private Long orderId; private String name; private LocalDateTime orderDate; private Address address; private OrderStatus orderStatus; private String itemName; private int orderPrice; private int count; public OrderFlatDto(Long orderId, String name, LocalDateTime orderDate, OrderStatus orderStatus, Address address, String itemName, int orderPrice, int count) { this.orderId = orderId; this.name = name; this.orderDate = orderDate; this.address = address; this.orderStatus = orderStatus; this.itemName = itemName; this.orderPrice = orderPrice; this.count = count; }}@Repository@RequiredArgsConstructorpublic class OrderQueryRepository { private final EntityManager entityManager; ... public List&amp;lt;OrderFlatDto&amp;gt; findAllByDto_flat() { String jpql = &quot;select new jpabook.jpashop.repository.order.query.OrderFlatDto( o.id, m.name, o.orderDate, o.status, d.address, i.name, oi.orderPrice, oi.count ) &quot; + &quot;from Order o &quot; + &quot;join o.member m &quot; + &quot;join o.delivery d &quot; + &quot;join o.orderItems oi &quot; + &quot;join oi.item i&quot;; return entityManager.createQuery(jpql, OrderFlatDto.class).getResultList(); }} /** * V6. JPA에서 DTO로 바로 조회, 플랫 데이터(1Query) (1 Query) * - 페이징 불가능... */ @GetMapping(&quot;/api/v6/orders&quot;) public Result&amp;lt;List&amp;lt;OrderQueryDto&amp;gt;&amp;gt; ordersV6() { List&amp;lt;OrderFlatDto&amp;gt; orders = orderQueryRepository.findAllByDto_flat(); return new Result&amp;lt;&amp;gt;(orders.stream() .collect(Collectors.groupingBy(o -&amp;gt; new OrderQueryDto(o.getOrderId(), o.getName(), o.getOrderDate(), o.getOrderStatus(), o.getAddress()), Collectors.mapping(o -&amp;gt; new OrderItemQueryDto(o.getOrderId(), o.getItemName(), o.getOrderPrice(), o.getCount()), Collectors.toList()) )).entrySet().stream() .map(e -&amp;gt; new OrderQueryDto(e.getKey().getOrderId(), e.getKey().getName(), e.getKey().getOrderDate(), e.getKey().getOrderStatus(), e.getKey().getAddress(), e.getValue())) .collect(Collectors.toList())); }생성되는 SQL 로그 2023-10-30 10:55:06.426 DEBUG 18016 --- [nio-8080-exec-1] org.hibernate.SQL : select order0_.order_id as col_0_0_, member1_.name as col_1_0_, order0_.order_date as col_2_0_, order0_.status as col_3_0_, delivery2_.city as col_4_0_, delivery2_.street as col_4_1_, delivery2_.zipcode as col_4_2_, item4_.name as col_5_0_, orderitems3_.order_price as col_6_0_, orderitems3_.count as col_7_0_ from orders order0_ inner join member member1_ on order0_.member_id=member1_.member_id inner join delivery delivery2_ on order0_.delivery_id=delivery2_.delivery_id inner join order_item orderitems3_ on order0_.order_id=orderitems3_.order_id inner join item item4_ on orderitems3_.item_id=item4_.item_id... Query : 1번 단점 쿼리는 한번이지만 조인으로 인하여 데이터베이스에서 어플리케이션에 전달하는 데이터에 중복데이터가 추가되어 상황에 따라 V5보다 느릴수 있음 어플리케이션에 데이터 처리에 대한 추가 작업이 많음 페이징 불가능 정리 엔티티 조회 엔티티를 조회해서 그대로 반환(V1) 엔티티 조회후 DTO로 변환(V2) 페치조인으로 쿼리 수 최적화(V3) 컬렉션 페이징과 한계 돌파(V3.1) 컬렉션은 페치조인시 페이징 불가능 ToOne 관계는 페치조인으로 쿼리수 최적화 컬렉션은 페치조인 대신에 지연 로딩을 유지하고, hibernate.default_batch_fetch_size나 @BatchSize로 최적화 DTO 직접 조회 JPA에서 DTO를 직접 조회(V4) 컬렉션조회 최적화(V5) 일대다 관계인 컬렉션은 IN 절을 활용하여 메모리에 미리 조회해서 최적화 시도 플렛 데이터 최적화(V6) JOIN 결과를 그대로 조죄 후 어플리케이션에서 워하는 모양으로 직접 변환 권장 순서 엔티티 조회 방식으로 우선접근 페치조인으로 쿼리수를 최적화 컬렉션 최적화 페이징이 필요하다면 hibernate.default_batch_fetch_size나 @BatchSize로 최적화 페이징이 불필요 하다면 단순히 패치조인 사용 엔티티 조회 방식은 페치조인이나 hibernate.default_batch_fetch_size나 @BatchSize 같이 코드를 거의 수정하지 않고,옵션만 약간 변경하여 다양한 성능 최적화 시도 가능 엔티티 조회 방식으로 해결이 안되면 DTO 조회 방식 사용 성능을 최적화 하거나 성능 최적화 방식을 변경할 떄 많은 코드 수정 필요 DTO 조회 방식으로도 해결이 안되면 NativeSQL이나 스프링 JdbcTemplate 사용하거나,캐시를 이용해서 성능 최적화 시도 캐시를 이용할 시, 영속성 컨텍스트에서 관리되고 있는 엔티티를 또 다른 캐시에 저장하면 안됨 또 다른 내부 캐시저장소에 저장하게 되면 관리 포인트가 2곳이 되므로 객체의 관리가 원활히 되지 않음 DTO를 만들어 DTO를 캐시에 저장해야 함 DTO 조회 방식의 선택지DTO로 조회하는 방법도 각각 장단이 있음 V4 방식은 코드가 단순함 특정 주문 한건만 조회 핟다면 해당 방식도 성능이 잘 나옴 예를 들어 조회한 Order 데이터가 1건이면 OrderItem을 찾기 위한 쿼리도 1번만 실행됨 V5 방식은 코드가 복잡하지만 실행되는 쿼리가 적음 여러 주문을 한번에 조회하는 경우 V4의 방식대신 V5 방식을 사용해야함 예를 들어 조회한 Order 데이터가 1000건일때 V4 방식을 그대로 사용하면,쿼리가 총 1 + 1000번 실행됨(1은 Order를 조회한 쿼리이고 1000은 조회된 Order의 row 수)그러나 V5 방식으로 최적화 하면 쿼리가 총 1 + 1번만 실행 됨 V6 방식은 완전히 다른 접근방식이며 쿼리가 한번만 실행 됨 쿼리가 한번만 실행되어 좋은 방식인 것 같으나, Order를 기준으로 페이징이 불가능 함 실무에서는 수백이나, 수천건 단위로 페이징 처리가 필요할 떄가 많으므로 선택하기엔 어려운 방식 데이터가 많으면 중복 전송으로 인하여 V5 방식과 비교했을떄 성능차이도 미비 함 참고 실전! 스프링 부트와 JPA 활용2 - 웹 애플리케이션 개발(김영한)" }, { "title": "JPA - 지연로딩과 성능 최적화", "url": "/posts/spring-jpa-12/", "categories": "Backend, JPA", "tags": "Web, Spring Framework, DataBase, JPA", "date": "2023-10-27 10:00:00 +0900", "snippet": "OneToOne, ManyToOne 관계에서의 지연로딩과 성능 최적화 예시를 위해 간단한 주문조회 API 컨트롤러와 엔티티를 구현하고 단계별로 어떻게 최적화 하는지 확인엔티티 예시@Entitypublic class Member { @Id @GeneratedValue @Column(name = &quot;member_id&quot;) private Long id; private String name; @Embedded private Address address; @OneToMany(mappedBy = &quot;member&quot;) private List&amp;lt;Order&amp;gt; orders = new ArrayList&amp;lt;&amp;gt;();}@Entitypublic class Order { @Id @GeneratedValue @Column(name = &quot;order_id&quot;) private Long id; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = &quot;member_id&quot;) private Member member; @OneToMany(mappedBy = &quot;order&quot;, cascade = CascadeType.ALL) private List&amp;lt;OrderItem&amp;gt; orderItems = new ArrayList&amp;lt;&amp;gt;(); @OneToOne(cascade = CascadeType.ALL, fetch = FetchType.LAZY) @JoinColumn(name = &quot;delivery_id&quot;) private Delivery delivery; ...}주문조회 V1 - 엔티티를 직접 노출@GetMapping(&quot;/api/v1/simple-orders&quot;)public List&amp;lt;Order&amp;gt; ordersV1() { List&amp;lt;Order&amp;gt; all = orderRepository.findAllByString(new OrderSearch()); return all;} 엔티티를 직접 노출 위 코드를 실행하면 예외가 발생함 order -&amp;gt; member 와 order -&amp;gt; address 의 관계가 지연로딩일떄, member와 address는 실제 엔티티 대신 프록시가 존재하게 됨 jackson 라이브러리는 이러한 프록시 객체를 json으로 어떻게 생성해야 하는지 모르므로 예외를 발생 시킴 예외를 해결하기 위해 Hibernate5Module 을 스프링 빈으로 등록하면 해결 위 코드에 대해 Hibernate5Module 을 설치하여 예외를 해결하더라도 api 동작시 응답을 확인해보면, order의 member 필드의 값이 JSON에서 null로 응답하게 됨.이는 지연 로딩으로 인하여 member 가 실제 엔티티가 아닌 프록시이기 때문인데, 이에 대한 해결방법은 아래와 같이 강제로 초기화하여 엔티티를 로딩 시켜주면 해결이 됨.@GetMapping(&quot;/api/v1/simple-orders&quot;)public List&amp;lt;Order&amp;gt; ordersV1() { List&amp;lt;Order&amp;gt; all = orderRepository.findAllByString(new OrderSearch()); for (Order order : all) { // Lazy 강제 초기화 order.getMember().getName(); // Lazy 강제 초기환 order.getDelivery().getAddress(); } return all;}위 V1 코드의 문제점 및 주의점들은 아래와 같음 엔티티를 직접 노출할 때는 양방향 연관관계가 걸린 곳은 한곳을 @JsonIgnore 처리 해야 함 @JsonIgnore를 사용하지 않는다면 양쪽을 서로 호출하면서 무한 루프가 걸리게 됨 정말 간단한 애플리케이션이 아니면 엔티티를 API 응답으로 외부로 노출하는 것은 피하는 것이 좋음 Hibernate5Module 를 사용하기 보다는 DTO로 변환해서 반환하는 것이 더 좋은 방법 지연 로딩(LAZY)을 피하기 위해 즉시 로딩(EARGR)으로 설정하면 안됨 즉시 로딩 때문에 연관관계가 필요 없는 경우에도 데이터를 항상 조회해서 성능 문제가 발생할 수 있음 즉시 로딩으로 설정하면 성능 튜닝이 매우 어려워 짐 항상 지연 로딩을 기본으로 하고, 성능 최적화가 필요한 경우에는 페치 조인(fetch join)을 사용하는 것을 추천주문조회 V2 - 엔티티를 DTO로 변환API의 응답을 엔티티로 바로 전달하는게 아닌 별도의 DTO를 만들어서 해당 DTO를 응답으로 반환하는 방식/** * V2. 엔티티를 조회해서 DTO로 변환(fetch join 사용X) * - 단점: 지연로딩으로 쿼리 N번 호출 */@GetMapping(&quot;/api/v2/simple-orders&quot;)public Result&amp;lt;List&amp;lt;SimpleOrderDto&amp;gt;&amp;gt; ordersV2() { log.info(&quot;OrderSimpleApiController.ordersV2&quot;); List&amp;lt;Order&amp;gt; orders = repository.findAllByString(new OrderSearch()); List&amp;lt;SimpleOrderDto&amp;gt; simpleOrderDtoes = orders.stream() .map(order -&amp;gt; new SimpleOrderDto(order)) .collect(Collectors.toList()); Result&amp;lt;List&amp;lt;SimpleOrderDto&amp;gt;&amp;gt; result = new Result&amp;lt;&amp;gt;(simpleOrderDtoes); return result;}@Datastatic class SimpleOrderDto { private Long orderId; private String name; private LocalDateTime orderDate; private OrderStatus orderStatus; private Address address; public SimpleOrderDto(Order order) { this.orderId = order.getId(); // Lazy loading 초기화 // 영속성 컨텍스트에 조재하지 않는다면 조회 쿼리 발생 this.name = order.getMember().getName(); this.orderDate = order.getOrderDate(); this.orderStatus = order.getStatus(); // Lazy loading 초기화 // 영속성 컨텍스트에 조재하지 않는다면 조회 쿼리 발생 this.address = order.getDelivery().getAddress(); }}@Datastatic class Result&amp;lt;T&amp;gt; { private T data; public Result(T data) { this.data = data; }}{ &quot;data&quot;: [ { &quot;orderId&quot;: 4, &quot;name&quot;: &quot;userA&quot;, &quot;orderDate&quot;: &quot;2023-10-27T12:02:55.087198&quot;, &quot;orderStatus&quot;: &quot;ORDER&quot;, &quot;address&quot;: { &quot;city&quot;: &quot;seoul&quot;, &quot;street&quot;: &quot;1&quot;, &quot;zipcode&quot;: &quot;1111&quot; } }, { &quot;orderId&quot;: 11, &quot;name&quot;: &quot;userB&quot;, &quot;orderDate&quot;: &quot;2023-10-27T12:02:55.11428&quot;, &quot;orderStatus&quot;: &quot;ORDER&quot;, &quot;address&quot;: { &quot;city&quot;: &quot;busan&quot;, &quot;street&quot;: &quot;2&quot;, &quot;zipcode&quot;: &quot;2222&quot; } } ]}API의 응답으로 DTO로 반환하도록 하여 V1 보다는 개선됬지만, 이 코드에선 한가지 문제가 더 존재함.해당 API 실행하고 로그를 확인해보면,order 한번을 조회하여 쿼리가 한개만 나가야 할것 처럼 보이지만 총 5번의 쿼리가 실행됨.2023-10-27 12:03:00.106 DEBUG 78441 --- [nio-8080-exec-1] org.hibernate.SQL : select order0_.order_id as order_id1_6_, order0_.delivery_id as delivery4_6_, order0_.member_id as member_i5_6_, order0_.order_date as order_da2_6_, order0_.status as status3_6_ from orders order0_ inner join member member1_ on order0_.member_id=member1_.member_id limit ?...2023-10-27 12:03:00.121 DEBUG 78441 --- [nio-8080-exec-1] org.hibernate.SQL : select member0_.member_id as member_i1_4_0_, member0_.city as city2_4_0_, member0_.street as street3_4_0_, member0_.zipcode as zipcode4_4_0_, member0_.name as name5_4_0_ from member member0_ where member0_.member_id=?...2023-10-27 12:03:00.124 DEBUG 78441 --- [nio-8080-exec-1] org.hibernate.SQL : select delivery0_.delivery_id as delivery1_2_0_, delivery0_.city as city2_2_0_, delivery0_.street as street3_2_0_, delivery0_.zipcode as zipcode4_2_0_, delivery0_.status as status5_2_0_ from delivery delivery0_ where delivery0_.delivery_id=?...2023-10-27 12:03:00.125 DEBUG 78441 --- [nio-8080-exec-1] org.hibernate.SQL : select member0_.member_id as member_i1_4_0_, member0_.city as city2_4_0_, member0_.street as street3_4_0_, member0_.zipcode as zipcode4_4_0_, member0_.name as name5_4_0_ from member member0_ where member0_.member_id=?...2023-10-27 12:03:00.126 DEBUG 78441 --- [nio-8080-exec-1] org.hibernate.SQL : select delivery0_.delivery_id as delivery1_2_0_, delivery0_.city as city2_2_0_, delivery0_.street as street3_2_0_, delivery0_.zipcode as zipcode4_2_0_, delivery0_.status as status5_2_0_ from delivery delivery0_ where delivery0_.delivery_id=?...이 로그에 대한 분석은 아래와 같으며 이러한 문제를 N + 1 문제 라고 함 쿼리가 총 1 + N + N번 실행됨 (v1과 쿼리수 결과는 같음) order 조회 1번order 조회 결과 수가 N이 됨 order -&amp;gt; member 지연로딩 조회 N 번 order -&amp;gt; delivery 지연로징 조회 N 번 예) order의 결과가 4개면 최악의 경우 1 + 4 + 4 번 실행 됨 지연로딩은 영속성 컨텍스트에서 조회하므로 이미 조회된 경우 쿼리를 생략 함 이러한 N + 1 문제를 해결하기 위해선 최초 order를 조회할떄 연관된 엔티티들도 한번에 조회를 해야하는데,이때 즉시로딩(EAGER)를 사용하면 안되고 fetch join 을 통하여 문제를 해결해야함. 즉시로딩(EAGER)를 사용시 최초 조회시 연관된 엔티티를 모두 조회하긴 하지만 어떠한 쿼리가 발생할지 직관적으로 알기에 어려워 사용을 피하는 것이 좋음주문조회 V3 - 엔티티를 DTO로 변환 및 페치 조인 최적화@Repository@RequiredArgsConstructorpublic class OrderRepository { private final EntityManager entityManager; ... public List&amp;lt;Order&amp;gt; findAllWithMemberDelivery() { String jpql = &quot;select o &quot; + &quot;from Order o &quot; + &quot;join fetch o.member m &quot; + &quot;join fetch o.delivery d&quot;; return entityManager.createQuery(jpql, Order.class).getResultList(); }}/** * V3. 엔티티를 조회해서 DTO로 변환(fetch join 사용O) * - fetch join으로 쿼리 1번 호출 * 참고: fetch join에 대한 자세한 내용은 JPA 기본편 참고(정말 중요함) */@GetMapping(&quot;/api/v3/simple-orders&quot;)public Result&amp;lt;List&amp;lt;SimpleOrderDto&amp;gt;&amp;gt; ordersV3() { List&amp;lt;Order&amp;gt; orders = repository.findAllWithMemberDelivery(); List&amp;lt;SimpleOrderDto&amp;gt; dto = orders.stream() .map(order -&amp;gt; new SimpleOrderDto(order)) .collect(Collectors.toList()); return new Result&amp;lt;&amp;gt;(dto);}2023-10-27 14:16:03.386 DEBUG 81195 --- [nio-8080-exec-1] org.hibernate.SQL : select order0_.order_id as order_id1_6_0_, member1_.member_id as member_i1_4_1_, delivery2_.delivery_id as delivery1_2_2_, order0_.delivery_id as delivery4_6_0_, order0_.member_id as member_i5_6_0_, order0_.order_date as order_da2_6_0_, order0_.status as status3_6_0_, member1_.city as city2_4_1_, member1_.street as street3_4_1_, member1_.zipcode as zipcode4_4_1_, member1_.name as name5_4_1_, delivery2_.city as city2_2_2_, delivery2_.street as street3_2_2_, delivery2_.zipcode as zipcode4_2_2_, delivery2_.status as status5_2_2_ from orders order0_ inner join member member1_ on order0_.member_id=member1_.member_id inner join delivery delivery2_ on order0_.delivery_id=delivery2_.delivery_id...엔티티를 페치 조인(fetch join)을 사용하여 쿼리 1번에 조회 페치 조인으로 order -&amp;gt; member, order -&amp;gt; delivery는 order 조회시 fetch join으로같이 조회되어 연속성 컨텍스트에 관리되고 있는 상태이므로 지연로딩X주문조회 V4 - JPA 에서 DTO로 바로 조회@Datapublic class OrderSimpleQueryDto { private Long orderId; private String name; private LocalDateTime orderTime; private OrderStatus orderStatus; private Address address; public OrderSimpleQueryDto(Long orderId, String name, LocalDateTime orderTime, OrderStatus orderStatus, Address address) { this.orderId = orderId; this.name = name; this.orderTime = orderTime; this.orderStatus = orderStatus; this.address = address; }}@Repository@RequiredArgsConstructorpublic class OrderSimpleQueryRepository { private final EntityManager entityManager; public List&amp;lt;OrderSimpleQueryDto&amp;gt; findOrdersDtos() { String jpql = &quot;select new jpabook.jpashop.repository.order.simplequery.OrderSimpleQueryDto(o.id, m.name, o.orderDate, o.status, d.address) &quot; + &quot;from Order o &quot; + &quot;join o.Member m &quot; + &quot;join o.delivery d&quot;; return entityManager.createQuery(jpql, OrderSimpleQueryDto.class) .getResultList(); }}/** * V4. JPA에서 DTO로 바로 조회 * - 쿼리 1번 호출 * - select 절에서 원하는 데이터만 선택해서 조회 */@GetMapping(&quot;/api/v4/simple-orders&quot;)public Result&amp;lt;List&amp;lt;OrderSimpleQueryDto&amp;gt;&amp;gt; ordersV4() { List&amp;lt;OrderSimpleQueryDto&amp;gt; orders = orderSimpleQueryRepository.findOrdersDtos(); return new Result&amp;lt;&amp;gt;(orders);}2023-10-27 14:38:02.683 DEBUG 83425 --- [nio-8080-exec-1] org.hibernate.SQL : select order0_.order_id as col_0_0_, member1_.name as col_1_0_, order0_.order_date as col_2_0_, order0_.status as col_3_0_, delivery2_.city as col_4_0_, delivery2_.street as col_4_1_, delivery2_.zipcode as col_4_2_ from orders order0_ inner join member member1_ on order0_.member_id=member1_.member_id inner join delivery delivery2_ on order0_.delivery_id=delivery2_.delivery_id...join 을 통해 필요한 정보가 있는 엔티티들도 한번에 조회한 이후 정의한 DTO에 맞춰 필요한 필드를 SELECT 함 일반적인 SQL을 사용할 때 처럼 원한는 값을 선택하여 조회 new 명령어를 사용하여 JPQL의 결과를 DTO로 즉시 변환 SELECT 절에서 원하는 데이터를 직접 선택하므로 DB -&amp;gt; 어플리케이션 네트워크 용량 최적화 리포지토리 재사용성이 떨어짐 API 스펙에 맞춘 코드가 리포지토리에 들어가는 단점 정리엔티티를 DTO로 변환(ordersV3 방법)하거나, DTO로 바로 조회(ordersV4 방법)하는 두가지 방법은 각각 장단점이 있음. 둘중 상황에 따라 더 나은 방법을 택하면 됨.쿼리 방식 선택 권장 순서 우선 엔티티를 DTO로 변환하는 방법을 선택(ordersV2 방법) 필요하다면 페치 조인으로 성능 최적화 시도(ordersV3 방법) 대부분의 경우 이 단계에서 성능 이슈가 해결 됨 그래도 안된다면 DTO로 직접 조회하는 방법으로 성능 최적화 시도(ordersV4 방법) 최후의 방법으로는 JPA가 제공하는 네이티브 SQL이나 스프링 JDBC Template을 사용하여 SQL을 직접 사용참고 실전! 스프링 부트와 JPA 활용2 - 웹 애플리케이션 개발(김영한)" }, { "title": "JPA - 예제 구현", "url": "/posts/spring-jpa-11/", "categories": "Backend, JPA", "tags": "Web, Spring Framework, DataBase, JPA", "date": "2023-10-26 17:00:00 +0900", "snippet": "예제 구현https://github.com/ISSuh/spring_shop_example엔티티 설계시 주의점외래 키가 있는 곳을 연관관계의 주인으로 정할 것연관관계의 주인은 단순히 외래 키를 누가 관리하냐의 문제이지 비지니스상 우위에 있다고 주인으로 정하면 안됨.예를 들어 자동차와 바퀴가 있다면, 일대다 관계에서 항상 다쪽에 외래 키가 있으므로 외래 키가 있는 바퀴를 연관관계의 주인으로 정하면 됨.물론 자동차를 연관관계의 주인으로 정하는 것이 불가능 한 것은 아니지만 자동차를 연관관계의 주인으로 정하면 자동차가 관리하지 않는 바퀴 테이블의 외래 키 값이 업데이트 되므로 관리와 유지보수에 어렵고 추가적으로 별도의 업데이트 쿼리가 발생하는 성능 문제도 발생 함.엔티티에는 가급적 Setter를 사용하지 말자 Setter가 모두 열려있다면 변경 포인트가 너무 많아서 유지보수에 어려움이 있음모든 연관관계는 지연로딩으로 설정 즉시로딩(EAGER)은 예측이 어렵고 어떤 SQL이 실행될지 추철하기 어려움 특히 JPQL을 실행할 떄 N+1 문제가 자주 발생할 수 있음 실무에서 모든 연관관계는 지연로딩(LAZY)로 설정해야 함 연관된 엔티티를 함꼐 DB에서 조회해야 한다면, fetch join또는 엔티티 그래프 기능을 사용 @XToOne(OneToOne, ManyToOne)관계는 기본이 즉시로딩이므로 직접 지연로딩으로 설정해야 함컬렉션은 필드에서 초기화 하자 컬렉션은 필드에서 바로 초기화하는것이 null 문제에 대해 안전함 하이버네이트는 엔티티를 영송화 할 뗴, 컬렉션을 감싸허 하이버네이트가 제공하는 내장 컬레션으로 변경하는데, 만약 getOrder()처럼 임의의 메소드에서 컬렉션을 잘못 생성하면 하이버네이트 내부 메커니즘에 문제가 발생할 수 있음. 그러므로 필드레벨에서 생성하는 것이 가장 안전하고 코드도 간결해짐폼객체 vs 엔티티 직접 사용요구사항이 정말 단순할 떄는 폼 객체 없이 엔티티를 직접 등록과 수정화면에서 사용해도 됨.그러나 화면 요구사항이 복잡해지기 시작하면 엔티티에 화면을 처리하기 위한 기능이 증가하게 되면서 결국 엔티티는 화면에 종속적으로 변하게 되버림.실무에서는 엔티티는 핵심 비지니스 로직만 가지고 있고, 화면을 위한 로직은 없어야 함.화면이나 API에 맞는 폼 객체나 DTO를 사용하여 요구사항을 처리하고 엔티티는 순수하게 유지하는것이 좋음.API를 만들떄는 엔티티를 반환하지 않는것이 좋음 엔티티를 변경하면 API의 스펙도 변경되어 버림참고 실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발(김영한)" }, { "title": "JPA - 변경 감지와 병합", "url": "/posts/spring-jpa-10/", "categories": "Backend, JPA", "tags": "Web, Spring Framework, DataBase, JPA", "date": "2023-10-26 16:00:00 +0900", "snippet": "변경 감지와 병합(merge)영속성 컨텍스트가 더는 관리하지 않는 엔티티인 준영속 엔티티를 수정하는 방법은 두가지가 있음 변경 감지 기능 사용 병합(merge) 사용 기존에 영속성 컨텍스트에 관리되고 있는 엔티티를 detach()를 통해 더이상 관리하지 않는 준영속 엔티티를 만드는 방법도 있지만, find()를 통해 얻오언 엔티티가 아닌 임의로 생성한 엔티티도 기존 식별자를 가지고 있으면 준영속 엔티티로 볼 수 있음변경 감지 기능 사용영속성 컨텍스트에서 엔티티를 다시 조회한 후에 데이터를 수정하는 방법.트랜잭션 안에서 엔티티를 다시 조회, 변경할 값으로 수정한 다음,트랜잭션 커밋 시점에 변경 감지(Dirty Checking)가 동작하여 데이터베이스에 UPDATE SQL 수행.@Transactional// itemParam: 파리미터로 넘어온 준영속 상태의 엔티티void update(Item itemParam) { // 같은 엔티티를 조회 Item findItem = em.find(Item.class, itemParam.getId()); // 데이터를 수정 findItem.setPrice(itemParam.getPrice()); // 이후 트랜잭션이 종료 되면서 커밋 수행 // 커밋 수행시 영속성 컨텍스트가 관리하는 엔티티의 몇몇 필드의 값이 변경되었으므로 // 이를 감지하여 UPDATE 쿼리 수행}병합 사용merge() 메소드를 사용하여 강제로 엔티티내의 필드의 값을 업데이트 하는 방법@Transactional// itemParam: 파리미터로 넘어온 준영속 상태의 엔티티void update(Item itemParam) { Item mergeItem = em.merge(itemParam);} merge()를 실행 파라미터로 넘어온 준영속 엔티티의 식별자 값으로 1차 캐시에서 엔티티를 조회 만약 1차 캐시에 엔티티가 없으면 데이터베이스에서 엔티티를 조회하고 1차 캐시에 저장 조죄한 영속 엔티티에 엔티티의 값을 수정함 영속 상태인 엔티티를 반환병합시의 동작방식을 정리하면 아래와 같음 준영속 엔티티의 식별자 값으로 영속 엔티티를 조회 영속 엔티티의 값을 준영속 엔티티의 값으로 모두 교체(병합) 트랜잭션 커밋 시점에 변경 감지 기능이 동작하여 데이터베이트에 UPDATE SQL 수행주의해야 할 사항은변경 감지 기능을 사용하면 원하는 필드만 선태하여 값을 변경할 수 있지만,병합을 사용하면 모든 필드가 변경되기 떄문에 병합시 값이 없으면 null 로 업데이트 할 위험이 있음.실무에서는 보통 업데이트 기능이 매우 제한적 임.병합은 모든 필드를 변경해버리고 데이터가 없으면 null로 업데이트 해버리기 떄문에, 보통 변경 가능한 데이터만 노출시키는 실무 환경에서는 병합을 사용하기 까다로움.그러므로 엔티티를 변경할 떄는 항상 변경 감지를 사용하도록 하는 것이 좋음 컨트롤러에서 어설프게 엔티티를 생성하지 않도록 함 트랜잭션이 있는 서비스 계층에 식별자와 변경할 데이터를 명확하게 전달 하도록 함(파라미터 or DTO) 트랜잭션이 있는 서비스 계층에서 영속 상태의 엔티티를 조회하고 엔티티의 데이터를 직접 변경하여 트랜잭션 커밋 시점에 변경 감지가 실행 되도록 함참고 실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발(김영한)" }, { "title": "JPA - 객체 지향 쿼리 언어(2)", "url": "/posts/spring-jpa-09/", "categories": "Backend, JPA", "tags": "Web, Spring Framework, DataBase, JPA", "date": "2023-10-26 10:00:00 +0900", "snippet": "경로 표현식 상태필드(state field) 경로 탐색의 끝이며 더이상 탐색 불가 단일 값 연관 경로 묵시적 내부 조인(inner join) 발생 이후 상태필드까지 탐색 가능 컬렉션 값 연관 경로 묵시적 내부조인 발생 더이상 탐색 불가 FROM 절에서 명시적 조인을 통해 별칭을 얻으면 별칠을 통해 탐색 가능 -- 상태 필드 경로 탐색-- JPQLselect m.username, m.age from Member m-- SQLselect m.username, m.age from Member m-- 단일 값 연관 경로 탐색-- JPQLselect o.member from Order o-- SQLselect m.*from Order oinner join Member m on o.member_id = m.id명시적 조인, 묵시적 조인 명시적 조인 join 키워드 직접 사용 select m from Member m join m.team t 묵시적 조인 경로 표현식에 의해 묵시적으로 SQL 조인 발생 내부 조인만 가능 select m.team from Member m 경로 탐색으로 인해 발새하는 묵시적 조인은 항상 내부 조인을 수행 함.또한 경로 탐색은 주로 SELECT, WHERE 절에서 사용하지만 묵시적 조인으로 인해 SQL의 FROM(JOIN) 절에 영향을 줌.결국 경로 탐색으로 발생하는 묵시적 조인은 JPQL과 실제 변환되서 수행되는 SQL과 차이를 만들어 한눈에 쿼리를 이해하기 어렵게 만듬.그러므로 가급적 묵시적 조인 대신 명시적 조인을 사용 해야함.명시적 조인을 사용해야 한눈에 조인을 사용하는 것을 이해할 수 있으며, 조인은 SQL 튜닝에 중요 포인트 이므로 추후 수정에도 용이 함.페치 조인(fetch join)실무에서 굉장히 많이 사용되는 기능 SQL 조인의 종류가 아니고, JPQL에서 성능 최적화를 위해 제공하는 기능 연관된 엔티티나 컬렉션을 SQL 한 번에 함꼐 조회하는 기능 즉, 즉시로딩을 통해 연관된 엔티티를 한번에 조회 -- JPQLselect m from Member m join fetch m.team-- SQLselect m.*, t.*from MEMBER minner join TEAM t on m.TEAM_ID = t.ID 회원을 조회 하면서 연관된 팀도 함꼐 조회(SQL 한번에) SQL을 보면 회원 뿐만 아니라 TEAM(T.*)도 함꼐 select 함페치 조인 예시String jpql = &quot;select m from Member m join fetch m.team&quot;;List&amp;lt;Member&amp;gt; members = em.createQuery(jpql, Member.class).getResultList();for (Member member : members) { //페치 조인으로 회원과 팀을 함께 조회해서 지연 로딩X System.out.println( &quot;username = &quot; + member.getUsername() + &quot;, &quot; + &quot;teamName = &quot; + member.getTeam().name());}username = 회원1, teamname = 팀Ausername = 회원2, teamname = 팀Ausername = 회원3, teamname = 팀B컬렉션에서의 페치 조인일대다 관계에서의 컬렉션 페치 조인-- JPQLselect tfrom Team t join fetch t.memberswhere t.name = &#39;A&#39;-- SQLselect t.*, m.*from TEAM t inner join MEMBER m on t.ID = m.TEAM_IDwhere t.NAME = &#39;A&#39;컬렉션에서의 페치 조인 예시String jpql = &quot;select t from Team t join fetch t.members where t.name = &#39;팀A&#39;&quot;;List&amp;lt;Team&amp;gt; teams = em.createQuery(jpql, Team.class).getResultList();for(Team team : teams) { System.out.println(&quot;teamname = &quot; + team.getName() + &quot;, team = &quot; + team); for (Member member : team.getMembers()) { //페치 조인으로 팀과 회원을 함께 조회해서 지연 로딩 발생 안함 System.out.println(“-&amp;gt; username = &quot; + member.getUsername()+ &quot;, member = &quot; + member); }}teamname = 팀A, team = Team@0x100-&amp;gt; username = 회원1, member = Member@0x200-&amp;gt; username = 회원2, member = Member@0x300teamname = 팀A, team = Team@0x100-&amp;gt; username = 회원1, member = Member@0x200-&amp;gt; username = 회원2, member = Member@0x300페치조인과 DISTINCT SQL의 DISTINCT는 중복된 결과를 제거하는 명령 JPQL의 DISTINCT는 2가지 기능 제공 SQL에 DISTINCT 구문 추가 어플리케이션에서 엔티티 중복 제거 select distinct tfrom Team t join fetch t.memberswhere t.name = ‘팀A’이와 같은 쿼리일때, SQL에 DISTINCT를 추가 한다고 해도 데이터가 다르면 SQL 결과에서 중복제거가 되지 않음그러므로 JPQL에서는 데이터베이스에서 이 중복된 데이터까지 통째로 가져오되, 추가로 어플리케이션 레벨에서 중복 제거를 시도 함. 같은 식별자를 가진 엔티티 제거 하이버네이트6 부터는 DISTINCT 명령어를 사용하지 않아도 어플리케이션에서 중복제거가 자옹으로 적용페치 조인과 일반 조인의 차이일반 조인 실행시 연관된 엔티티를 함꼐 조회하지 않음 일반 조인 JPQL은 결과를 반환할 떄 연관관계를 고려하지 않고 단지 SELECT 절에 지정한 엔티티만 조회 함 위 예시에서는 팀 엔티티가 회원엔티티와 연관관계가 있으며 지연로딩으로 되어있을 떄, 팀 엔티티만 조회하고 회원 엔티티를 조회하지 않음 페치 조인 페이 조인을 사용할 때만 연관된 엔티티도 함꼐 조회 즉, 즉시 로딩이 수행됨 페치 조인은 객체 그래프를 SQL 한번에 조회하는 개념 -- 일반 join 예시-- JPQLselect tfrom Team t join t.members mwhere t.name = &#39;A&#39;-- SQLselect t.*from TEAM t inner join MEMBER m on t.ID = m.TEAM_IDwhere t.NAME = &#39;A&#39;-- fetch join 예시-- JPQLselect tfrom Team t join fetch t.memberswhere t.name = &#39;A&#39;-- SQLselect t.*, m.*from TEAM t inner join MEMBER m on t.ID = m.TEAM_IDwhere t.NAME = &#39;A&#39;페치조인의 특징과 한계 한계점 페치 조인 대상에는 별칭을 줄 수 없음 하이버네이트에선 가능하지만 가급적이면 사용하면 안됨 페치 조인은 연관된 엔티티에 대하여 모든 데이터를 가져오는 것을 기본으로 하기 떄문에 별칭을 사용하여 where 절로 조건을 걸게되면 모든 데이터를 가져오지 못하고 데이터에 대한 정합을 보장해주지 않음 둘 이상의 컬렉션은 페치 조인 할수 없음 일 x 다 x 다(일대다 x 다대다) 로 형성되어 조인의 결과 데이터에 빈 칼럼이 많이 생기게 될수 있어 데이터에 대한 정합을 보장할 수 없음 컬렉션을 페치 조인하면 페이징 API(setFirstResult, setMaxResult)를 사용할 수 없음 일대일, 다대일 같은 단일 값 연관 필드들은 페치 조인해도 페이징 가능 하이버네이트는 경고 로그를 남기고 메모리에서 페이징을 하는데 이는 매우 위험하므로 사용하지 않는 것이 좋음 특징 연관된 엔티티들을 SQL 한번으로 조회 성능 최적화에 이점 엔티티에 직접 적용하는 글로벌 로딩 전략보다 우선시 됨 @OneToMany(fetch = FetchType.LAZY) // 글로벌 로딩 전략 실무에서 글로벌 로딩 전략은 모두 지연 로딩을 사용하되, 최적화가 필요한 곳은 페치 조인을 사용 페치 조인 정리 모든 것을 페치 조인으로 해결할 수는 없음 페치 조인은 객체 그래프를 유지할 떄 사용하면 효과적 여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야 한다면, 페치 조인 보다는 일반 조인을 사용하고 필요한 데이터들만 조회해서 DTO로 반환하는 것이 효과적다형성 쿼리조회 대상을 특정 자식으로 한정 자바의 타입 캐스팅과 유사 상속 구조에서 부모 타입을 특정 자식 타입으로 다룰 떄 사용 FROM, WHERE, SELECT(하이버네이트 지원) 사용-- Item 중에 Book, Movie를 조회-- JPQLselect ifrom Item iwhere type(i) in (Book, Movie)-- SQLselect ifrom ITEM iwhere i.DTYPE in (&#39;B&#39;, &#39;M&#39;)-- 부모인 Item중에 Book 이면서 저자가 kim 인 item 조회-- JPQLselect ifrom Item iwhere treat(i as Book).author = &#39;kim&#39;-- SQLselect i.*from ITEM iwhere i.DTYPE = &#39;B&#39; and i.author = &#39;kim&#39;엔티티 직접 적용JPQL에서 엔티티를 직접 사용하면 SQL에서 해당 엔티티의 기본 키 값을 사용 함.만약 엔티티의 연관관계가 있는 타 엔티티를 직접 사용할 땐, 외래 키 값을 사용 함.엔티티를 직접 사용하여 기본 키값을 사용할 떄// 엔티티를 파라미터로 전달String jpql = “select m from Member m where m = :member”;List resultList = em.createQuery(jpql) .setParameter(&quot;member&quot;, member) .getResultList();// 식별자를 직접 전달String jpql = “select m from Member m where m.id = :memberId”;List resultList = em.createQuery(jpql) .setParameter(&quot;memberId&quot;, memberId) .getResultList();select m.* from Member m where m.id=?연관관계에 있는 엔티티를 직접 사용하여 외래 키값을 사용할 떄// 연관관계에 있는 엔티티를 파라미터로 전달String jpql = “select m from Member m where m.team = :team”;List resultList = em.createQuery(jpql) .setParameter(&quot;team&quot;, team) .getResultList();// 식별자를 직접 전달String jpql = “select m from Member m where m.team.id = :teamId”;List resultList = em.createQuery(jpql) .setParameter(&quot;teamId&quot;, teamId) .getResultList();select m.* from Member m where m.team_id=?Named 쿼리 미리 정의해서 이름을 부여해두고 사용하는 JPQL 정적 쿼리 어노테이션, XML에 정의 XML이 항상 우선권을 가짐 어플리케이션 운영 환경에 따라 다른 XML을 배포 할 수 있음 어플리케이션 로딩 시점에 초기화 후 재사용 어플리케이션 로딩 시점에 쿼리를 검증 쿼리에 대한 문법에러를 어플리케이션 로딩시점(어플리케이션 시작시점)에 확인할 수 있음 어노테이션 방식@Entity@NamedQuery( name = &quot;Member.findByUsername&quot;, query=&quot;select m from Member m where m.username = :username&quot;)public class Member { ...}...List&amp;lt;Member&amp;gt; resultList = em.createNamedQuery(&quot;Member.findByUsername&quot;, Member.class) .setParameter(&quot;username&quot;, &quot;회원1&quot;) .getResultList();xml에 정의persistence.xml 혹은 ormMember.xml 파일에 정의&amp;lt;!-- META-INF/persistence.xml --&amp;gt;&amp;lt;persistence-unit name=&quot;jpabook&quot; &amp;gt; &amp;lt;mapping-file&amp;gt;META-INF/ormMember.xml&amp;lt;/mapping-file&amp;gt;&amp;lt;!-- META-INF/ormMember.xml --&amp;gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;entity-mappings xmlns=&quot;http://xmlns.jcp.org/xml/ns/persistence/orm&quot; version=&quot;2.1&quot;&amp;gt; &amp;lt;named-query name=&quot;Member.findByUsername&quot;&amp;gt; &amp;lt;query&amp;gt;&amp;lt;![CDATA[ select m from Member m where m.username = :username ]]&amp;gt;&amp;lt;/query&amp;gt; &amp;lt;/named-query&amp;gt; &amp;lt;named-query name=&quot;Member.count&quot;&amp;gt; &amp;lt;query&amp;gt;select count(m) from Member m&amp;lt;/query&amp;gt; &amp;lt;/named-query&amp;gt;&amp;lt;/entity-mappings&amp;gt;벌크 연산예를 들어 재고가 10개 미만인 모든 상품의 가격을 10% 상승하려면 아래와 같은 작업이 수행됨 재고가 10개 미만인 상품을 리스트로 조회 상품 엔티티의 가격을 10% 증가 트랜잭션 커밋 시점에 변경감지가 동작 변경된 데이터가 100건이라면 100번의 UPDATE SQL 실행즉, JPA 변경 감지 기능으로 실행하려면 너무 많은 SQL 실행되는 문제가 있음이에 대한 문제를 JPA는 벌크 연산을 통해 한번에 여러 테이블을 업데이트 할 수 있게 함벌크 연산 쿼리 한 번으로 여러 테이블 로우 변경(엔티티) executeUpdate()의 결과는 영향받은 엔티티의 수 반환 UPDATE, DELETE 지원 하이버네이트에선 INSERT(insert into … select) 지원// 재고가 10개 미만인 상품을 조호하여 상품의 가격을 10% 증가String jpql = &quot;update Product p &quot; + &quot;set p.price = p.price * 1.1 &quot; + &quot;where p.stockAmount &amp;lt; :stockAmount&quot;;int resultCount = em.createQuery(jpql) .setParameter(&quot;stockAmount&quot;, 10) .executeUpdate();벌크 연산 주의점 벌크 연산은 영속성 컨텍스트를 무시하고 데이터베이트에 집접 쿼리 벌크 연산으로 인하여 버그를 유발시키지 않기 위하여 아래와 같은 방법을 사용 벌크 연산을 가장 먼저 실행하는 방법 벌크 연산 수행 후, 영속성 컨텍스트를 초기화하여 다시 갱신하는 방법 참고 자바 ORM 표준 JPA 프로그래밍(김영한)" }, { "title": "Spring MVC - PRG(Post/Redirect/Get) 패턴", "url": "/posts/spring-mvc-05/", "categories": "Backend, Spring MVC", "tags": "Web, Spring Framework", "date": "2023-10-25 21:00:00 +0900", "snippet": "PRG(Post/Redirect/Get) 패턴위와 같은 흐름으로 요청이 전달된다고 가정 했을떄,요청에 대한 흐름을 자세히 표현하면 아래 그램과 같음웹 브라우저의 새로 고침은 마지막에 서버에 전송한 데이터를 다시 전송함.상품 등록 폼에서 데이터를 입력하고 저장을 하게되면 POST /add + 상품 데이터를 서버로 전송함.이 상태에서 새로 고침을 하게 되면 마지막에 전송한 POST /add + 상품 데이터를 다시 서버로 전송하게 됨.그러므로 내용이 같은 상품 데이터가 계속 쌓이게 되는 문제가 있음.이 문제는 리다이렉트를 활용하여 해결할 수 있음웹 브라우저의 새로고침은 마지막에 서버에 전송한 데이터를 다시 전송함.그러므로 이 문제를 해결하기 위해 상품 저장 후 뷰 템플릿으로 이동하는 것이 아닌 상품 상세 화면으로 리다이렉트를 호출하도록 해야 함.웹 브라우저는 리다이렉트의 영향으로 상품 저장 후에 실제 상품 상세 화면으로 다시 이동함.따라서 마지막에 호출한 내용이 상품 상세 화면인 GET /items/{id} 가 되어 새로고침이 발생해도 반복적으로 데이터가 쌓이는 것을 방지할 수 있음.@PostMapping(&quot;/add&quot;)public String addItem(Item item, RedirectAttributes redirectAttributes) { Item item = reepository.save(item); redirectAttributes.addAttribute(&quot;itemId&quot;, savedItem.getId()); redirectAttributes.addAttribute(&quot;status&quot;, true); return &quot;redirect:/basic/items/{itemId}&quot;;}참고 스프링 MVC - 백엔드 웹 개발 핵심 기술(김영한)" }, { "title": "JPA - 객체 지향 쿼리 언어(1)", "url": "/posts/spring-jpa-08/", "categories": "Backend, JPA", "tags": "Web, Spring Framework, DataBase, JPA", "date": "2023-10-25 14:30:00 +0900", "snippet": "JPQL 개요 테이블이 아닌 객체를 대상으로 검색하는 객체 지향 쿼리 SQL을 추상화하여 특정 데이터베이스 SQL에 의존하지 않음 쿼리시 테이블이 아닌 엔티티 객체를 대상으로 쿼리 JPQL은 엔티티 객체를 대상으로 쿼리 SQL은 데이터베이스 테이블을 대상으로 쿼리 String jpql = &quot;select m from Member m where m.age &amp;gt; 18&quot;;List&amp;lt;Member&amp;gt; result = em.createQuery(jpql, Member.class).getResultList();select m.id as id, m.age as age, m.USERNAME as USERNAME, m.TEAM_ID as TEAM_IDfrom Member mwhere m.age&amp;gt;18JPQL 기본 문법과 기능-- 기본문법select_문 :: = select_절 from_절 [where_절] [groupby_절] [having_절] [orderby_절]update_문 :: = update_절 [where_절]delete_문 :: = delete_절 [where_절]-- 기본적인 함수 지원select COUNT(m), //회원수 SUM(m.age), //나이 합 AVG(m.age), //평균 나이 MAX(m.age), //최대 나이 MIN(m.age) //최소 나이from Member m-- 기본적인 정렬 지원GROUP BY, HAVINGORDER BYselect m from Member as m where m.age &amp;gt; 18 엔티티와 속성은 대소문자를 구분 함 JPQL 키워드는 대소문자를 구분하지 않음 엔티티 이름을 사용하며 테이블의 이름이 아님 별칭이 필수(as는 생략 가능)TypeQuery, Query TypeQuery 반환 타입이 명확할 떄 사용 Query 반환 타입이 명확하지 않을 떄 사용 TypedQuery&amp;lt;Member&amp;gt; query = em.createQuery(&quot;SELECT m FROM Member m&quot;, Member.class);Query query = em.createQuery(&quot;SELECT m.username, m.age from Member m&quot;);결과 조회 API query.getResultList() 결과가 하나 이상일떄 리스트를 반환 결과가 없으면 빈 리스트 반환 query.getSingleResult() 경과가 정확히 하나일떄 단일 객체 반환 결과가 없으면 javax.persistence.NoResultException 발생 결과가 2개 이상이면 javax.persistence.NonUniqueResultException 발생 파라미터 바인딩// 이름으로 바인딩String jpql = &quot;SELECT m FROM Member m where m.username=:username&quot;;TypedQuery&amp;lt;Member&amp;gt; query = em.createQuery(jpql, Member.class) .setParameter(&quot;username&quot;, usernameParam);// 인덱스로 바인딩String jpql = &quot;SELECT m FROM Member m where m.username=?1&quot;;TypedQuery&amp;lt;Member&amp;gt; query = em.createQuery(jpql, Member.class) .setParameter(1, usernameParam); 인덱스로 바인딩하는 경우 인덱스를 밀려 파라미터를 설정할수 있으므로 실수를 미연에 방지하기 위해 이름으로 바인딩 하는것을 추천프로젝션Select 절에 조회할 대상을 지정하는 것 프로젝션 대상 : 엔티티, 임베디드 타입, 스칼라 타입(숫자, 문자등 기본 데이터 타입) SELECT m FROM Member m -&amp;gt; 엔티티 프로젝션 SELECT m.team FROM Member m -&amp;gt; 엔티티 프로젝션 엔티티 타입은 별도의 테이블이 존재하므로, jpql에서 명시적으로 join을 하지 않아도 sql로 변환할떄 자동으로 해당 테이블을 join 하도록 sql이 변환됨 유지보수를 위해 명시적으로 jpql에도 join을 명시하여 생성되는 sql과 싱크를 맞추는것이 좋음 SELECT m.address FROM Member m -&amp;gt; 임베디드 타입 프로젝션 SELECT m.username, m.age FROM Member m -&amp;gt; 스칼라 타입 프로젝션 DISTINCT로 중복 제거하나의 대상 말고 여러 대상을 조회하고 싶을떈 아래와 같은 방법이 있음 Query 타입으로 조회 Object[] 타입으로 조회 new 명령어로 조회 단순 값을 DTO로 바로 조회 패키지 명을 포함한 전체 클래스명 입력 필요 순서와 타입이 일치하는 생성자 필요 // new 명령어를 통해 DTO로 변환하여 조회public class UserDTO { private String username; private int age; public UserDTO(Strig username, int age) { this.username = username; this.age = age; }}...String jpql = &quot;SELECT new jpabook.jpql.UserDTO(m.username, m.age) FROM Member m&quot;페이징JPA는 페이징을 다음 두 API로 추상화 setFirstResult(int startPosition) 조회 시작 위치 0부터 시작 setMaxResults(int maxResult) 조회할 데이터 수 // 10번쨰 부터 20개를 가져옴String jpql = &quot;select m from Member m order by m.name desc&quot;;List&amp;lt;Member&amp;gt; resultList = em.createQuery(jpql, Member.class) .setFirstResult(10) .setMaxResults(20) .getResultList();조인 내부 조인 SELECT m FROM Member m [INNER] JOIN m.team t INNER 는 생략 가능 외부 조인 SELECT m FROM Member m LEFT [OUTER] JOIN m.team t OUTER 는 생략 가능 세타 조인 SELECT count(m) FROM Member m, TEAM t WHERE m.username = t.name 조인 ON 절 ON절을 활용한 조인(JPA 2.1 부터 지원) 조인 대상 필터링 연관관계 없는 엔티티 외부 조인(하이버네이트 5.1 부터 지원) 조인 대상 필터링 예시-- 회원과 팀을 조인하면서 팀 이름이 A인 팀만 조인-- JPQLSELECT m, tFROM Member mLEFT JOIN m.team t on t.name = &#39;A&#39;-- SQLSELECT m.*, t.*FROM Member mLEFT JOIN Team t on m.TEAM_ID = t.id AND t.name = &#39;A&#39;연관관계 없는 엔티티 외부 조인 예시-- 회원의 이름과 팀의 이름이 같은 대상 외부 조인-- JPQLSELECT m, tFROM Member mLEFT JOIN Team t on m.username = t.name-- SQLSELECT m.*, t.*FROM Member mLEFT JOIN Team t on m.username = t.name서브 쿼리 [NOT] EXISTS (subquery): 서브쿼리에 결과가 존재하면 참 {ALL ANY SOME} (subquery) ALL 모두 만족하면 참 ANY, SOME: 같은 의미, 조건을 하나라도 만족하면 참 [NOT] IN (subquery): 서브쿼리의 결과 중 하나라도 같은 것이 있으면 참서브쿼리 예시-- 나이가 평균보다 많은 회원select mfrom Member mwhere m.age &amp;gt; (select avg(m2.age) from Memeber m2)-- 한 건이라도 주문한 고객select mfrom Member mwhere (select count(o) from Order o where m = o.member) &amp;gt; 0-- 팀이름이 A에 소속된 회원select mfrom Member mwhere exists (select t from m.team t where t.name = &#39;A&#39;)-- 전체 상품 각각의 재고보다 주문량이 많은 주문들select mfrom Member mwhere o.orderAmount &amp;gt; all (select p.stockAmount from Product p)-- 어떤 팀이든 팀에 소속된 회원select mfrom Member mwhere m.team = any (select t from Team t)서브쿼리의 한계 JPA는 WHERE, HAVING 절에서만 서브 쿼리 사용가능 SELECT 절의 경우 하이버네이트 사용시 사용 가능 FROM 절의 서브쿼리는 JPQL에서 불가능 조인으로 풀 수 있으면 풀어서 해결 하이버네이트 6 부터는 FROM 절의 서브쿼리를 지원조건식(CASE 식)-- 기본 CASE 식select case when m.age &amp;lt;= 10 then &#39;학생&#39; when m.age &amp;gt;= 60 then &#39;경로&#39; else &#39;일반&#39; andfrom Member m-- 단순 CASE 식select case t.name when &#39;팁A&#39; then &#39;인센티브110%&#39; when &#39;팁B&#39; then &#39;인센티브120%&#39; else &#39;인센티브105%&#39; andfrom Team t-- COALESCE: 하나씩 조회해서 null이 아니면 반환-- 사용자 이름이 없으면 이름 없는 회원을 반환select coalesce(m.username, &#39;이름없는회원&#39;)from Member m-- NULLIF: 두 값이 같으면 null 반환, 다르면 첫번째 값 반환-- 사용자 이름이 관리자면 null을 반환하고 나머지는 본인의 이름을 반한select NULLIF(m.username, &#39;관리자&#39;)from Member mJPQL 기본 함수 CONCAT SUBSTRING TRIM LOWER, UPPER LENGTH LOCATE ABS, SQRT, MOD SIZE, INDEX(JPA 용도)사용자 정의 함수를 지정하여 호출할 수 있음 하이버네이트는 사용전 방언에 추가해야 함 사용하는 DB 방언을 상속받고, 사용자 정의 함수를 등록해야 함 select function(&#39;group_concat&#39;, i.name)from Item i참고 자바 ORM 표준 JPA 프로그래밍(김영한)" }, { "title": "JPA - 프록시와 연관관계 관리(2)", "url": "/posts/spring-jpa-07/", "categories": "Backend, JPA", "tags": "Web, Spring Framework, DataBase, JPA", "date": "2023-10-25 10:30:00 +0900", "snippet": "JPA의 데이터 타입 엔티티 타입 @Entity로 정의하는 객체 데이터가 변해도 식별자로 지속해서 추적 가능 예) 회원 엔티티의 키나 나이 값을 변경해도 식별자로 인식 가능 값 타입 int, Integer, String 처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체 식별자가 없고 값만 있으므로 변경시 추적 불가 예) 숫자 100을 200으로 변경하면 완전히 다른 값으로 대체 값 타입 분류 기본값 타입 자바 기본 타입(int, double…) 래퍼 클래스(Integer, Long…) String 임베디드 타입(embedded type, 복합 값 타입) 컬렉션 값 타입(collection value type)기본값 타입 생명주기를 엔티티의 의존 예) 회원을 삭제하면 이름, 나이 필드도 함꼐 삭제 값 타입은 공유하면 안됨 예) 회원 이름 변경시 다른 회원의 이름도 함께 변경되면 안됨 자바의 기본 타입은 공유 Xint, double 같은 기본 타입은 공유되지 않고 항상 값을 복사함.Integer 같은 래퍼 클래스나 String 같은 특수한 클래스는 공유 가능할 객체이지만 변경 X임베디드 타입(복합 값 타입) 새로운 값 타입을 직접 정의할 수 있는데, 이러한 직접 정의한 값 타입을 JPA는 임베디드 타입 이라 함 주로 기본 값 타입을 모아서 만들기 때문에 복합 값 타입이라고도 함 int, String 과 같은 값 타입값 타입 사용법 으로는 아래와 같음@Embeddablepublic class Address { private String city; private String street; private String zipcode; public Address() { } ...}@Entitypublic class Member { ... @Embedded private Address address; ...} @Embeddable : 값 타입을 정의하는 곳에 표시 기본 생성자 필수 @Embedded : 값 타입을 사용하는 곳에 표시(생략 가능)입베디드 타입의 장점 재사용 높은 응집도 해당 값 타입만 사용하는 의미있는 메소드를 만들수 있음 임베디드 타입을 포함한 모든 값 타입은, 값 타입을 소유한 엔티티에 생명주기를 의존함임베디드 타입과 테이블 매핑 테이블은 변하는것 없이 그대로이며 엔티티내의 객체만 나누어 진 것 임베디드 타입은 엔티티의 값일 뿐 임 임베디드 타입을 사용하기 전과 후에 매핑하는 테이블은 같음 객체와 테이블을 아주 세밀하게(find-grained) 매핑하는 것이 가능 임베디드 타입의 값이 null이면 매핑한 컬럼 값은 모두 null 속성 재정의하나의 엔티티에서 같은 값 타입을 사용할떄, 컬럼명이 중복되어 에러 발생.이를 해결하기 위해 @AttributeOverrides, @AttributeOverride 를 사용하여 컬럼명 속성을 재정의 하여 사용해야 함.값 타입과 불변 객체값 타입은 복잡한 객체 세상을 조금이라도 단순화하려고 만든 개념이므로 값 타입은 단순하고 안전하게 다룰 수 있어야 함값 타입 사용시 주의Address addr = new Address(“OldCity”);Memmber member1 = new Member();Memmber member2 = new Member();member1.setAddress(addr);member2.setAddress(addr);Address memberAddress = member1.getAddress();memberAddress.setCity(&quot;NewCity&quot;); 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 부작용이 발생 할 수 있음 두개의 엔티티가 서로 같은 값 타입 인스턴스를 공유하므로 한쪽에서 값을 수정하면 다른 한쪽에서도 같이 수정됨이에 대한 대안으로 값을 공유하는 것이 아닌 복사해서 사용하도록 함Address addr1 = new Address(“OldCity”);Memmber member1 = new Member();Memmber member2 = new Member();member1.setAddress(addr);Address addr2 = new Address(addr1.getCity());member2.setAddress(addr2);객체 타입의 한계 항상 값을 복사해서 사용하면 공유 참조로 인하여 발생하는 부작용을 피할 수 있음 문제는 임베디드 타입처럼 작접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입 인 점 자바 기본 타입에 값을 대입하면 값을 복사함 객체 타입은 참조 값을 직접 대입하는 것을 막을 방법이 없음 객체의 공유 참조는 피할 수 없음int a = 10;int b = a; // 기본 타읍은 값을 복사b = 4;Address a = new Address(&quot;a&quot;);Address b = a; // 객체 타입은 참조를 전달b.setCity();불변 객체 객체 타입을 수정할 수 없게 만들면 부작용을 원찬 차단할 수 있음 값 타입은 불변 객체(immutable object)로 설계해야 함 불변 객체는 생성 시점 이후 절대 값을 변경할 수 없는 객체를 말함 Integer, Sting은 자바가 제공하는 대표적인 불변 객체 생성자로만 값을 설정하고 setter를 만들지 않으면 됨값 타입의 비교값 타입은 인스턴스가 달라도 그 안의 값이 같으면 같은 것으로 봐야 함int a = 10;int b = 10;Address a = new Address(&quot;a&quot;);Address b = new Address(&quot;a&quot;);그러므로 값 타입을 비교할떄 동일성 비교 보단 동등성 비교로 값타입을 비교 해야함 동일성(identity) 비교 인스턴스의 참조 값을 비교 == 사용 동등성(equivalencee) 비교 인스턴스의 값을 비교 equals() 사용 값 타입은 a.equals(b) 와 같이 동등성 비교를 해야함 값 타입의 equals() 메소드를 적절하게 재정의 하여 비교에 사용해야 함 값 타입 컬렉션 값 타입을 하나 이상 저장할떄 사용 @ElementCollection, @CollectionTable 사용 데이터베이스는 컬렉션을 같은 테이블에 저장할 수 없으므로 컬렉션을 저장하기 위한 별도의 테이블이 필요public class Member { ... @ElementCollection @CollectionTable( name = &quot;FAVORITE_FOOG&quot;, joinColumm = @JoinColumm(name = &quot;FOOD_NAME&quot;) ) private Set&amp;lt;String&amp;gt; favoriteFoods = new HashSet&amp;lt;&amp;gt;(); @ElementCollection @CollectionTable( name = &quot;ADDRESS&quot;, joinColumm = @JoinColumm(name = &quot;MEMBER_ID&quot;) ) private List&amp;lt;Address&amp;gt; addressHistoty = new ArrayList&amp;lt;&amp;gt;(); ...} 매핑된 값타입의 라이프사이클은 소유한 엔티티가 관리하게 됨이러한 값 타입 컬렉션을 사용할 떄 저장, 조회의 경우는 단순히 엔티티와 비슷하게 사용하면 되지만, 수정의 경우 주의할 점이 있음Member findMember = em.find(Member.class, id);// 치킨 -&amp;gt; 한식findMember.getFavoriteFoods().remove(&quot;치킨&quot;);findMember.getFavoriteFoods().remove(&quot;한식&quot;); 값 타입 컬렉션도 지연 로딩 전략 사용 값타입의 수정은 단순히 setter로 값 타입 내의 필드값을 수정하는게 아닌 값 타입을 새로 생성하여 인스턴스를 교체해야 함 값 타입 컬렉션의 경우 업데이트 하고 싶은 엘리먼트를 지우고 새로운 값을 엘리먼트로 넣어주어야 함 단, 값 타입 컬렉션의 엘리먼트를 지울떄, 주인 엔티티와 연관된 모든 데이터를 삭제하고 다시 갱신하기 떄문에 delete 쿼리가 여러개 수행됨값 타입 컬렉션 제약사항 값 타입은 엔티티와 다르게 식별자 개념이 없음 값은 변경하면 추적이 어려움 값 타입 컬렉션에 변경 사항이 발생하면, 주인 엔티티와 연관된 모든 데이터를 삭제하고, 값 타입 컬렉션에 있는 현재 값 모두 다시 저장 함 값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본키를 구성해야함 null 입력 불가 중복 저장 불가 값 타입 컬렉션 대안 실무에서는 상황에 따라 값 타입 컬렉션 대신에 일대다 관계를 고려 일대다 관계를 위한 엔티티를 만들고, 여기에서 값 타입을 사용 영속석 전이(Cascade) + 고아 객체 제거를 사용하여 값 타입 컬렉션 처럼 사용@Entity@Table(name = &quot;ADDRESS&quot;)public class AddressEntity { ... private Address address; ...}@Entitypublic class Member { ... @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true) @JoinColumm(name = &quot;MEMBER_ID&quot;) private List&amp;lt;Address&amp;gt; addressHistoty = new ArrayList&amp;lt;&amp;gt;(); ...}값 타입 정리 엔티티 타입 특징 식별자가 존재함 생명 주기 관리 공유 값 타입 특징 식별자가 존재하지 않음 생명 주기를 엔티티에 의존 공유하지 않는 것이 안전(복사해서 사용해야 함) 불변객체로 만드는 것이 안전 값 타입은 정말 값 타입이라 판단될 떄만 사용.엔티티와 값 타입을 혼동해서 엔티티를 값 타입으로 만들면 안됨.식별자가 필요하고, 지속해서 값을 추적, 변경해야 한다면 그것은 값 타입이 아닌 엔티티.참고 자바 ORM 표준 JPA 프로그래밍(김영한)" }, { "title": "Spring MVC - HTTP 응답 기본 기능", "url": "/posts/spring-mvc-04/", "categories": "Backend, Spring MVC", "tags": "Web, Spring Framework", "date": "2023-10-24 20:40:00 +0900", "snippet": "HTTP View Template 응답@RequestMapping(&quot;/response-view-v1&quot;)public ModelAndView responseView() { ModelAndView mav = new ModelAndView(&quot;response/hello&quot;) .addObject(&quot;data&quot;, &quot;hello!&quot;); return mav;}@RequestMapping(&quot;/response-view-v2&quot;)public String responseViewV2(Model model) { model.addAttribute(&quot;data&quot;, &quot;hello&quot;); return &quot;response/hello&quot;;}@RequestMapping(&quot;/response/hello&quot;)public void responseViewV3(Model model) { model.addAttribute(&quot;data&quot;, &quot;hello&quot;);}HTTP API, 메세지 바디에 값 응답@GetMapping(&quot;/response-body-string-v1&quot;)public void responseBodyV1(HttpServletResponse resp) throws IOException { resp.getWriter().write(&quot;ok&quot;);}/** * HttpEntity, ResponseEntity(Http Status 추가) * @return */@GetMapping(&quot;/response-body-string-v2&quot;)public ResponseEntity&amp;lt;String&amp;gt; responseBodyV2() { return new ResponseEntity&amp;lt;&amp;gt;(&quot;ok&quot;, HttpStatus.OK);}@ResponseBody@GetMapping(&quot;/response-body-string-v3&quot;)public String responseBodyV3() { return &quot;ok&quot;;}@GetMapping(&quot;/response-body-json-v1&quot;)public ResponseEntity&amp;lt;HelloData&amp;gt; responseJsonV1() { HelloData helloData = new HelloData(); helloData.setUsername(&quot;user&quot;); helloData.setAge(10); return new ResponseEntity&amp;lt;&amp;gt;(helloData, HttpStatus.OK);}@ResponseStatus(HttpStatus.OK)@ResponseBody@GetMapping(&quot;/response-body-json-v2&quot;)public HelloData responseJsonV2() { HelloData helloData = new HelloData(); helloData.setUsername(&quot;user&quot;); helloData.setAge(10); return helloData;} @Controller 대신에 @RestController 애노테이션을 사용하면 해당 컨트롤러에 모두 @ResponseBody가 적용되는 효과가 있음참고 스프링 MVC - 백엔드 웹 개발 핵심 기술(김영한)" }, { "title": "JPA - 프록시와 연관관계 관리(1)", "url": "/posts/spring-jpa-06/", "categories": "Backend, JPA", "tags": "Web, Spring Framework, DataBase, JPA", "date": "2023-10-24 16:30:00 +0900", "snippet": "프록시 em.find() vs em.getReference() em.find() : 데이터베이스를 통해서 실제 엔티티 객체 조회 em.getReference() : 데이터베이스 조회를 미루는 프록시 엔티티 객체 조회 프록시 객체 실제 클래스를 상속받아서 만들어짐 실제 클래스와 겉 모양이 같음 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용 가능 프록시 객체는 실제 객체의 참조(target)를 보관 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드 호출프록시 객체의 초기화Member member = em.getReference(Member.class, “id1”);member.getName(); em.getReference() 를 통해 프록시 객체를 반환받는 시점에는 데이터베이스에 조회를 하지 않음 getName() 메소드를 통해 실제 값을 얻어오는 시점에 데이터베이스를 조회하여 실제 Entity를 생성하여 값을 얻어옴프록시 객체의 특징 프록시 객체는 처음 사용할 떄 한번만 초기화 함 프록시 객체를 초기화 할떄, 프록시 객체가 실제 엔티티로 바뀌는것은 아님. 초기화 되면 프록시 객체를 통하여 실제 엔티티에 접근 가능 프록시 객체는 원본 엔티티를 상속받기 때문에 타입 체크시 주의해야 함 == 으로 비교하면 false 이므로 instance of 를 사용하여 비교해야 함 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환 반대로 이미 em.find() 를 통해 실제 객체를 조회하여 영속성 컨텍스트에 이미 존재하면, 이후에 em.getReference()를 호출해도 프록시 객체가 아닌 실제 엔티티를 반환 영속성 컨텍스트의 도움을 받을수 없는 준영속 상태일때, 프록시를 초기화 하면 문제 발생 하이버네이트의 경우 org.hibernate.LazyInitializationException 예외 발생 try { // 영속성 컨텍스트에 등록 Member member = new Member(); member.setName(&quot;member1&quot;); entityManager.persist(entityManager); // 준영속 상태로 전환 entityManager.detach(member); // entityManager.close(); // 프록시 객체 반환 Member findMember = entityManager.getReference(Member.class, member.getId()); // 메소드를 통해 실제 엔티티에 접근하려 할떄, // 이미 준영속 상태이므로 영속성 컨텍스트에 해당 엔티티가 등록되지 않음 // 하이버네이트의 경우 LazyInitializationException 예외 발생 findMember.getTeam(); transaction.commit();} catch (LazyInitializationException e) { transaction.rollback();} finally { entityManager.close();}프록시 관련 유틸리티 프록시 인스턴스의 초기화 여부 확인 PersistenceUnitUtil.isLoaded(Object entity) 프록시 클래스 확인 방법 entity.getClass().getName() 출력(..javasist.. or HibernateProxy…) 프록시 강제 초기화 org.hibernate.Hibernate.initialize(entity); JPA 표준은 강제 초기화 없으며 하이버네이트에서 제공하는 함수 즉시 로딩과 지연 로딩지연 로딩프록시를 이용하여 연관관계에 있는 다른 테이블의 정보를 추후 사용할떄 로딩하는 방법@Entitypublic class Member { ... @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = &quot;TEAM_ID&quot;) private Team team; ..} 프록시를 반환 Member member = em.find(Member.class, 1L) Team team = member.getTeam();team.getName(); // 실제 team을 사용하는 시점에 초기화(DB 조회)즉시 로딩엔티티를 조회할떄 해당 엔티티의 연관관계에 있는 모든 엔티티도 함께 조회하여 가져오는 방법@Entitypublic class Member { ... @ManyToOne(fetch = FetchType.EAGER) @JoinColumn(name = &quot;TEAM_ID&quot;) private Team team; ..} 프록시가 아닌 실제 엔티티를 반환 즉시 로딩이므로 Member 조회시 항상 Team도 조회 JPA 구현체는 가능하면 조인을 사용하여 SQL 한번에 함꼐 조회프록시와 즉시로딩의 주의점 가급적 지연 로딩만 사용 즉시 로딩을 적용하면 예상하지 못한 SQL이 발생 즉시 로딩은 JPQL에서 N+1 문제를 일으킴 JPQL은 SQL로 바로 치환되어 나감 @ManyToOne, @OneToOne을 기본이 즉시로딩이므로 연관관계를 매핑할떄 지연로딩으로 설정 필요 즉시 로딩 처럼 한번에 연관관계의 엔티티를 같이 조회하려면 아래와 같은 방법을 사용 JPQL fetch 조인 엔티티 그래프 기능 즉시 로딩사용시 JPQL N+1 문제 예시List&amp;lt;Member&amp;gt; members = em.createQuery(&quot;select m from Member m&quot;, Member.class) .getResultList(); 위와 같은 코드에서 JPQL “select m from Member m” 구문은 “select * from MEMBER” 와 같이 치환되어 적용 즉시로딩으로 연관관계가 매핑되었을시, member 만 조회하더라도 연관관계에 있는 엔티티도 조회하게됨 예를들어 Team 엔티티가 즉시로딩으로 연관관계일시, “select * from Team where TEAM_ID = xxx” 와 같은 쿼리도 같이 수행됨 위 코드의 반환은 List 이므로 위와 같은 연관관계 엔티티의 조회 쿼리도 얻어오는 List내의 크기만큼 수행됨 즉, Member의 리스트만 반환하려 했지만 불필요한 테이블 조회 쿼리도 리스트의 크기만큼 수행되는 문제 발생 모든 연관관계에 지연로딩을 사용하는 것을 권장함영속성 전이와 고아객체영속성 전이(CASCADE)특정 엔티티를 영속 상태로 만들 떄 연관된 엔티티도 함께 영속상태로 말들고 싶을 떄 사용 예) 부모 엔티티를 저장할떄 자식 엔티티도 함꼐 저장@OneToMany(mappedBy=&quot;parent&quot;, cascade=CascadeType.PERSIST) ALL : 모두 적용 PERSIST : 영속 REMOVE : 삭제 MERGE : 병합 REFRESH : REFRESH DETACH : DETACH영속성 전이 주의사항 영속성 전이는 연관관계를 매핑하는 것과 아무 상관없음 엔티티를 영속화할 떄 연관된 엔티티도 함꼐 영속화하는 편리함을 제공하는 깃 child의 소유가 parent 에게만 있을때 사용 하나의 child 클래스에 대하여 여러 parent(ParentA 클래스, ParentB 클래스 등)가 참조하고 있을때는 사용하면 안됨 여러 곳에서 child에 대한 리이프사이클을 관리하게 되어 유지보수에 어려움이 있음 고아 객체고아 객체 제거 : 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제@OneToMany(mappedBy=&quot;parent&quot;, orphanRemoval=true)...Parent parent1 = em.find(Parent.class, id);// 자식 엔티티를 컬렉션에서 제거// DELETE FROM CHILD WHERE ID=?parent1.getChildren().remove(0);고아 객체 주의점 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고자 객체로 보고 삭제하는 기능 참조하는 곳이 하나일 떄 사용해야함 특정 엔티티가 개인 소유할 때 사용 @OneToOne, @OneToMany 만 사용가능 개념적으로 부모를 제거하면 자식은 고아가 됨.따라서 고아 객체 제거 기능을 활성화 하면, 부모를 제거할 떄 자식도 함께 제거가 됨.이는 CascadeType.REMOVE 처럼 동작함영속성 전이 + 고아 객체, 생명주기cascade와 orphanRemoval 두 옵션 모두 활성화 하면 부모 엔티티를 통하여 자식의 생명주기를 관리할 수 있음 스스로 생명주기를 관리하는 엔티티는 em.persist()로 영속화, em.remove()로 제거 도메인 주도 설계(DDD)의 Aggregate Root 개념을 구현할 떄 유용함@OneToMany(mappedBy=&quot;parent&quot;, cascade=CascadeType.All, orphanRemoval=true)참고 자바 ORM 표준 JPA 프로그래밍(김영한)" }, { "title": "JPA - 고급 매핑", "url": "/posts/spring-jpa-05/", "categories": "Backend, JPA", "tags": "Web, Spring Framework, DataBase, JPA", "date": "2023-10-24 15:30:00 +0900", "snippet": "상속관계 매핑 관계형 데이터베이스는 상속관계가 없고, 슈퍼타입, 서브타입 관계라는 모델링 기법이 객체 상속과 유사 함 상속관계 매핑은 결국 객체의 상속 구조와 데이터베이스의 슈퍼타입, 서브타입 관계를 매핑하는 것슈퍼타입, 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법은 크게 3가지가 있음 각각 테이블로 변환 -&amp;gt; 조인 전략 통합 테이블로 변환 -&amp;gt; 단일 테이블 전략 서브타입 테이블로 변환 -&amp;gt; 구현 클래스마다 테이블 전략JPA 에서 위와 같은 상속관계 매핑에 쓰이는 주요 어노테이션은 아래와 같음 @Inheritance(strategy=Inheritance.XXX) JOINED : 조인전략 SINGLE_TABLE : 단일 테이블 전략 TABLE_PER_CLASS : 구현 클래스마다 테이블 전략 @DiscriminatorColumn(name=”DTYPE”) @DiscriminatorValue(“XXX)조인 전략서브타입 테이블을 만들어 FK로 서로 연결하고 조인을 통하여 테이블을 조회하록 하는 전략 장점 테이블 정규화 외래키 참조 무결성 제약조건 활용 가능 저장공간 효율화 단점 조회시 조인을 많이 사용하여 성능 저하 조회 쿼리가 복잡함 슈퍼타입 테이블과 서브타입 테이블에 각각 데이터를 저장해야 하므로 데이터 저장시 INSERT SQL 2번 호출 싱글 테이블 전략서브타입 테이블의 스키마들을 모두 합쳐 하나의 테이블로 구성하는 전략 장점 조인이 필요없으므로 일반적으로 조회 성능이 빠름 조회 쿼리가 단순함 단점 자식 엔티티가 매핑한 컬럼은 모두 null을 허용 단일 테이블에 모든것을 저장하므로 테이블이 커질 수 있음 상황에 따라 조회 성능이 오히려 느려질 수 있음 구현 클래스마다 테이블 전략슈퍼타입의 테이블 없이 서브타입 테이블로만 구성하는 전략 이 전략은 데이터베이스 설계자와 개발자 모두에게 추천하지 않는 전략 장점 서브 타입을 명확하게 구분해서 처리할때 효과적 not null 제약조건 사용 가능 단점 여러 자식 테이블을 함꼐 조회할떄 성능이 느림(UNION SQL 필요) 자식 테이블을 통합하여 쿼리하기 어려움 @MappedSuperclass공통 매핑 정보가 필요할 떄 사용(id, name과 같은 정보) 예) 모든 테이블에 timestamp 스키마가 있어야 한다는 정책이 있는 경우 상속관계 매핑이 아님 엔티티가 아님 테이블과 매핑하지 않음 부모 클래스를 상속받는 자식 클래스에 매필 정보만 제공 조회, 검색 불가(em.find(…) 불가) 직접 생성해서 사용할 일이 없으므로 추상 클래스 권장 테이블과는 관계없고 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할 주로 등록일, 수정일, 등록자, 수정자와 같은 전체 엔티티에서 공통적으로 적용하는 정보를 모을때 사용 @Entity 클래스는 엔티티나 @MappedSuperclass로 지정한 클래스만 상속가능참고 자바 ORM 표준 JPA 프로그래밍(김영한)" }, { "title": "JPA - 다양한 연관관계 매핑", "url": "/posts/spring-jpa-04/", "categories": "Backend, JPA", "tags": "Web, Spring Framework, DataBase, JPA", "date": "2023-10-24 14:00:00 +0900", "snippet": "연관관계 매핑시 고려사항 3가지 다중성 단방향, 양방향 연관관계의 주인다중성 다대일 : @ManyToOne 일대다 : @OneToMany 일대일 : @OneToOne 다대디 : @ManyToMany단방향, 양방향 테이블 외래키 하나로 양쪽 조인 가능 사실 방향이라는 개념이 없음 객체 참조용 필드가 있는 쪽으로만 참조 가능 한쪽만 참조하면 단방향 양쪽이 서로 참조하면 양방향 연관관예의 주인 테이블은 외래키 하나로 두 테이블이 연관관계를 맺음 객체 양방향 관계는 A-&amp;gt;B, B-&amp;gt;A 처럼 참조가 2군데 존재 객체 양방향 관계는 참조가 2둔데 존재하기 떄문에 둘중 곳에 어느 테이블의 외래키를 관리해야 할건지 지정해야 함 연관관계의 주인 : 외래키를 관리하는 참조 주인의 반대편 : 외래키에 영향을 주지 않음. 단순 조회만 가능다대일(N:1)다대일 단방향 가장 많이 사용하는 연관관계 다애일의 반대는 일대다다대일 양방향 외래키가 있는 쪽이 연관관계의 주인 양쪽을 서로 참조하도록 개발일대다(1:N)일대다 단방향 일대다 단방향은 일대다(1:N)에서 일(1)이 연관관계의 주인 테이블의 일대다 관계는 항상 다(N) 쪽에 외래키가 있음 객체와 테이블의 차이 때문에 반대편 테이블의 외래키를 관리하는 특이한 구조 @JoinColumn을 반드시 사용해야함. 그렇지 않으면 조인 테이블 방식을 사용함(중간에 테이블을 하나 추가함) 일대다 단방향 매핑의 단점 엔티티가 관리하는 외래키가 다른 테이블에 있음 연관관계 관리를 위해 JPA에서 추가로 Update SQL을 실행 함 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하는 것이 좋음일대다 양방향 이러한 매핑은 공식적으로는 존재하지 않음 @JoinCloumn(insertable = false, updatable = false) 를 통하여 강제로 읽기 전용 으로 설정하여 양방향 처럼 사용하는 방법 이러한 방법보다는 다대일 양방향을 사용하는 것이 좋음일대일(1:1) 일대일 관계의 반대는 그대로 일대일 주 테이블이나 대상 테이블 중에 외래키 선택 가능 주 테이블에 외래키 대상 테이블에 외래키 외래키에 데이터베이스 유니크(UNI) 제약조건 추가주테이블에 외래키 일떄 일대일 단방향 다대일(@ManyToOne) 단방향 매핑과 유사주테이블에 외래키 일떄 일대일 양방향 대디일 양방향 매핑처럼 외래키가 있는 곳이 연관관계의 주인 반대편은 mappedBy 사용대상테이블에 외래키 일떄 일대일 단방향 JPA 에서 지원하지 않음대상테이블에 외래키 일떄 일대일 양방향 일대일 주 테이블에 외래키 양뱡향과 매핑방법은 같음일대일 관계에서의 매핑 정리 주 테이블에 외래키 주 객체가 대상 객체의 참조를 가지는 것 처럼 주 테이블에 외래키를 두고 대상 테이블을 찾음 객체지향 개발자가 선호 JPA 매핑 편리 장점 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능 단점 값이 없으면 외래키에 null 허용해야 함 대상 테이블에 외래키 대상 테이블에 외래 키가 존재 전통적인 데이터베이스 개발자 선호 장점 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 떄 테이블 구조 유지 단점 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨 다대다(N:M) 관게형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없음 연결 테이블을 추가하여 일대다, 다대일 관계로 풀어야함 객체는 컨렉션을 이용하여 객체 2개로 다대다 관계 표현 가능 @ManyToMay 사용 @JoinTable로 연결 테이블 지정 단방향, 양방향 매핑 가능다대다 매핑의 한계 편리해 보이지만 실무에서는 사용하지 않는것이 좋음 연결 테이블이 단순히 연결하고 끝나는 것이 아닌, 추후 수정으로 인하여 스키마가 추가되거나 지워일수 있음 기존 단순한 연결테이블에서 ORDERAMOUNT, ORDERDATE 가 추가됨다대다 한계 극복 연결 테이블용 엔티티 추가(연결 테이블을 엔티티로 승격) @ManyToMany -&amp;gt; @OneToMany, @ManyToOne 으로 나누어 적용참고 자바 ORM 표준 JPA 프로그래밍(김영한)" }, { "title": "JPA - 연관관계 매핑", "url": "/posts/spring-jpa-03/", "categories": "Backend, JPA", "tags": "Web, Spring Framework, DataBase, JPA", "date": "2023-10-24 10:30:00 +0900", "snippet": "연관관계가 필요한 이유객체를 테이블에 맞추어 데이터 중심으로 모델링 하면, 협력관계를 만들 수 없음 데이블은 외래키로 조인을 사용해서 연관된 테이블을 찾음 객체는 참조를 사ㅇ해서 연관된 객체를 찾음 데이블과 객체 사이에는 이런 큰 간격이 존재 함단방향 연관관계어느 한쪽만이 다른쪽을 소유하고 있는 관계.객체의 참조와 테이블의 외래키를 매핑.@Entitypublic class Team { @Id @GeneratedValue @Column(name = &quot;TEAM_ID&quot;) private Long id; private String name;}@Entitypublic class Member { @Id @GeneratedValue @Column(name = &quot;MEMBER_ID&quot;) private Long id; @Column(name = &quot;USERNAME&quot;) private String name; // 객체의 참조와 테이블의 FK를 매핑 @ManyToOne @JoinColumn(name = &quot;TEAM_ID&quot;) private Team team;}양방향 연관관계어느 한쪽만이 다른쪽을 소유하고 있는 관계가 아닌 서로 참조하는 관계@Entitypublic class Team { @Id @GeneratedValue @Column(name = &quot;TEAM_ID&quot;) private Long id; private String name; @OneToMany(mappedBy = &quot;team&quot;) private List&amp;lt;Member&amp;gt; members = new ArrayList&amp;lt;&amp;gt;();}@Entitypublic class Member { @Id @GeneratedValue @Column(name = &quot;MEMBER_ID&quot;) private Long id; @Column(name = &quot;USERNAME&quot;) private String name; @ManyToOne @JoinColumn(name = &quot;TEAM_ID&quot;) private Team team;}...//조회Team findTeam = em.find(Team.class, team.getId());int memberSize = findTeam.getMembers().size(); //역방향 조회양방향 연관관계객체와 테이블이 관계를 맺는 차이테이블의 경우, 외래키로 두 테이블이 묶여 있을 떄 해당 외래키를 이용 하여 조인하면 값을 확인할 수 있음. 즉, 테이블은 방향이라는 개념이 따로 없으며 굳이 정하자면 외래키를 통하여 서로간 양방향 관계라고 볼 수 있음.그러나 객체 참조의 경우 클래스의 필드에 타 클래스의 참조가 존재하지 않는한 참조관계가 성립되지 않고, 참조하고 있는 클래스만이 단방향으로 관계를 맺고 있음.즉, 참조에서 양방향관계를 맺기 위해선 서로간 참조를 실제로 소유하고 있어야 함. 그러므로 양방향 관계라고 하더라도 사실상 단방향 관계가 두개가 있는 형상임 객체가 양방향 연관관계 일때의 세부 연관관계 = 2개 회원 -&amp;gt; 팀 연관관계 1개(단방향) 팀 -&amp;gt; 회원 연관관계 1개(단방향) 테이블 양방향 연관관계 일때의 세부 연관관계 = 1개 회원 &amp;lt;-&amp;gt; 팀의 연관관계 1개(양방향) 객체의 양방향 관계 객체의 양방향 관계는 사싱 양방향 관계가 아니라 서로다른 2개의 단방향 관계의 조합 임 객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야함class A { B b;}class B { A a;}테이블의 양방향 관계 테이블은 외래 키 하나로 두 테이블의 연관관계를 관리 외래키 하나로 인하여 양방향 연관관계를 가짐-- MEMBER.TEAM_ID 외래키 하나로 양방향 연관관계를 가짐-- (양쪽으로 조인할 수 있음)SELECT *FROM MEMBER MJOIN TEAM T ON M.TEAM_ID = T.TEAM_IDSELECT *FROM TEAM TJOIN MEMBER M ON T.TEAM_ID = M.TEAM_ID연관관계의 주인결국 객체에선 양방향 관계에선 결국 2개의 단방향 관계가 성립되므로 어느 한쪽이 외래키를 매핑하여 관리할 것인지 지정해 주어야 함양방향 매핑 규칙 객체의 두 관계중 하나를 연관관계의 주인으로 지정 연관관예의 주인만이 외래 키를 관리(등록, 수정) 주인이 아닌 쪽은 읽기만 가능 주인은 mappedBy 속성을 사용하면 안됨 주인이 아니면 mappedBy 속성을 사용하여 주인을 지정해야 함주인 선정 기준 외래키가 있는 곳을 주인으로 선택하는 방법이 좋음 아래 그림의 예에선 Member.team이 연관관계의 주인으로 선정양방향 연관관계에서의 주의점연관관계의 주인에 값을 입력하지 않는 경우Team team = new Team();team.setName(&quot;TeamA&quot;);em.persist(team);Member member = new Member();member.setName(&quot;member1&quot;);//역방향(주인이 아닌 방향)만 연관관계 설정team.getMembers().add(member);em.persist(member);양방향 매핑시 연관관계의 주인에 값을 입력해야함Team team = new Team();team.setName(&quot;TeamA&quot;);em.persist(team);Member member = new Member();member.setName(&quot;member1&quot;);team.getMembers().add(member);//연관관계의 주인에 값 설정member.setTeam(team);em.persist(member); commit() 시점에 실제 쿼리가 적용되고 이전에는 영속성 컨텍스트의 1차 캐시에만 객체가 저장되어 있는 상태 해당 상황에서 연관관계의 주인에만 값을 설정하게 되면 flush(), clear()와 같이 바로 쿼리를 적용하지 않는이상 하나의 트랜잭션 내에서 주인이 아닌 쪽에는 값이 설정되지 않은 상태가 됨주의점 정리 순수 객체 상태를 고려하여 항상 양쪽에 값을 설정해야 함 연관관계 편의 메소드를 생성하도록 함 양방향 매핑시에 무한루프를 조심해야 함 예) toString(), lombok, JSON 생성 라이브러리 Controller 에서 Entity를 바로 반환하지 않도록 해야 함Controller 에서 Entity를 바로 반환시 JSON 으로 변환하는 과정에서 무한루프에 빠질수 있으며, 무엇보다 Entity 수정시 API 도한 수정이 발생하여 정합을 다시 해야하는 문제가 발생함.그러므로 되도록이면 Entity를 바로 반환하는 것이 아닌 단순 데이터가 있는 DTO로 변환하여 반환하는것이 좋음.양방향 매핑 정리 단방향 매핑만으로도 이미 연관관계 매핑을 완료 되도록이면 양방향 매핑을 피하는 설계가 좋음 양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것 뿐 JPQL에서 영방향으로 탐색할 일이 많음 단방향 매핑을 잘 하고 양방향은 필요할 떄 추가해도 됨(테이블에 영향을 주지 않음) 비지니스 로직을 기준으로 연관관계의 주인을 선택하는 것이 아닌 외래키의 위치를 기준으로 연관관계의 주인을 정해야 함참고 자바 ORM 표준 JPA 프로그래밍(김영한)" }, { "title": "Spring MVC - HTTP 요청 기본 기능", "url": "/posts/spring-mvc-03/", "categories": "Backend, Spring MVC", "tags": "Web, Spring Framework", "date": "2023-10-23 22:40:00 +0900", "snippet": "HTTP 요청 - 기본@RequestMapping(&quot;/hello-basic&quot;)public String helloBasic() { log.info(&quot;MappingController.helloBasic&quot;); return &quot;ok&quot;;}@RequestMapping(value = &quot;/mapping-get-v1&quot;, method = RequestMethod.GET)public String mappingGetV1() { log.info(&quot;MappingController.mappingGetV1&quot;); return &quot;ok&quot;;}@GetMapping(&quot;/mapping-get-v2&quot;)public String mappingGetV2() { log.info(&quot;MappingController.mappingGetV2&quot;); return &quot;ok&quot;;}@GetMapping(&quot;/mapping/{userId}&quot;)public String mappinPathV1(@PathVariable(&quot;userId&quot;) String data) { log.info(&quot;mappinPathV1 userId={}&quot;, data); return &quot;ok&quot;;}@GetMapping(&quot;/mapping/{userId}&quot;)public String mappinPathV2(@PathVariable String userId) { log.info(&quot;mappinPathV2 userId={}&quot;, userId); return &quot;ok&quot;;}@GetMapping(&quot;/mapping/users/{userId}/orders/{orderId}&quot;)public String mappinPathV3(@PathVariable String userId, @PathVariable Long orderId) { log.info(&quot;mappinPathV3 userId={} orderId={}&quot;, userId, orderId); return &quot;ok&quot;;}// mode=debug 이라는 파라미터 문자열이 있어야 호출@GetMapping(value = &quot;/mapping-param&quot;, params = &quot;mode=debug&quot;)public String mappingParam() { log.info(&quot;mappingParam&quot;); return &quot;ok&quot;;}// HTTP header에 mode=debug 값이 있어야 호출@GetMapping(value = &quot;/mapping-header&quot;, headers = &quot;mode=debug&quot;)public String mappingHeader() { log.info(&quot;mappingHeader&quot;); return &quot;ok&quot;;}// HTTP header에 Content-Type 이 application/json 이어야 호출@PostMapping(value = &quot;/mapping-consume&quot;, consumes = &quot;application/json&quot;)public String mappingConsumes() { log.info(&quot;mappingConsumes&quot;); return &quot;ok&quot;;}// HTTP header에 Accept 가 text/html 이어야 호출@PostMapping(value = &quot;/mapping-produce&quot;, produces = &quot;text/html&quot;)public String mappingProduces() { log.info(&quot;mappingProduces&quot;); return &quot;ok&quot;;}HTTP 요청 - 헤더 조회@RequestMapping(&quot;/headers&quot;)public String headers(HttpServletRequest req, HttpServletResponse resp, HttpMethod httpMethod, Locale locale, @RequestHeader MultiValueMap&amp;lt;String, String&amp;gt; headerMap, @RequestHeader(&quot;host&quot;) String host, @CookieValue(value = &quot;myCookie&quot;, required = false) String cookie) { log.info(&quot;request={}&quot;, req); log.info(&quot;response={}&quot;, resp); log.info(&quot;httpMethod={}&quot;, httpMethod); log.info(&quot;locale={}&quot;, locale); log.info(&quot;headerMap={}&quot;, headerMap); log.info(&quot;header host={}&quot;, host); log.info(&quot;myCookie={}&quot;, cookie); return &quot;ok&quot;;}HTTP 요청 파라미터 - 쿼리 파라미터, HTML Form, @RequestParam@RequestMapping(&quot;/request-mapping&quot;)public void requestParamV1(HttpServletRequest req, HttpServletResponse resp) throws IOException { String username = req.getParameter(&quot;username&quot;); int age = Integer.parseInt(req.getParameter(&quot;age&quot;)); log.info(&quot;username={}, age={}&quot;, username, age); resp.getWriter().write(&quot;ok&quot;);}@ResponseBody@RequestMapping(&quot;/request-mapping-v2&quot;)public String requestParamV2( @RequestParam(&quot;username&quot;) String memberName, @RequestParam(&quot;age&quot;) int memberAge) { log.info(&quot;username={}, age={}&quot;, memberName, memberAge); return &quot;ok&quot;;}@ResponseBody@RequestMapping(&quot;/request-mapping-v3&quot;)public String requestParamV3(@RequestParam String username, @RequestParam int age) { log.info(&quot;username={}, age={}&quot;, username, age); return &quot;ok&quot;;}@ResponseBody@RequestMapping(&quot;/request-mapping-v3&quot;)public String requestParamV4(String username, int age) { log.info(&quot;username={}, age={}&quot;, username, age); return &quot;ok&quot;;}// 파라미터 필수 여부// 필수 값이 true일때 해당 파라미터가 없는 요청이면 Bad Request 에러 반환// 필수 값이 false 일때 해당 파라미터가 없는 요청이면 해당 변수는 null로 넘어옴@ResponseBody@RequestMapping(&quot;/request-param-requeired&quot;)public String requestParamRequired( @RequestParam(required = true) String username, @RequestParam(required = false) Integer age) { log.info(&quot;username={}, age={}&quot;, username, age); return &quot;ok&quot;;}// 파라미터 기본값 설정@ResponseBody@RequestMapping(&quot;/request-param-defult&quot;)public String requestParamDefault( @RequestParam(required = true, defaultValue = &quot;guest&quot;) String username, @RequestParam(required = false, defaultValue = &quot;-1&quot;) int age) { log.info(&quot;username={}, age={}&quot;, username, age); return &quot;ok&quot;;}// 파라미터를 Map 으로 전달 받기@ResponseBody@RequestMapping(&quot;/request-param-map&quot;)public String requestParamMap(@RequestParam Map&amp;lt;String, Object&amp;gt; paramMAp) { log.info(&quot;username={}, age={}&quot;, paramMAp.get(&quot;username&quot;), paramMAp.get(&quot;age&quot;)); return &quot;ok&quot;;}HTTP 요청 파라미터 - @ModelAttribute// @ModelAttribute 사용시 각 필드의 getter, setter 필요@Datapublic class HelloData { private String username; private int age;}...@ResponseBody@RequestMapping(&quot;/model-attribute-v1&quot;)public String modelAttributeV1(@ModelAttribute HelloData helloData) { log.info(&quot;username={}, age={}&quot;, helloData.getUsername(), helloData.getAge()); return &quot;ok&quot;;}@ResponseBody@RequestMapping(&quot;/model-attribute-v2&quot;)public String modelAttributeV2(HelloData helloData) { log.info(&quot;username={}, age={}&quot;, helloData.getUsername(), helloData.getAge()); return &quot;ok&quot;;}HTTP 요청 메세지 - 단순 텍스트@PostMapping(&quot;/request-body-string-v1&quot;)public void requestBodyStringV1(HttpServletRequest res, HttpServletResponse resp) throws IOException { ServletInputStream inputStream = res.getInputStream(); String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); log.info(&quot;messageBody={}&quot;, messageBody); resp.getWriter().write(&quot;ok&quot;);}/** * InputStream(Reader): HTTP 요청 메시지 바디의 내용을 직접 조회 * OutputStream(Writer): HTTP 응답 메시지의 바디에 직접 결과 출력 */@PostMapping(&quot;/request-body-string-v2&quot;)public void requestBodyStringV2(InputStream inputStream, Writer responseWriter) throws IOException { String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); log.info(&quot;messageBody={}&quot;, messageBody); responseWriter.write(&quot;ok&quot;);}/** * HttpEntity: HTTP header, body 정보를 편리하게 조회 * - 메시지 바디 정보를 직접 조회(@RequestParam X, @ModelAttribute X) * - HttpMessageConverter 사용 -&amp;gt; StringHttpMessageConverter 적용 * * 응답에서도 HttpEntity 사용 가능 * - 메시지 바디 정보 직접 반환(view 조회X) * - HttpMessageConverter 사용 -&amp;gt; StringHttpMessageConverter 적용 */@PostMapping(&quot;/request-body-string-v3&quot;)public HttpEntity&amp;lt;String&amp;gt; requestBodyStringV3(HttpEntity&amp;lt;String&amp;gt; httpEntity) { String messageBody = httpEntity.getBody(); log.info(&quot;messageBody={}&quot;, messageBody); return new HttpEntity&amp;lt;&amp;gt;(&quot;ok&quot;);}/** * @RequestBody * - 메시지 바디 정보를 직접 조회(@RequestParam X, @ModelAttribute X) * - HttpMessageConverter 사용 -&amp;gt; StringHttpMessageConverter 적용 * * @ResponseBody * - 메시지 바디 정보 직접 반환(view 조회X) * - HttpMessageConverter 사용 -&amp;gt; StringHttpMessageConverter 적용 */@ResponseBody@PostMapping(&quot;/request-body-string-v4&quot;)public String requestBodyStringV4(@RequestBody String messageBody) { log.info(&quot;messageBody={}&quot;, messageBody); return &quot;ok&quot;;}HTTP 요청 메세지 - JSON@Datapublic class HelloData { private String username; private int age;}...@Slf4j@Controllerpublic class RequestBodyJsonController { private ObjectMapper objectMapper = new ObjectMapper(); /** * {&quot;username&quot;:&quot;hello&quot;, &quot;age&quot;:20} * content-type: application/json */ @PostMapping(&quot;/request-body-json-v1&quot;) public void requestBodyJsonV1(HttpServletRequest req, HttpServletResponse resp) throws IOException { ServletInputStream inputStream = req.getInputStream(); String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); log.info(&quot;messageBody={}&quot;, messageBody); HelloData data = objectMapper.readValue(messageBody, HelloData.class); log.info(&quot;username={}, age={}&quot;, data.getUsername(), data.getAge()); resp.getWriter().write(&quot;ok&quot;); } /** * @RequestBody * HttpMessageConverter 사용 -&amp;gt; StringHttpMessageConverter 적용 * * @ResponseBody * - 모든 메서드에 @ResponseBody 적용 * - 메시지 바디 정보 직접 반환(view 조회X) * - HttpMessageConverter 사용 -&amp;gt; StringHttpMessageConverter 적용 */ @ResponseBody @PostMapping(&quot;/request-body-json-v2&quot;) public String requestBodyJsonV2(@RequestBody String messageBody) throws IOException { log.info(&quot;messageBody={}&quot;, messageBody); HelloData data = objectMapper.readValue(messageBody, HelloData.class); log.info(&quot;username={}, age={}&quot;, data.getUsername(), data.getAge()); return &quot;ok&quot;; } /** * @RequestBody 생략 불가능(@ModelAttribute 가 적용되어 버림) * HttpMessageConverter 사용 -&amp;gt; MappingJackson2HttpMessageConverter (content- * type: application/json) */ @ResponseBody @PostMapping(&quot;/request-body-json-v3&quot;) public String requestBodyJsonV3(@RequestBody HelloData data) { log.info(&quot;username={}, age={}&quot;, data.getUsername(), data.getAge()); return &quot;ok&quot;; } @ResponseBody @PostMapping(&quot;/request-body-json-v4&quot;) public String requestBodyJsonV4(HttpEntity&amp;lt;HelloData&amp;gt; httpEntity) { HelloData data = httpEntity.getBody(); log.info(&quot;username={}, age={}&quot;, data.getUsername(), data.getAge()); return &quot;ok&quot;; } /** * @RequestBody 생략 불가능(@ModelAttribute 가 적용되어 버림) * HttpMessageConverter 사용 -&amp;gt; MappingJackson2HttpMessageConverter (content- type: application/json) * * @ResponseBody 적용 * - 메시지 바디 정보 직접 반환(view 조회X) * - HttpMessageConverter 사용 -&amp;gt; MappingJackson2HttpMessageConverter 적용 (Accept: application/json) */ @ResponseBody @PostMapping(&quot;/request-body-json-v5&quot;) public HelloData requestBodyJsonV5(@RequestBody HelloData data) { log.info(&quot;username={}, age={}&quot;, data.getUsername(), data.getAge()); return data; }} HTTP 요청시에 header의 content-type이 application/json 이여야 json을 처리할 수 있는 HTTP 메세지 컨버터가 실행 됨참고 스프링 MVC - 백엔드 웹 개발 핵심 기술(김영한)" }, { "title": "JPA - 엔티티 매핑", "url": "/posts/spring-jpa-02/", "categories": "Backend, JPA", "tags": "Web, Spring Framework, DataBase, JPA", "date": "2023-10-23 14:30:00 +0900", "snippet": "엔티티 매핑 객체와 테이블 매핑 @Entity, @Table 필드와 컬럼 매핑 @Column 기본 키 매핑 @Id 연관관계 매핑 @ManyToOne, @JoinColumn 객체와 테이블 매핑@Entity @Entity가 붙는 클래스는 JPA가 관리하며 엔티티라고 불림 JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 어노테이션이 필수 주의 사항 기본 생성자가 필수(파라미터가 없는 public 혹은 protected 생성자) final 클래스, enum, interface, inner 클래스에 사용 불가 저장할 필드에 final 키워드 사용 불가 @Table@Table은 엔티티와 매핑할 테이블을 지정 속성 기능 기본값 name 매핑할 테이블 이름 엔티티 이름을 사용 catalog 데이터베이스 catalog 매핑   schema 데이터베이스 schema 매핑   uniqueConstraints(DDL) DDL 생성 시에 유니크 제약 조건 생성   데이버베이스 스키마 자동 생성DDL을 어플리케이션 실행 시점에 자동 생성 테이블 중심 -&amp;gt; 객체 중심 데이터베이스 방언을 활용하여 각 데이터베이스 제품별로 맞는 DDL을 생성 생성된 DDL은 반드시 개발 장비에서만 사용 생성된 DDL은 운영서버에 사용하지 않거나 적절히 다듬은 후 사용 DDL 생성기능은 DDL을 자동 생성할 떄만 사용되고 JPA의 실행 로직에는 영향을 주지 않음데이터베이스 스키마 자동 생성의 속성들&amp;lt;!-- maven --&amp;gt;&amp;lt;!-- resources/META-INF --&amp;gt;&amp;lt;properties&amp;gt; &amp;lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;create&quot; /&amp;gt;&amp;lt;/properties&amp;gt; 옵션 설명 create 기존테이블 삭제 후 다시 생성(DROP + CREATE) create-drop create와 같으나 종료시점에 테이블 DROP update 변경분만 반영(운영DB에는 사용하면 안됨) validate 엔티티와 테이블이 정상 매핑되었는지만 화인 none 사용하지 않음 데이버베이스 스키마 자동 생성의 주의 사항 운영 장비에는 정대 create, create-dop, update 속성을 사용하면 안됨 운영하는 데이터베이스의 데이터가 날라감 개발 초기 단계는 create 또는 update 테스트 서버는 update 또는 validate 스테이징과 운영서버는 validate 또는 none필드와 컬럼 매핑@Entitypublic class Member { @Id private Long id; @Column(name = &quot;name&quot;) private String username; private Integer age; @Enumerated(EnumType.STRING) private RoleType roleType; @Temporal(TemporalType.TIMESTAMP) private Date createdDate; @Temporal(TemporalType.TIMESTAMP) private Date lastModifiedDate; @Lob private String description; ...}매핑 어노테이션 정리 어노테이션 설명 @Column 컬럼 매핑 @Temporal 날짜 타입 매핑 @Enumerated enum 타입 매핑 @Lob BLOB, CLOB 매핑 @Transient 특정 필드를 컬럼에 매핑하지 않음(매핑 무시) @Column 속성 설명 기본값   name 필드와 매핑할 테이블의 컬럼 이름 객체의 필드 이름   insertable, updatable 등록, 변경 가능 여부 TRUE nullable(DDL) null 값의 허용 여부를 설정한다. false로 설정하면 DDL 생성 시에 not null 제약조건이 붙는다.     unique(DDL) @Table의 uniqueConstraints와 같지만 한 컬럼에 간단히 유니크 제약조건을 걸 때 사용한다.     columnDefinition(DDL) 데이터베이스 컬럼 정보를 직접 줄 수 있다. ex) varchar(100) default ‘EMPTY’ 필드의 자바 타입과 방언 정보를 사용 length(DDL) 문자 길이 제약조건. String 타입에만 사용한다. 255   precision, scale(DDL) BigDecimal 타입에서 사용한다(BigInteger도 사용할 수 있다). precision은 소수점을 포함한 전체 자릿수를, scale은 소수의 자릿수다. 참고로 double, float 타입에는 적용되지 않는다. 아주 큰 숫자나 정밀한 소수를 다루어야 할 때만 사용한다. precision=19, scale=2   @Enumerated자바 enum 타입을 매핑할 때 사용. 속성 설명 기본값 value EnumType.ORDINAL: enum 순서를 데이터베이스에 저장. EnumType.STRING: enum 이름을 데이터베이스에 저장 EnumType.ORDINAL ORDINAL의 경우 데이터베이스의 필드에 값이 숫자로 저장되기 떄문에 값을 추론하기 어려움이 있으며 가장 큰 문제는 enum에 값이 추가되었을때 지정되는 숫자가 밀리려서 지정되기 떄문에, 같은 enum의 필드를 저장해도 데이터베이스에 저장되어 있는 값과 다를수가 있음 ORDINAL 보다는 STRING 을 사용하는 것이 좋음@Temporal날짜 타입(java.util.Date, java.util.Caledar)을 매핑할 떄 사용 최신 하이버네이트 사용시에는 LocalData, LocalDataTime을 사용할 때는 생략 가능 속성 설명 기본값 value TemporalType.DATE: 날짜, 데이터베이스 date 타입과 매핑(예: 2013–10–11) TemporalType.TIME: 시간, 데이터베이스 time 타입과 매핑 (예: 11:11:11) TemporalType.TIMESTAMP: 날짜와 시간, 데이터베이스 timestamp 타입과 매핑(예: 2013–10–11 11:11:11)   @Lob데이터베이스 BLOB, CLOB 타입과 매핑 @LOB에는 지정할 수 있는 속석이 없음 매핑하는 필드 타입이 문자면 CLOB, 나머지는 BLOB 매핑 CLOB : String, char[]. java.sql.CLOB BLOB : byte[], java.sql.BLOB @Transient 필드 매핑을 하지 않음 데이터베이스에 저장 및 조회를 하지 않음 주로 메모리상에만 임시로 어떤 값을 보관하기 위해 사용기본 키 매핑 직접 할당 : @Id만 사용 자동 할당(@GeneratedValue) IDENTITY 데이터베이스에 위임 MySQL SEQUENCE 데이터베이스 시퀀스 오브젝트 사용 Oracle @SequenceGenerator 필요 TABLE 키 생성용 테이블 사용 모든 DB에서 사용 @TableGenerator 필요 AUTO 데이터베이스 방언에 따라 지정 기본값 IDENTITY 전략 기본 키 생성을 데이터베이스에 위임 주로 MySQL, PostgreSQL, SQL Server, DB2에서 사용 MySQL의 AUTO_INCREMENT AUTO_INCREMENT는 데이터베이스에 INSERT SQL을 실행한 이후에 ID 값을 알 수 있기 때문에 JPA는 보통 트랜잭션 커밋 시점에 INSERT SQL 실행하지만 IDENTITY 전략은 예외적으로 em.persis() 시점에 즉시 INSERT SQL 실행하고 데이터베이스에서 식별자를 조회해 옴@Entitypublic class Member { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id;}SEQUENCE 전략 데이터베이스 시퀀스는 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트를 사용 예를 들면 오라클 시퀀스가 있음 오라클, PostgreSQL, DB2, H2 데이터베이스에서 사용@Entity@SequenceGenerator( name = &quot;MEMBER_SEQ_GENERATOR&quot;, sequenceName = &quot;MEMBER_SEQ&quot; // 매핑할 데이터베이스 시퀀스 이름 initialValue = 1, allocationSize = 1)public class Member { @Id @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = &quot;MEMBER_SEQ_GENERATOR&quot;) private Long id;}SEQUENCE - @SequenceGenerator 속성 속성 설명 기본값 name 식별자 생성기 이름 필수 sequenceName 데이터베이스에 등록되어 있는 시퀀스 이름 hibernate_sequence initialValue DDL 생성 시에만 사용됨. 시퀀스 DDL을 생성할 때 처음 1 시작하는 수를 지정한다. 1 allocationSize 시퀀스 한 번 호출에 증가하는 수(성능 최적화에 사용됨). 데이터베이스 시퀀스 값이 하나씩 증가하도록 설정되어 있으면 이 값을 반드시 1로 설정해야 한다 50 catalog, schema 데이터베이스 catalog, schema 이름   allocationSize 속성을 통한 성능 최적화allocationSize 속성에 적용된 값만큼 다음 id 값의 증가값이 결정되어짐.즉, allocationSize 속성의 값이 50 이라면,처음 엔티티가 저장될떄의 id 가 1 일 때 데이터베이스 내의 다음에 생성되는id는 50이 증가된 51이 됨.이를 이용하여 미리 여러개의 allocationSize 속성의 값만큼 키를 한번에 받아와서 다음 엔티티를 저장할 떄 굳이 데이터베이스와 통신하지 않도록 함.TABLE 전략 키 생성 전용 테이블을 하나 만들어서 데이터베이스시퀀스를 흉내내는 전략 장점으로는 모든 데이터베이스에 적용 가능 단점으로는 성능에 대한 이슈 발생create table MY_SEQUENCES ( sequence_name varchar(255) not null, next_val bigint, primary key ( sequence_name ))@Entity@TableGenerator( name = &quot;MEMBER_SEQ_GENERATOR&quot;, table = &quot;MY_SEQUENCES&quot;, pkColumnValue = “MEMBER_SEQ&quot;, allocationSize = 1)public class Member { @Id @GeneratedValue(strategy = GenerationType.TABLE, generator = &quot;MEMBER_SEQ_GENERATOR&quot;) private Long id;}@TableGenerator 속성 속성 설명 기본값 name 식별자 생성기 이름 필수 table 키생성 테이블명 hibernate_sequences pkColumnName 시퀀스 컬럼명 sequence_name valueColumnName 시퀀스 값 컬럼명 next_val pkColumnValue 키로 사용할 값 이름 엔티티 이름 initialValue 초기 값, 마지막으로 생성된 값이 기준이다. 0 allocationSize 시퀀스 한 번 호출에 증가하는 수(성능 최적화에 사용됨) 50 catalog, schema 데이터베이스 catalog, schema 이름   uniqueConstraints(DDL) 유니크 제약 조건을 지정할 수 있다.   권장하는 식별자 전략 기본 키 제약 조건 null 이 아님 유일 해야 함 변하면 안됨 미래까지 기본 키 제약 조건을 만족하는 자연키는 찾기 어려우니 대리키(댜체키)를 사용하는 것 자연키 : 비지니스와 연관된 필드인 키 주민번호, 전화번호 와 같은 값 대리키 : 비지니스와 연관되지 않은 시스템에서 생성된 키 권장하는 키 생성은 [Long 형 + 대체키 + 키 생성전략 사용] 방법을 사용 하는 것참고 자바 ORM 표준 JPA 프로그래밍(김영한)" }, { "title": "JPA - 영속성 관리", "url": "/posts/spring-jpa-01/", "categories": "Backend, JPA", "tags": "Web, Spring Framework, DataBase, JPA", "date": "2023-10-23 10:00:00 +0900", "snippet": "영속성 컨텍스트 엔티티를 영구 저장하는 환경 영속성 컨텍스트는 눈에 보이지 않는 논리적인 개녕 엔티티 매니저를 통하여 영속성 컨텍스트에 접근스프링 프레임워크의 컨테이너내에는 엔티티 매니저와 영속성 컨택스트가 N:1 관게로 이루어져 있음엔티티의 생명주기 비영속(new/transient) 영속(menaged) 준영속(detached) 삭제(removed)비영속영속성 컨텍스트와 전혀 관계가 없는 새로운 상태// 객체를 생성한 상태Meber member = new Member(&quot;memberId&quot;, &quot;memberName&quot;);영속영속성 컨텍스트에 관리되는 상태// 객체를 생성한 상태(비영속)Meber member = new Member(&quot;memberId&quot;, &quot;memberName&quot;);EntityManager em = emf.createEntityManager();em.getTransaction().begin();// 객체를 저장한 상태(영속)em.persist(member)준영속영속성 컨텍스트에 저장되었다가 분리된 상태// Member 엔티티를 영속성 컨텍스트에서 분리(준영속)em.detach(member)삭제삭제된 상태// 객체를 삭제한 상태(삭제)em.remove(member)영속성 컨텍스트의 이점 1차 캐시 동일성(identity) 보장 트랜잭션을 지원하는 쓰기 지연(transactional writed-behind) 변경 감지(Dirty Checking) 지연 로딩(Lazy Loading)1차 캐시1차 캐시를 통해 데이터베이스에서 조회하는 것이 아닌 내부 캐시에서 데이터를 조회함1차 캐시에서 조회Meber member1 = new Member(&quot;member1&quot;, &quot;memberName1&quot;);EntityManager em = emf.createEntityManager();// 1차 캐시에 저장됨em.persist(member1)// 1차 캐시에서 조회Member findMember = em.find(Member.class, &quot;member1&quot;);데이터베이스에서 조회// 1차 캐시에 없는 데이터를 조회Member findMember = em.find(Member.class, &quot;member2&quot;);1차 캐시의 한계보통 사용할때 하나의 트랜잭션에 대해 하나의 EntityManager를 사용하고, 트랜잭션 종료후 EntityManager 객체는 제거됨.그러므로 1차 캐시에 캐시된 값도 모두 제거되기 때문에 해당 캐시로 인하여 큰 이득을 보기는 어려움이 있음동일성 보장1차 캐시로 반복 가능한 읽기(Repeatable Read)등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 어플리케이션 차원에서 제공Member findMember1 = em.find(Member.class, &quot;member1&quot;);Member findMember2 = em.find(Member.class, &quot;member1&quot;);System.out.println(findMember1 == findMember2);트랜잭션을 지원하는 쓰기 지연(엔티티 등록)EntityManager em = emf.createEntityManager();EntityTransaction transaction = em.getTransaction();//엔티티 매니저는 데이터 변경시 트랜잭션을 시작해야 함transaction.begin(); // 트랜잭션 시작em.persist(memberA);em.persist(memberB);//여기까지 INSERT SQL을 데이터베이스에 보내지 않음//커밋하는 순간 데이터베이스에 INSERT SQL을 보냄transaction.commit(); // 트랜잭션 커밋 1차 캐시에 저장 쓰기 지연 SQL 저장소에 저장 생성한 SQL 저장 1차 캐시에 저장 쓰기 지연 SQL 저장소에 저장 생성한 SQL 저장 쓰기 지연 SQL 저장소에 저장 되어있던 SQL을 데이터베이스에 적용한 이후 커밋요청변경 감시(엔티티 수정)EntityManager em = emf.createEntityManager();EntityTransaction transaction = em.getTransaction();transaction.begin(); // 트랜잭션 시작// 영속 엔티티 조회Member memberA = em.find(Member.class, &quot;memberA&quot;);// 영속 엔티티 데이터 수정memberA.setUsername(&quot;hi&quot;);memberA.setAge(10);// 별도의 작업 없이 객체에 값을 바꾸는 것 만으로 update 쿼리가 생성되어// commit 시점에 데이터베이스의 값을 수정함transaction.commit(); // 트랜잭션 커밋 트랜잭션 commit시, 내부에 저장되있는 엔티티의 스냅샵과 비교하여 엔티티가 수정되었다면 update SQL을 생성 이후 update SQL을 데이터베이스에 적용 및 commit 요청Flush영속성 컨텍스트의 변경내용을 데이터베이스에 반영하는 작업이며 크게 아래와 같은 작업을 수행함 변경 감지 수정된 엔티티 쓰기 지연 SQL 저장소에 등록 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송(등록, 수정, 삭제 쿼리)Flush 하는 여러 방법은 아래와 같음 em.flush() : 직접 호출 트랜잭션 커밋 : 플러시 자동 호출 JPQL 쿼리 실행 : 플러시 자동 호출flush에 대한 주요 내용으로는, 영속성 컨텍스트를 비우지 않음 수행해도 1차 캐시는 그대로 유지됨 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화 트랜잭션이라는 작업 단위가 중요 커밋 직전에만 동기화 하면 됨 준영속 상태영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)된 상태 영속성 컨텍스트가 제공하는 지연 쓰기, 지연 로딩등의 기능을 사용하지 못함준영속 상태로 만드는 여러 방법은 아래와 같음 em.detach(entity) 특정 엔티티만 준영속 상태로 전환 em.clear() 영속성 컨텍스트를 완전히 초기화 관리하고 있는 전체 엔티티들을 준영속 상태로 전환 참고 자바 ORM 표준 JPA 프로그래밍(김영한)" }, { "title": "Spring MVC - 구조 이해", "url": "/posts/spring-mvc-02/", "categories": "Backend, Spring MVC", "tags": "Web, Spring Framework", "date": "2023-10-18 20:40:00 +0900", "snippet": "Spring MVC 구조동작 순서 핸들러 조회 : 핸들러 매핑을 통해 요청 URL에 매핑된 핸들러(컨트롤러)를 조회 핸들러 어댑터 조회 : 핸들러를 실행 할 수 있는 핸들러 어댑터를 조회 핸들러 어댑터 실행 : 핸들러 어댑터 실행 핸들러 실행 : 핸들러 어댑터가 실제 핸들러를 실행 ModelAndView 반환 : 핸들러 어댑터는 핸들러가 반환하는 정보를 ModelAndView로 변환하여 반환 viewResolver 반환 : 뷰 리졸버를 찾고 실행   * JSP의경우 InternalResourceViewResolver가 자동 등록되고 사용됨 View 반환 : 뷰 리졸버는 뷰의 논리 이름을 물리 이름으로 바꾸로, 렌더링 역할을 담당하는 뷰 객체를 반환   * JSP의경우 InternalResourceView(JstlView)를 반환하는데 내부에 forward() 로직이 있음 뷰 렌더링 : 뷰를 통해 뷰를 렌더링스프링 MVC의 가장 큰 강점은 DispatcherServlet 코드의 변경 없이 원하는 기능을 변경하거나 확장 할 수 있다는 점.대부분을 확장 가능할 수 있게 인터페이스로 제공하며 이러한 인터페이스들만 구현하여 DispatcherServlet 에 등록하면 자신만의 컨트롤러를 구현할 수도 있음.주요 인터페이스 목록으로는 아래와 같이 존재 핸들러 매핑 : org.springframework.web.servlet.HandlerMapping 핸들러 어댑터 : org.springframework.web.servlet.HandlerAdapte 뷰 리졸버 : org.springframework.web.servlet.ViewResolver 뷰 : org.springframework.web.servlet.ViewDispatcherServlet 서블릿 등록 DispatcherServlet도 부모 클래스에서 HttpServlet을 상속방아 사용하고 서블릿으로 동작 함. DispatcherServlet -&amp;gt; FrameworkServlet -&amp;gt; HttpServletBean -&amp;gt; HttpServlet 스트링 부트는 DispatcherServlet을 서블릿으로 자동으로 등록하면서 모든경로(urlPatterns=”/”)에 대하여 매핑 함참고 스프링 MVC - 백엔드 웹 개발 핵심 기술(김영한)" }, { "title": "Spring DB - 스프링 트랜잭션 전파", "url": "/posts/spring-db-08/", "categories": "Backend, Spring DB", "tags": "Web, Spring Framework, DataBase", "date": "2023-10-18 16:00:00 +0900", "snippet": "트랜잭션 전파(propagation)트랜잭션을 각각 사용하는 것이 아닌 하나의 트랜잭션이 이미 진행중인 상황에서 또다른 트랜잭션이 수행될떄,어떤식으로 동작할지 결졍하는 것을 트랜잭션 전파(propagation) 이라 함. 외부 트랜잭션이 수행중이고, 아직 끝나기 전 내부 트랜잭션이 수행 먼저 실행된 트랜잭션이 상대적으로 밖에 있기 떄문에 외부 트랜잭션이라 함 외부 트랜잭션이 실행되고 있는 도중 호출되기 떄문에 마치 내부에 있는것으로 보여 내부 트랜잭션이라 함 이 경우 스프링에선 외부 트랜잭션과 내부 트랜잭션을 묶어서 하나의 트랜잭션을 만들어 줌 내부 트랜잭션이 외부 트랜잭션에 참여 위와 같은 방식이 기본동작이며 옵션을 통해 다른 동작방식으로 선탱할 수 있음 스프링에선 개념적으로 물리 트랜잭션, 논리 트랜잭션이라고 나눔 물리 트랜잭션은 실제 데이터베이스에 적용되는 트랜잭션을 뜻함 실제 커넥션을 통해 트랜잭션을 시작(setAutoCommit(false))하고, 실제 커넥션을 통해 커밋, 롤백하는 단위 논리 트랜잭션은 트랜잭션 매니저를 통해 트랜잭션을 사용하는 단위 논리 트랜잭션들은 하나의 물리 트랜잭션으로 묶임 기본인 REQUIRED 전파옵션을 사용할 할시, 이러한 논리 트랜잭션 개념은 트랜잭션이 진행되는 중에 내부에 추가로 트랜잭션을 사용하는 경우에 나타남 이와 같이 물리 트랜잭션, 논리 트랜잭션으로 나누면 다음과 같은 단순한 원칙을 만들 수 있음 모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋 됨 하나의 논리 트랜잭션이라도 롤백되면 물리 트랜잭션은 롤백 됨 모든 논리 트랜잭션이 커밋되었으므로 물리 트랜잭션도 커밋 외부 트랜잭션이 롤백되었으므로 내부 트랜잭션이 커밋되어도 물리 트랜잭션은 롤백 반대로 내부 트랜잭션이 롤백, 외부 트랜잭션이 커밋되어도 물리 트랜잭션은 롤백이러한 외부 트랜잭션과 내부 트랜잭션에 대하여 테스트 코드로 확인해 볼 수 있음@Testvoid inner_commit() { log.info(&quot;외부 트랜잭션 시작&quot;); TransactionStatus outer = txManager.getTransaction(new DefaultTransactionAttribute()); log.info(&quot;outer.isNewTransaction()={}&quot;, outer.isNewTransaction()); log.info(&quot;내부 트랜잭션 시작&quot;); TransactionStatus inner = txManager.getTransaction(new DefaultTransactionAttribute()); log.info(&quot;inner.isNewTransaction()={}&quot;, inner.isNewTransaction()); log.info(&quot;내부 트랜잭션 커밋&quot;); txManager.commit(inner); log.info(&quot;외부 트랜잭션 커밋&quot;); txManager.commit(outer);} 외부 트랜잭션 수행중 내부 트랜잭션을 추가로 수행 외부 트랜잭션은 처음 수행된 트랜잭션이며 이 경우 신규 트랜잭션(isNewTransaction=true)가 됨 내부 트랜잭션을 시작하는 시점에는 이미 외부 트랜잭션이 진행중인 상태이며 이 경우 내부 트랜잭션은 외부 트랜잭견에 참여하는 형태가 됨 트랜잭션 참여 내부 트랜잭션이 외부 트랜잭션에 참여한다는 뜻은 내부 트랜잭션이 외부 트랜잭션을 그대로 이어 받아 따른다는 뜻 다른 관점으로 보면 외부 트랜잭션의 범위가 내부 트랜잭션까지 넓어진다는 뜻 외부에서 시작된 물리적인 트랜잭션의 범위가 내부 트랜잭션까지 넓어진다는 뜻 즉, 외부 트랜잭션과 내부 트랜잭션이 하나의 물리 트랜잭션으로 묶여버리게 됨 내부 트랜잭션은 이미 진행되고 있는 트랜잭션에 참여하므로 신규 트랜잭션이 아님(isNewTransaction=false)# 실행 결과외부 트랜잭션 시작Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULTAcquired Connection [HikariProxyConnection@1943867171 wrapping conn0] for JDBC transactionSwitching JDBC Connection [HikariProxyConnection@1943867171 wrapping conn0] to manual commitouter.isNewTransaction()=true내부 트랜잭션 시작Participating in existing transactioninner.isNewTransaction()=false내부 트랜잭션 커밋외부 트랜잭션 커밋Initiating transaction commitCommitting JDBC transaction on Connection [HikariProxyConnection@1943867171 wrapping conn0]Releasing JDBC Connection [HikariProxyConnection@1943867171 wrapping conn0] after transaction 내부 트랜잭션을 시작할 때 Participating in existing transaction 이라는 메시지를 확인할 수 있음. 이 메시지는 내부 트랜잭션이 기존에 존재하는 외부 트랜잭션에 참여한다는 뜻 외부 트랜잭션만 물리 트랜잭션을 시작하고, 커밋 함 내부 트랜잭션이 실제 물리 트랜잭션을 커밋하면 트랜잭션이 끝나버리기 때문에, 트랜잭션을 처음 시작한 외부 트랜잭션 까지 이어갈 수 없음. 그러므로 내부 트랜잭션은 DB 커넥션을 통한 물리 트랜잭션을 커밋하면 안됨 스프링은 이렇게 여러 트랜잭션이 함꼐 사용되는 경우, 처음 트랜잭션을 시작한 외부 트랜잭션이 실제 물리 트랜잭션을 관리하도록 함. 이를 통해 트랜잭션 중복 커밋 문제를 해결 함트랜잭션 전파의 동작 흐름요청 흐름 - 외부 트랜잭션 1.. txManager.getTransaction()을 호출하여 외부 트랙잭션을 시작 트랜잭션 매니저는 데이터소스를 통해 커넥션을 생성 생성한 커넥션을 수동 커밋 모드(setAutoCommit(false))로 설정(물리 트랜잭션 시작) 트랜잭션 매니저는 트랜잭션 동기화 매니저에 커넥션을 보관 트랜잭션 매니저는 트랜잭션을 생성하여 반환   * 트랜잭션 매니저는 트랜잭션을 생성한 결과를 TransactionStatus에 담아서 반환하는데, 여기에 신규 트랜잭션의 여부가 담겨 있음. \\ 로직 1이 수행되고, 커넥션이 필요한 경우 트랜잭션 동기화 매니저를 통해 트랜잭션이 적용된 커넥션을 획득하여 사용요청 흐름 - 내부 트랜잭션 txManager.getTransaction() 를 호출해서 내부 트랜잭션을 시작 트랜잭션 매니저는 트랜잭션 동기화 매니저를 통해서 기존 트랜잭션이 존재하는지 확인 기존 트랜잭션이 존재하므로 기존 트랜잭션에 참여 함   * 기존 트랜잭션에 참여한다는 뜻은 사실 아무것도 하지 않는다는 뜻   * 이미 기존 트랜잭션인 외부 트랜잭션에서 물리 트랜잭션을 시작하였고 물리 트랜잭션이 시작된 커넥션을 트랜잭션 동기화 매니저에 담아두어 둔 상태   * 이후 로직은 자연스럽게 트랜잭션 동기화 매니저에 보관된 기존 커넥션을 사용하게 됨 \\ 트랜잭션 매니저는 기존 생성되었던 트랜잭션을 찾아서 반환   * 트랜잭션 매니저는 트랜잭션을 생성한 결과를 TransactionStatus 에 담아서 반환하는데, 여기에서 isNewTransaction 를 통해 신규 트랜잭션 여부를 확인할 수 있음. 여기서는 기존 트랜잭션에 참여했기 때문에 신규 트랜잭션이 아님(false) \\ 로직2가 수행되고, 커넥션이 필요한 경우 트랜잭션 동기화 매니저를 통해 외부 트랜잭션이 보관한 커넥션을 획득해서 사용응답 흐름 - 내부 트랜잭션 로직2가 끝나고 트랜잭션 매니저를 통해 내부 트랜잭션을 커밋 트랜잭션 매니저는 커밋 시점에 신규 트랜잭션 여부에 따라 다르게 동작 함. 이 경우 신규 트랜잭션이 아니기 때문에 실제 커밋을 호출하지 않음.   * 실제 커넥션에 커밋이나 롤백을 호출하면 물리 트랜잭션이 끝나버리기 때문에 아직 트랜잭션이 끝난 것이 아닌 이 시점에는 실제 커밋을 호출하면 안됨.   * 물리 트랜잭션은 외부 트랜잭션을 종료할 때 까지 이어져야 함 \\응답 흐름 - 외부 트랜잭션 로직1이 끝나고 트랜잭션 매니저를 통해 외부 트랜잭션을 커밋 트랜잭션 매니저는 커밋 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다. 외부 트랜잭션은 신규 트랜잭션 이므로 DB 커넥션에 실제 커밋을 호출 트랜잭션 매니저에 커밋하는 것이 논리적인 커밋이라면, 실제 커넥션에 커밋하는 것을 물리 커밋이라 할 수 있음. 실제 데이터베이스에 커밋이 반영되고, 물리 트랜잭션도 끝난다트랜잭션 전파의 동작 흐름 정리 주요 핵심은 트랜잭션 매니저에 커밋을 호출한다고 해서 항상 실제 커넥션에 물리 커밋이 발생하지 않는다는 것 신규 트랜잭션인 경우에만 실제 커넥션을 사용하여 물리 커밋과 롤백을 수행함. 신규 트랜잭션이 아니면 실제 물리 커밋을 수행하지 않음 트랜잭션이 내부에서 추가로 사용되면 트랜잭션 매니저에 커밋하는 것이 항상 물리 커밋으로 이어지지 않음. 그러므로 이러한 경우 논리 트랜잭션과 물리 트랜잭션으로 나뉘어 지게 됨. 또는 외부 트랜잭션과 내부 트랜잭션으로 나누어 설명하기도 함 트랜잭션이 내부에서 추가로 사용되면 트랜잭션 매니저를 통해 논리 트랜잭션을 관리하고 모든 논리 트랜잭션이 커밋되면 물리 트랜잭션이 커밋 됨외부 롤백시 흐름내부 트랜잭션은 커밋이 되는데 외부에서 트랜잭션이 롤백이 된다면, 내부 트랜잭션안 에서 저장한 데이터도 모두 함께 롤백 됨응답 흐름 - 내부 트랜잭션1, 로직2가 끝나고 트랜잭션 매니저를 통해 내부 트랜잭션을 커밋 \\ 트랜잭션 매니저는 커밋 시점에 신규 트랜잭션 여부에 따라 다르게 동작 함. 이 경우 신규 트랜잭션이 아니기 때문에 실제 커밋을 호출하지 않음.   * 실제 커넥션에 커밋이나 롤백을 호출하면 물리 트랜잭션이 끝나버리기 때문에 아직 트랜잭션이 끝난 것이 아닌 이 시점에는 실제 커밋을 호출하면 안됨.   * 물리 트랜잭션은 외부 트랜잭션을 종료할 때 까지 이어져야 함 \\응답 흐름 - 외부 트랜잭션 로직1이 끝나고 트랜잭션 매니저를 통해 외부 트랜잭션을 롤백 트랜잭션 매니저는 롤백 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다. 외부 트랜잭션은 신규 트랜잭션이므로 DB 커넥션에 실제 롤백을 호출 트랜잭션 매니저에 롤백하는 것이 논리적인 롤백이라면, 실제 커넥션에 롤백하는 것을 물리 롤백이라 할 수 있음. 실제 데이터베이스에 롤백이 반영되고, 물리 트랜잭션도 끝나게 됨내부 롤백시 흐름외부 롤백시의 흐름과 다르게 내부 트랜잭션은 롤백되고 외부 트랜잭션이 커밋되는 상황이라면 단순히 해결되지 않는 문제가 발생함.이에 대하여 응답 흐름을 확인해보면 아래와 같음응답 흐름 - 내부 트랜잭션1, 로직2가 끝나고 트랜잭션 매니저를 통해 내부 트랜잭션을 롤백 트랜잭션 매니저는 롤백 시점에 신규 트랜잭션 여부에 따라 다르게 동작함. 이 경우 신규 트랜잭션이 아니기 때문에 실제 롤백을 호출하지 않음   * 실제 커넥션에 커밋이나 롤백을 호출하면 물리 트랜잭션이 끝나버리기 때문에 아직 트랜잭션이 끝난 것이 아닌 이 시점에는 실제 커밋을 호출하면 안됨.   * 물리 트랜잭션은 외부 트랜잭션을 종료할 때 까지 이어져야 함 \\ 내부 트랜잭션은 물리 트랜잭션을 롤백하지 않는 대신에 트랜잭션 동기화 매니저에 rollbackOnly=true 라는 표시를 해둠 \\응답 흐름 - 외부 트랜잭션 로직1이 끝나고 트랜잭션 매니저를 통해 외부 트랜잭션을 커밋 트랜잭션 매니저는 커밋 시점에 신규 트랜잭션 여부에 따라 다르게 동작 함. 외부 트랜잭션은 신규 트랜잭션이므로 DB 커넥션에 실제 커밋을 호출해야 하지만, 트랜잭션 동기화 매니저에 롤백 전용(rollbackOnly=true) 표시가 있는지 확인화고, 롤백 전용 표시가 있으면 물리 트랜잭션을 커밋하는 것이 아니라 롤백을 진행 함 실제 데이터베이스에 롤백이 반영되고, 물리 트랜잭션도 끝남 트랜잭션 매니저에 커밋을 호출한 개발자 입장에서는 분명 커밋을 기대했는데 롤백 전용 표시로 인해 실제로는 롤백이 되었기 때문에 이를 UnexpectedRollbackException 런타임 예외를 통해 알림   * 시스템 입장에서는 커밋을 호출했지만 롤백이 되었다는 것은 분명하게 알려주어야 함   * 예를 들어서 고객은 주문이 성공했다고 생각했는데, 실제로는 롤백이 되어서 주문이 생성되지 않은 상황   * 스프링은 이 경우 UnexpectedRollbackException 런타임 예외를 던져 커밋을 시도했지만 기대하지 않은 롤백이 발생했다는 것을 명확하게 알려줌 \\트랜잭션 전파 흐름 정리 논리 트랜잭션이 하나라도 롤백이 되면 물리 트랜잭션 또한 롤백을 진행함 내부 논리 트랜잭션이 롤백되면 롤백 전용 마크를 표시함 외부 트랜잭션을 커밋 할 떄 롤백 전용 마크를 확인하고, 롤백 전용 마크가 표시되어 있다면 물리 트랜잭션을 롤백한뒤, 만일 외부 트랜잭션이 롤백이 아닌 커밋을 한다면 UnexpectedRollbackException 예외를 던짐REQUIRES_NEW외부 트랜잭션과 내부 트랜잭션을 완전히 분리해서 사용하는 방법도 있음이 방법은 내부 트랜잭션에 문제가 발생해도 외부 트랜잭션에는 영향을 주지 않음. 반대로 외부 트랜잭션에 문제가 발생해도 내부 트랜잭션에 영향을 주지 않음 이렇게 물리 트랜잭션을 분리하기 위해 내부 트랜잭션을 시작할때 REQUIRES_NEW 옵션을 사용 외부 트랜잭션과 내부 트랜잭션이 각각 별도의 물리 트랜잭션을 가짐 DB 커넥션을 각각 따로 사용함 내부 트랜잭션이 롤백되더라도 외부 트랜잭션에서 수행한 데이터에는 영향을 주지 않음@Testvoid inner_rollback_requires_new() { log.info(&quot;외부 트랜잭션 시작&quot;); TransactionStatus outer = txManager.getTransaction(new DefaultTransactionAttribute()); log.info(&quot;outer.isNewTransaction()={}&quot;, outer.isNewTransaction()); log.info(&quot;내부 트랜잭션 시작&quot;); // 별도의 DefaultTransactionAttribute 객체를 만들고 // setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW) // 을 통해 물리 트랜잭션을 분리 DefaultTransactionAttribute definition = new DefaultTransactionAttribute(); definition.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW); TransactionStatus inner = txManager.getTransaction(definition); log.info(&quot;inner.isNewTransaction()={}&quot;, inner.isNewTransaction()); log.info(&quot;내부 트랜잭션 롤백&quot;); txManager.rollback(inner); //롤백 log.info(&quot;외부 트랜잭션 커밋&quot;); txManager.commit(outer); //커밋}외부 트랜잭션 시작Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULTAcquired Connection [HikariProxyConnection@1064414847 wrapping conn0] for JDBC transactionSwitching JDBC Connection [HikariProxyConnection@1064414847 wrapping conn0] to manual commitouter.isNewTransaction()=true내부 트랜잭션 시작Suspending current transaction, creating new transaction with name [null]Acquired Connection [HikariProxyConnection@778350106 wrapping conn1] for JDBC transactionSwitching JDBC Connection [HikariProxyConnection@778350106 wrapping conn1] to manual commitinner.isNewTransaction()=true내부 트랜잭션 롤백Initiating transaction rollbackRolling back JDBC transaction on Connection [HikariProxyConnection@778350106 wrapping conn1]Releasing JDBC Connection [HikariProxyConnection@778350106 wrapping conn1] after transactionResuming suspended transaction after completion of inner transaction외부 트랜잭션 커밋Initiating transaction commitCommitting JDBC transaction on Connection [HikariProxyConnection@1064414847 wrapping conn0]Releasing JDBC Connection [HikariProxyConnection@1064414847 wrapping conn0] after transaction 외부 트랜잭션 시작 외부 트랜잭션을 시작하면서 커넥션를 획득하고 manual commit 으로 변경하여 물리 트랜잭션을 시작 외부 트랜잭션은 신규 트랜잭션임 내부 트랜잭션 시작 내부 트랜잭션을 시작하면서 커넥션를 획득하고 manual commit 으로 변경하여 물리 트랜잭션을 시작 내부 트랜잭션은 외부 트랜잭션에 참여하는것이 아닌 PROPAGATION_REQUIRES_NEW 옵션을 사용했기 때문에 완전히 새로운 트랜잭션으로 생성됨 내부 트랜잭션 롤백 내부 트랜잭션을 롤백 내부 트랜잭션은 신규 트랜잭션이기 때문에 실제 물리 트랜잭션을 롤백 외부 트랜잭션 커밋 외부 트랜잭션을 커밋 외부 트랜잭션은 신규 트랜잭션이기 때문에 실제 물리 트랜잭션을 커밋 REQUIRES_NEW 옵션 사용시, 트랜잭션 전파의 동작 흐름요청 흐름 - 외부 트랜잭션 1, txManager.getTransaction()을 호출하여 외부 트랙잭션을 시작 트랜잭션 매니저는 데이터소스를 통해 커넥션을 생성 생성한 커넥션을 수동 커밋 모드(setAutoCommit(false))로 설정(물리 트랜잭션 시작) 트랜잭션 매니저는 트랜잭션 동기화 매니저에 커넥션을 보관 트랜잭션 매니저는 트랜잭션을 생성하여 반환   * 트랜잭션 매니저는 트랜잭션을 생성한 결과를 TransactionStatus에 담아서 반환하는데, 여기에 신규 트랜잭션의 여부가 담겨 있음. 로직 1이 수행되고, 커넥션이 필요한 경우 트랜잭션 동기화 매니저를 통해 트랜잭션이 적용된 커넥션을 획득하여 사용요청 흐름 - 내부 트랜잭션 REQUIRES_NEW 옵션과 함께 txManager.getTransaction() 를 호출해서 내부 트랜잭션을 시작   *트랜잭션 매니저는 REQUIRES_NEW 옵션을 확인하고, 기존 트랜잭션에 참여하는 것이 아닌 새로운 트랜잭션을 시작함 트랜잭션 매니저는 데이터소스를 통해 커넥션을 생성 생성한 커넥션을 수동 커밋 모드(setAutoCommit(false))로 설정(물리 트랜잭션 시작) 트랜잭션 매니저는 트랜잭션 동기화 매니저에 커넥션을 보관   * 이때 외부 트랜잭션의 커넥션인 con1은 잠시 보류 되고 con2가 사용됨   * 내부 트랜잭션을 완료 할 떄 까지 con2가 사용됨 트랜잭션 매니저는 신규 트랜잭션을 생성한 결과를 반환 로직 2이 수행되고, 커넥션이 필요한 경우 트랜잭션 동기화 매니저를 통해 트랜잭션이 적용된 커넥션을 획득하여 사용응답 흐름 - 내부 트랜잭션 로직2가 끝나고 트랜잭션 매니저를 통해 내부 트랜잭션을 롤백 트랜잭션 매니저는 롤백 시점에 신규 트랜잭션 여부에 따라 다르게 동작 함. 현재 신규 트랜잭션이므로 롤백을 수행 함 내부 트랜젝션이 con2 물리 트랜잭션을 롤백 함   * 트랜잭션이 종료되고, con2는 종료되거나 커넥션 풀에 반납 됨   * 이후 con1의 보류가 끝나고, 다시 con1을 사용 함 \\응답 흐름 - 외부 트랜잭션 외부 트랜잭션에 커밋을 요청 외부 트랜잭션은 신규 트랜잭션 이므로 물리 트랜잭션에 커밋 진행 이떄 rollbackOnly 설정을 체크 함. 위 상황에는 rollbackOnly 설정이 없으므로 커밋 진행 본인이 만든 con1 커넥션을 통해 물리 트랜잭션을 커밋   * 트랜잭션이 종료되고, con1는 종료되거나 커넥션 풀에 반납 됨 \\&amp;lt;/br&amp;gt; 정리 REQUIRES_NEW 옵션을 사용하면 물리 트랜잭션이 명확하게 분리 됨 REQUIRES_NEW 옵션을 사용하면 데이터베이스 커넥션이 동시에 다수(내부 트랜잭션의 수)가 사용된 다는 점을 주의 다양한 전파 옵션스프링은 다양한 트랜잭션 전파 옵션을 제공 함. 전파 옵션에 대해 별도의 설정을 하지 않으면 기본으로 REQUIRED 가 사용됨.실무에서는 대부분 REQUIRED 옵션을 사용하고 가끔 REQUIRED_NEW 가 사용되며 나머지는 잘 사용되지 않음 REQUIRED 가장 많이 사용되는 기본 설정 기존 트랜잭션이 없으면 생성하고 있으면 참여 함 트랜잭션이 필수라는 의미 기존 트랜잭션 없음 : 새로운 트랜잭션을 생성 기존 트랜잭션 있음 : 기존 트랜잭션에 참여 REQUIRED_NEW 할상 새로운 트랜잭션을 생성 기존 트랜잭션 없음 : 새로운 트랜잭션을 생성 기존 트랜잭션 있음 : 새로운 트랜잭션을 생성 SUPPORT 트랜잭션을 지원한 다는 뜻이며 기존 트랜잭션이 없으면 없는대로 진행하고 있다면 참여 함 기존 트랜잭션 없음 : 트랜잭션 없이 진행 기존 트랜잭션 있음 : 기존 트랜잭션에 참여 NOT_SUPPORT 트랜잭션을 지원하지 않는 다는 의미 기존 트랜잭션 없음 : 트랜잭션 없이 진행 기존 트랜잭션 있음 : 트랜잭션 없이 진행하며 기존 트랜잭션은 보류 함 MANDATORY 의무사항으로, 트랜잭션이 반드시 있어야 하며 기존 트랜잭션이 없다면 예외 발생 기존 트랜잭션 없음 : IllegalTransactionStateException 예외 발생 기존 트랜잭션 있음 : 기존 트랜잭션에 참여 NEVER 트랜잭션을 사용하지 않는다는 의미이며 기존 트랜잭셩이 있다면 예외가 발생 기존 트랜잭션도 허용하지 않는 강한 부정의 의미 기존 트랜잭션 없음 : 트랜잭션 없이 진행 기존 트랜잭션 있음 : IllegalTransactionStateException 예외 발생 NESTED 기존 트랜잭션 없음 : 새로운 트랜잭션을 생성 기존 트랜잭션 있음 : 중첩 트랜잭션에 참여 중첩 트랜잭션은 외부 트랜잭션의 영향을 받지만 중첩 트랜잭션은 외부에 영향을 주지 않음 중첩 트랜잭션이 롤백 되어도 외부 트랜잭션은 커밋할 수 있음 외부 트랜잭션이 롤백 되면 중첩 트랜잭션도 함께 롤백 됨 JDBC savepoint 기능을 하용하여 각 DB 드라이버별로 해당 기능을 지원하는지 확인이 필요 JPA 에선 중첩 트랜잭션을 사용할 수 없음 isolation, timeout, readOnly는 트랜잭션이 처음 시작될때만 적용 되며 트랜잭션에 참여하는 경우에는 적용되지 않음. 따라서 REQUIRED를 통한 트랜잭션 시작, REQUIRED_NEW를 통한 트랜잭션 시작 시점에만 적용 됨.참고 스프링 DB - 데이터 접근 활용 기술(김영한)" }, { "title": "Spring DB - 스프링 트랜잭션의 이해", "url": "/posts/spring-db-07/", "categories": "Backend, Spring DB", "tags": "Web, Spring Framework, DataBase", "date": "2023-10-18 10:00:00 +0900", "snippet": "트랜잭션 적용 확인@Transactional을 통해 선언적 트랜잭션 방식을 사용하면 다눈히 어노테이션 하나로 트랜잭션을 적용할 수 있음제대로 적용 되었는지 아래와 같이 확인 해 볼 수 있음public class TxBasicTest { @Autowired BasicService basicService; @Test void proxyCheck() { //BasicService$$EnhancerBySpringCGLIB... log.info(&quot;aop class={}&quot;, basicService.getClass()); assertThat(AopUtils.isAopProxy(basicService)).isTrue(); } ... static class BasicService { @Transactional public void tx() { log.info(&quot;call tx&quot;); boolean txActive = TransactionSynchronizationManager.isActualTransactionActive(); log.info(&quot;tx active={}&quot;, txActive); } public void nonTx() { log.info(&quot;call nonTx&quot;); boolean txActive = TransactionSynchronizationManager.isActualTransactionActive(); log.info(&quot;tx active={}&quot;, txActive); } } ...}TxBasicTest : aop class=class ..$BasicService$$EnhancerBySpringCGLIB$$xxxxxx위 테스트의 결과를 확인해보면 클래스 이름이 프록시 클래스의 이름으로 출력되는 것을 확인 할 수 있음스프링 컨테이너에 트랜잭션 프록시 등록 @Transactional 어노테이션이 특정 클래스나 메서드에 하나라도 있으면 트랜잭션 AOP는 프록시를 만들어서 스프링 컨테이너에 등록 실제 baseService 객체 대신에 프록시인 basicService$$CGLIB 을 스프링 빈에 등록 프록시 내부는 실제 baseService 객체를 참조 핵심은 실제 객체 대신에 프록시가 스프링 컨테이너에 등록되었다는 것 클라이언트인 txBasicTest는 스프링 컨테이너에 @Autowired로 의존관계 주입 요청할때, 스프링 컨테이너는 실제 객체 대신에 프록시가 스프링 빈으로 등록되어있기 때문에 프록시를 주입 프록시는 BasicService를 상속하여 만들어지기 때문에 다형성을 활용할 수 있어 BasicService 대신에 프록시인 BasicService$$CGILB를 주입할 수 있음 클라이언트가 주입받은 BasicService$$CGILB은 트랜잭션을 적용하는 프록시 임 TransactionSynchronizationManager.isActualTransactionActive()현재 쓰레드에 트랜잭션이 적용되었는지 확인할 수 있는 기능결과가 true 이면 트랜잭션이 적용되어 있는 상태. 트랜잭션의 적용 여부를 가장 확실히 확인할 수 있음트랜잭션 적용 위치스프링에서의 우선순위는 항상 더 구체적이고 자세한 것이 높은 우선순위를 가짐스프링의 @Transactional은 다음과 같은 두가지 규칙이 있음 우선순위 규칙 클래스에 적용하면 메서트는 자동 적용우선순위트랜잭션을 사용할때는 다양한 옵션을 사용할 수 있음.@Transactional(readOnly = true)static class LevelService { @Transactional(readOnly = false) public void write() { log.info(&quot;call write&quot;); printInfo(); } ...}위와 같이 클래스에는 읽기 전용 트랜잭션옵션(@Transactional(readOnly = true)) 이 붙어 있고, 메소드에는 아닌경우, 클래스 보다는 메소드가 더 구체적이므로 메소드에 있는 @Transactional(readOnly = false)가 적용되어 짐클래스에 적용되면 메소드는 자동 적용@Transactional(readOnly = true)static class LevelService { public void read() { log.info(&quot;call read&quot;); printInfo(); } ...}위 테스트 코드를 확인해 보면, 메소드에 @Transactional이 없기 떄문에 더 상위 클래스를 확인하게 됨클래스에는 @Transactional(readOnly = true)이 적용되어 있으므로 메소드도 적용됨 readOnly = true 는 기본옵션이므로 보통 생략 함인터페이스에 @Transactional 적용인터페이스에서도 @Transactional를 적용할 수 있음.다만 이경우에도 구체적인 것이 더 우선순위가 높으므로 아래와 같은 우선순위가 적용됨 클래스의 메소드 클래스 타입 인터페이스 메소드 인터페이스 타입다만 인터페이스에 @Transactional 을 사용하는 것은, 스프링 5.0 이전 버전에서는 AOP가 정상적으로 적용되지 않을 수도 있기 때문에 스프링 공식 메뉴얼에서 권장하지 않는 방법public 메소드에만 트랜잭션 적용스프링 트랜잭션 AOP 기능은 public 메소드에만 트랜잭션을 적용하도록 기본 설정이 되어 있음.그러므로 private, protected, package-visible 에는 트랜잭션이 적용되지 않음.@Transactionalpublic class Hello { public method1(); method2(): protected method3(); private method4();}만일 위와 같이 트랜잭션이 적용되어 있다면 모든 메소드에 트랜잭션이 걸리게 됨.그러므로 의도하지 않은 메소드 까지 트랜잭션이 걸리게 되어 트랜잭션이 과도하게 적용되는 문제가 발생함.트랜잭션은 주로 비지니스 로직의 시작점에 걸기 떄문에 대부분 외부에 열어준 곳을 시작점으로 사용하게 되는데 이때 의도하지 않은 메소드까지 전부 트랜잭션이 걸릴수가 있기 떄문에 public 에만 트랜잭션을 적용하도록 스프링에서 설정되어 있음. 스프링 부트 3.0 부터는 protected, package-visible(default 접근제한자)에도 트랜잭션이 적용됨트랜잭션 AOP 주의 사항 - 프록시 내부 호출@Transactional을 사용하면 스프링의 트랜잭션 AOP가 적용됨.트랜잭션 AOP는 기본적으로 프록시 방식의 AOP를 사용하여 프록새 객체가 요청을 먼저 받아서 트랜잭션을 처리하고 이후 실제 객체를 호출함.따라서 트랜잭션을 적용하려면 항상 프록시를 통하여 대상 객체(Target)를 호출해야함만약 프록시를 거치지 않고 대상 객체를 직접 호출하게 되면 AOP가 적용되지 않고 트랜잭션 또한 적용되지 않음.AOP를 적용하면 스프링은 대상 객체 대신에 프록시를 스프링 빈으로 등록함. 따라서 스프링은 의존관계 주입시에 항상 실제 객체 대신에 프록시 객체를 주입함.프록시 객체가 주입되기 때문에 대상 객체를 직접 호출하는 문제는 일반적으로 발생하지 않으나, 대상 객체의 내부에서 메소드 호출이 발생하면 프록시를 거치지 않고 대상 객체를 직접 호출하는 문제가 발생 함.이렇게 되면 AOP가 적용되지 않기 떄문에 @Transactional이 있어도 트랜잭션이 적용되지 않음public class InternalCallV1Test { ... @Slf4j static class CallService { public void external() { log.info(&quot;call external&quot;); printTxInfo(); internal(); } @Transactional public void internal() { log.info(&quot;call internal&quot;); printTxInfo(); } private void printTxInfo() { boolean txActive = TransactionSynchronizationManager.isActualTransactionActive(); log.info(&quot;tx active = {}&quot;, txActive); } } @Test void internalCall() { callService.internal(); } @Test void externalCall() { callService.external(); } ...internalCall() 실행 클라이언트 테스트 코드는 callService.internal() 호출. 이때 callService는 트랜잭션 프록시 임 callService의 트랜잭션 프록시 호출 internal() 메소드에 @Transactional이 붙어있으므로 트랜잭션 프록시는 트랜잭션을 적용 트랜잭션 적용 후 실제 callService 객체 인스턴스의 internal() 을 호출 실제 callService 가 처리를 완료하면 응답이 트랜잭션 프록시로 돌아오고 트랜잭션 프록시는 트랜잭션을 완료TransactionInterceptor : Getting transaction for [..CallService.internal]..rnalCallV1Test$CallService : call internal..rnalCallV1Test$CallService : tx active=trueTransactionInterceptor : Completing transaction for [..CallService.internal]externalCall() 실행CallService : call externalCallService : tx active=falseCallService : call internalCallService : tx active=false위 경우에, 실행 결과를 보면 트랜잭션관련 코드 및 tx active=false 로 로그가 출력되는 것으로 봐 태랜잭션이 적용되지 않음을 확인 할 수 있음. 해당 내용에 대한 이유는 프록시가 아닌 실제 객체의 내부 메소드를 호출해서 발생함프록시와 내부 호출 클라이언트 테스트 코드는 callService.external() 호출. 이때 callService는 트랜잭션 프록시 임 callService의 트랜잭션 프록시 호출 internal() 메소드에 @Transactional이 없으므로 트랜잭션 프록시는 트랜잭션을 적용하지 않음 트랜잭션 적용하지 않고 실제 callService 객체 인스턴스의 external() 을 호출 external()은 내부에서 internal() 메소드를 호출하지만 이는 트랜잭션 프록시 객체의 internal() 이 아닌 실제 객체의 internal() 메소드를 호출하는 것이므로 트랜잭션을 수행하지 않음프록시 방식의 AOP 한계위와 같은 상황의 문제 원인으로는 자바 언어에서는 메소드 앞에 별도의 참조가 없다면 this 라는 뜻으로 자기 자신의 인스턴스를 가리킴.결과적으로 자기자신의 내부 메소드를 호출하는 this.internal()이 되는데, 이떄 this 는 자기 자신을 가리키므로 실제 대상 객체(Target)의 인스턴스를 뜻함. 그러므로 결과적으로 이러한 내부 호출은 프록시를 커치지 못하여 트랜잭션을 적용할 수 없음.@Transactional을 사용하는 트랜잭션 AOP는 프록시를 사용함. 프록시를 사용하면 메소드 내부 호출에는 프록시를 적용 할 수 없음.내부 호출문제 해결방안메소드 내부 호출로 인하여 트랜잭션 프록시가 적용되지 않는 문제에 대하여, 가장 간단한 해결 방안은 internal() 메서드를 별도의 클래스로 분리하는 것public class InternalCallV1Test { ... @Slf4j @RequiredArgsConstructor static class CallService { private final InternalService internalService; public void external() { log.info(&quot;call external&quot;); printTxInfo(); internalService.internal(); } private void printTxInfo() { boolean txActive = TransactionSynchronizationManager.isActualTransactionActive(); log.info(&quot;tx active = {}&quot;, txActive); } } static class InternalService { @Transactional public void internal() { log.info(&quot;call internal&quot;); printTxInfo(); } private void printTxInfo() { boolean txActive = TransactionSynchronizationManager.isActualTransactionActive(); log.info(&quot;tx active={}&quot;, txActive); } } ...#external()..InternalCallV2Test$CallService : call external..InternalCallV2Test$CallService : tx active=false#internal()TransactionInterceptor : Getting transaction for [..InternalService.internal]..rnalCallV2Test$InternalService : call internal..rnalCallV2Test$InternalService : tx active=trueTransactionInterceptor : Completing transaction for [..InternalService.internal] 클라이언트 테스트 코드는 callService.external() 호출. callService는 클래스 외부, 내부에 @Transactional이 없으므로 실제 객체임 임 callService는 주입 받은 internalService.internal()을 호출 internalService는 트랜잭션 프록시이며 internal() 메소드에 @Transactional이 붙어 있으므로 트랜잭션 프록시는 트랜잭션을 적용 트랜잭션 적용 후 실제 internalService 객체 인스턴스의 internal()을 호출트랜잭션 AOP 주의 사항 - 초기화 시점초기화 코드(예: @PostConstruct)와 @Transactional을 함꼐 사용하면 트랜잭션이 적용되지 않음.@PostConstruct@Transactionalpublic void init() { boolean isActive = TransactionSynchronizationManager.isActualTransactionActive(); log.info(&quot;Hello init @PostConstruct tx active={}&quot;, isActive);}Hello init @PostConstruct tx active=false이는 트랜잭션 AOP를 포함한 스프링 컨테이너가 완전히 생성되기도 전에 해당 초기화 코드가 호출되어 AOP가 적용되지 못하여 발생하는 문제.이를 해결하기 위해 @PostConstruct 와 같은 초기화 방법이 아닌 ApplicationReadyEvent 이벤트를 사용하여 초기화에 이용하면 해결 됨@EventListener(value = ApplicationReadyEvent.class)@Transactionalpublic void init() { boolean isActive = TransactionSynchronizationManager.isActualTransactionActive(); log.info(&quot;Hello init @PostConstruct tx active={}&quot;, isActive);}TransactionInterceptor : Getting transaction for [Hello.init]..ngtx.apply.InitTxTest$Hello : Hello init ApplicationReadyEvent tx active=trueTransactionInterceptor : Completing transaction for [Hello.init]이 ApplicationReadyEvent 이벤트는 트랜잭션 AOP를 포함한 스프링 컨테이너가 완전히 생성되고 난 다음에 이벤트가 붙은 메소드를 호출하기 떄문에 트랜잭션을 적용할 수 있음.예외와 트랜잭션 커밋, 롤백 예외 발생시 스프링 트랜잭션 AOP는 예외의 종류에 따라 트랜잭션을 커밋하거나 롤백 함 언체크 예외인 RuntimeException, Error와 그 하위 예외가 발생하면 트랜잭션을 롤백 체크 예외인 Exception과 그 하위 예외가 발생하면 트랜잭션을 커밋 정상 응답(리터)시 트랜잭션을 커밋 스프링은 기본적으로 체크 예외는 비지니스 의미가 있을때 사용하고, 런타임(언체크) 예외는 복구 불가능한 예외로 가정함 체크 예외 : 비지니스 의미가 있을때 사용 언체크 예외 : 복구 불가능한 예외그러나 이는 필수가 아니며, 개발자가 rollbackFor라는 옵션을 통해 체크 예외에도 롤백이 가능함비지니스 예외비지니스 예외라는 내용에 대하여 예시를 통해 설명하면 아래와 같음주문을 하는데 있어 비지니스 요구사항을 아래와 같이 가정함 정상 : 주문시 결제를 성공하면 주문 데이터를 저장하고 결제 상태를 완료 처리 시스템 예외 : 주문시 내부에 복구 불가능한 예외가 발생하면 전체 데이터 롤백 처리 비지니스 예외 : 주문시 고객의 결제 잔고가 부족하면 주문 데이터를 저장하고 결제 상태를 대기로 처리하고 고객에게 잔고 부족을 알리고 별도의 계좌로 입급하도록 안내위와 같은 상황일떄, 결제 잔고가 부족하면 NotEnoughMoneyException 예외가 발생한다고 가정한다면,이 예외는 시스템에 문제가 있어 발생하는 시스템 예외가 아님.시스템은 정상 동작 했지만 비지니스 상황에서 문제가 되기 떄문에 발생한 예외.이와 같은 상황을 비지니스 예외라고 함. 이러한 비지니스 예외는 매우 중요하고 반드시 처리해야 하는 경우가 많으므로 주로 체크 예외를 고려 할 수 있음.예외에 대한 정리 스프링의 기본값은 체크 예외일떄는 커밋, 언체크 예외일떄는 롤백을 수행 함 비지니스 상황에 다라 체크 예외의 경우에도 트랜잭션을 커밋하지 않고 롤백할 수 있으며 이때는 rollbackFor 옵션 사용 런타임 예외는 항상 롤백되며 체크 예외의 경우 rollbackFor 옵션을 사용하여 비지니스 상황에 따라 커밋과 롤백을 선택할 수 있음참고 스프링 DB - 데이터 접근 활용 기술(김영한)" }, { "title": "Spring DB - 식별자(PK) 선택 전략", "url": "/posts/spring-db-06/", "categories": "Backend, Spring DB", "tags": "Web, Spring Framework, DataBase", "date": "2023-10-15 10:00:00 +0900", "snippet": "권장하는 식별자 선택 전략데이터베이스의 기본키는 다음 3가지 조건을 모두 만족해야 함 null 값을 허용하지 않음 유일해야 함 변해선 안됨위 조건을 기반으로 테이블의 기본 키를 선택하는 전략은 크게 2가지가 있음 자연 키(natural key) 비지니스에 의미있는 혹은 연관된 키 예) 주민등록번호, 이메일, 전화번호 등 대리 (surrogate key) 비지니스와 관련없는 임의로 만들어진 키 대체 키로도 불림 예) 오라클 시퀀스, auto_increment. identity, 키생성 테이블 등 자연 키 보다는 대리 키를 권장하는데, 그 이유는 자연키의 경우 비지니스와 연관된 내용을 키로 사용하기 때문에 비지니스 규칙이 변경된다면 더이상 기본키의 조건을 만족하지 못할 수도 있음참고 스프링 DB - 데이터 접근 활용 기술(김영한)" }, { "title": "Spring DB - 예외처리, 반복", "url": "/posts/spring-db-05/", "categories": "Backend, Spring DB", "tags": "Web, Spring Framework, DataBase", "date": "2023-10-14 16:00:00 +0900", "snippet": "체크 예외와 인터페이스서비스 계층은 가급적이면 특정 구현 기술에 의존하지 않고 순수하게 유지되는 것이 좋음. 그러나 이렇게 하려면 예외에 대한 의존도 함꼐 해결해야 함예를 들어서 리포지토리가 던지는 SQLException 체크 예외는 서비스에서 처리할수 있든 없든 체크 예외이므로 반드시 SQLException 예외에 의존하게 됨.이러한 문제를 해결하기 위해 서비스가 처리할 수 없는 리포지토리의 예외를 체크예외가 아닌 런타임 예외로 전환하여 서비스 계층에 던지게 하면 런타임 예외이므로 서비스 계층에선 해당 예외를 무시할 수 있게되고 특정한 구현 기술에 의존하지 않아도 됨데이터 접근 예외데이터베이스 오류에는 보통 각 오류에 대한 오류 코드가 존재함각각의 데이터베이스 마다 자신의 오류코드를 직접 정의하며 예외 발생시 해당 오류코드도 같이 전달함스프링 예외 추상화 이해 스프링은 데이터 접근 계층에 대한 수십가지 예외를 정리하여 일관된 예외 계층을 제공 각각의 예외는 특정 기술에 종속적이지 않게 설계되어 있음. 그러므로 서비스 계층에서도 스프링이 제공하는 에외를 사용하면 됨 JDBC나 JPA를 사용할 때 발생하는 예외를 스프링이 제공하는 예외로 변환해주는 역할도 스프링이 제공함 예외의 최고 상위는 org.springframework.dao.DataAccessException 스프링이 제공하는 데이터 접근 계층의 모든 예외는 런타임 예외 임 DataAccessException는 크게 2가지로 구분하되는데 NonTransient예외와 Transient예외 두가지가 있음 NonTransient 일시적이지 않은 예외 SQL 문법오류, 데이터베이스 제약조건과 같은 SQL을 그대로 반복해서 실행하면 실패 함 Transient 일시적 예외 Transient 하위의 예외는 동일한 SQL을 다시 시도했을떄 성공할 가능성이 있음 예를 들면 쿼리 타임아웃, 락과 관련된 오류 스프링이 제공하는 예외 변환기스프링은 데이터베이스에서 발생하는 오류 코드를 스프링이 정의한 예외로 자동으로 변환해주는 변환기를 제공 함@Testvoid exceptionTranslator() { String sql = &quot;select bad grammar&quot;; try { Connection con = dataSource.getConnection(); PreparedStatement stmt = con.prepareStatement(sql); stmt.executeQuery(); } catch (SQLException e) { assertThat(e.getErrorCode()).isEqualTo(42122); //org.springframework.jdbc.support.sql-error-codes.xml SQLExceptionTranslator exTranslator = new SQLErrorCodeSQLExceptionTranslator(dataSource); //org.springframework.jdbc.BadSqlGrammarException DataAccessException resultEx = exTranslator.translate(&quot;select&quot;, sql, e); log.info(&quot;resultEx&quot;, resultEx); assertThat(resultEx.getClass()).isEqualTo(BadSqlGrammarException.class); }}각 DB마다 정의한 SQL 에러코드는 저마다 다른데, 스프링은 이를 sql-error-codes.xml에 정의하여 에러코드를 예외로 변환함&amp;lt;bean id=&quot;H2&quot; class=&quot;org.springframework.jdbc.support.SQLErrorCodes&quot;&amp;gt; &amp;lt;property name=&quot;badSqlGrammarCodes&quot;&amp;gt; &amp;lt;value&amp;gt;42000,42001,42101,42102,42111,42112,42121,42122,42132&amp;lt;/value&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;property name=&quot;duplicateKeyCodes&quot;&amp;gt; &amp;lt;value&amp;gt;23001,23505&amp;lt;/value&amp;gt; &amp;lt;/property&amp;gt;&amp;lt;/bean&amp;gt;&amp;lt;bean id=&quot;MySQL&quot; class=&quot;org.springframework.jdbc.support.SQLErrorCodes&quot;&amp;gt; &amp;lt;property name=&quot;badSqlGrammarCodes&quot;&amp;gt; &amp;lt;value&amp;gt;1054,1064,1146&amp;lt;/value&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;property name=&quot;duplicateKeyCodes&quot;&amp;gt; &amp;lt;value&amp;gt;1062&amp;lt;/value&amp;gt; &amp;lt;/property&amp;gt;&amp;lt;/bean&amp;gt;... org.springframework.jdbc.support.sql-error-codes.xml스프링 예외 추상화 정리 스프링은 데이터 접근 계층에 대한 일관된 에외 추상화를 제공함 스프링은 예외 변환기를 통해 SQLException의 ErrorCode에 맞는 적절한 스프링 데이터 접근 예외로 변환 해 줌 만약 서비스, 컨트롤러 계층에서 예외 처리가 필요하면 특정 기술에 종속적인 SQLException 같은 예외보단 스프링이 제공하는 데이터 접근 예외를 사용하면 됨 스프링이 제공하는 예외를 사용하기 때문에 스프링에 대한 기술 종속성은 발생함JDBC 반복문제 - JdbcTemplate리포지토리에서 동작하는 각 메소드는 보통 아래와 같은 공통 코드가 필요하게 됨 커넥션 조회, 커넥션 동기화 PreparedStatement 생성 및 파라미터 바인딩 쿼리 실행 결과 바인딩 예외 발생시 스프링 예외 변환기 실행 리소스 종료위와 같은 반복된 코드를 효과적으로 처리하는 방법이 템플릿 콜백 패턴임.스프링은 JDBC의 반복 문제를 해결하기 위해 JdbcTemplate이라는 템플릿을 제공함public class MemberRepositoryImpl implements MemberRepository { private final JdbcTemplate template; public MemberRepositoryImpl(DataSource dataSource) { template = new JdbcTemplate(dataSource); } @Override public Member save(Member member) { String sql = &quot;insert into member(member_id, money) values(?, ?)&quot;; template.update(sql, member.getMemberId(), member.getMoney()); return member; } @Override public Member findById(String memberId) { String sql = &quot;select * from member where member_id = ?&quot;; return template.queryForObject(sql, memberRowMapper(), memberId); } @Override public void update(String memberId, int money) { String sql = &quot;update member set money=? where member_id=?&quot;; template.update(sql, money, memberId); } @Override public void delete(String memberId) { String sql = &quot;delete from member where member_id=?&quot;; template.update(sql, memberId); } private RowMapper&amp;lt;Member&amp;gt; memberRowMapper() { return (rs, rowNum) -&amp;gt; { Member member = new Member(); member.setMemberId(rs.getString(&quot;member_id&quot;)); member.setMoney(rs.getInt(&quot;money&quot;)); return member; }; }}JdbcTemplate은 JDBC로 개발할 떄 발생하는 반복을 대부분 해결해 줌.또한 트랜잭션을 위한 커넥션 동기화, 예외 발생시의 스프링 예외 변환기도 자동으로 실행 함.정리 서비스 계층의 순수성 트랜잭션 추상화 + 트랜잭션 AOP 덕분에 서비스 계층의 순수성을 최대한 유지하면서 서비스 계층에서 트랜잭션을 사용할 수 있음 스프링이 제공하는 예외 추상화와 변환기 덕분에, 데이터 접근 기술이 변경되어도 서비스 계층의 순수성을 유지하면서 예외도 사용할 수 있음 서비스 계층이 리포지토리 인터페이스에 의존한 덕분에 향후 리포지토리가 다른 구현 기술로 변경되어도 서비스 계층을 순수하게 유지할 수 있음 리포지토리에서 JDBC를 사용하는 반복코드가 JdbcTemplate으로 대부분 제거할 수 있음참고 스프링 DB - 데이터 접근 핵심 원리(김영한)" }, { "title": "Java - Exception", "url": "/posts/java-01/", "categories": "Java", "tags": "Java, Exception", "date": "2023-10-14 13:00:00 +0900", "snippet": "예외 계층 Object 예외도 객체 모든 객체의 최상위 부모는 Object이므로 예외의 최상위 부모도 Object Throwable 최상위의 예외 Error 메모리 부족이나 심각한 시스템 오류와 같이 어플리케이션에서 복구 불가능한 시스템 예외 어플리케이션 개발자는 이 예외를 잡으면 안됨 상위 예외를 catch로 잡으면 그 하위 예외까지 잡히기 떄문에 Throwable 예외도 잡으면 안됨 Throwable 예외를 catch로 잡으면 하위인 Error 예외도 함꼐 잡히기 때문 언체크 예외 Exception 체크 예외 어플리케이션 로직에서 사용할 수 있는 실질적인 최상위 예외 Exception와 그 하위 예외는 모두 컴파일러가 체크하는 체크 예외임. 단 RuntimeException만은 해당이 안됨 RuntimeException 언체크 예외. 런타임 예외 컴파칠러가 체크하지 않는 언체크 예외 RuntimeException과 그 자식 예외는 모두 언체크 예외 임 RuntimeException의 이름을 따라서 RuntimeException과 그 하위 언체크 예외를 런타임 에러라고도 함 예외의 기본 규칙예외는 기본적으로 잡아서 처리하거나, 처리할 수 없다면 밖으로 던져야 함 예외는 잡아서 처리하거나 던져야 함 예외를 잡거나 던질떄 지정한 예외 뿐만 아니라 그 예외의 자식들도 함꼐 처리됨 예를 들어 Exception을 catch로 잡으면 그 하위 예외들도 모두 잡을 수 있음 예를 들어 Exception을 throws로 던지면 그 하위 예외들도 모두 던질 수 있음 예외 처리 5번에서 예외를 처리하면 이후에는 어플리케이션 로직이 정상흐름으로 동작예외 던짐 여예를 처리하지 못하면 호출한 곳으로 예외를 계속 던짐체크 예외 Exception과 그 하위 예외는 모두 컴파일러가 체크하는 체크 예외. 단 RuntimeException만은 제외됨 체크 예외는 잡아서 처리하거나 또는 밖으로 던지도록 선언해야 함. 그렇지 않으면 컴파일 오휴 발생static class MyCheckedException extends Exception { public MyCheckedException(String message) { super(message); }}// 체크 예외를 잡아서 처리하는 코드try { repository.call();} catch (MyCheckedException e) { //예외 처리 로직}// 체크 예외를 잡아서 처리하는 코드try { repository.call();} catch (Exception e) { //예외 처리 로직} catch에 예외를 지정하면 해당 예외와 그 하위 타입 예외를 모두 잡음 MyCheckedException의 상위 타입인 Exception을 적더라도 MyCheckedException을 잡을 수 있음 // 체크 예외를 밖으로 던지는 코드public void callThrow() throws MyCheckedException { repository.call();}public void callThrow() throws Exception { repository.call();} 체크 예외를 처리할 수 없는 경우에는 “Method() throws 예외”를 사용하여 밖으로 던질 예외를 필수적으로 지정해야 함 throw를 지정하지 않으면 첨파일 오류 발생 체크 예외의 경우 예외를 잡아서 처리하거나 또는 throws를 지정하여 예외를 밖으로 던진다는 선언을 필수로 해주어야 함 throws에 지전한 타입과 그 하위 타입 예외를 밖으로 던짐 throws에 MyCheckedException의 상위 타입인 Exception을 적어주어도 MyCheckedException을 던짐 언처크 예외 RuntimeException과 그 하위 예외는 언체크 예외로 분류 언체크 예외는 컴파일러가 예외를 체크하지 않는다는 뜻 언체크 예외는 체크 예외와 기본적으로 동일하지만 언체크 예외는 예외를 던지는 throws를 선언하지 않고 생략이 가능함. 이 경우 자동으로 예외를 던짐체크 예외 vs 언체크 예외 체크 예외 : 예외를 잡아서 처리하지 않으면 항상 throws에 던지는 예외 선언을 해야함 해당 예외를 잡아서 반드시 처리해야하는 비지니스 로직상의 문제에서 던지는 예외에만 사용 예를 들면 계좌 이체 실패, 결제시 포인틑 부족, 로그인 ID, PW 불필치 등 언체크 예외 : 예외를 잡아서 처리하지 않아도 throws를 생략할 수 있음 기본적으로 언체크 예외를 사용하는 것이 좋음 사실상 체크 예외와 언체크 예외의 차이는 예외를 처리할 수 없을 때 예외를 밖으로 던지는 부분에 있음.throws 부분을 필수로 선언해야 하는가 생략할 수 있는가의 차이임.체크 예외의 문제점 서비스 체크 예외를 처리하지 못해서 밖으로 던지기 위해 logic() throws SQLException, ConnectException 를 선언 컨트롤러 체크 예외를 처리하지 못해서 밖으로 던지기 위해 request() throws SQLException, ConnectException 를 선언 위 그림으로 볼떄 크게 두가지 문제가 있을 수 있음 복구 불가능한 예외 의존 관계에 대한 문제복구 불가능한 예외대부준의 예외는 복구가 불가능 함. SQLException을 예로 들면 데이터베이스에 무언가 문제가 있어서 발생하는 예외인데, SQL 문법에 문제가 있을 수 있고, 데이터베이스 자체에 문제가 발생했을 수도 있으며 데이터베이스가 아예 다운되었을 수도 있음. 이러한 문제는 대체로 어플리케이션에선 복구가 불가능 함. 따라서 대부분의 서비스와 컨트롤러에서도 이 문제를 해결 할 수 없으며 해결하지 못하는 예외를 공통 예외 처리 로직 까지 예외를 던져야 함의존 관계에 대한 문제체크 예외이기 때문에 서비스나 컨트롤러 입장에서는 자신이 처리하지 못하더라도 throws를 통해 예외를 던져야 함class Controller { public void request() throws SQLException, ConnectException { service.logic(); }}class Service { public void logic() throws SQLException, ConnectException { repository.call(); networkClient.call(); }}위와 같은 결루, 서비스나 컨트롤러는 단순히 예외를 던지기 위해 SQLException를 의존하게 되는 문제가 발생 함.추후 리포지토리를 JDBC 기술이 아닌 다른 기술로 변경해야 한다면 SQLException에 의존하던 모든 서비스, 컨트롤러의 코드를 수정해야 함.결국 자신이 처리하지도 못하는 예외로 인하여 의존관계가 성립되어 OCP, DI에 위배되는 코드가 되는 문제가 있음런타임 예외의 활용 SQLException을 런타임 예외인 RuntimeSQLException으로 변환 ConnectionExceoption 대신 RuntimeConnectionExceoption으로 변환 런타임 예이이기 때문에 서비스, 컨트롤러는 해당 예외를 처리할 수 없다면 별도의 선언 없이 그냥 두면 됨런타임 예외 - 복구 불가능한 예외시스템에서 발생하는 예외는 대부분 복구 불가능한 예외.런타임 예외를 사용하면 서비스나 컨트롤러가 이러한 복구 불가능한 예외를 신경쓰지 않아도 됨. 물론 이러한 복구 불가능한 예외는 일관성 있게 공통으로 처리해야 함런타임 예외 - 의존 관계에 대한 문제런타임 예외는 해당 객체가 처리할 수 없는 예외는 무시하면 됨. 그러므로 체크 예외 처럼 throws를 갈제로 사용하지 않아도 되기 때문에 예외를 강제로 의존하지 않음 서비스와 컨트롤러에선 의존관계가 발생하지 않기 때문에 기술 변경시 코드를 변경하지 않아도 됨 공통으로 예외를 처리하는 부분의 코드만 변경하면 되기 때문에 변경의 영향 범위를 최소화 할 수 있음예외 포함예외를 전환할떄는 발생한 예외의 원일 파악을 위해 반드시 기존 예외가 포홈되어야 함public void call() { try { runSQL(); } catch (SQLException e) { throw new RuntimeSQLException(e); //기존 예외(e) 포함 }}13:10:45.626 [Test worker] INFO hello.jdbc.exception.basic.UncheckedAppTest - exhello.jdbc.exception.basic.UncheckedAppTest$RuntimeSQLException: java.sql.SQLException: exat hello.jdbc.exception.basic.UncheckedAppTest$Repository.call(UncheckedAppTest.java:61)at hello.jdbc.exception.basic.UncheckedAppTest$Service.logic(UncheckedAppTest.java:45)at hello.jdbc.exception.basic.UncheckedAppTest$Controller.request(UncheckedAppTest.java:35)at hello.jdbc.exception.basic.UncheckedAppTest.printEx(UncheckedAppTest.java:24)Caused by: java.sql.SQLException: exat hello.jdbc.exception.basic.UncheckedAppTest$Repository.runSQL(UncheckedAppTest.java:66)at hello.jdbc.exception.basic.UncheckedAppTest$Repository.call(UncheckedAppTest.java:59)public void call() { try { runSQL(); } catch (SQLException e) { throw new RuntimeSQLException(); //기존 예외(e) 미포함 }}[Test worker] INFO hello.jdbc.exception.basic.UncheckedAppTest - exhello.jdbc.exception.basic.UncheckedAppTest$RuntimeSQLException: nullat hello.jdbc.exception.basic.UncheckedAppTest$Repository.call(UncheckedAppTest.java:61)at hello.jdbc.exception.basic.UncheckedAppTest$Service.logic(UncheckedAppTest.java:45) 기존 예외를 포함하지 않아서 기존에 발생한 SQLException과 스텍 트레이스를 확인 할 수 없고 변환한 RuntimeSQLException부터 예외를 확인할 수 있음예외를 전환할 때는 반드시 기존 예외를 포함하도록 해야 함참고 스프링 DB - 데이터 접근 핵심 원리(김영한)" }, { "title": "Chromium - Netowk", "url": "/posts/chromium_network_service/", "categories": "Chromium", "tags": "Chromium", "date": "2023-10-13 22:58:00 +0900", "snippet": "Chromium의 Network ServiceNetwork Process(Utility Process) Class DiagramTLS Handshaking Sequence https://www.chromium.org/developers/design-documents/network-stack/https://docs.google.com/document/d/1wAHLw9h7gGuqJNCgG1mP1BmLtCGfZ2pys-PdZQ1vg7M/edit?pref=2&amp;amp;pli=1#heading=h.7001qjw7yymp" }, { "title": "Spring MVC - MVC 패턴 개요", "url": "/posts/spring-mvc-01/", "categories": "Backend, Spring MVC", "tags": "Web, Spring Framework", "date": "2023-10-13 21:50:00 +0900", "snippet": "MVC 패턴하나의 서블릿이나 JSP만으로는 비지니스 로직과 뷰 렌더링까지 모두 처리하게 되면 너무 많은 역할을 하게되고 결국 유지보수가 어려워짐. 비지니스 로직을 호출하는 부분만 변경이 발생해도, UI만을 변경하더라도 같은 파일을 수정해야 함가장 중요한 포인트는 비지니스 로직과 UI는 서로간 변경의 라이프 사이클이 다르다는 점.UI를 일부 수정하는 작업과 비지니스 로직을 수정하는 작업은 각각 다르게 발생할 가능성이 높고 대부분의 경우 서로간 영향을 주시 않음.이렇게 변경의 라이프 사이클이 다른 부분을 하나의 코드로 관리하는 것은 유지보수에 어려움이 있음 MVC 패턴이전의 웹 어플리케이션Model, View, ControllerMVC 패턴은 지금까지 학습한 것 처럼 하나의 서블릿이나 JSP로 처리하던 것을 Controller와 View라는 영역으로 서로 역할을 나눈 구조.현재의 웹 어플리케이션은 보통 이 MVC 패턴을 사용함. Controller HTTP 요청을 받아서 파라미터를 검증하고 비지니스 로직을 실행함 뷰에 전달할 결과 데이터를 조회하여 모델에 담음 Model 뷰에 출력할 데이터를 저장해둠 뷰가 필요한 데이터를 모두 모델에 담아서 전달해주는 덕분에 뷰는 비지니스 로직이나 데이터 접근을 몰라도 되고 화면을 렌더링 하는 일에 집중할 수 있음 View 모델에 담겨있는 데이터를 사용하여 화면을 그리는 담당 참고 스프링 MVC - 백엔드 웹 개발 핵심 기술(김영한)" }, { "title": "Spring DB - 스프링을 통한 트랜잭션 동작 개선", "url": "/posts/spring-db-04/", "categories": "Backend, Spring DB", "tags": "Web, Spring Framework, DataBase", "date": "2023-10-13 16:20:00 +0900", "snippet": "어플리케이션 구조현재 가장 많이 사용하는 어플리케이션의 구조는 역할에 따라 3가지 계층으로 나누는 것 프리젠테이션 계층 UI와 관련된 처리 담당 웹 요청과 응답 사용자 요청을 검증 주 사용 기술 : 서블릿, HTTP와 같은 웹 기술, 스프링 MVC 서비스 계층 비지니스 로직 담당 가급적이면 특정 기술에 의존하지 않고 순수 자바코드로 작성하는 것이 좋음 데이터 접근 계층 실제 데이터베이스에 접근하는 코드 주요 사용 기술 : JDBC, JPA, File, Redis, Mongo DB 등 순수한 서비스 계층보통 핵심 비지니스 로직을 수행하는 서비스 계층이 다른 계층보다 우선시 되곤 함. 시간이 흘러 UI, 웹과 같은 기술이 변하고 데이터 저장 기술 또한 다른 기술로 변한다고 하더라도 비지니스 로직은 최대한 변경 없이 유지되어야 하기 떄문.서비스 계층을 최대한 변경없이 유지하려면 특정 기술에 종속적이지 않게 개발해야 함. 그래야 비지니스 로직을 유지보수 하거나 테스트 및 비지니스 로직 변경등에 있어서 수정을 최소화 할 수 있음.트랜잭션 추상화구현 기술에 따른 트랜잭션 사용번 트랜잭션은 원자적 단위의 비지니스 로직을 처리하기 위해 사용됨 구현 기술마다 트랜잭션을 사용하는 방법이 다름 JDBC : connection.setAudoCommit(false) JPA : transaction.begin() 트랜잭션을 사용하는 코드는 데이터 접근 기술마다 다름.만약 JDBC 기술을 사용해 JDBC 트랜잭션에 의존하다가 JPA 기술로 변경하게 되면 서비스 계층의 트랜잭션을 처리하는 코드를 모두 수정해야함. JDBC 트랜잭션에 의존 JDBC 기술을 사용하다가 JPA 기술로 변경할 시 서비스 계층의 코드를 JPA 기술을 사용하도록 수정해야 함위와 같은 문제를 해결하기 위한 방법중 하나는 아래와 같이 트랜잭션 기능을 추상화 하는 것.public interface TxManager { public void begin(); public void commit(); public void rollback();}서비스는 특정 트랜잭션 기술에 직접 의존하는 것이 아닌 TxManager 라는 추상화된 인터페이스에 의존하게 함이후 원하는 구현체를 DI를 통해 주입받아 사용하면 됨.이렇게 되면 클라이언트인 서비스는 인터페이스에 의존하고 DI를 사용한 덕분에 OCP 원칙을 지킬 수 있음스프링의 트랜잭션 추상화 및 동기화스프링이 제공하는 트랜잭션 매니저는 크게 2가지 역할을 함 트랜잭션 추상화 트랜잭션 동기화스프링의 트랜잭션 추상화스프링은 이미 위와 같은 트랜잭션 추상화 기능을 제공하고 있음. 또한 각 데이터 접근 기술에 대한 트랜잭션 구현체도 대부분 구현되어 있어 개발자는 단순히 사용만 하면 됨. 스프링의 트랜잭션 추상화의 핵심은 PlatformTransactionManager 인터페이스 org.springframework.transaction.PlatformTransactionManager 스프링의 트랜잭션 동기화트랜잭션을 유지하려면 트랜잭션의 시작부터 끝까지 같은 데이터베이스 커넥션을 유지하여 세션을 유지해야 함.결국 같은 커넥션을 동기화하기 위해서 이전에는 파라미터로 커넥션을 전달하는 방법을 사용했지만 해당 방법은 코드의 가독성과 중복 코드등의 여러 단점이 존재 함. 스프링은 트랜잭션 동기화 매니저를 제공함 트랜잭션 동기화 매니저는 쓰레드 로컬(ThreadLocal)을 사용하여 커넥션을 동기화 해줌 트랜잭션 매니저는 내부에서 해당 트랜잭션 동기화 매니저를 사용함 트랜잭션 동기화 매니저는 쓰레드 로컬을 사용하기 떄문에 멀티쓰레드 상황에 안전하게 커넥션을 동기화 할 수 있게 해줌. 그러므로 커넥션이 필요하면 트랜잭션 동기화 매니저를 통해 커넥션을 획득하면 됨다음 트랜잭션 동기화 매니저 클래스를 열어서 확인해보면 쓰레드 로컬을 사용하는 것을 알 수 있음 org.springframework.transaction.support.TransactionSynchronizationManager 쓰레드 로컬을 사용하면 각각의 쓰레드마다 별도의 저장소가 부여되어 쓰레드는 자기 자신의 저장소의 데이터에만 접근할 수 있음트랜잭션 동기화 매니저의 동작방식 트랜잭션의 시작하려면 커넥션이 필요하므로 트랜잭션 매니저는 DataSource를 통해 커넥션을 만들고 트랜잭션을 시작함 트랜잭션 매니저는 트랜잭션이 시작된 커넥션을 트랜잭션 동기화 매니저에 보관 Repository는 트랜잭션 동기화 매니저에 보관된 커넥션을 꺼내서 사용 함 트랜잭션이 종료되면 트랜잭션 매니저는 트랜잭션 동기화 매니저에 보관된 커넥션을 통해 트랜잭션을 종료하고 커넥션을 닫음트랜잭션 매니저의 동작 흐름 클라이언트 요청으로 서비스 로직을 실행함 서비스계층에서 transactionManager.getTransaction()을 호출하여 트랜잭션 시작 트랜잭셕을 시작하려면 데이터베이스 커넥션이 필요하므로 트랜잭션 매니저는 내부에서 데이터 소스를 사용해 커넥션을 생성 커넥션을 수동 커밋 모드로 변경하여 실제 데이터베이스 트랜잭션을 시작 커넥션을 트랜잭션 동기화 매니저에 보관 트랜잭션 동기화 매니저는 쓰레드 로컬에 커넥션을 보관하여 멀티 쓰레드 환경에 안전하게 커넥션을 보관함 서비스는 비지니스 로직을 실행하면서 리포지토리의 메서드를 호출 리포지토리 메서드들은 트랜잭션이 시작된 커넥션이 필요하므로 리포지토리는 DataSourceUtils.GetConnection()을 호출하여 트랜잭션 동기화 매니저에 보관된 커넥션을 꺼내어 사용. 이 과정을 통해 같은 커넥션을 사용하고, 트랜잭션도 유지됨 획득한 커넥션을 사용하여 SQL을 데이터베이스에 전달하여 실행 비지니스 로직이 끝나고 트랜잭션을 종료. 트랜잭션은 커밋하거나 롤백하면 종료됨 트랜잭션을 종료하려면 동기화된 커넥션이 필요하므로 트랜잭션 동기화 매니저를 통해 동기화된 커넥션을 획득 획득한 커넥션을 통해 데이터베이스에 트랜잭션을 커밋하거나 롤백함 전체 리소스 정리 트랜잭션 동기화 매니저를 정리. 쓰레트 로컬은 사용후 반드시 정리해야함 connection.setAutoCommit(true) 로 되돌림. 커넥션 풀을 고려해야함 connection.clost() 를 호출하여 커넥션을 종료함. 커넥션 풀을 사용하는 경우 connection.clost()를 호출하면 커넥션 풀에 반환됨 정리트랜잭션 추상화 덕분에 서비스 코드를 이제 JDBC 기술에 의존하지 않음 이후 JDBC에서 JPA로 변경해도 서비스 코드를 그대로 유지 가능 기술 변경시 의존관계 주입만 DataSourceTransactionManager에서 JpaTransactionManager로 변경해주면 됨트랜잭션 템플릿트랜잭션을 사용할때 getTransaction() -&amp;gt; logic -&amp;gt; commit, rollback 과 같이 logic 이외에 반복되는 코드가 존재함이러한 반복코드를 제거하기 위해 스프링은 템플릿 콜백 패턴을 적용한 클래스를 제공함public class TransactionTemplate { private PlatformTransactionManager transactionManager; // return 값이 있을 때 사용 public &amp;lt;T&amp;gt; T execute(TransactionCallback&amp;lt;T&amp;gt; action){..} // return 값이 없을 때 사용 void executeWithoutResult(Consumer&amp;lt;TransactionStatus&amp;gt; action){..}}// 사용 예시public void accountTransfer(String fromId, String toId, int money) throws SQLException { transactionTemplate.executeWithoutResult((status) -&amp;gt; { // 코드에서 예외를 처리하기 위해 try~catch 가 들어갔는데, bizLogic() 메서드를 호출하면 // SQLException 체크 예외를 넘겨줌. // 해당 람다에서 체크 예외를 밖으로 던질 수 없기 때문에 언체크 예외로 바꾸어 던지도록 예외를 전환했다 try { //비즈니스 로직 bizLogic(fromId, toId, money); } catch (SQLException e) { throw new IllegalStateException(e); } }); } 트랜잭션 템플릿의 기본동작은 다음과 같음 비지니스 로직이 정상수행되면 커밋 언체크 예외가 발생하면 롤백. 그외의 경우 커밋 체크 예외의 경우에는 커밋 트랜잭션 AOP트랜잭션을 편리하게 처리하기 위해 트랜잭션 추상화와 반복적인 트랜잭션 로직을 해결하기 위해 트랜잭션 템플릿을 도입해봤으나, 서비스 계층에 순수한 비지니스 로직만 남지 않고 트랜잭션 관련 코드가 남는 문제가 존재이를 해결하기 위해 스프링 AOP를 통해 프록시를 도입.프록시 도입 전//트랜잭션 시작TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());try { //비즈니스 로직 bizLogic(fromId, toId, money); transactionManager.commit(status); //성공시 커밋} catch (Exception e) { transactionManager.rollback(status); //실패시 롤백 throw new IllegalStateException(e);}프록시 도입 후// proxy 코드public class TransactionProxy { private MemberService target; public void logic() { //트랜잭션 시작 TransactionStatus status = transactionManager.getTransaction(..); try { //실제 대상 호출 target.logic(); transactionManager.commit(status); //성공시 커밋 } catch (Exception e) { transactionManager.rollback(status); //실패시 롤백 throw new IllegalStateException(e); } }}// service 코드public class Service { public void logic() { //트랜잭션 관련 코드 제거, 순수 비즈니스 로직만 남음 bizLogic(fromId, toId, money); }} 스프링이 제공하는 AOP 기능을 사용하면 프록시를 매우 편리하게 적용할 수 있음 스프링 AOP를 직접 사용해서 트랜잭션을 처리해도 되지만 스프링은 트랜잭션 AOP를 처리하기 위한 모든 기능을 제공함. 스프링 부트를 사용하면 트랜잭션 AOP를 처리하기 위해 필요한 스프링 빈들도 자동으로 등록해줌 개발자는 트랜잭션 처리가 필요한 곳에 @Transactional 애노테이션만 붙여주면 됨 스프링의 트랜잭션 AOP는 이 애노테이션을 인식해서 트랜잭션 프록시를 적용함 @Transactionalorg.springframework.transaction.annotation.Transactional 참고스프링 AOP를 적용하려면 어드바이저, 포인트컷, 어드바이스가 필요함.스프링은 트랜잭션 AOP 처리를 위해 다음 클래스를 제공함. 스프링 부트를 사용하면 해당 빈들은 스프링 컨테이너에 자동으로 등록됨 어드바이저: BeanFactoryTransactionAttributeSourceAdvisor포인트컷: TransactionAttributeSourcePointcut어드바이스: TransactionInterceptor트랜잭션 AOP 적용 전체 흐름선언적 트랜잭션 관리 vs 프로그래밍 방식 트랜잭션 관리 선언적 트랜잭션 관리(Declarative Transaction Management) @Transactional 어노테이션 하나만 선언하여 편리하게 트랜잭션을 적용하는 방식 선언적 트랜잭션 관리가 프로그래밍 방식에 비해 간편하고 실용적이므로 실무에선 주로 선언적 프로그래밍 방식을 사용 프로그래밍 방식 트랜잭션 관리(Programmatic transaction management) 트랜잭션 매니저 또는 트랜잭션 템플릿 등을 사용하여 트랜잭션 관련 코드를 직접 작성하는 방식 스프링 컨테이너나 스프링 AOP 기술 없이 간단히 사용할 수 있지만 실무에서는 대부분 스프링 컨테이너나 스프링 AOP 기술을 사용하기 떄문에 거의 사용되지 않음 가끔 테스트시에 사용되기도 함 스프링 부트의 자동 리소스 등록스프링 부트가 등작하기 이전에는 데이터소스와 트랜잭션 매니저를 개발자가 직접 스프링 빈으로 등록하여 사용 했음.이후 스프링 부트에서 많은 부분이 자동화 되면서 데이터 소스와 트랜잭션 매니저 또한 자동으로 등록해줌 데이터소스 자동등록 스프링 부트는 데이터소스(DataSource)를 스프링 빈에 자동으로 등록함 자동으로 등록된 스프링 빈 이름은 dataSource 트랮잭션 매니저 자동등록 스프링 부트는 적절한 트랜잭션 매니저(PlatformTransctionManager)를 자동으로 스프링 빈에 등록함 자동으로 등록된 스프링 빈 이름은 transactionManager 어떤 트랜잭션 매니저를 선택할지는 현재 등록된 라이브러리를 보고 판단 JDBC를 기술을 사용하면 DataSourceTransactionManager를 빈으로 등록하고, JPA를 사용하면 JpaTransactionManager를 빈으로 등록함. 둘다 사용하는 경우 JpaTransactionManager를 등록 개발자가 직접 데이터소스나 트랜잭션 매니저를 등록하면 스프링 부트는 자동으로 등록하지 않음데이터 소스와 트랜잭션 매니저 자동등록# application.propertiespring.datasource.url=jdbc:h2:tcp://localhost/~/testspring.datasource.username=saspring.datasource.password=@TestConfiguration static class TestConfig { // 스프링 부트에서 자동으로 생성된 DataSource를 주입 private final DataSource dataSource; public TestConfig(DataSource dataSource) { this.dataSource = dataSource; } @Bean MemberRepositoryV3 memberRepository() { return new MemberRepositoryV3(dataSource); } @Bean MemberServiceV3_3 memberService() { return new MemberService(memberRepository()); } }참고 스프링 DB - 데이터 접근 핵심 원리(김영한)" }, { "title": "Spring DB - 트랜잭션 이해", "url": "/posts/spring-db-03/", "categories": "Backend, Spring DB", "tags": "Web, Spring Framework, DataBase", "date": "2023-10-13 13:10:00 +0900", "snippet": "트랜잭션데이터를 데이터베이스에 저장하는 대표적인 이유는 데이터베이스가 트랜잭션 이라는 개념을 지원하기 때문트랜잭션이란 데이터베이스에서 하나의 작업을 안전하게 처리하도록 보장해주는 것을 뜻함예를 들면, A가 B에게 1000원 계좌이체를 한다고 생각했을떄, A의 잔고 1000원 감소 B의 잔고 1000원 증가위 두가지 작업이 합쳐 하나의 작업처럼 동작해야 함. 만약 첫번쨰 작업만 성공하고 두번쨰 작업이 실패한다면 A의 잔고만 1000원 감소하는 심각한 문제가 발생하게 돰.이러한 문제에 대하여 데이터베이스의 트랜잭션은 첫번쨰, 두번째 작업이 둘다 함꼐 성공해야 데이터를 저장하고 중간에 하나라도 실패하면 작업 전의 상태로 되돌아 갈 수 있도록 함모든 작업이 성공해서 데이터베이스에 정상 반영되는것은 Commit, 작업중 실패하여 이전 상태로 되돌아 가는것을 Rollback 이라고 함트랜잭션 ACID트랜잭션은 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)를 보장해야 함 원자성(Atomicity) 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것 처럼 모두 성공하거나 모두 실패해야 함 일관성(Consistency) 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 함 데이터베이스에서 정한 무결성 제약조건을 항상 만족해야 함 격리성(Isolation) 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리되어야 함 동시에 같은 데이터를 수정하지 못하도록 해야 함 격리성은 동시성과 관련된 성능이슈로 인하여 트랜잭션의 격리 수준(Isolation Level)을 선탠할 수 있음 지속성(Durability) 트랜잭션을 성공적으로 끝내며 그 결과가 항상 기록되어야 함 중간에 시스템에 문제가 생기더라도 데이터베이스 로그 등을 사용하여 성공한 트랜잭션 내용을 복구 할 수 있어야 함 트랜잭션 격리 수준 Read Uncommited(커밋되지 않은 읽기) Read Commited(커밋된 읽기) Repeatable Read(반복 가능한 읽기) Serializable(직렬화 가능)성능과 데이터의 무결성을 어느정도 타협하여 보통 Read Commited(커밋된 읽기), Repeatable Read(반복 가능한 읽기)을 사용함데이터베이스 연결 구조와 DB 세션 사용자는 웹 어플리케이션 서버(WAS)나 데이터베이스 접근 툴과 같은 클라이언트를 사용하여 데이터베이스 서버에 접근할 수 있음 클라이언트는 데이터베이스 서버에 연결을 요청하고 커넥션을 맺게 되고 이때 데이터베이스 서버 내부에는 세션이라는 것을 생성함 앞으로 해당 커넥션을 통한 모든 요청은 이 세션을 통해서 실행하게 됨 예를 들어 개발자가 클라이언트를 통해 SQL을 전달하면 현재 커넥션에 연결된 세션이 SQL을 실행함 세션은 트랜잭션을 실행하고 커밋 또는 롤백을 통해 트랜잭션을 종료 함. 이후 새로운 트랜잭션을 다시 시작 할 수 있음 사용자가 커넥션을 닫거나 관리자가 세션을 갈제로 종료하면 세션을 종료됨 만약 커넥션 풀이 10개의 커넥션을 생성하면 세션도 10개가 만들어짐트랜잭션의 자동 커밋과 수동 커밋drop table member if exists cascade;create table member ( member_id varchar(10), money integer not null default 0, primary key (member_id));-- 자동 커밋(기본값)set autocommit true; -- 자동 커밋 모드 설정insert into member(member_id, money) values (&#39;data1&#39;,10000); -- 자동 커밋insert into member(member_id, money) values (&#39;data2&#39;,10000); -- 자동 커밋-- 수동 커밋set autocommit false; -- 수종 커밋 모드 설정insert into member(member_id, money) values (&#39;data3&#39;,10000); -- 수동 커밋insert into member(member_id, money) values (&#39;data4&#39;,10000); -- 수동 커밋-- 트랜잭션 성공하여 커밋commit;-- 트랜잭션 실패하여 롤백rollback; 자동 커밋 자동 커밋으로 설정이 되면 각각의 쿼리 실행 직후에 자동으로 커밋을 호출함. 직접 커밋이라 롤백을 호출하지 않아 편리하지만 반대로 쿼리를 하나하나 실행할 떄마다 자동으로 커밋이 되기 떄문에 트랜잭션 기능을 제대로 사용할 수 없음 보통 기본 설정값으로 자동 커밋으로 되어있음 수동 커밋 수동 커밋 모드로 설정하는 것을 트랜잭션을 시작한다고 표현 쿼리를 실항한 이후에 커밋, 롤백을 호출해주어야 함 수동 커밋 모드나 자동 커밋 모드는 한번 설정하면 해당 세션에서는 계속 유지됨DB 락세션1이 트랜잭션을 시작하고 데이터를 수정하는 동안 아직 커밋을 수행하지 않았는데 세션2에서 동시에 같은 데이터를 수정하게 되면 데이터의 무결정이 보장되지 않아 여러 문제를 야기함. 바로 트랜잭션의 원자성이 깨져버리게 되는것.이러한 문제를 방지하려면 세션이 트랜잭션을 시작하고 데이터를 수정하는 동안에는 커밋이나 롤백 전까지 다른 세션에서 해당 데이터를 수정 할 수 없도록 막아햐 함 세션1은 memberA의 금액을 500원으로 변경하려하고 세션2는 같은 memberA의 금액을 1000원으로 변경하여 함 세션1이 먼저 트랜잭션을 시작하여 해당 필드의 락을 획득함 락을 소유하고 있으므로 해당 필드에 update SQL을 수행함 세션2는 트랜잭션을 수행하려하지만 해당 필드의 락을 획득하지 못하여 대기함 무한정 대기하는 것은 아니며 대기시간을 넘어가면 락 타임아웃 오류 발생 락 타임아웃 시간은 설정가능함 세션1이 커밋을 수행하여 트랜잭션이 완료되고 락을 반환함 세션2가 락을 획득 세션2가 락을 획득한 이후 update SQL을 수행 세션2가 커밋을 수행하여 트랜잭션이 완료되고 락을 반환함조회시 DB 락데이터베이스마다 다르지만 보통의 경우 일반적으로 조회는 락을 사용하지 않고 바로 데이터를 조회함그러나 주요한 계산 및 정보 획득을 위해 데이터를 조회할 떄 “select for update” 구문을 사용하여 락을 획득해 다른 세션에서 해당 데이터를 수정하지 못하게 할 수 있음set autocommit false;select * from member where member_id=&#39;memberA&#39; for update;commit; 조회하면서 선택한 필드의 락도 획득함 조회할 시점에 락이 없다면 락을 획득할 때까지 대기트랜잭션의 적용 트랜잭션은 비지니스 로직이 있는 서비스 계층에서 시작해야 함 비지니스 로직이 잘못되면 해당 비지니스 로직으로 인한 문제가 되는 부분을 함께 롤백 해야하기 떄문 트랜잭션을 시작하려면 커넥션이 필요하기 떄문에 서비스 계층에서 커넥션을 만들고 트랜잭션 커밋 이후 커넥션을 종료해야 함 어플리케이션에서 DB 트랜잭션을 사용하려면 트랜잭션을 사용하는 동안 같은 커넥션을 유지해야 항상 같은 세션으로 사용할 수 있음 주의 트랜잭션과 락은 실제 동작하는 방식이 데이터베이스 마다 다르기 떄문에 사용하는 데이터베이스의 메뉴얼을 확일할 필요가 있음참고 스프링 DB - 데이터 접근 핵심 원리(김영한)" }, { "title": "Spring DB - 커넥션풀과 데이터소스 이해", "url": "/posts/spring-db-02/", "categories": "Backend, Spring DB", "tags": "Web, Spring Framework, DataBase", "date": "2023-10-13 11:10:00 +0900", "snippet": "커넥션 풀 이해데이터데이스 커넥션을 획득할 떄는 복잡한 과정을 걸치게 됨 어펄리케이션 로직은 DB 드라이버를 통해 커넥션 조회 DB 드라이버는 DB와 TCP/IP 커넥션 연결 DB 드라이버는 TCP/IP 커넥션이 연결되면 ID, PW와 기타 부가정보를 DB에 전달 DB는 ID, PW를 통해 내부 인증을 완료하고 내부에 DB 세션을 생성 DB는 커넥션 생성이 완료되었다는 응답 전송 DB 드라이버는 커넥션 객체를 생성하여 클라이언트에 반환이러한 커넥션을 새로 만드는 과정은 복잡하며 시간 및 리소스를 많이 소모하는 일임.이러한 문제를 해결하기 위해 매번 커넥션을 요청하는것이 아닌 미리 커넥션을 생성해두고 사용하는 커넥션 풀이라는 방법커넥션 풀 초기화어플리케이션을 시작하는 시점에 커넥션 풀은 필요한 만큼 커넥션을 미리 확보하여 풀에 보관 보통 얼마나 보관할 지는 서비스의 특징과 서버 스펙에 따라 다르지만 기본값은 보통 10개커넥션 풀의 연결 상태커넥션 풀에 들어있는 커넥션은 TCP/IP로 DB와 커넥션이 연결되어 있는 상태이기 때문에 언제든지 즉시 SQL을 DB에 전달 가능커넥션 풀 사용어플리케이션 로직에서 DB 드라이버를 통해 새로운 커넥션을 획득하는 것이 아닌 커넥션 풀을 통해 이미 생성된 커넥션을 객체 참조로 사용어플리케이션 로직은 커넥션 풀에서 받은 커넥션을 사용하여 SQL을 데이터베이스에 전달하고 결과를 받아 처리. 이후 커넥션을 모두 사용했다면 커넥션을 종료하는 것이 아닌 그대로 커넥션 풀에 반환하여 커넥션이 살아있는 상태로 커넥션 풀에 유지시켜야 함정리 적절한 커넥션 풀 숫자는 서비스의 특징과 어플리케이션 서버스펙, DB 서버 스펙에 따라 다르기 때문에 성능 테스트를 통해 적절한 커넥션 풀 숫자를 찾아야 함 커넥션 풀은 서버당 최대 커넥션을 제한 할 수도 있기 때문에 무한정 DB에 연결이 생성되는것을 막아줌 실무에서는 항상 기본으로 사용됨DataSource 이해데이터베이스 커넥션은 얻는 방법은 JDBC DriverManager를 직접 사용하거나 커넥션 풀을 사용하는등 여러 방법이 존재함그러나 만약 DriverManager를 통해 직접 커넥션을 획득하다가 커넥션 풀로 방법을 바꾸게 된다면 의존관계가 DriverManager에서 커넥션 풀로 바뀌었기 떄문에 커넥션을 획득하는 어플리케이션 코드를 모두 수정해주어야 함이러한 문제를 해결하기 위해 자바는 javax.sql.DataSource 라는 추상화 인터페이스를 제공함 DataSource는 커넥션을 획득하는 방법을 추상화 하는 인터페이스 해당 인터페이스의 핵심 기능은 커넥션 조회public interface DataSource { Connection getConnection() throws SQLException; ...}대부분의 커넥션 풀은 DataSource 인터페이스를 이미 구현해두었기 떄문에 개발자는 DataSource 인터페이스에만 의존하도록 어플리케이션 로직을 작성하면 됨.즉, 자바는 DataSource를 통해 커넥션을 획득하는 방법을 추상화하여 구현체만 변경하면 되도록 했기 떄문에 DriverManager를 사용하다 다른 커넥션 풀로 변경하더라도 코드를 재사용 할 수 있음정리 DB 연결시 매번 새로운 연결을 하지 않도록 되도록이면 커넥션 풀을 하용하여 커넥션을 유지하도록 함 추상화인 DataSource를 사용하여 구현체를 DriverManagerDataSource(매번 커넥션 형성)를 사용하든 HikariDataSource(커넥션 풀)을 사용하든 코드를 변경하지 않도록 해야함 DB 커넥션을 위한 설정과 실제 커넥션을 사용하는 코드를 분리할 수 있음 DataSource의 인터페이스에만 의존하도록 하여 구현체를 수정하더라도 코드의 수정이 필요 없음(DI + OOP) 참고 스프링 DB - 데이터 접근 핵심 원리(김영한)" }, { "title": "Spring DB - JDBC 이해", "url": "/posts/spring-db-01/", "categories": "Backend, Spring DB", "tags": "Web, Spring Framework, DataBase", "date": "2023-10-12 16:10:00 +0900", "snippet": "JDBC 표준 인터페이스JDBC(Java Database Connectivity)는 자바에서 데이터베이스에 접속 할 수 있도록 하는 자바 API.JDBC는 데이터베이스에서 자료를 쿼리하거나 업데이트 하는 방법을 제공함대표적으로 다음 3가지 기능을 표준 인터페이스로 정의해서 제공함 java.sql.Connection : 연결 java.sql.Statement : SQL을 담은 내용 java.sql.ResultSet : SQL 요청 응답그러나 인터페이스만 있다면 동작하지 않기 떄문에 각각의 데이터베이스 벤더들이 자신의 데이터베이트에 맞춰 구현한 라이브러리인 JDBC 드라이버를 이용하여 각 데이터베이스를 사용함JDBC와 최신 데이터 접근 기술JDBC는 오래된 기술이며 사용하기 어려움이 있기 때문에 최근에는 JDBC를 직접 사용하기보단 JDBC를 편리하게 사용하는 다양한 기술을 이용함대표적으로는 SQL Mapper 와 ORM 기술로 나눌수 있음 SQL Mapper 장점 SQL 응답 결과를 객체로 편리하게 변환 JDBC의 반복코드 제거 단점 개발자가 SQL을 직접 작성해야 함 대표기술로는 스프링 JdbcTemplate, MyBatis 등이 있음 ORM 기술 ORM은 객체를 관계형 데이터베이스 테이블과 매핑해주는 기술 장점 반복적인 SQL을 직접 작성하지 않아도 됨 각각의 데이터베이스마다 다른 SQL을 사용해야 하는 문제를 중간에서 해결해줌 대표기술로는 JPA, 하이버네이트, 이클립스링크 등이 있음 JPA는 자바 진영의 ORM 표준 인터페이스이며 이를 구현한 구현체가 하이버네이트, 이클립스 링크등이 있음 SQL Mapper vs ORM 기술SQL Mapper와 ORM 기술은 서로 각각 장단점이 존재함. SQL Mapper SQL만 직접 작성하면 나머지 번거로운 일은 SQL Mapper가 대신 해결줌 SQL Mapper는 SQL만 작성할 줄 알면 비교적 쉽게 학습가능 ORM 기술 SQL 자체를 작성하지 않아도 되어서 개발 생산성이 매우 향상됨 편리한 반면에 쉬운 기술은 아니므로 실무에서 사용하려면 깊이있는 학습 필요 SQL Mapper와 ORM 기술 두 기술 모두 결국 JDBC를 사용하고 있음참고 스프링 DB - 데이터 접근 핵심 원리(김영한)" }, { "title": "Spring Framework - 빈 스코프", "url": "/posts/spring-09/", "categories": "Backend, Spring Framework", "tags": "Web, Spring Framework", "date": "2023-10-12 11:30:00 +0900", "snippet": "빈 스코프란?스프링 빈이 존재할 수 있는 범위 혹은 생명주기스프링은 다음과 같은 다양한 스코프를 지원함 싱글턴 : 기본 스코프. 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프 프로토타입 : 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 이후에는 관리하지 않는 매우 짧은 범위의 스코프 웹 관련 스코프 request : 웹 요청이 들어오고 나갈떄 까지 유지되는 스코프 session : 웹 세션이 생성되고 종료될떄 까지 유지되는 스코프 application : 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프 // 컴포넌트 스캔 자동 등록@Scope(&quot;prototype&quot;)@Componentpublic class HelloBean {}// 수동 등록@Scope(&quot;prototype&quot;)@BeanPrototypeBean HelloBean() { return new HelloBean();}프로토타입 스코프싱글턴 스코프 빈을 조회하면 스프링 컨테이너는 항상 같은 인스턴스의 스프링 빈을 반환함.반면에 프로토타입 스코프를 스프링 컨테이너에 조회하면 스프링 컨테이너는 항상 새로운 인스턴스를 생성해서 반환함프로토타입 빈 요청에 대한 흐름은 아래와 같음 프로토타입 스코프의 빈을 스프링 컨테이너에 요청 스프링 컨테이너는 이 시점에 프로토타입 빈을 생성하고 필요한 의존관계를 주입 스프링 컨테이너는 생성한 프로토타입 빈을 클라이언트에 반환 이후 스프링 컨테이너에 같은 요청이 오면 항상 새로운 프로토타입 빈을 생성하여 반환주요 핵심은 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화 까지만 처리한다는 것.클라이언트에 반환하고 난 이후부터 스프링 컨테이너는 생성된 프로토타입 빈을 관리하지 않고 관리 책임은 모두 프로토타입 빈을 받은 클라이언트에 있음. 그러므로 @PreDestory 같은 종료 메서드가 호출되지 않음프로토타입빈의 특징은 아래과 같음 스프링 컨테이너에 요청할 떄 마다 새로 생성됨 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입 그리고 초기화까지만 관여 종료 메서드가 호출되지 않기 떄문에 프로토타입 빈은 프로토타입 빈을 조회한 클라이언트가 관리해야함 종료 메서드에 대한 호출도 클라이언트가 직접 해야함 프로토타입 스코프와 싱글톤 빈과 함께 사용시 문제점싱글턴 스코프의 스프링 빈이 프로토 타입 스코프 빈을 소유하여 의존관계가 형성되는 구조의 경우, 프로토타입 빈의 사용의도와는 다른 문제가 발생하게 됨프로토타입 빈 직접 요청의 경우 클라이언트A는 스프링 컨테이너에 프로토타입 빈을 요청 스프링 컨테이너는 프로토타입 빈을 새로 생성하여 반환(x01) 하며 해당 빈의 count 값은 0 클라이언트는 조회한 프로토타입 빈에 addCount()를 호출하여 count 값을 1 더함 결과적으로 프로토타입 빈(x01)의 count 는 1 클라이언트B는 스프링 컨테이너에 프로토타입 빈을 요청 스프링 컨테이너는 프로토타입 빈을 새로 생성하여 반환(x02) 하며 해당 빈의 count 값은 0 클라이언트는 조회한 프로토타입 빈에 addCount()를 호출하여 count 값을 1 더함 결과적으로 프로토타입 빈(x02)의 count 는 1싱글턴 빈에서 프로토타입 빈 사용 clientBean은 싱글턴이므로 보통 스프링 컨테이너 생성 시점에 함께 생성되며 의존관계 주입도 발생하게 됨 clientBean은 의존관계 자동주입으로 주입 시점에 스프링 컨테이너에 프로토타입 빈을 요청함 스프링 컨테이너는 프로토타입 빈을 생성하여 clientBean에 반환함. 이때 프로토타입 빈의 count 값은 0 이후 clientBean은 프로토타입 빈을 내부 필드에 보관함(참조값을 보관) 클라이언트A는 clientBean을 스프링 컨테이너에 요청하여 받음 이때 싱글턴 빈이므로 항상 같은 clientBean이 반환됨 클라이언트A는 clientBean.logic()을 호출함 clientBean은 prototypeBean의 addCount()를 호출하여 count 값을 1 더하여 count 값이 1이됨 클라이언트B는 clientBean을 스프링 컨테이너에 요청하여 받음 이때 싱글턴 빈이므로 클라이언트A와 같은 clientBean이 반환됨 해당 시점에 주요 포인트는 clientBean이 내부에 소유하고 있는 프로토타입 빈은 이미 과거에 의존관계 주입이 끝난 빈임. 즉, 의존관계 주입 시점에 스프링컨테이너에 요청하여 프로토타입 빈이 새로 생성된 것이지, 사용할 떄마다 새로 생성되지 않음 클라이언트B는 clientBean.logic()을 호출함 clientBean은 prototypeBean의 addCount()를 호출하여 count 값을 1 더하여 count 값이 2가 됨싱글턴 빈은 생성 시점에만 의존관계를 주입 받기 떄문에 프로토타입 빈이 새로 생성되긴 하지만 처음 생성된 프로토타입 빈이 싱글톤 빈과 함꼐 계속 유지되는 것이 문제 포인트 여러 빈에서 같은 프로토타입 빈을 주입 받으면 주입 받는 시점에 각각 새로운 프로토타입 빈이 생성됨clientA -&amp;gt; prototypeBean@x01clientB -&amp;gt; prototypeBean@x02프로토타입 스코프와 싱글톤 빈과 함께 사용시 Provider로 문제 해결가장 간단한 방법은 싱글턴 빈이 프로토타입을 사용할 때 마다 스프링 컨테이너에 새로 요청하는것class ClientBean { @Autowired private ApplicationContext ac; public int logic() { PrototypeBean prototypeBean = ac.getBean(PrototypeBean.class); ... }}이렇게 의존관계를 외부에서 주입(DI) 받는게 아니라 직접 필요한 의존관계를 찾는것을 DL(Dependency Looup) 혹은 의존관계 조회(탐색) 이라고 함그러나 위와 같이 스프링의 어플리케이션 컨텍스트 전체를 주입받게 되면 스프링 컨테이너에 종속적인 코드가 되며 단위 테스트에 어려움이 있음ObjectFactory, ObjectProvider지정한 빈을 컨테이너에서 대신 찾아주는 DL 서비스를 제공해 주는것이 ObjectProvider(과거에는 ObjectFactory) 임@Autowiredprivate ObjectProvider&amp;lt;PrototypeBean&amp;gt; prototypeBeanProvider;public int logic() { PrototypeBean prototypeBean = prototypeBeanProvider.getObject(); prototypeBean.addCount(); int count = prototypeBean.getCount(); return count;}ObjectProvicer의 getObject()를 호출하면 내부에선 스프링 컨테이너를 통해 해당 빈을 찾아 반환(DL)스프링에 의존적인 방법JSR-330 Provider다른 방법으로는 javax.inject.Provider(스프링 부트 3.0은 jakarta.inject.Provicer) 라는 JSR-330 자바 표준을 사용하는 방법이 있음해당 방법은 다음 라이브러리를 추가 해주어야 함 스프링 부트 3.0 미만 javax.inject:javax.inject:1 스프링 부트 3.0 이상 jakarta.inject:jakata.inject-api:2.0.1 @Autowiredprivate Provider&amp;lt;PrototypeBean&amp;gt; provider;public int logic() { PrototypeBean prototypeBean = provider.get(); prototypeBean.addCount(); int count = prototypeBean.getCount(); return count;}Provider의 get() 을 호출하면 내부에서는 스프링 컨테이너를 통해 해당 빈을 찾아서 반환(DL)자바 표준이므로 스프링이 안니 다른 컨테이너에서도 사용 가능정리주로 실무에서 웹 어플리케이션을 개발할떄는 싱글턴 빈으로 대부분의 문제를 해결할 수 있기 때문에 프로토타입 빈을 직접적으로 사용하는 일은 매우 드음. 다만 매번 사용하 떄 마다 의존관계 주입이 완료된 새로운 객체가 필요할때 프로토타입 빈을 사용함ObjectProvider, JSR-330 Provider 등은 프로토타입 빈 뿐만 아니라 DL이 필요한 경우는 언제든 사용할 수 있음웹 스코프웹 환경에서만 동작하는 스코프웹 스코프는 프로토타입과 다르게 스프링이 해당 스코프의 종료 시점까지 관리 함. 그러므로 종료 메서드가 호출됨웹 스코프의 종류는 아래과 같이 여러 종류가 있음 request HTTP 요청 하나가 들어오고 나갈 떄 까지 유지되는 스코프 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고 관리됨 session HTTP Session과 동일한 생명주기를 가지는 스코프 application 서블릿 컨텍슽트(ServletContext)와 동일한 생명주기를 가지는 스코프 websocket 웹 소켓과 동일한 생명주기를 가지는 스코프 스코프와 프록시@Component@Scope(value = &quot;request&quot;)public class MyLogger {}@Service@RequiredArgsConstructorpublic class LogDemoService { private final MyLogger myLogger; public void logic(String id) { myLogger.log(&quot;service id = &quot; + id); }}위와 같이 로그 클래스가 있고 request 마다 해당 로그 클래스를 주입받아 사용하려 할때, 실행해보면 런타임시 에러가 발생함Error creating bean with name &#39;myLogger&#39;: Scope &#39;request&#39; is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton;이는 스프링 어플리케이션을 실행하는 시점에 싱글턴 빈은 생성해서 주입이 가능하지만 request 스코프 빈은 아직 HTTP reeust가 오기 전이므로 생성되지 않았기 떄문임위와 같은 문제를 해결하기 위해선 아래와 같이 두가지 방법을 사용할 수 있음 ObjectProvider, JSR-330 Provicer 를 사용 프록시 방식 사용ObjectProvider, JSR-330 Provicer 사용하는 방법에 대해선 위 내용에 대해 그대로 따라하면 되므로 넘어가고 프록시 방법에 대해 확인해보면 아래와 같음@Component@Scope(value = &quot;request&quot;, proxyMode = ScopedProxyMode.TARGET_CLASS)public class MyLogger {}ProxyMode = ScopedProxyMode.TARGET_CLASS를 추가 적용 대상이 클래스면 TARGET_CLASS 를 선택 적용 대상이 인터페이스면 INTERFACES 를 선색이렇게 하면 MyLogger의 가짜 프록시 클래스를 만들어두고 HTTP reqeust와 상관없이 가짜 프록시 클래스를 다른 빈에 미리 주입해 둘 수 있음동작을 확인하기 위해 주입된 myLogger를 확인해 보면 아래와 같음@Controller@RequiredArgsConstructorpublic class LogDemoController { private final MyLogger myLogger; @RequestMapping(&quot;log-demo&quot;) @ResponseBody public String logDemo(HttpServletRequest req) { System.out.println(&quot;mylogger : &quot; + myLogger.getClass()); ... }}mylogger : class hello.core.common.MyLogger$$EnhancerBySpringCGLIB$$33575f05CGLIB이라는 라이브러리로 내 클래스를 상속받은 가짜 프록시 객체를 만들어서 주입된 것을 확인 @Scope의 proxyMode = ScopedProxyMode.TARGET_CLASS 를 설정하면 스프링 컨테이너는 CGLIB 이라는 바이트코드를 조작하는 라이브러리를 사용하여 MyLogger를 상속받는 가까 프록시 객체를 생성함 이후 스프링 컨테이너에 “myLogger” 라는 이름으로 진짜 대신에 이 가짜 프록시 객체를 등록함 그러므로 의존관계 주입도 이 가짜 프로시 객체가 주입됨가짜 프록시 객체는 요청이 오면 그떄 내부에서 진짜 빈을 요청하는 위임 로직이 들어가 있음 가짜 프록시 객체는 내부에 진짜 myLogger 를 찾는 방법을 알고 있음 클라이언트가 myLogger.log() 를 호출하면 사실은 가짜 프록시 객체의 메서드를 호출한 것 가짜 프록시 객체는 request 스코프의 진짜 myLogger.log() 를 호출함 가짜 프록시 객체는 원본 클래스를 상속 받아 만들어 졌기 때문에 이 객체를 사용하는 클라이언트 입장에서는 원본인지 가짜인지 모르게 동일하게 사용 할 수 있음(다형성)동작에 대하여 정리하면 아래와 같음 CGLIB 이라는 라이브러리로 내 클래스를 상속 받은 가짜 프록시 객체를 만들어서 주입 가짜 프록시 객체는 실제 요청이 오면 그때 내부에서 실제 빈을 요청하는 위임 로직이 있음 가짜 프록시 객체는 실제 request scope 와는 관계가 없는 그냥 가짜이며 내부에는 단순한 위임 로직만 존재하고 싱글턴 처럼 동작함Provider를 사용하든 프록시를 사용하든 주요 포인트는 진짜 객체 조회를 꼭 필요한 시점까지 지연처리 한다는 것또한 꼭 웹 스코프가 아니더라도 프록시는 사용가능주의해야 할 점으로는 싱글턴 처럼 동작하지만 결국 싱글턴이 아니고 다르게 동작하기 떄문에 주의가 필요 이러한 특별한 scope는 꼭 필요한 곳에만 최소화해서 사용해야 유지보수에 어려움이 없음참고 스프링 핵심 원리 - 기본편(김영한)" }, { "title": "Spring Framework - 빈 생명주기 콜백", "url": "/posts/spring-08/", "categories": "Backend, Spring Framework", "tags": "Web, Spring Framework", "date": "2023-10-12 09:30:00 +0900", "snippet": "빈 생명주기 콜백스프링 빈은 간단하게 다음과 같은 라이프사이클을 가짐객체 생성 -&amp;gt; 의존관계 주입스프링 빈은 객체를 생성하고, 의존관계 주입이 끝난 다음에야 필요한 데이터를 사용할 수 있는 준비가 완료됨그러므로 초기화 작업은 의존관계 주입 단계가 다 완료되고 난 다음에 호출 해야함스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해 초기화 시점을 알려주는 다양한 기능을 제공함또한 스프링 컨테이너가 종요되기 직전에도 소멸 콜백을 호출해줌스프링 빈의 이벤트 라이프사이클스프링 컨테이너 생성 -&amp;gt; 스프링 빈 생성 -&amp;gt; 의존관계 주입 -&amp;gt; 초기화 콜백 -&amp;gt; 동작 -&amp;gt; 소멸전 콜백 -&amp;gt; 스프링 종료 초기화 콜백 : 빈이 생성되고 빈의 의존과계 주입이 완료된 후 호출 소멸전 콜백 : 빈이 소멸되기 직전에 호출 싱글턴 빈들은 컨테이너가 종료될 떄 싱글턴 빈들도 함께 종료되기 때문에 스프링 컨테이너가 종료되기 직전에 소멸전 콜백이 호출됨.싱글턴 처럼 컨테이너의 시작과 종료까지 생존하는 빈도 있지만 생명주기가 짧은 빈들도 있는데 이 빈들은 컨테이너와 무관하게 해당 빈이 종료 되기 직전에 소멸전 콜백이 호출됨스프링은 크게 3가지 방법으로 빈 라이프사이클 콜백을 지원함 인터페이스(InitializingBean, DisposableBean) 설정 정보에 초기화, 종료 멤서드 지정 @PostConstruct, @PreDestroy 지정인터페이스 InitializingBean, DisposableBeanpublic class NetworkClient implements InitializingBean, DisposableBean { private String url; @Override public void afterPropertiesSet() throws Exception { ... } @Override public void destroy() throws Exception { ... } ...} InitializingBean 인터페이스의 afterPropertiesSet() 메서드를 통해 초기화 지원 DisposableBean 인터페이스의 destroy() 메서드를 통해 소멸을 지원인터페이스 사용시의 단점 해당 인터페이스는 스프링 전용 인터페이스 이므로 코드가 스프링 전용 인터페이스에 의존하게 됨 초기화, 소멸 메서드의 이름을 변경할 수 없음 개발자가 코드를 수정할수 없는 외부 라이브러리에 적용할 수 없음인터페이스를 사용하는 방법은 스프링 초창기의 방법이며 현재는 더 나은 방법으로 인해 거의 사용되지 않음빈 등록 초기화, 소멸 메서드 지정public class NetworkClient { private String url; public void init() { ... } public void close() { ... } ...}@Configurationpublic class LifeCycleConfig { @Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;close&quot;) public NetworkClient networkClient() { NetworkClient networkClient = new NetworkClient(); return networkClient; }}설정정보 사용 특징 메서드 이름을 자유롭게 설정 할 수 있음 스프링 빈이 스프링 코드에 의존하지 않음 코드가 아니라 설정 정보를 사용하기 떄문에 코드를 수정 할 수 없는 외부 라이브러리에도 초기화, 소멸 메서드를 적용 할 수 있음종료 메서드 추론(@Bean의 destroyMethod 속성) 라이브러리는 대부분 close, shutdown 이라는 이름의 종료 메서드를 사용함 @Bean의 destroyMethod는 기본값이 (inferred) 으로 등록되어 있음 해당 추론 기능은 close, shutdown 이라는 이름의 메서드를 자동으로 호출하게 해줌 종료 메서드의 이름을 추론하여 호출해줌 그러므로 직접 스프링 빈으로 등록하면 종료 메서드는 따로 적지 않아도 동작함 추론 기능을 사용하지 않으려면 destroyMethod=”” 과 같이 공백을 저장 애노테이션 @PostConstruct, @PreDestroypublic class NetworkClient { private String url; @PostConstruct public void init() { ... } @PreDestroy public void close() { ... } ...}@Configurationpublic class LifeCycleConfig { @Bean public NetworkClient networkClient() { NetworkClient networkClient = new NetworkClient(); return networkClient; }}@PostConstruct, @PreDestroy 방식의 특징 스프링에서 권장하는 방법 javax.annotation.PostConstruct, javax.annotation.PreDestroy 패키지를 사용하고 있으며 이는 스프링의 종속적인 기능이 아닌 JSR-250 라는 자바 표준을 사용하고 있음 스프링이 아닌 다른 컨테이너에서도 동작함 단점으로는 외부 라이브러리에는 적용하지 못함 외부 라이브러리를 초기화, 종료 해야할 때는 빈 등록시 초기화, 소멸 메서드 지정 방법을 사용 정리 가급적이면 @PostConstruct, @PreDestroy 방식 사용 코드를 수정할 수 없는 외부 라이브러리를 초기화, 종료 해야할 때는 @Bean의 initMethod, destoryMethod 방식을 사용참고 스프링 핵심 원리 - 기본편(김영한)" }, { "title": "Spring Framework - 의존관계 자동 주입", "url": "/posts/spring-07/", "categories": "Backend, Spring Framework", "tags": "Web, Spring Framework", "date": "2023-10-11 15:30:00 +0900", "snippet": "다양한 의존관계 주입 방법의존관계 주입은 아래와 같이 크게 4가지가 존재 생성자 주입 수정자 주입(setter 주입) 필드 주입 일반 메서드 주입생성자 주입 생성자를 통해 의존관계를 주입 받는 방법 생성자 호출시점에 딱 1번만 호출되는 것이 보장됨 불변, 필수 의존관계에서 사용@Componentpublic class OrderServiceImpl implements OrderService { private final MemberRepository memberRepository; private final DiscountPolicy discountPolicy; @Autowired // 생성자가 하나뿐 이므로 생략 가능 public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) { this.memberRepository = memberRepository; this.discountPolicy = discountPolicy; }}생성자가 딱 1개만 있으면 @Autowired를 생략해도 자동 주입이 가능 함. 스프링 빈에만 해당됨수정자 주입(setter 주입) setter 라 불리는 필드의 값을 변경하는 수정자 메서드를 통하여 의존관계를 주입하는 방법 선택, 변경 가능성이 있는 의존관계에 사용 자바의 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법임@Componentpublic class OrderServiceImpl implements OrderService { private MemberRepository memberRepository; private DiscountPolicy discountPolicy; @Autowired public void setMemberRepository(MemberRepository memberRepository) { this.memberRepository = memberRepository; } @Autowired public void setDiscountPolicy(DiscountPolicy discountPolicy) { this.discountPolicy = discountPolicy; }} @Autowired 의 기본 동작은 주입할 대상이 없으면 오류가 발생함. 주입할 대상이 없어도 동작하게 하려면 @Autowired(required = false) 로 지정 자바빈 프로퍼티, 자바에서는 과거로부터 필드의 값을 직접 변경하지 않고, setXxx, getXxx 라는 메서드를 통해 값을 읽거나 수정하는 규칙이 있는데 그것이 자바빈 프로퍼티 규약임필드 주입 필드에 바로 주입하는 방법 외부에서 변경이 불가능 하기 때문에 테스트하기 어려움 DI 프레임워크가 없다면 아무것도 할 수 없음 되도록이면 사용하지 않을것@Componentpublic class OrderServiceImpl implements OrderService { @Autowired private MemberRepository memberRepository; @Autowired private DiscountPolicy discountPolicy;}일반 메서드 주입 일반 메서드를 통해 주입 받는 방법 한번에 여러 필드를 주입 받을수 있음 일반적으로는 잘 사용하지 않는 방식@Componentpublic class OrderServiceImpl implements OrderService { private MemberRepository memberRepository; private DiscountPolicy discountPolicy; @Autowired public void init(MemberRepository memberRepository, DiscountPolicy discountPolicy) { this.memberRepository = memberRepository; this.discountPolicy = discountPolicy; }} 의존관계 자동 주입은 스프링 컨테이너가 관리하는 스프링 빈 이여야만 동작함옵션 처리주입할 스프링 빈이 없다고 하더라도 동작해야 할 때가 있음그러나 @Autowired만 사용한다면 required 옵션의 기본값이 true로 되어 있어 자동 주입 대상이 없다면 오류가 발생자동 주입 대상을 옵션으로 처리하는 방법은 아래와 같음 @Autowired(required=false) 자동 주입할 대상이 없다면 수정자 메서드 자체가 호출 안됨 org.springframework.lang.@Nullable 자동 주입할 대상이 없으면 null이 입력됨 Optional&amp;lt;&amp;gt; 자동 주입할 대상이 없으면 Optional.empty가 입력됨 //호출 안됨@Autowired(required = false)public void setNoBean1(Member member) { System.out.println(&quot;setNoBean1 = &quot; + member);}//null 호출@Autowiredpublic void setNoBean2(@Nullable Member member) { System.out.println(&quot;setNoBean2 = &quot; + member);}//Optional.empty 호출@Autowired(required = false)public void setNoBean3(Optional&amp;lt;Member&amp;gt; member) { System.out.println(&quot;setNoBean3 = &quot; + member);}# setNoBean1 은 @Autowired(required=false) 이므로 아예 호출이 안됨 setNoBean2 = nullsetNoBean3 = Optional.empty @Nullable, Optional은 스프링 전반에 걸쳐서 지원함. 예를 들어 생성자 자동 주입에서 특정 필드에만 사용하는 것도 가능생성자 주입을 선택해라과거에는 수정자 주입과 필드 주입을 많이 사용했지만 최근에는 스프링을 포함한 DI 프레임워크 대부분이 생성자 주입을 권장함그 이유에 대해선 아래와 같음불변 대부분의 의존관계 주입은 한번 일어나면 어플리케이션 종료시점까지 의존관계를 변경할 일이 없음 오히려 대부분의 경우, 의존관계는 어플리케이션 종료 전까지 변하면 안됨(불변이여야 함) 수정자 주입을 사용하면 setXxx 메서드를 public으로 열어두어야 함 생성자 주입은 객체를 생성할떄 1번만 호출되므로 이후에는 호출될 일이 없음. 그러므로 불변으로 설계할 수 있음누락프레임워크 없이 순수 자바 코드를 단위 테스트 하는 경우에 다음과 같이 수정자 의존관계인 경우public class OrderServiceImpl implements OrderService { private MemberRepository memberRepository; private DiscountPolicy discountPolicy; @Autowired public void setMemberRepository(MemberRepository memberRepository) { this.memberRepository = memberRepository; } @Autowired public void setDiscountPolicy(DiscountPolicy discountPolicy) { this.discountPolicy = discountPolicy; } ...}아래와 같이 테스트를 수행하면 동작은 함@Testvoid createOrder() { OrderServiceImpl orderService = new OrderServiceImpl(); orderService.createOrder(1L, &quot;itemA&quot;, 10000);}그러나 테스트 수행 결과는 Null Point Exception이 발생하는데, memberRepository, discountPolicy 모두 의존관계 주입이 누락되었기 때문임.생성자 주입을 사용하면 위와 같이 주입 데이터가 누락 되었을때는 컴파일 오류가 발생하여 바로 오류 확인이 가능함final 키워드생성자 주입을 사용하면 필드에 final 키워드를 사용할 수 있음그러므로 생성자에서 혹시라도 값이 설정되지 않는 오류를 컴파일 시점에 확인 할 수 있음Componentpublic class OrderServiceImpl implements OrderService { private final MemberRepository memberRepository; private final DiscountPolicy discountPolicy; @Autowired public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) { this.memberRepository = memberRepository; // discountPolicy 필드는 final 이므로 값 설정이 필수이지만 누락되어 컴파일 오류 발생 }} 수정자 주입을 포함한 다른 나머지 주입 방식은 모두 생성자 이후에 호출되므로 필드에 final 키워드를 사용할 수 없음. 오직 생성자 주입 방식만 final 키워드를 사용 할 수 있음정리 기본적으로 생성자 주입을 사용하고, 필수 값이 아닌 경우에는 수정자 주입 방식을 옵션으로 부여하면 됨 생성자 주입과 수정자 주입을 동시에 사용할 수 있음(final 이 아닌 경우) 되도록이면 항상 생성자 주입을 선택하도록 하고 가끔 옵션이 필요할때 수정자 주입을 선택하면 됨 필드 주입은 테스트와 같이 특정한 상황이 아니면 사용하지 않을 것 조회 빈이 2개 이상일때@Autowired는 타입으로 조회를 함그러므로 선책된 빈이 2개 이상일때 문제가 발생하게 됨@Componentpublic class FixDiscountPolicy implements DiscountPolicy {}@Componentpublic class RateDiscountPolicy implements DiscountPolicy {}@Autowiredprivate DiscountPolicy discountPolicy위와 같이 fixDiscountPolicy, rateDiscountPolicy 두개의 후보가 존재하게 되므로 UniqueBeanDefinitionException 오류가 발생하게 됨NoUniqueBeanDefinitionException: No qualifying bean of type &#39;hello.core.discount.DiscountPolicy&#39; available: expected single matching bean but found 2: fixDiscountPolicy,rateDiscountPolicy위와 같은 상황일 떄 하위 타입(구현클래스)로 지정할 수도 있지만 하위 타입으로 지정하는 것은 DIP에 위배하고 유연성을 떨어지게 만듬또한 이름만 다르고 똑같은 타입의 스프링 빈이 2개 이상 있을때는 해결되지 않음@Autowired 필드 명, @Qualifier, @Primary조회 대상 빈이 2개 이상일 떄 크게 아래와 같이 3가지 방법으로 해결이 가능함 @Autowired 필드 명 @Qualifier -&amp;gt; @Qualifier끼지 매칭 -&amp;gt; 빈 이름 매칭 @Primary@Autowired 필드 명 매칭@Autowired는 타입 매칭을 시도하고, 이떄 여러 빈이 있다면 필드 이름, 파라미터 이름으로 빈 이름을 추가 매칭함// 기존 코드@Autowiredprivate DiscountPolicy discountPolicy// 필드 명을 빈 이름으로 변경@Autowiredprivate DiscountPolicy rateDiscountPolicy필드 명 매칭은 먼저 타입 매칭을 시도하고 그 결과에 여러 빈이 있을때 추가로 동작하는 기능@Qualifier 사용@Qualifier는 추가 구분자를 붙여주는 방법주입시 추가적인 방법을 제공하는 것이지 빈 이름을 변경하는 것은 아님Component@Qualifier(&quot;mainDiscountPolicy&quot;)public class RateDiscountPolicy implements DiscountPolicy {}@Component@Qualifier(&quot;fixDiscountPolicy&quot;)public class FixDiscountPolicy implements DiscountPolicy {}주입시에 @Qualifier를 붙여주고 등록한 이름을 적어줌// 생성자 자동 주입 예시@Autowiredpublic OrderServiceImpl(MemberRepository memberRepository, @Qualifier(&quot;mainDiscountPolicy&quot;) DiscountPolicy discountPolicy) { this.memberRepository = memberRepository; this.discountPolicy = discountPolicy;}// 수정자 자동 주입 예시@Autowiredpublic DiscountPolicy setDiscountPolicy(@Qualifier(&quot;mainDiscountPolicy&quot;) DiscountPolicy discountPolicy) { this.discountPolicy = discountPolicy;}다음과 같이 직접 빈 등록시에도 @Qualifier를 동일하게 사용 가능@Bean@Qualifier(&quot;mainDiscountPolicy&quot;)public DiscountPolicy discountPolicy() { return new ...}@Primary@Primary는 우선순위를 정하는 방법@Autowired 시에 여러 빈이 매칭된다면 @Primary가 우선권을 가지게 됨// RateDiscountPolicy 가 FixDiscountPolicy 보다 우선권을 가지게 됨@Component@Primarypublic class RateDiscountPolicy implements DiscountPolicy {}@Componentpublic class FixDiscountPolicy implements DiscountPolicy {}// 생성자 자동 주입 예시@Autowiredpublic OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) { this.memberRepository = memberRepository; this.discountPolicy = discountPolicy;}// 수정자 자동 주입 예시@Autowiredpublic DiscountPolicy setDiscountPolicy(DiscountPolicy discountPolicy) { this.discountPolicy = discountPolicy;}우선순위스프링은 자동보다 수동이, 넓은 범위보다 좁은 범위의 선택권이 더 우선권이 높음.그러므로 @Primary 보다 @Qualifuer가 더 우선권이 높음자동, 수동의 올바른 실무 운영최근 추세에서는 점점 자동 등록을 사용하고 있음. 스프링은 @Component 뿐만 아니라 @Controller, @Service, @Repository 처럼 계층에 맞추어 일반적인 어플리케이션 로직을 자동으로 스캔 할 수 있도록 지원함. 추가적으로 스프링 부트는 컴포넌트 스캔을 기본으로 사용하고 있으며 스프링 부트의 다양한 스프링 빈들도 조건이 맞으면 자동으로 등록되어 지도록 설계되어 있음수동 빈 등록이 사용되면 좋은 경우어플리케이션은 크게 업무로직과 기술로직 두가지 로직으로 나누어 질수 있음 업무로직 웹을 지원하는 컨트롤러, 핵식 비지니스 로직이 있는 서비스, 데이터 계층의 로직을 처리하는 리포지터리등이 모두 업무로직 보통 비지니스 요구사항을 개발할떄 추가되거나 변경됨 개발시 컨트롤러, 서비스, 리포지토리 처럼 유사한 패턴이 존재 보통 문제가 발생하더라도 어느 부분이 문제인지 명확하게 나타남 그러므로 자동 빈 등록 을 사용하여도 무방함 기술로직 기술적인 문제나 공통 관심사(AOP)를 처리할 때 주로 사용됨 데이터베이스 연결, 공통 로그처리등 업무로직을 지원하기 위한 하부기술이나 공통 기술 임 기술로직은 어플리케이션 전반에 걸쳐 광범위 하게 영향을 미치므로 문제 발생시 정확한 포인트를 찾기가 어려움 이러한 광범위하게 사용되는 기술로직의 경우 가급적 수동 빈 등록을 사용하여 명확하게 드러내는 것이 좋음 추가적으로 비지니스로직중에서 다형성을 적극 활용하는 경우에는 수동 빈 등록을 사용하거나 특정 패키지에 같이 묶어두는것이 좋음.그렇게 하면 어떠한 빈들이 주입되는지 바로 확인이 가능 하기 떄문에 유지보수의 이점이 있음@Configurationpublic class DiscountPolicyConfig { @Bean public DiscountPolicy rateDiscountPolicy() { return new RateDiscountPolicy(); } @Bean public DiscountPolicy fixDiscountPolicy() { return new FixDiscountPolicy(); }} 스프링과 스프링 부트가 자동으로 등록하는 수 많은 빈들은 예외이고 반면에 내가 직접 기술지원객체를 스프링 빈으로 등록한다면 수동으로 등록하여 명확하게 드러내는 편이 좋음정리 되도록이면 편리한 자동 기능을 사용하도록 함 직접 등록하는 기술 지원 객체는 수동 등록 다형성을 적극 활용하는 비지니스 로직은 별도의 패키지에 몰아 넣거나 수동 등록을 고민해보면 좋음참고 스프링 핵심 원리 - 기본편(김영한)" }, { "title": "Spring Framework - 컴포넌트 스캔", "url": "/posts/spring-06/", "categories": "Backend, Spring Framework", "tags": "Web, Spring Framework", "date": "2023-10-11 14:30:00 +0900", "snippet": "컴포넌트 스캔과 의존관계 자동 주입스프링은 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 컴포넌트 스캔이라는 기능을 제공함또한 의존관계도 자동으로 주입하는 @Autowired 라는 기능도 제공컴포넌트 스캔은 @Component 어노테이션이 붙은 클래스를 스캔하여 스프링 빈으로 등록함@ComponentScan 으로 인하여 직접 @Bean으로 설정정보를 작성하고 의존관계를 직접 명시하지 않기 때문에 @Autowired 를 통해 의존관계를 자동으로 주입해 주어야 함@Configuration@ComponentScanpublic class AutoAppConfig { }@Component // ComponentScan 에 의해 등록 되도록 @Component 사용public class OrderServiceImpl implements OrderService { private final MemberRepository memberRepository; private final DiscountPolicy discountPolicy; @Autowired // 직접 설정정보를 명시 하지 않고 스프링 내부에서 처리하도록 @Autowired 사용 public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) { this.memberRepository = memberRepository; this.discountPolicy = discountPolicy; }}@ComponentScan @ComponentScan 은 @Compnent가 붙은 모든 클래스를 스프링 빈으로 등록함 기본적인 네이밍은 클래스명을 그대로 사용하되 앞글자만 소문자임 MemberServiceImpl 클래스 -&amp;gt; memberServiceImpl @Component(“memberServiceTest”) 와 같이 이름 지정 가능 @Autowired 의존관계 자동주입 생성자에 @Autowired를 지정하면 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입함 기본 조회 전략은 타입이 같은 빈을 찾아서 주입하는 것 기본적으로 getBean(MemberRepository.class)와 동일함 탐색 위치과 기본 스캔 대상컴포넌트 탐색 위치모든 자바 클래스를 다 컴포넌트 스캔하면 오랜 시간이 걸리기 때문에 필요한 위치부터 탐색하도록 지정할 수 있음@ComponentScan( basePackage = &quot;hello.core&quot;,) basePackage : 탐생할 패키지의 시작 위치 지정. 해당 패키지를 포함하여 하위 모든 패키지는 탐색 basePackage = “hello.core”, “hello.service”, 와 같이 여러 시작위치 설정 가능 basePackageClass : 지정한 클래스 패키지를 탐생 시작 위치로 지정 만약 지정하지 않으면 @ComponentScan이 붙은 설정 정보 클래스의 패키지가 시작위치가 됨컴포넌트 스캔의 기본 대상@ComponentScan은 @Component뿐만 아니라 아래 다른 어노테이션들도 스캔의 대상으로 함또한 다음 어노테이션이 있으면 스프링은 추가 부가 기능을 수행함 @Component 컴포넌트 스캔에서 사용 @Controller 스프링 MVC 컨트롤러에서 사용 스프링 MVC 컨트롤러로 인식 @Service 스프링 비즈니스 로직에서 사용 틀별한 처리를 하지 않지만 개발자들의 핵심 비지니스 로직을 해당 어노테이션 하위에 구현 @Repository 스프링 데이터 접근 계층에서 사용 스프링 데이터 접근 계층으로 인식하고, 데이터 계층의 예외를 스프링 예외로 변환 @Configuration 스프링 설정 정보에서 사용 스프링 설정정보로 인식하고 스프링 빈이 싱글턴을 유지하도록 추가 처리 실제 코드를 확인해보면 @Component를 포함하고 있는것을 확인 할 수 있음@Componentpublic @interface Controller {}@Componentpublic @interface Service {}@Componentpublic @interface Configuration {} 어노테이션은 상속관계라는 것이 없음. 따라서 어노테이션이 특정 어노테이션을 들고 있는 것을 인식하는것은 자바 언어가 아닌 스프링의 기능 임필터컴포넌트 스캔 대상에 추가 및 제거 애노테이션 예시package hello.core.scan.filter;import java.lang.annotation.*;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface MyIncludeComponent {}package hello.core.scan.filter;@MyIncludeComponentpublic class BeanA {}package hello.core.scan.filter;import java.lang.annotation.*;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface MyExcludeComponent {}package hello.core.scan.filter;@MyExcludeComponentpublic class BeanB {}@ComponentScan( includeFilters = @Filter(type = FilterType.ANNOTATION, classes = MyIncludeComponent.class), excludeFilters = @Filter(type = FilterType.ANNOTATION, classes = MyExcludeComponent.class))static class ComponentFilterAppConfig {}중복 등록과 충돌컴포넌트 스캔에서 빈 이름에 대하여 다음 두가지 상황이 있음 자동 빈 등록 vs 자동 빈 등록 수동 빈 등록 vs 자동 빈 등록자동 빈 등록 vs 자동 빈 등록컴포넌트 스캔에 의하여 자동으로 스프링 빈이 등록되는데 만약 이름이 같은 경우 스프링 오류를 발생함 ConflictingBeanDefinitionException 예외 발생수동 빈 등록 vs 자동 빈 등록// 자동 빈 등록@Componentpublic class MemoryMemberRepository implements MemberRepository {}@Configuration@ComponentScan( excludeFilters = @Filter(type = FilterType.ANNOTATION, classes = Configuration.class))public class AutoAppConfig { // 수동 빈 등록 @Bean(name = &quot;memoryMemberRepository&quot;) public MemberRepository memberRepository() { return new MemoryMemberRepository(); }}이러한 경우 수동 빈 등록이 우선권을 가짐(수동 빈이 자동 빈을 오버라이딩 해버림)# 수동 빈 등록시 출력되는 로그Overriding bean definition for bean &#39;memoryMemberRepository&#39; with a different definition: replacing그러나 최신의 스프링 부트에서는 수동 빈 등록과 자동 빈 등록이 충록나면 오류가 발생하도록 기본 값을 바꿈# 수동 빈 등록, 자동 빈 등록 오류시 스프링 부트 에러Consider renaming one of the beans or enabling overriding by setting spring.main.allow-bean-definition-overriding=true해당 설정은 application.properties 파일에 아래 와 같이 설정으로 오버라이딩 허용, 불허용 설정 가능spring.main.allow-bean-definition-overriding= true or false참고 스프링 핵심 원리 - 기본편(김영한)" }, { "title": "Spring Framework - 싱글턴 컨테이너", "url": "/posts/spring-05/", "categories": "Backend, Spring Framework", "tags": "Web, Spring Framework", "date": "2023-10-11 12:30:00 +0900", "snippet": "싱글턴 컨테이너 스프링 컨테이너는 싱글턴 패턴을 적용하지 않아도 객체인스턴스를 싱글턴으로 관리함 컨테이너는 객체를 하나만 생성해서 관리 스프링 컨테이너는 싱글턴 컨테이너 영할을 함 이러한 싱글턴 객체를 생성하고 관리하는 기능을 싱글턴 레지스트리라고 함 스프링 컨테이너로 인하여 요청이 올때마다 객체를 생성하는것이 아닌 이미 만들어진 객체를 효율적으로 재사용함 기본적으로 스프링의 기본 빈 등록방식은 싱글턴 이지만 요청할때 마다 새로운 객체를 생성해서 반환하는것도 가능 싱글턴 방식의 문제점 객체 인스턴스를 하나만 갱성해서 공유하는 싱글턴 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글턴 객체는 무상태(stateless)로 설계해야만 함 특정 클라이언트에 의존적인 필드가 있으면 안됨 특정 클라이언트가 값을 변경할수 있는 필드가 있으면 안됨 가급적이면 read only이여야 함 필드 대신에 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용해야만 함 스프인 빈의 필드에 공유 자원을 설정하면 동시성 이슈가 발생할 수 있음싱글턴 방식의 문제점 예시public class StatefullService { // 공유 변수 private int price; public void order(String name, int price) { this.price = price; } public int getPrice() { return price; }}public class StatefulServiceTest { @Test void statefulServiceSingleton() { ApplicationContext ac = new AnnotationConfigApplicationContext(TestConfig.class); StatefulService statefulService1 = ac.getBean(&quot;statefulService&quot;, StatefulService.class); StatefulService statefulService2 = ac.getBean(&quot;statefulService&quot;, StatefulService.class); //ThreadA: A사용자 10000원 주문 statefulService1.order(&quot;userA&quot;, 10000); //ThreadB: B사용자 20000원 주문 statefulService2.order(&quot;userB&quot;, 20000); //ThreadA: 사용자A 주문 금액 조회 int price = statefulService1.getPrice(); //ThreadA: 사용자A는 10000원을 기대했지만, 기대와 다르게 20000원 출력 System.out.println(&quot;price = &quot; + price); Assertions.assertThat(statefulService1.getPrice()).isEqualTo(20000); } static class TestConfig { @Bean public StatefulService statefulService() { return new StatefulService(); } }} thead 로 인하여 동시적으로 price 변수에 접근하여 서로 값을 변경하려함 위와 같은 이슈를 피하기 위해 반드시 스프링 빈은 항상 무상태(stateless)로 설계해야 함@Configuration과 싱글턴@Configurationpublic class AppConfig { @Bean public MemberService memberService() { return new MemberServiceImpl(memberRepository()); } @Bean public OrderService orderService() { return new OrderServiceImpl( memberRepository(), discountPolicy()); } @Bean public MemberRepository memberRepository() { return new MemoryMemberRepository(); } ...} 위 코드를 보면 memberService 빈과 orderService 빈을 만드는 과정에서 new MemoryMemberRepository() 가 두번 호출됨 new MemoryMemberRepository() 가 두번 호출되면서 인스턴스가 두개가 생성되며 싱글턴을 만족시키지 못할 것으로 보이나, 동작상 하나의 인스턴스만 존재함 해당 동작에 대해선 아래에 정리@Configuration과 바이트코드 조작싱글턴 컨텐이너는 싱글턴 레지스트리임. 따라서 스프링 빈이 싱글턴이 되도록 보장을 해 주어야함.이를 보장하기 위해 스프링 빈이 두개의 인스턴스가 생성되지 않도록 스프링은 클래스의 바이트코드를 조작하는 라이브러리를 사용함@Testvoid configurationDeep() { ApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class); //AppConfig도 스프링 빈으로 등록된다. AppConfig bean = ac.getBean(AppConfig.class); System.out.println(&quot;bean = &quot; + bean.getClass());}bean = class hello.core.AppConfig$$EnhancerBySpringCGLIB$$bd479d70순수한 클래스라면 아래와 같이 출력되어야 함bean = class hello.core.AppConfig이는 개발자가 만든 클래스가 아닌 스프링의 CGLIB이라는 바이트코드 조작 라이브러리를 사용하여 AppConfig 클래스를 상속받은 임의의 다른 클래스를 만들고, 해당 다른 클래스를 스피링 빈으로 등로하고 있기 때문임이러한 임의로 생성된 다른 클래스가 싱글턴이 보장되도록 해줌즉, @Bean 이 붙은 메서드마다 이미 스프링 빈이 존재하면 존재하는 빈을 반환하고 없다면 생성해서 스프링 빈으로 등록하고 반환하는 코드가 동적으로 생성됨 AppConfig@CGLIB 은 AppConfig의 자식 타입이므로 AppConfig 타입으로 조회할 수 있음정리 @Bean만 사용하더라도 스프링 빈으로 등록되지만 싱글턴을 보장하지 않음 스프링 설정 정보는 항상 @Configuration을 사용하도록 함참고 스프링 핵심 원리 - 기본편(김영한)" }, { "title": "Spring Framework - 스프링 컨테이너와 스프링 빈", "url": "/posts/spring-04/", "categories": "Backend, Spring Framework", "tags": "Web, Spring Framework", "date": "2023-10-11 09:47:00 +0900", "snippet": "스프링 컨테이너와 스프링 빈스프링 컨테이너 생성//스프링 컨테이너 생성ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); ApplicationContext 를 스프링 컨테이너 라고 함 스프링 컨테이너는 XML 기반으로 만들수도 있고 에노테이션 기반의 자바 설정 클래스로 만들수도 있음스프링 컨테이너 생성 과정스프링 컨테이너 생성 new AnnotationConfigApplicationContext(AppConfig.class) 스프링 컨테이너를 생성할 때는 구성 정보를 지정해주어야 함 위 사진의 예에선 AppConfig.class를 구성 정보로 지정스프링 빈 등록 스프링 컨테이너는 파라미터로 넘겨받은 설정 클래스 정보를 사용하여 스프링 빈을 등록함 스프링 빈의 이름은 보통 메소드 이름으로 지정하며 항상 다른 이름으로 등록해야 함스프링 빈 의존광계 설정 - 준비스프링 빈 의존광계 설정 - 완료 스프링 컨테이너는 설정 정보를 참고하여 의존관계를 주입(DI) 함스프링 빈 조회 부모 타입을 조회하면 자식 타입도 함께 조회 됨 그러므로 자바 객체 최고 부모인 Object 타입으로 죄회하면 모든 스프링 빈을 조회하게됨 BeanFactory와 ApplicationContextBeanFactory 스프링 컨테이너의 최상위 인터페이스 스프링 빈을 관리하고 조회하는 역할 getBean() 제공 ApplicationContext BeanFactory 기능을 모두 상속받아서 제공 BeanFacotry 기능인 스프링 빈 관리 및 조회 말고도 여러 부가 기능 제공ApplicationContext 기능 메시지소스를 활용한 국제화 기능 로컬라이징(클라이언트가 한국이면 한국어로, 영어권이면 영어로 출력) 환경변수 로컬, 개발, 운영등을 구분해서 처리 어플리케이션 이벤트 이벤트를 발행하고 구독하는 모델을 지원 리소스 조회 파일, 클래스패스, 외부 등에서 리소스를 조회 스프링 빈 설정 메타 정보 - BeanDefinition 스프링이 다양한 설정 형식을 가지기 위해서 BeanDefinition 라는 추상화가 존재함 BeanDefinition을 빈 설정 정보라고 함 @Bean, 당 각각 하나씩 메타정보가 생성됨 스프링 컨테이너는 이 메타정보를 기반으로 스프링 빈을 생성BeanDefinition 정보 BeanClassName: 생성할 빈의 클래스 명(자바 설정 처럼 팩토리 역할의 빈을 사용하면 없음) factoryBeanName: 팩토리 역할의 빈을 사용할 경우 이름, 예) appConfig factoryMethodName: 빈을 생성할 팩토리 메서드 지정, 예) memberService Scope: 싱글톤(기본값) lazyInit: 스프링 컨테이너를 생성할 때 빈을 생성하는 것이 아니라, 실제 빈을 사용할 때 까지 최대한 생성을 지연 처리 하는지 여부 InitMethodName: 빈을 생성하고, 의존관계를 적용한 뒤에 호출되는 초기화 메서드 명 DestroyMethodName: 빈의 생명주기가 끝나서 제거하기 직전에 호출되는 메서드 명 Constructor arguments, Properties: 의존관계 주입에서 사용한다. (자바 설정 처럼 팩토리 역할의 빈을 사용하면 없음)참고 스프링 핵심 원리 - 기본편(김영한)" }, { "title": "Spring Framework - 핵심 원리 이해", "url": "/posts/spring-03/", "categories": "Backend, Spring Framework", "tags": "Web, Spring Framework", "date": "2023-10-10 15:40:00 +0900", "snippet": "IoC, DI, 컨테이너IoC(Inversion of Control) - 제어의 역전 기존 프로그램은 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고, 연결하고 실행함 즉 구현 객체가 프로그램의 제어 흐름을 스스로 조종했음 반면에 AppConfig(DI를 위한 configure class. 구현체 객체 생성을 담당)를 사용하며 구현 객체는 자기 자신의 로직만을 실행하는 역할만 담당하게 됨 즉 프로그램의 제어의 흐름을 구현객체에서 AppConfig가 가져가게 됨 이와 같이 프로그램의 제어의 흐름을 개발자가 직접 제어하는 것이 아닌 외부에서 관리하는 것을 제어의 역전(IoC)이라 함DI(Dependency Injection) - 의존관계 주입 의존관계는 정적인 클래스 의존관계와, 실행 시점에 결정되는 동적인 객체(인스턴스) 의존관계 둘을 분리해서 생각해야 함 정적인 클래스 의존관계 : 코드상에서 특정 클래스가 사용하는 다른 클래스와의 관계(import 되어지는 class) 동적인 객체 인스턴스 의존 관계 : 어플리케이션 실행 시점에 실제 생성되는 객체 인스턴스의 참조가 연결된 의존 관계 어플리케이션 실행 시점에 외부에서 구현 객체를 생성하고 클라이언트에 전달하여 클라이언트와 서버의 실제 의존관계가 연결되는 것을 의존관계 주입이라고 함 객체 인스턴스를 생성하고 그 참조값을 전달하여 열결됨 의존관계 주입을 사용하게 되면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경 가능IoC 컨테이너, DI 컨테이너 AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는것을 IoC 컨테이너 또는 DI 컨테이너라 함 의존 관계 주입에 초점을 맞추어 주로 DI 컨테이너라고 함 참고 스프링 핵심 원리 - 기본편(김영한)" }, { "title": "Spring Framework - 핵심 원리 이해(예제 만들기)", "url": "/posts/spring-02/", "categories": "Backend, Spring Framework", "tags": "Web, Spring Framework", "date": "2023-10-10 11:40:00 +0900", "snippet": "요구사항과 설계회원 도메인 요구사항 회원가입 및 조회 회원은 일반, VIP 두가지 유형이 존재 회원 데이터는 자체 DB를 구축할 수 있거나 외부 시스템과 연동될수도 있음(미확정)회원 도메인 협력 관계회원 클래스 다이어그램회원 객체 다이어그램회원 도메인 설계의 문제점 다른 저장소로 변경할떄 OCP 를 준수하는지? DIP 가 잘 준수되고 있는지? 의존관게가 인터페이스 뿐만 아니라 구현까지 모두 의존하는 문제점이 있음주문과 할인 도메인 설계주문과 할인 정책 회원은 상품주문 가능 회원 등급에 따라 할인 정책 적용 할인 정책은 모든 VIP는 1000원을 할인해주는 고정 금액 할인 적용(추후 변경가능) 할인 정책은 변경가능성이 높음주문 도메인 협력, 역할, 책임 주문 생성 : 클라이언트는 주문 서비스에 주문 생성을 요청 회원 조회 : 할인을 위해선 회원 등급이 필요. 그러므로 주문서비스는 회원 저장소에서 회원을 조회 할인 적용 : 주문 서비스는 회원등급에 따라 할인 여부를 할인 정책에 위임 주문 결과 반환 : 주문 서비스는 할인 결과를 포함한 주문결과를 반환실제로는 주문을 DB에 저장하지만 예제이므로 결과 반환만 함주문 도메인 전체주문 도메인 클래스 다이어그램주문 도메인 객체 다이어그램1번 유형 회원을 메모리에서 조회2번 유형 회원을 DB에서 조회참고 스프링 핵심 원리 - 기본편(김영한)" }, { "title": "Spring Framework - 객체 지향 설계와 스프링", "url": "/posts/spring-01/", "categories": "Backend, Spring Framework", "tags": "Web, Spring Framework", "date": "2023-10-10 09:05:00 +0900", "snippet": "스프링이란? 여러가지 기술(모듈)들의 집합 스프링 데이터, 스프링 세션, 스프링 시큐리티 등등 Spring Framework 핵심 기술 : 스프링 DI 컨테이너, AOP, 이벤트, 기타 웹 기술 : 스프링 MVC, 스프링 WebFlux 데이터 접근 기술 : 트랜잭션, JDBC, ORM 지원, XML 지원 기술 통합 : 캐시, 이메일, 원격접근, 스케쥴링 테스트 : 스프링 기반 테스트 지원 언어 : 코틀린, 그루비Spring Boot 스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용 단독으로 실행할 수 있는 스프링 어플리케이션 생성 톰캣 같은 웹서버를 내장하여 별도의 웹 서버를 설치하지 않아도 됨 손쉬운 빈드 구설을 위한 스타터 종속석 제공 스프링과 서드파티 외부 라이브러리 자동 구성 메트릭, 상태확인, 외부 구성 같은 프로덕션 준비 기능 제공 관례에 의한 간결한 설정핵심 개념 스프링은 자바 언어 기반의 프레임워크 자바 언어의 가장 큰 특징 - OOP 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크 스프링은 좋은 객체 지향 어플리케이션을 개발할 수 있게 도와주는 프레임워크객체지향 - 다형성의 본질 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다. 다현성의 본질을 이해하려면 협력이라는 객체사이의 관계에서 시작해야함 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.객체지향 - 역할과 구현을 분리 실세계의 역할과 구현이라는 편리한 컨셉을 다형성을 통해 객체 세상으로 가져올 수 있음 유연하고, 변경에 용이 확장 가능한 설계 클라이언트에 영향을 주지 않는 변경 가능 인터페이스를 안정적으로 잘 설계하는 것이 중요객체지향 - SOLIDSRP(Single Responesibility Principle) - 단인 책임 원칙 한 클래스는 하나의 책임만 가진다. 그러나 하나의 책임이라는 것을 모호한 개념 클 수 있고, 작을수 있음 문맥과 상황에 따라 다름 주요 기준은 변경이다. 변경이 있을때 마다 파금효과가 적으면 SRP를 잘 따른것 예) UI 변경, 객체의 생성과 사용을 분리OCP(Open Closed Principle) - 개방-폐쇠 원칙 소프트웨어의 요소는 확장에는 열려있으나 변경에는 닫혀 있어야 한다 다형성을 활용하여 구현 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현 구현 객체를 변경하려면 클라이언트 코드를 변경해야 함 다형성을 사용해도 완벽히 OCP 원칙을 지킬수 없음 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정하가 필요함 스프링의 역할 // 인터페이스에 구현체를 할당하는 과정에서 기존 코드의 변결이 필요해짐 InterfaceA a = new DerivedA(); // 기존코드 InterfaceA a = new DerivedAA(); // 변경코드 LSP(Liskov Substitution Principle) - 리스코프 치환 원칙 프로그램의 객체는 프로그램의 정확설을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀수 있어야 함 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것 다형성을 지원하기 위한 원칙 단순히 컴파일 성공을 넘어서는 이야기 예) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능. 뒤로 가게 구현하면 LSP 위반.ISP(Interface Segregation Principle) - 인터페이스 분리 원칙 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 나음 자동차 인터페이스 -&amp;gt; 운전 인터페이스, 정비 인터페이스로 분리 사용자 클라리언트 -&amp;gt; 운전자 클라이언트, 정비사 클라이언트로 분리 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음 인터페이스가 명확해지고 대체 가능성이 높아짐DIP(Dependecy Inversion Principle) - 의존관계 역전 원칙 추상화에 의존해야지, 구체화에 의존해선 안됨. 즉 구현 클래스에 의존하지 말고 인터페이스에 의존해야함 객체 세상도 클라이언트가 인터페이스에 의존해야 구현체를 변경할 수 있음 구현체에 의존하게 되면 변경이 어려워짐 인터페이스에 구현체를 할당하는 과정에서 구현 클래스를 의존하게됨 완벽히 DIP 원칙을 지킬수 없음 // 인터페이스에 구현체를 할당하는 과정에서 DerivedAA 라는 구현체가 필요하므로 // DerivedAA 라는 구현체에 의존하게됨 InterfaceA a = new DerivedAA(); SOLID 정리 객체 지향의 핵심은 다형성 다형성 만으로는 구현 객체를 변경 할때 클라이언트 코드도 함께 변경됨 다형성 만으로는 OCP, DIP를 만족 할수 없음스프링과 객체지향 다형성이 중요 스프링은 다형성을 극대화 하여 이용할 수 있게 도와준다 스프링에서 이야기 하는 제어의 역전(IoC), 의존관계 주입(DI)은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다 스프링은 다음 기술로 다형성 + OCP, DIP를 만족할 수 있게 지원 DI(Dependency Injection) : 의존관계, 의존성 주입 DI 컨테이너 제공 클라이언트 코드의 변경없이 기능 확장정리 모든 설계에 영할과 구현을 분리해야 함 이상적으로는 모든 설계에 인터페이스를 부여해보자 하지만 인터페이스를 도입하면 추상화라는 비용이 발생 런타임에 어떠한 구현 클레스를 사용하고 있는지 확인이 필요 기능을 확장할 필요가 없다면 구현 클래스를 직접 사용하고, 향후 꼭 필요할때 리펙토링을 하여 인터페이스를 도입하는 것도 하나의 방법참고 스프링 핵심 원리 - 기본편(김영한)" }, { "title": "Programmers - 키패드 누르기", "url": "/posts/ps-programmers-052/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Math, Array", "date": "2023-10-10 07:10:00 +0900", "snippet": " 키패드 누르기 - lv.1문제이 전화 키패드에서 왼손과 오른손의 엄지손가락만을 이용해서 숫자만을 입력하려고 합니다.맨 처음 왼손 엄지손가락은 * 키패드에 오른손 엄지손가락은 # 키패드 위치에서 시작하며, 엄지손가락을 사용하는 규칙은 다음과 같습니다. 엄지손가락은 상하좌우 4가지 방향으로만 이동할 수 있으며 키패드 이동 한 칸은 거리로 1에 해당합니다. 왼쪽 열의 3개의 숫자 1, 4, 7을 입력할 때는 왼손 엄지손가락을 사용합니다. 오른쪽 열의 3개의 숫자 3, 6, 9를 입력할 때는 오른손 엄지손가락을 사용합니다. 가운데 열의 4개의 숫자 2, 5, 8, 0을 입력할 때는 두 엄지손가락의 현재 키패드의 위치에서 더 가까운 엄지손가락을 사용합니다.4-1. 만약 두 엄지손가락의 거리가 같다면, 오른손잡이는 오른손 엄지손가락, 왼손잡이는 왼손 엄지손가락을 사용합니다.순서대로 누를 번호가 담긴 배열 numbers, 왼손잡이인지 오른손잡이인 지를 나타내는 문자열 hand가 매개변수로 주어질 때, 각 번호를 누른 엄지손가락이 왼손인 지 오른손인 지를 나타내는 연속된 문자열 형태로 return 하도록 solution 함수를 완성해주세요.제한사항 numbers 배열의 크기는 1 이상 1,000 이하입니다. numbers 배열 원소의 값은 0 이상 9 이하인 정수입니다. hand는 “left” 또는 “right” 입니다. “left”는 왼손잡이, “right”는 오른손잡이를 의미합니다. 왼손 엄지손가락을 사용한 경우는 L, 오른손 엄지손가락을 사용한 경우는 R을 순서대로 이어붙여 문자열 형태로 return 해주세요.입출력 예 numbers hand result [1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5] “right” “LRLLLRLLRRL” [7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2] “left” “LRLLRRLLLRR” [1, 2, 3, 4, 5, 6, 7, 8, 9, 0] “right” “LLRLLRLLRL” 입출력 예 #1순서대로 눌러야 할 번호가 [1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5]이고, 오른손잡이입니다. 왼손 위치 오른손 위치 눌러야 할 숫자 사용한 손 설명 * # 1 L 1은 왼손으로 누릅니다. 1 # 3 R 3은 오른손으로 누릅니다. 1 3 4 L 4는 왼손으로 누릅니다. 4 3 5 L 왼손 거리는 1, 오른손 거리는 2이므로 왼손으로 5를 누릅니다. 5 3 8 L 왼손 거리는 1, 오른손 거리는 3이므로 왼손으로 8을 누릅니다. 8 3 2 R 왼손 거리는 2, 오른손 거리는 1이므로 오른손으로 2를 누릅니다. 8 2 1 L 1은 왼손으로 누릅니다. 1 2 4 L 4는 왼손으로 누릅니다. 4 2 5 R 왼손 거리와 오른손 거리가 1로 같으므로, 오른손으로 5를 누릅니다. 4 5 9 R 9는 오른손으로 누릅니다. 4 9 5 L 왼손 거리는 1, 오른손 거리는 2이므로 왼손으로 5를 누릅니다. 5 9 - -   따라서 “LRLLLRLLRRL”를 return 합니다.입출력 예 #2왼손잡이가 [7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2]를 순서대로 누르면 사용한 손은 “LRLLRRLLLRR”이 됩니다.입출력 예 #3오른손잡이가 [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]를 순서대로 누르면 사용한 손은 “LLRLLRLLRL”이 됩니다.풀이 Math, Arrayclass Solution { public int left = 10; public int right = 12; public String answer = &quot;&quot;; public void setValue(int number, char hand) { if (hand == &#39;L&#39;) { left = number; answer += hand; } else { right = number; answer += hand; } } public int calculateDistance(int target, int number) { return (Math.abs(target - number) / 3) + (Math.abs(target - number) % 3); } public String solution(int[] numbers, String hand) { for (int number : numbers) { if (number == 1 || number == 4 || number == 7) { setValue(number, &#39;L&#39;); } else if (number == 3 || number == 6 || number == 9) { setValue(number, &#39;R&#39;); } else { if (number == 0) { number = 11; } int leftDis = calculateDistance(number, this.left); int rightDis = calculateDistance(number, this.right); if (leftDis &amp;lt; rightDis) { setValue(number, &#39;L&#39;); } else if (leftDis &amp;gt; rightDis) { setValue(number, &#39;R&#39;); } else { if (hand.equals(&quot;left&quot;)) { setValue(number, &#39;L&#39;); } else { setValue(number, &#39;R&#39;); } } } } return answer; }}" }, { "title": "Programmers - 콜라 문제", "url": "/posts/ps-programmers-051/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Math", "date": "2023-10-10 06:40:00 +0900", "snippet": " 콜라 문제 - lv.1문제오래전 유행했던 콜라 문제가 있습니다. 콜라 문제의 지문은 다음과 같습니다.정답은 아무에게도 말하지 마세요.콜라 빈 병 2개를 가져다주면 콜라 1병을 주는 마트가 있다. 빈 병 20개를 가져다주면 몇 병을 받을 수 있는가?단, 보유 중인 빈 병이 2개 미만이면, 콜라를 받을 수 없다.문제를 풀던 상빈이는 콜라 문제의 완벽한 해답을 찾았습니다. 상빈이가 푼 방법은 아래 그림과 같습니다. 우선 콜라 빈 병 20병을 가져가서 10병을 받습니다. 받은 10병을 모두 마신 뒤, 가져가서 5병을 받습니다. 5병 중 4병을 모두 마신 뒤 가져가서 2병을 받고, 또 2병을 모두 마신 뒤 가져가서 1병을 받습니다. 받은 1병과 5병을 받았을 때 남은 1병을 모두 마신 뒤 가져가면 1병을 또 받을 수 있습니다. 이 경우 상빈이는 총 10 + 5 + 2 + 1 + 1 = 19병의 콜라를 받을 수 있습니다.문제를 열심히 풀던 상빈이는 일반화된 콜라 문제를 생각했습니다. 이 문제는 빈 병 a개를 가져다주면 콜라 b병을 주는 마트가 있을 때, 빈 병 n개를 가져다주면 몇 병을 받을 수 있는지 계산하는 문제입니다. 기존 콜라 문제와 마찬가지로, 보유 중인 빈 병이 a개 미만이면, 추가적으로 빈 병을 받을 순 없습니다. 상빈이는 열심히 고심했지만, 일반화된 콜라 문제의 답을 찾을 수 없었습니다. 상빈이를 도와, 일반화된 콜라 문제를 해결하는 프로그램을 만들어 주세요.콜라를 받기 위해 마트에 주어야 하는 병 수 a, 빈 병 a개를 가져다 주면 마트가 주는 콜라 병 수 b, 상빈이가 가지고 있는 빈 병의 개수 n이 매개변수로 주어집니다. 상빈이가 받을 수 있는 콜라의 병 수를 return 하도록 solution 함수를 작성해주세요.제한사항 1 ≤ b &amp;lt; a ≤ n ≤ 1,000,000 정답은 항상 int 범위를 넘지 않게 주어집니다.입출력 예 a b n result 2 1 20 19 3 1 20 9 입출력 예 #1본문에서 설명한 예시입니다.입출력 예 #2빈 병 20개 중 18개를 마트에 가져가서, 6병의 콜라를 받습니다. 이때 상빈이가 가지고 있는 콜라 병의 수는 8(20 – 18 + 6 = 8)개 입니다.빈 병 8개 중 6개를 마트에 가져가서, 2병의 콜라를 받습니다. 이때 상빈이가 가지고 있는 콜라 병의 수는 4(8 – 6 + 2 = 4)개 입니다.빈 병 4 개중 3개를 마트에 가져가서, 1병의 콜라를 받습니다. 이때 상빈이가 가지고 있는 콜라 병의 수는 2(4 – 3 + 1 = 2)개 입니다.3번의 교환 동안 상빈이는 9(6 + 2 + 1 = 9)병의 콜라를 받았습니다.풀이 Mathclass Solution { public int solution(int a, int b, int n) { int answer = 0; while(n &amp;gt;= a) { n = n - a + b; answer += b; } return answer; }}" }, { "title": "Programmers - 최소직사각형", "url": "/posts/ps-programmers-050/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Absolute Search", "date": "2023-10-09 19:05:00 +0900", "snippet": " 최소직사각형 - lv.1문제명함 지갑을 만드는 회사에서 지갑의 크기를 정하려고 합니다. 다양한 모양과 크기의 명함들을 모두 수납할 수 있으면서, 작아서 들고 다니기 편한 지갑을 만들어야 합니다. 이러한 요건을 만족하는 지갑을 만들기 위해 디자인팀은 모든 명함의 가로 길이와 세로 길이를 조사했습니다.아래 표는 4가지 명함의 가로 길이와 세로 길이를 나타냅니다.명함 번호 가로 길이 세로 길이1 60 502 30 703 60 304 80 40가장 긴 가로 길이와 세로 길이가 각각 80, 70이기 때문에 80(가로) x 70(세로) 크기의 지갑을 만들면 모든 명함들을 수납할 수 있습니다. 하지만 2번 명함을 가로로 눕혀 수납한다면 80(가로) x 50(세로) 크기의 지갑으로 모든 명함들을 수납할 수 있습니다. 이때의 지갑 크기는 4000(=80 x 50)입니다.모든 명함의 가로 길이와 세로 길이를 나타내는 2차원 배열 sizes가 매개변수로 주어집니다. 모든 명함을 수납할 수 있는 가장 작은 지갑을 만들 때, 지갑의 크기를 return 하도록 solution 함수를 완성해주세요.제한사항 sizes의 길이는 1 이상 10,000 이하입니다. sizes의 원소는 [w, h] 형식입니다. w는 명함의 가로 길이를 나타냅니다. h는 명함의 세로 길이를 나타냅니다. w와 h는 1 이상 1,000 이하인 자연수입니다. 입출력 예 sizes result [60, 50], [30, 70], [60, 30], [80, 40] 4000 [10, 7], [12, 3], [8, 15], [14, 7], [5, 15] 120 [14, 4], [19, 6], [6, 16], [18, 7], [7, 11] 133 입출력 예 #1문제 예시와 같습니다.입출력 예 #2명함들을 적절히 회전시켜 겹쳤을 때, 3번째 명함(가로: 8, 세로: 15)이 다른 모든 명함보다 크기가 큽니다. 따라서 지갑의 크기는 3번째 명함의 크기와 같으며, 120(=8 x 15)을 return 합니다.입출력 예 #3명함들을 적절히 회전시켜 겹쳤을 때, 모든 명함을 포함하는 가장 작은 지갑의 크기는 133(=19 x 7)입니다.풀이 Simulateclass Solution { public int solution(int[][] sizes) { int max_width = 0; int max_height = 0; for (int i = 0 ; i &amp;lt; sizes.length ; i++) { int max = (sizes[i][0] &amp;gt; sizes[i][1]) ? sizes[i][0] : sizes[i][1]; int min = (sizes[i][0] &amp;lt; sizes[i][1]) ? sizes[i][0] : sizes[i][1]; int width = max; int height = min; if (max_width &amp;lt; width) { max_width = width; } if (max_height &amp;lt; height) { max_height = height; } } int answer = max_width * max_height; return answer; }}" }, { "title": "Programmers - 공원 산책", "url": "/posts/ps-programmers-049/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Simulate", "date": "2023-10-07 01:05:00 +0900", "snippet": " 공원 산책 - lv.1문제지나다니는 길을 ‘O’, 장애물을 ‘X’로 나타낸 직사각형 격자 모양의 공원에서 로봇 강아지가 산책을 하려합니다. 산책은 로봇 강아지에 미리 입력된 명령에 따라 진행하며, 명령은 다음과 같은 형식으로 주어집니다.[“방향 거리”, “방향 거리” … ]예를 들어 “E 5”는 로봇 강아지가 현재 위치에서 동쪽으로 5칸 이동했다는 의미입니다. 로봇 강아지는 명령을 수행하기 전에 다음 두 가지를 먼저 확인합니다.주어진 방향으로 이동할 때 공원을 벗어나는지 확인합니다.주어진 방향으로 이동 중 장애물을 만나는지 확인합니다.위 두 가지중 어느 하나라도 해당된다면, 로봇 강아지는 해당 명령을 무시하고 다음 명령을 수행합니다.공원의 가로 길이가 W, 세로 길이가 H라고 할 때, 공원의 좌측 상단의 좌표는 (0, 0), 우측 하단의 좌표는 (H - 1, W - 1) 입니다.제한사항 3 ≤ park의 길이 ≤ 50 3 ≤ park[i]의 길이 ≤ 50 park[i]는 다음 문자들로 이루어져 있으며 시작지점은 하나만 주어집니다. S : 시작 지점 O : 이동 가능한 통로 X : 장애물 park는 직사각형 모양입니다. 1 ≤ routes의 길이 ≤ 50 routes의 각 원소는 로봇 강아지가 수행할 명령어를 나타냅니다. 로봇 강아지는 routes의 첫 번째 원소부터 순서대로 명령을 수행합니다. routes의 원소는 “op n”과 같은 구조로 이루어져 있으며, op는 이동할 방향, n은 이동할 칸의 수를 의미합니다. op는 다음 네 가지중 하나로 이루어져 있습니다. N : 북쪽으로 주어진 칸만큼 이동합니다. S : 남쪽으로 주어진 칸만큼 이동합니다. W : 서쪽으로 주어진 칸만큼 이동합니다. E : 동쪽으로 주어진 칸만큼 이동합니다. 1 ≤ n ≤ 9 입출력 예 park routes result [“SOO”,”OOO”,”OOO”] [“E 2”,”S 2”,”W 1”] [2,1] [“SOO”,”OXX”,”OOO”] [“E 2”,”S 2”,”W 1”] [0,1] [“OSO”,”OOO”,”OXO”,”OOO”] [“E 2”,”S 3”,”W 1”] [0,0] 입출력 예 #1입력된 명령대로 동쪽으로 2칸, 남쪽으로 2칸, 서쪽으로 1칸 이동하면 [0,0] -&amp;gt; [0,2] -&amp;gt; [2,2] -&amp;gt; [2,1]이 됩니다.입출력 예 #2입력된 명령대로라면 동쪽으로 2칸, 남쪽으로 2칸, 서쪽으로 1칸 이동해야하지만 남쪽으로 2칸 이동할 때 장애물이 있는 칸을 지나기 때문에 해당 명령을 제외한 명령들만 따릅니다. 결과적으로는 [0,0] -&amp;gt; [0,2] -&amp;gt; [0,1]이 됩니다.입출력 예 #3처음 입력된 명령은 공원을 나가게 되고 두 번째로 입력된 명령 또한 장애물을 지나가게 되므로 두 입력은 제외한 세 번째 명령만 따르므로 결과는 다음과 같습니다. [0,1] -&amp;gt; [0,0]설명 생략풀이 Simulateclass Solution { public boolean CheckRange(int[] range, int[] target) { if ((0 &amp;gt; target[0] || target[0] &amp;gt;= range[0]) || (0 &amp;gt; target[1] || target[1] &amp;gt;= range[1])) { return false; } return true; } public int[] solution(String[] park, String[] routes) { int[] boardSize = {park.length, park[0].length()}; boolean[][] board = new boolean[boardSize[0]][boardSize[1]]; int[] position = {0, 0}; for (int y = 0 ; y &amp;lt; board.length ; y++ ) { for (int x = 0 ; x &amp;lt; board[y].length ; x++ ) { if (park[y].charAt(x) == &#39;S&#39;) { position[0] = y; position[1] = x; board[y][x] = true; } else if (park[y].charAt(x) == &#39;X&#39;) { board[y][x] = false; } else { board[y][x] = true; } } } for (String route : routes) { int[] targetPos = position; int moveCount = route.charAt(2) - &#39;0&#39;; boolean needPass = false; for (int i = 0 ; i &amp;lt; moveCount ; i++) { int[] offset = {0, 0}; if (route.charAt(0) == &#39;E&#39;) { offset[1] += 1; } else if (route.charAt(0) == &#39;W&#39;) { offset[1] -= 1; } else if (route.charAt(0) == &#39;S&#39;) { offset[0] += 1; } else if (route.charAt(0) == &#39;N&#39;) { offset[0] -= 1; } int[] calPosition = {targetPos[0] + offset[0], targetPos[1] + offset[1]}; if (!CheckRange(boardSize, calPosition) || !board[calPosition[0]][calPosition[1]]) { needPass = true; break; } else { targetPos = calPosition; } } if (!needPass) { position = targetPos; } } return position; }}" }, { "title": "Programmers - 추억 점수", "url": "/posts/ps-programmers-048/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Hash", "date": "2023-10-06 21:29:00 +0900", "snippet": " 추억 점수 - lv.1문제사진들을 보며 추억에 젖어 있던 루는 사진별로 추억 점수를 매길려고 합니다. 사진 속에 나오는 인물의 그리움 점수를 모두 합산한 값이 해당 사진의 추억 점수가 됩니다. 예를 들어 사진 속 인물의 이름이 [“may”, “kein”, “kain”]이고 각 인물의 그리움 점수가 [5점, 10점, 1점]일 때 해당 사진의 추억 점수는 16(5 + 10 + 1)점이 됩니다. 다른 사진 속 인물의 이름이 [“kali”, “mari”, “don”, “tony”]이고 [“kali”, “mari”, “don”]의 그리움 점수가 각각 [11점, 1점, 55점]]이고, “tony”는 그리움 점수가 없을 때, 이 사진의 추억 점수는 3명의 그리움 점수를 합한 67(11 + 1 + 55)점입니다.그리워하는 사람의 이름을 담은 문자열 배열 name, 각 사람별 그리움 점수를 담은 정수 배열 yearning, 각 사진에 찍힌 인물의 이름을 담은 이차원 문자열 배열 photo가 매개변수로 주어질 때, 사진들의 추억 점수를 photo에 주어진 순서대로 배열에 담아 return하는 solution 함수를 완성해주세요.제한사항 3 ≤ name의 길이 = yearning의 길이≤ 100 3 ≤ name의 원소의 길이 ≤ 7 name의 원소들은 알파벳 소문자로만 이루어져 있습니다. name에는 중복된 값이 들어가지 않습니다. 1 ≤ yearning[i] ≤ 100 yearning[i]는 i번째 사람의 그리움 점수입니다. 3 ≤ photo의 길이 ≤ 100 1 ≤ photo[i]의 길이 ≤ 100 3 ≤ photo[i]의 원소(문자열)의 길이 ≤ 7 photo[i]의 원소들은 알파벳 소문자로만 이루어져 있습니다. photo[i]의 원소들은 중복된 값이 들어가지 않습니다. 입출력 예 name yearning photo result [“may”, “kein”, “kain”, “radi”] [5, 10, 1, 3] [[“may”, “kein”, “kain”, “radi”],[“may”, “kein”, “brin”, “deny”], [“kon”, “kain”, “may”, “coni”]] [19, 15, 6] [“kali”, “mari”, “don”] [11, 1, 55] [[“kali”, “mari”, “don”], [“pony”, “tom”, “teddy”], [“con”, “mona”, “don”]] [67, 0, 55] [“may”, “kein”, “kain”, “radi”] [5, 10, 1, 3] [[“may”],[“kein”, “deny”, “may”], [“kon”, “coni”]] [5, 15, 0] 입출력 예 #1첫 번째 사진 속 “may”, “kein”, “kain”, “radi”의 그리움 점수를 합치면 19(5 + 10 + 1 + 3)점 입니다. 두 번째 사진 속 그리워하는 사람들인 “may”와 “kein”의 그리움 점수를 합치면 15(5 + 10)점입니다. 세 번째 사진의 경우 “kain”과 “may”만 그리워하므로 둘의 그리움 점수를 합한 6(1 + 5)점이 사진의 추억 점수입니다. 따라서 [19, 15, 6]을 반환합니다.입출력 예 #2첫 번째 사진 속 그리워하는 사람들인 “kali”, “mari”, “don”의 그리움 점수를 합치면 67(11 + 1 + 55)점입니다. 두 번째 사진 속엔 그리워하는 인물이 없으므로 0점입니다. 세 번째 사진 속 그리워하는 사람은 “don”만 있으므로 55점입니다. 따라서 [67, 0, 55]를 반환합니다.입출력 예 #3설명 생략풀이 Hashimport java.util.HashMap;class Solution { public int[] solution(String[] name, int[] yearning, String[][] photo) { HashMap&amp;lt;String, Integer&amp;gt; nameMap = new HashMap&amp;lt;String, Integer&amp;gt;(); for (int i = 0 ; i &amp;lt; name.length ; i++) { nameMap.put(name[i], yearning[i]); } int[] answer = new int[photo.length]; for (int i = 0 ; i &amp;lt; photo.length ; i++) { for (String entry : photo[i]) { Integer value = nameMap.get(entry); answer[i] += (value != null) ? value.intValue() : 0; } } return answer; }}" }, { "title": "Programmers - 달리기 경주", "url": "/posts/ps-programmers-047/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Hash", "date": "2023-10-06 21:29:00 +0900", "snippet": " 달리기 경주 - lv.1문제얀에서는 매년 달리기 경주가 열립니다. 해설진들은 선수들이 자기 바로 앞의 선수를 추월할 때 추월한 선수의 이름을 부릅니다. 예를 들어 1등부터 3등까지 “mumu”, “soe”, “poe” 선수들이 순서대로 달리고 있을 때, 해설진이 “soe”선수를 불렀다면 2등인 “soe” 선수가 1등인 “mumu” 선수를 추월했다는 것입니다. 즉 “soe” 선수가 1등, “mumu” 선수가 2등으로 바뀝니다.선수들의 이름이 1등부터 현재 등수 순서대로 담긴 문자열 배열 players와 해설진이 부른 이름을 담은 문자열 배열 callings가 매개변수로 주어질 때, 경주가 끝났을 때 선수들의 이름을 1등부터 등수 순서대로 배열에 담아 return 하는 solution 함수를 완성해주세요.제한사항 5 ≤ players의 길이 ≤ 50,000 players[i]는 i번째 선수의 이름을 의미합니다. players의 원소들은 알파벳 소문자로만 이루어져 있습니다. players에는 중복된 값이 들어가 있지 않습니다. 3 ≤ players[i]의 길이 ≤ 10 2 ≤ callings의 길이 ≤ 1,000,000 callings는 players의 원소들로만 이루어져 있습니다. 경주 진행중 1등인 선수의 이름은 불리지 않습니다. 입출력 예 players callings result [“mumu”, “soe”, “poe”, “kai”, “mine”] [“kai”, “kai”, “mine”, “mine”] [“mumu”, “kai”, “mine”, “soe”, “poe”] 4등인 “kai” 선수가 2번 추월하여 2등이 되고 앞서 3등, 2등인 “poe”, “soe” 선수는 4등, 3등이 됩니다. 5등인 “mine” 선수가 2번 추월하여 4등, 3등인 “poe”, “soe” 선수가 5등, 4등이 되고 경주가 끝납니다. 1등부터 배열에 담으면 [“mumu”, “kai”, “mine”, “soe”, “poe”]이 됩니다.풀이 Hashclass Solution { public String[] solution(String[] players, String[] callings) { HashMap&amp;lt;String, Integer&amp;gt; playerMap = new HashMap&amp;lt;String, Integer&amp;gt;(); HashMap&amp;lt;Integer, String&amp;gt; rankMap = new HashMap&amp;lt;Integer, String&amp;gt;(); for (int i = 0 ; i &amp;lt; players.length; i++ ) { playerMap.put(players[i], i); rankMap.put(i, players[i]); } for (String calling : callings) { Integer curruntRank = playerMap.get(calling); Integer newRank = curruntRank - 1; String losePlayer = rankMap.get(newRank); // player 순서 병경 playerMap.put(calling, newRank); playerMap.put(losePlayer, curruntRank); // ranking 순서 변경 rankMap.put(newRank, calling); rankMap.put(curruntRank, losePlayer); } String[] answer = new String[players.length]; for (int i = 0 ; i &amp;lt; players.length; i++ ) { answer[i] = rankMap.get(i); } return answer; }}" }, { "title": "Programmers - 요격 시스템", "url": "/posts/ps-programmers-046/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Greedy", "date": "2023-10-06 02:31:00 +0900", "snippet": " 요격 시스템 - lv.2문제문제 설명A 나라가 B 나라를 침공하였습니다. B 나라의 대부분의 전략 자원은 아이기스 군사 기지에 집중되어 있기 때문에 A 나라는 B 나라의 아이기스 군사 기지에 융단폭격을 가했습니다.A 나라의 공격에 대항하여 아이기스 군사 기지에서는 무수히 쏟아지는 폭격 미사일들을 요격하려고 합니다. 이곳에는 백발백중을 자랑하는 요격 시스템이 있지만 운용 비용이 상당하기 때문에 미사일을 최소로 사용해서 모든 폭격 미사일을 요격하려 합니다.A 나라와 B 나라가 싸우고 있는 이 세계는 2 차원 공간으로 이루어져 있습니다. A 나라가 발사한 폭격 미사일은 x 축에 평행한 직선 형태의 모양이며 개구간을 나타내는 정수 쌍 (s, e) 형태로 표현됩니다. B 나라는 특정 x 좌표에서 y 축에 수평이 되도록 미사일을 발사하며, 발사된 미사일은 해당 x 좌표에 걸쳐있는 모든 폭격 미사일을 관통하여 한 번에 요격할 수 있습니다. 단, 개구간 (s, e)로 표현되는 폭격 미사일은 s와 e에서 발사하는 요격 미사일로는 요격할 수 없습니다. 요격 미사일은 실수인 x 좌표에서도 발사할 수 있습니다.각 폭격 미사일의 x 좌표 범위 목록 targets이 매개변수로 주어질 때, 모든 폭격 미사일을 요격하기 위해 필요한 요격 미사일 수의 최솟값을 return 하도록 solution 함수를 완성해 주세요.제한사항 1 ≤ targets의 길이 ≤ 500,000 targets의 각 행은 [s,e] 형태입니다. 이는 한 폭격 미사일의 x 좌표 범위를 나타내며, 개구간 (s, e)에서 요격해야 합니다. 0 ≤ s &amp;lt; e ≤ 100,000,000 입출력 예 targets result [4,5],[4,8],[10,14],[11,13],[5,12],[3,7],[1,4] 3 주어진 데이터는 다음과 같습니다.위 그림과 같이 최소 세 번의 요격 미사일 발사로 전부 방어할 수 있습니다.풀이 Greedybool compare(const vector&amp;lt;int&amp;gt;&amp;amp; a, const vector&amp;lt;int&amp;gt;&amp;amp; b) { return a[1] &amp;lt; b[1];}int solution(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; targets) { int answer = 0; std::sort(targets.begin(), targets.end(), compare); uint32_t e = 0; for (const auto&amp;amp; taget : targets) { if (taget[0] &amp;gt;= e) { ++answer; e = taget[1]; } } return answer;}" }, { "title": "LeetCode - 1934. Confirmation Rate", "url": "/posts/ps-leetcode-1934/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, SQL", "date": "2023-06-01 08:42:00 +0900", "snippet": " 1934. Confirmation Rate - Medium문제Table: Signups+----------------+----------+| Column Name | Type |+----------------+----------+| user_id | int || time_stamp | datetime |+----------------+----------+user_id is the primary key for this table.Each row contains information about the signup time for the user with ID user_id. Table: Confirmations+----------------+----------+| Column Name | Type |+----------------+----------+| user_id | int || time_stamp | datetime || action | ENUM |+----------------+----------+(user_id, time_stamp) is the primary key for this table.user_id is a foreign key with a reference to the Signups table.action is an ENUM of the type (&#39;confirmed&#39;, &#39;timeout&#39;)Each row of this table indicates that the user with ID user_id requested a confirmation message at time_stamp and that confirmation message was either confirmed (&#39;confirmed&#39;) or expired without confirming (&#39;timeout&#39;).The confirmation rate of a user is the number of ‘confirmed’ messages divided by the total number of requested confirmation messages. The confirmation rate of a user that did not request any confirmation messages is 0. Round the confirmation rate to two decimal places.Write an SQL query to find the confirmation rate of each user.Return the result table in any order.The query result format is in the following example.입출력 예Input: Signups table:+---------+---------------------+| user_id | time_stamp |+---------+---------------------+| 3 | 2020-03-21 10:16:13 || 7 | 2020-01-04 13:57:59 || 2 | 2020-07-29 23:09:44 || 6 | 2020-12-09 10:39:37 |+---------+---------------------+Confirmations table:+---------+---------------------+-----------+| user_id | time_stamp | action |+---------+---------------------+-----------+| 3 | 2021-01-06 03:30:46 | timeout || 3 | 2021-07-14 14:00:00 | timeout || 7 | 2021-06-12 11:57:29 | confirmed || 7 | 2021-06-13 12:58:28 | confirmed || 7 | 2021-06-14 13:59:27 | confirmed || 2 | 2021-01-22 00:00:00 | confirmed || 2 | 2021-02-28 23:59:59 | timeout |+---------+---------------------+-----------+Output: +---------+-------------------+| user_id | confirmation_rate |+---------+-------------------+| 6 | 0.00 || 3 | 0.00 || 7 | 1.00 || 2 | 0.50 |+---------+-------------------+Explanation: User 6 did not request any confirmation messages. The confirmation rate is 0.User 3 made 2 requests and both timed out. The confirmation rate is 0.User 7 made 3 requests and all were confirmed. The confirmation rate is 1.User 2 made 2 requests where one was confirmed and the other timed out. The confirmation rate is 1 / 2 = 0.5.풀이" }, { "title": "LeetCode - 1280. Students and Examinations", "url": "/posts/ps-leetcode-1280/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, SQL", "date": "2023-06-01 08:42:00 +0900", "snippet": " 1280. Students and Examinations - Easy문제Table: Students+---------------+---------+| Column Name | Type |+---------------+---------+| student_id | int || student_name | varchar |+---------------+---------+student_id is the primary key for this table.Each row of this table contains the ID and the name of one student in the school. Table: Subjects+--------------+---------+| Column Name | Type |+--------------+---------+| subject_name | varchar |+--------------+---------+subject_name is the primary key for this table.Each row of this table contains the name of one subject in the school. Table: Examinations+--------------+---------+| Column Name | Type |+--------------+---------+| student_id | int || subject_name | varchar |+--------------+---------+There is no primary key for this table. It may contain duplicates.Each student from the Students table takes every course from the Subjects table.Each row of this table indicates that a student with ID student_id attended the exam of subject_name.Write an SQL query to find the number of times each student attended each exam.Return the result table ordered by student_id and subject_name.The query result format is in the following example.입출력 예Input: Students table:+------------+--------------+| student_id | student_name |+------------+--------------+| 1 | Alice || 2 | Bob || 13 | John || 6 | Alex |+------------+--------------+Subjects table:+--------------+| subject_name |+--------------+| Math || Physics || Programming |+--------------+Examinations table:+------------+--------------+| student_id | subject_name |+------------+--------------+| 1 | Math || 1 | Physics || 1 | Programming || 2 | Programming || 1 | Physics || 1 | Math || 13 | Math || 13 | Programming || 13 | Physics || 2 | Math || 1 | Math |+------------+--------------+Output: +------------+--------------+--------------+----------------+| student_id | student_name | subject_name | attended_exams |+------------+--------------+--------------+----------------+| 1 | Alice | Math | 3 || 1 | Alice | Physics | 2 || 1 | Alice | Programming | 1 || 2 | Bob | Math | 1 || 2 | Bob | Physics | 0 || 2 | Bob | Programming | 1 || 6 | Alex | Math | 0 || 6 | Alex | Physics | 0 || 6 | Alex | Programming | 0 || 13 | John | Math | 1 || 13 | John | Physics | 1 || 13 | John | Programming | 1 |+------------+--------------+--------------+----------------+Explanation: The result table should contain all students and all subjects.Alice attended the Math exam 3 times, the Physics exam 2 times, and the Programming exam 1 time.Bob attended the Math exam 1 time, the Programming exam 1 time, and did not attend the Physics exam.Alex did not attend any exams.John attended the Math exam 1 time, the Physics exam 1 time, and the Programming exam 1 time.풀이SELECT s.student_id, s.student_name, ss.subject_name, COUNT(e.subject_name) AS attended_examsFROM Students AS s JOIN Subjects AS ss LEFT JOIN Examinations AS e ON (s.student_id = e.student_id) AND (ss.subject_name = e.subject_name)GROUP BY ss.subject_name, s.student_idORDER BY s.student_id ASC, ss.subject_name ASC;" }, { "title": "LeetCode - 570. Managers with at Least 5 Direct Reports", "url": "/posts/ps-leetcode-570/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, SQL", "date": "2023-06-01 08:28:00 +0900", "snippet": " 570. Managers with at Least 5 Direct Reports - Medium문제Table: Employee+-------------+---------+| Column Name | Type |+-------------+---------+| id | int || name | varchar || department | varchar || managerId | int |+-------------+---------+id is the primary key column for this table.Each row of this table indicates the name of an employee, their department, and the id of their manager.If managerId is null, then the employee does not have a manager.No employee will be the manager of themself.Write an SQL query to report the managers with at least five direct reports.Return the result table in any order.The query result format is in the following example.입출력 예Input: Employee table:+-----+-------+------------+-----------+| id | name | department | managerId |+-----+-------+------------+-----------+| 101 | John | A | None || 102 | Dan | A | 101 || 103 | James | A | 101 || 104 | Amy | A | 101 || 105 | Anne | A | 101 || 106 | Ron | B | 101 |+-----+-------+------------+-----------+Output: +------+| name |+------+| John |+------+풀이SELECT e1.nameFROM Employee AS e1 JOIN Employee AS e2 ON (e1.id = e2.managerId)GROUP BY e1.idHAVING COUNT(e1.id) &amp;gt;= 5;" }, { "title": "LeetCode - 577. Employee Bonus", "url": "/posts/ps-leetcode-577/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, SQL", "date": "2023-06-01 06:09:00 +0900", "snippet": " 577. Employee Bonus - Easy문제Table: Employee+-------------+---------+| Column Name | Type |+-------------+---------+| empId | int || name | varchar || supervisor | int || salary | int |+-------------+---------+empId is the primary key column for this table.Each row of this table indicates the name and the ID of an employee in addition to their salary and the id of their manager. Table: Bonus+-------------+------+| Column Name | Type |+-------------+------+| empId | int || bonus | int |+-------------+------+empId is the primary key column for this table.empId is a foreign key to empId from the Employee table.Each row of this table contains the id of an employee and their respective bonus.Write an SQL query to report the name and bonus amount of each employee with a bonus less than 1000.Return the result table in any order.The query result format is in the following example.입출력 예Input: Employee table:+-------+--------+------------+--------+| empId | name | supervisor | salary |+-------+--------+------------+--------+| 3 | Brad | null | 4000 || 1 | John | 3 | 1000 || 2 | Dan | 3 | 2000 || 4 | Thomas | 3 | 4000 |+-------+--------+------------+--------+Bonus table:+-------+-------+| empId | bonus |+-------+-------+| 2 | 500 || 4 | 2000 |+-------+-------+Output: +------+-------+| name | bonus |+------+-------+| Brad | null || John | null || Dan | 500 |+------+-------+풀이SELECT e.name, b.bonusFROM Employee AS e LEFT JOIN Bonus AS b ON e.empId = b.empIdWHERE (b.bonus &amp;lt; 1000) OR (b.bonus IS NULL)" }, { "title": "LeetCode - 197. Rising Temperature", "url": "/posts/ps-leetcode-197/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, SQL", "date": "2023-05-31 08:05:00 +0900", "snippet": " 197. Rising Temperature - Easy문제Table: Weather+---------------+---------+| Column Name | Type |+---------------+---------+| id | int || recordDate | date || temperature | int |+---------------+---------+id is the primary key for this table.This table contains information about the temperature on a certain day.Write an SQL query to find all dates’ Id with higher temperatures compared to its previous dates (yesterday).Return the result table in any order.The query result format is in the following example.입출력 예Input: Weather table:+----+------------+-------------+| id | recordDate | temperature |+----+------------+-------------+| 1 | 2015-01-01 | 10 || 2 | 2015-01-02 | 25 || 3 | 2015-01-03 | 20 || 4 | 2015-01-04 | 30 |+----+------------+-------------+Output: +----+| id |+----+| 2 || 4 |+----+Explanation: In 2015-01-02, the temperature was higher than the previous day (10 -&amp;gt; 25).In 2015-01-04, the temperature was higher than the previous day (20 -&amp;gt; 30).풀이SELECT next.idFROM Weather AS prev JOIN Weather AS next ON (prev.recordDate = SUBDATE(next.recordDate, 1)) AND (prev.temperature &amp;lt; next.temperature);SELECT *FROM Weather AS prev JOIN Weather AS next ON DATEDIFF(next.recordDate, prev.recordDate) = 1WHERE prev.temperature &amp;lt; next.temperature;" }, { "title": "LeetCode - 1661. Average Time of Process per Machine", "url": "/posts/ps-leetcode-1661/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, SQL", "date": "2023-05-31 08:05:00 +0900", "snippet": " 1661. Average Time of Process per Machine - Easy문제Table: Activity+----------------+---------+| Column Name | Type |+----------------+---------+| machine_id | int || process_id | int || activity_type | enum || timestamp | float |+----------------+---------+The table shows the user activities for a factory website.(machine_id, process_id, activity_type) is the primary key of this table.machine_id is the ID of a machine.process_id is the ID of a process running on the machine with ID machine_id.activity_type is an ENUM of type (&#39;start&#39;, &#39;end&#39;).timestamp is a float representing the current time in seconds.&#39;start&#39; means the machine starts the process at the given timestamp and &#39;end&#39; means the machine ends the process at the given timestamp.The &#39;start&#39; timestamp will always be before the &#39;end&#39; timestamp for every (machine_id, process_id) pair.There is a factory website that has several machines each running the same number of processes. Write an SQL query to find the average time each machine takes to complete a process.The time to complete a process is the ‘end’ timestamp minus the ‘start’ timestamp. The average time is calculated by the total time to complete every process on the machine divided by the number of processes that were run.The resulting table should have the machine_id along with the average time as processing_time, which should be rounded to 3 decimal places.Return the result table in any order.The query result format is in the following example.입출력 예Input: Activity table:+------------+------------+---------------+-----------+| machine_id | process_id | activity_type | timestamp |+------------+------------+---------------+-----------+| 0 | 0 | start | 0.712 || 0 | 0 | end | 1.520 || 0 | 1 | start | 3.140 || 0 | 1 | end | 4.120 || 1 | 0 | start | 0.550 || 1 | 0 | end | 1.550 || 1 | 1 | start | 0.430 || 1 | 1 | end | 1.420 || 2 | 0 | start | 4.100 || 2 | 0 | end | 4.512 || 2 | 1 | start | 2.500 || 2 | 1 | end | 5.000 |+------------+------------+---------------+-----------+Output: +------------+-----------------+| machine_id | processing_time |+------------+-----------------+| 0 | 0.894 || 1 | 0.995 || 2 | 1.456 |+------------+-----------------+Explanation: There are 3 machines running 2 processes each.Machine 0&#39;s average time is ((1.520 - 0.712) + (4.120 - 3.140)) / 2 = 0.894Machine 1&#39;s average time is ((1.550 - 0.550) + (1.420 - 0.430)) / 2 = 0.995Machine 2&#39;s average time is ((4.512 - 4.100) + (5.000 - 2.500)) / 2 = 1.456풀이SELECT s.user_id, ROUND(SUM(CASE `action` WHEN &#39;confirmed&#39; THEN 1 ELSE 0 END) / COUNT(s.user_id), 2) AS confirmation_rateFROM Signups AS s LEFT JOIN Confirmations AS c ON s.user_id = c.user_idGROUP BY s.user_id" }, { "title": "LeetCode - 1581. Customer Who Visited but Did Not Make Any Transactions", "url": "/posts/ps-leetcode-1581/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, SQL", "date": "2023-05-31 07:39:00 +0900", "snippet": " 1581. Customer Who Visited but Did Not Make Any Transactions - Easy문제Table: Visits+-------------+---------+| Column Name | Type |+-------------+---------+| visit_id | int || customer_id | int |+-------------+---------+visit_id is the primary key for this table.This table contains information about the customers who visited the mall. Table: Transactions+----------------+---------+| Column Name | Type |+----------------+---------+| transaction_id | int || visit_id | int || amount | int |+----------------+---------+transaction_id is the primary key for this table.This table contains information about the transactions made during the visit_id.Write a SQL query to find the IDs of the users who visited without making any transactions and the number of times they made these types of visits.Return the result table sorted in any order.The query result format is in the following example.입출력 예Input: Visits+----------+-------------+| visit_id | customer_id |+----------+-------------+| 1 | 23 || 2 | 9 || 4 | 30 || 5 | 54 || 6 | 96 || 7 | 54 || 8 | 54 |+----------+-------------+Transactions+----------------+----------+--------+| transaction_id | visit_id | amount |+----------------+----------+--------+| 2 | 5 | 310 || 3 | 5 | 300 || 9 | 5 | 200 || 12 | 1 | 910 || 13 | 2 | 970 |+----------------+----------+--------+Output: +-------------+----------------+| customer_id | count_no_trans |+-------------+----------------+| 54 | 2 || 30 | 1 || 96 | 1 |+-------------+----------------+Explanation: Customer with id = 23 visited the mall once and made one transaction during the visit with id = 12.Customer with id = 9 visited the mall once and made one transaction during the visit with id = 13.Customer with id = 30 visited the mall once and did not make any transactions.Customer with id = 54 visited the mall three times. During 2 visits they did not make any transactions, and during one visit they made 3 transactions.Customer with id = 96 visited the mall once and did not make any transactions.As we can see, users with IDs 30 and 96 visited the mall one time without making any transactions. Also, user 54 visited the mall twice and did not make any transactions.풀이SELECT Visits.customer_id, COUNT(Visits.customer_id) AS count_no_transFROM Visits LEFT JOIN Transactions ON Visits.visit_id = Transactions.visit_idWHERE Transactions.visit_id IS NULLGROUP BY Visits.customer_id;" }, { "title": "LeetCode - 1068. Product Sales Analysis I", "url": "/posts/ps-leetcode-1068/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, SQL", "date": "2023-05-31 07:23:00 +0900", "snippet": " 1068. Product Sales Analysis I - Easy문제Table: Sales+-------------+-------+| Column Name | Type |+-------------+-------+| sale_id | int || product_id | int || year | int || quantity | int || price | int |+-------------+-------+(sale_id, year) is the primary key of this table.product_id is a foreign key to Product table.Each row of this table shows a sale on the product product_id in a certain year.Note that the price is per unit.Table: Product+--------------+---------+| Column Name | Type |+--------------+---------+| product_id | int || product_name | varchar |+--------------+---------+product_id is the primary key of this table.Each row of this table indicates the product name of each product.Write an SQL query that reports the product_name, year, and price for each sale_id in the Sales table.Return the resulting table in any order.The query result format is in the following example.입출력 예Input: Sales table:+---------+------------+------+----------+-------+| sale_id | product_id | year | quantity | price |+---------+------------+------+----------+-------+ | 1 | 100 | 2008 | 10 | 5000 || 2 | 100 | 2009 | 12 | 5000 || 7 | 200 | 2011 | 15 | 9000 |+---------+------------+------+----------+-------+Product table:+------------+--------------+| product_id | product_name |+------------+--------------+| 100 | Nokia || 200 | Apple || 300 | Samsung |+------------+--------------+Output: +--------------+-------+-------+| product_name | year | price |+--------------+-------+-------+| Nokia | 2008 | 5000 || Nokia | 2009 | 5000 || Apple | 2011 | 9000 |+--------------+-------+-------+Explanation: From sale_id = 1, we can conclude that Nokia was sold for 5000 in the year 2008.From sale_id = 2, we can conclude that Nokia was sold for 5000 in the year 2009.From sale_id = 7, we can conclude that Apple was sold for 9000 in the year 2011.풀이SELECT Product.product_name, Sales.year, Sales.priceFROM ProductINNER JOIN Sales ON Product.product_id = Sales.product_id;" }, { "title": "LeetCode - 1378. Replace Employee ID With The Unique Identifier", "url": "/posts/ps-leetcode-1378/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, SQL", "date": "2023-05-31 07:06:00 +0900", "snippet": " 1378. Replace Employee ID With The Unique Identifier - Easy문제Table: Employees+---------------+---------+| Column Name | Type |+---------------+---------+| id | int || name | varchar |+---------------+---------+id is the primary key for this table.Each row of this table contains the id and the name of an employee in a company. Table: EmployeeUNI+---------------+---------+| Column Name | Type |+---------------+---------+| id | int || unique_id | int |+---------------+---------+(id, unique_id) is the primary key for this table.Each row of this table contains the id and the corresponding unique id of an employee in the company.Write an SQL query to show the unique ID of each user, If a user does not have a unique ID replace just show null.Return the result table in any order.The query result format is in the following example.입출력 예Input: Employees table:+----+----------+| id | name |+----+----------+| 1 | Alice || 7 | Bob || 11 | Meir || 90 | Winston || 3 | Jonathan |+----+----------+EmployeeUNI table:+----+-----------+| id | unique_id |+----+-----------+| 3 | 1 || 11 | 2 || 90 | 3 |+----+-----------+Output: +-----------+----------+| unique_id | name |+-----------+----------+| null | Alice || null | Bob || 2 | Meir || 3 | Winston || 1 | Jonathan |+-----------+----------+Explanation: Alice and Bob do not have a unique ID, We will show null instead.The unique ID of Meir is 2.The unique ID of Winston is 3.The unique ID of Jonathan is 1.풀이SELECT EmployeeUNI.unique_id, Employees.nameFROM EmployeesLEFT JOIN EmployeeUNI ON Employees.id = EmployeeUNI.id;" }, { "title": "LeetCode - 1683. Invalid Tweets", "url": "/posts/ps-leetcode-1683/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, SQL", "date": "2023-05-31 06:35:00 +0900", "snippet": " 1683. Invalid Tweets - Easy문제Table: Tweets+----------------+---------+| Column Name | Type |+----------------+---------+| tweet_id | int || content | varchar |+----------------+---------+tweet_id is the primary key for this table.This table contains all the tweets in a social media app.Write an SQL query to find the IDs of the invalid tweets. The tweet is invalid if the number of characters used in the content of the tweet is strictly greater than 15.Return the result table in any order.The query result format is in the following example.입출력 예Input: Tweets table:+----------+----------------------------------+| tweet_id | content |+----------+----------------------------------+| 1 | Vote for Biden || 2 | Let us make America great again! |+----------+----------------------------------+Output: +----------+| tweet_id |+----------+| 2 |+----------+Explanation: Tweet 1 has length = 14. It is a valid tweet.Tweet 2 has length = 32. It is an invalid tweet.풀이SELECT t.tweet_id FROM Tweets as tWHERE LENGTH(t.content) &amp;gt; 15;" }, { "title": "LeetCode - 1148. Article Views I", "url": "/posts/ps-leetcode-1148/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, SQL", "date": "2023-05-31 06:30:00 +0900", "snippet": " 1148. Article Views I - Easy문제Table: Views+---------------+---------+| Column Name | Type |+---------------+---------+| article_id | int || author_id | int || viewer_id | int || view_date | date |+---------------+---------+There is no primary key for this table, it may have duplicate rows.Each row of this table indicates that some viewer viewed an article (written by some author) on some date. Note that equal author_id and viewer_id indicate the same person.Write an SQL query to find all the authors that viewed at least one of their own articles.Return the result table sorted by id in ascending order.The query result format is in the following example.입출력 예Input: Views table:+------------+-----------+-----------+------------+| article_id | author_id | viewer_id | view_date |+------------+-----------+-----------+------------+| 1 | 3 | 5 | 2019-08-01 || 1 | 3 | 6 | 2019-08-02 || 2 | 7 | 7 | 2019-08-01 || 2 | 7 | 6 | 2019-08-02 || 4 | 7 | 1 | 2019-07-22 || 3 | 4 | 4 | 2019-07-21 || 3 | 4 | 4 | 2019-07-21 |+------------+-----------+-----------+------------+Output: +------+| id |+------+| 4 || 7 |+------+풀이SELECT DISTINCT v.author_id as idFROM Views as vWHERE v.author_id = v.viewer_idORDER BY v.author_id ASC;" }, { "title": "LeetCode - 595. Big Countries", "url": "/posts/ps-leetcode-595/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, SQL", "date": "2023-05-31 06:18:00 +0900", "snippet": " 595. Big Countries - Easy문제Table: World+-------------+---------+| Column Name | Type |+-------------+---------+| name | varchar || continent | varchar || area | int || population | int || gdp | bigint |+-------------+---------+name is the primary key column for this table.Each row of this table gives information about the name of a country, the continent to which it belongs, its area, the population, and its GDP value.A country is big if: it has an area of at least three million (i.e., 3000000 km2), or it has a population of at least twenty-five million (i.e., 25000000).Write an SQL query to report the name, population, and area of the big countries.Return the result table in any order.The query result format is in the following example.입출력 예Example 1:Input: World table:+-------------+-----------+---------+------------+--------------+| name | continent | area | population | gdp |+-------------+-----------+---------+------------+--------------+| Afghanistan | Asia | 652230 | 25500100 | 20343000000 || Albania | Europe | 28748 | 2831741 | 12960000000 || Algeria | Africa | 2381741 | 37100000 | 188681000000 || Andorra | Europe | 468 | 78115 | 3712000000 || Angola | Africa | 1246700 | 20609294 | 100990000000 |+-------------+-----------+---------+------------+--------------+Output: +-------------+------------+---------+| name | population | area |+-------------+------------+---------+| Afghanistan | 25500100 | 652230 || Algeria | 37100000 | 2381741 |+-------------+------------+---------+풀이SELECT w.name, w.population, w.areaFROM World as wWHERE (w.area &amp;gt;= 3000000) OR (w.population &amp;gt;= 25000000);" }, { "title": "LeetCode - 584. Find Customer Referee", "url": "/posts/ps-leetcode-584/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, SQL", "date": "2023-05-31 06:11:00 +0900", "snippet": " 584. Find Customer Referee - Easy문제Table: Customer+-------------+---------+| Column Name | Type |+-------------+---------+| id | int || name | varchar || referee_id | int |+-------------+---------+id is the primary key column for this table.Each row of this table indicates the id of a customer, their name, and the id of the customer who referred them.Write an SQL query to report the names of the customer that are not referred by the customer with id = 2.Return the result table in any order.The query result format is in the following example.입출력 예Example 1:Input: Customer table:+----+------+------------+| id | name | referee_id |+----+------+------------+| 1 | Will | null || 2 | Jane | null || 3 | Alex | 2 || 4 | Bill | null || 5 | Zack | 1 || 6 | Mark | 2 |+----+------+------------+Output: +------+| name |+------+| Will || Jane || Bill || Zack |+------+풀이SELECT nameFROM Customer as cWHERE (c.referee_id IS NULL) OR (c.referee_id != 2)" }, { "title": "LeetCode - 1757. Recyclable and Low Fat Products", "url": "/posts/ps-leetcode-1757/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, SQL", "date": "2023-05-31 06:00:00 +0900", "snippet": " 1757. Recyclable and Low Fat Products - Easy문제Table: Products+-------------+---------+| Column Name | Type |+-------------+---------+| product_id | int || low_fats | enum || recyclable | enum |+-------------+---------+product_id is the primary key for this table.low_fats is an ENUM of type (&#39;Y&#39;, &#39;N&#39;) where &#39;Y&#39; means this product is low fat and &#39;N&#39; means it is not.recyclable is an ENUM of types (&#39;Y&#39;, &#39;N&#39;) where &#39;Y&#39; means this product is recyclable and &#39;N&#39; means it is not.Write an SQL query to find the ids of products that are both low fat and recyclable.Return the result table in any order.The query result format is in the following example.입출력 예Example 1:Input: Products table:+-------------+----------+------------+| product_id | low_fats | recyclable |+-------------+----------+------------+| 0 | Y | N || 1 | Y | Y || 2 | N | Y || 3 | Y | Y || 4 | N | N |+-------------+----------+------------+Output: +-------------+| product_id |+-------------+| 1 || 3 |+-------------+Explanation: Only products 1 and 3 are both low fat and recyclable.풀이SELECT product_idFROM Products as pWHERE (p.low_fats = &#39;Y&#39;) AND (p.recyclable = &#39;Y&#39;)" }, { "title": "simpleDB - 시작해보자!", "url": "/posts/project-simpledb/", "categories": "Project, simpleDB", "tags": "project, storage", "date": "2023-03-14 08:20:00 +0900", "snippet": "개인적으로 만들고 있는 link 프로젝트 진행 중 persistence storage 를 지원하고 싶었다.처음엔 처음부터 만들기 힘들어 보여 google 의 leveldb 를 가져와 wrapping 하는 식으로 key value storage를 지원하게끔 구성하였다." }, { "title": "Programmers - 게임 맵 최단거리", "url": "/posts/ps-programmers-045/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, BFS", "date": "2022-09-22 08:23:00 +0900", "snippet": " 게임 맵 최단거리 - lv.2문제ROR 게임은 두 팀으로 나누어서 진행하며, 상대 팀 진영을 먼저 파괴하면 이기는 게임입니다. 따라서, 각 팀은 상대 팀 진영에 최대한 빨리 도착하는 것이 유리합니다.지금부터 당신은 한 팀의 팀원이 되어 게임을 진행하려고 합니다. 다음은 5 x 5 크기의 맵에, 당신의 캐릭터가 (행: 1, 열: 1) 위치에 있고, 상대 팀 진영은 (행: 5, 열: 5) 위치에 있는 경우의 예시입니다.위 그림에서 검은색 부분은 벽으로 막혀있어 갈 수 없는 길이며, 흰색 부분은 갈 수 있는 길입니다. 캐릭터가 움직일 때는 동, 서, 남, 북 방향으로 한 칸씩 이동하며, 게임 맵을 벗어난 길은 갈 수 없습니다.아래 예시는 캐릭터가 상대 팀 진영으로 가는 두 가지 방법을 나타내고 있습니다.첫 번째 방법은 11개의 칸을 지나서 상대 팀 진영에 도착했습니다.두 번째 방법은 15개의 칸을 지나서 상대팀 진영에 도착했습니다.위 예시에서는 첫 번째 방법보다 더 빠르게 상대팀 진영에 도착하는 방법은 없으므로, 이 방법이 상대 팀 진영으로 가는 가장 빠른 방법입니다.만약, 상대 팀이 자신의 팀 진영 주위에 벽을 세워두었다면 상대 팀 진영에 도착하지 못할 수도 있습니다. 예를 들어, 다음과 같은 경우에 당신의 캐릭터는 상대 팀 진영에 도착할 수 없습니다.게임 맵의 상태 maps가 매개변수로 주어질 때, 캐릭터가 상대 팀 진영에 도착하기 위해서 지나가야 하는 칸의 개수의 최솟값을 return 하도록 solution 함수를 완성해주세요. 단, 상대 팀 진영에 도착할 수 없을 때는 -1을 return 해주세요.제한사항 maps는 n x m 크기의 게임 맵의 상태가 들어있는 2차원 배열로, n과 m은 각각 1 이상 100 이하의 자연수입니다. n과 m은 서로 같을 수도, 다를 수도 있지만, n과 m이 모두 1인 경우는 입력으로 주어지지 않습니다. maps는 0과 1로만 이루어져 있으며, 0은 벽이 있는 자리, 1은 벽이 없는 자리를 나타냅니다. 처음에 캐릭터는 게임 맵의 좌측 상단인 (1, 1) 위치에 있으며, 상대방 진영은 게임 맵의 우측 하단인 (n, m) 위치에 있습니다.입출력 예 maps answer ([1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,1],[0,0,0,0,1]) 11 ([1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,0],[0,0,0,0,1]) -1 입출력 예 #1주어진 데이터는 다음과 같습니다.캐릭터가 적 팀의 진영까지 이동하는 가장 빠른 길은 다음 그림과 같습니다.따라서 총 11칸을 캐릭터가 지나갔으므로 11을 return 하면 됩니다.입출력 예 #3문제의 예시와 같으며, 상대 팀 진영에 도달할 방법이 없습니다. 따라서 -1을 return 합니다.풀이 BFSvector&amp;lt;int&amp;gt; y_offset = {0, 1, 0, -1};vector&amp;lt;int&amp;gt; x_offset = {1, 0, -1, 0};struct Position { int x = 0; int y = 0; int count = 0;};int solution(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; maps){ int n = maps.size(); int m = maps[0].size(); int count = 0; vector&amp;lt;int&amp;gt; answers; queue&amp;lt;Position&amp;gt; q; q.push({0, 0, 1}); while (!q.empty()) { auto position = q.front(); q.pop(); if (position.y == n - 1 &amp;amp;&amp;amp; position.x == m - 1) { answers.emplace_back(position.count); continue; } for (int i = 0 ; i &amp;lt; 4 ; ++i) { int y = position.y + y_offset[i]; int x = position.x + x_offset[i]; if ((0 &amp;lt;= y &amp;amp;&amp;amp; y &amp;lt; n) &amp;amp;&amp;amp; (0 &amp;lt;= x &amp;amp;&amp;amp; x &amp;lt; m) &amp;amp;&amp;amp; maps[y][x]) { q.push({x, y, position.count + 1}); maps[y][x] = 0; } } } return answers.size() &amp;gt; 0 ? *min_element(answers.begin(), answers.end()) : -1;}" }, { "title": "Programmers - 로또의 최고 순위와 최저 순위", "url": "/posts/ps-programmers-044/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Hash", "date": "2022-01-05 08:23:00 +0900", "snippet": " 로또의 최고 순위와 최저 순위 - lv.1문제로또 6/45(이하 ‘로또’로 표기)는 1부터 45까지의 숫자 중 6개를 찍어서 맞히는 대표적인 복권입니다. 아래는 로또의 순위를 정하는 방식입니다. 1 순위 당첨 내용 1 6개 번호가 모두 일치 2 5개 번호가 일치 3 4개 번호가 일치 4 3개 번호가 일치 5 2개 번호가 일치 6(낙첨) 그 외 로또를 구매한 민우는 당첨 번호 발표일을 학수고대하고 있었습니다. 하지만, 민우의 동생이 로또에 낙서를 하여, 일부 번호를 알아볼 수 없게 되었습니다. 당첨 번호 발표 후, 민우는 자신이 구매했던 로또로 당첨이 가능했던 최고 순위와 최저 순위를 알아보고 싶어 졌습니다.알아볼 수 없는 번호를 0으로 표기하기로 하고, 민우가 구매한 로또 번호 6개가 44, 1, 0, 0, 31 25라고 가정해보겠습니다. 당첨 번호 6개가 31, 10, 45, 1, 6, 19라면, 당첨 가능한 최고 순위와 최저 순위의 한 예는 아래와 같습니다. 당첨 번호 31 10 45 1 6 19 결과 최고 순위 번호 31 0→10 44 1 0→6 25 4개 번호 일치, 3등 최저 순위 번호 31 0→11 44 1 0→7 25 2개 번호 일치, 5등 순서와 상관없이, 구매한 로또에 당첨 번호와 일치하는 번호가 있으면 맞힌 걸로 인정됩니다. 알아볼 수 없는 두 개의 번호를 각각 10, 6이라고 가정하면 3등에 당첨될 수 있습니다. 3등을 만드는 다른 방법들도 존재합니다. 하지만, 2등 이상으로 만드는 것은 불가능합니다. 알아볼 수 없는 두 개의 번호를 각각 11, 7이라고 가정하면 5등에 당첨될 수 있습니다. 5등을 만드는 다른 방법들도 존재합니다. 하지만, 6등(낙첨)으로 만드는 것은 불가능합니다. 민우가 구매한 로또 번호를 담은 배열 lottos, 당첨 번호를 담은 배열 win_nums가 매개변수로 주어집니다. 이때, 당첨 가능한 최고 순위와 최저 순위를 차례대로 배열에 담아서 return 하도록 solution 함수를 완성해주세요제한사항 lottos는 길이 6인 정수 배열입니다. lottos의 모든 원소는 0 이상 45 이하인 정수입니다. 0은 알아볼 수 없는 숫자를 의미합니다. 0을 제외한 다른 숫자들은 lottos에 2개 이상 담겨있지 않습니다. lottos의 원소들은 정렬되어 있지 않을 수도 있습니다. win_nums은 길이 6인 정수 배열입니다. win_nums의 모든 원소는 1 이상 45 이하인 정수입니다. win_nums에는 같은 숫자가 2개 이상 담겨있지 않습니다. win_nums의 원소들은 정렬되어 있지 않을 수도 있습니다. 입출력 예 lottos win_nums result [44, 1, 0, 0, 31, 25] [31, 10, 45, 1, 6, 19] [3, 5] [0, 0, 0, 0, 0, 0] [38, 19, 20, 40, 15, 25] [1, 6] [45, 4, 35, 20, 3, 9] [20, 9, 3, 45, 4, 35] [1, 1] 입출력 예 #1문제 예시와 같습니다.입출력 예 #2| 당첨 번호 | 38 | 19 | 20 | 40 | 15 | 25 | 결과 || ———– | ———– | ———– | ———– | ———– | ———– | ———– | ———– || 최고 순위 번호 | 0→38 | 0→19 | 0→20 | 0→40 | 0→15 | 0→25 | 6개 번호 일치, 1등 || 최저 순위 번호 | 0→21 | 0→22 | 0→23 | 0→24 | 0→26 | 0→27 | 0개 번호 일치, 6등 |입출력 예 #3민우가 구매한 로또의 번호와 당첨 번호가 모두 일치하므로, 최고 순위와 최저 순위는 모두 1등입니다.풀이 Hashfunc solution(lottos []int, win_nums []int) []int { lottosMap := make(map[int]bool) erasedCount := 0 for _, v := range(lottos) { lottosMap[v] = true if v == 0 { erasedCount++ } } matchCount := 0 for _, v := range(win_nums) { _, exists := lottosMap[v] if exists { matchCount++ } } max := 7 - (matchCount + erasedCount) min := 7 - matchCount if max &amp;gt;= 6 { max = 6 } if min &amp;gt;= 6 { min = 6 } return []int{max, min}}" }, { "title": "LeetCode - 922. Sort Array By Parity II", "url": "/posts/ps-leetcode-922/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Two Pointer", "date": "2021-09-29 06:29:00 +0900", "snippet": " 922. Sort Array By Parity II - Easy문제Given an array of integers nums, half of the integers in nums are odd, and the other half are even.Sort the array so that whenever nums[i] is odd, i is odd, and whenever nums[i] is even, i is even.Return any answer array that satisfies this condition.제한사항 2 &amp;lt;= nums.length &amp;lt;= 2 * 104 nums.length is even. Half of the integers in nums are even. 0 &amp;lt;= nums[i] &amp;lt;= 1000입출력 예Example 1:Input: nums = [4,2,5,7]Output: [4,5,2,7]Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.Example 2:Input: nums = [2,3]Output: [2,3]풀이 Two Pointerclass Solution {public: vector&amp;lt;int&amp;gt; sortArrayByParityII(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int i = 0; int j = 1; while (i &amp;lt; nums.size() &amp;amp;&amp;amp; j &amp;lt; nums.size()) { if ((nums[i] &amp;amp; 1) == 0) { i += 2; } else if ((nums[j] &amp;amp; 1) == 1) { j += 2; } else { std::swap(nums[i], nums[j]); } } return nums; }};" }, { "title": "LeetCode - 763. Partition Labels", "url": "/posts/ps-leetcode-763/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Greedy", "date": "2021-09-28 07:38:00 +0900", "snippet": " 763. Partition Labels - Medium문제You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.Return a list of integers representing the size of these parts.제한사항` 1 &amp;lt;= s.length &amp;lt;= 500 s consists of lowercase English letters.입출력 예Example 1:Input: s = &quot;ababcbacadefegdehijhklij&quot;Output: [9,7,8]Explanation:The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.This is a partition so that each letter appears in at most one part.A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits s into less parts.Example 2:Input: s = &quot;eccbbbbdec&quot;Output: [10]풀이 Sortclass Solution {public: vector&amp;lt;int&amp;gt; partitionLabels(string s) { std::vector&amp;lt;int&amp;gt; res; std::map&amp;lt;char, int&amp;gt; items; for (auto i = 0 ; i &amp;lt; s.size() ; ++i) { items[s[i]] = i; } // hash에 저장되어있는 범위의 최대 인덱스와 // 현재 index가 같을때 // 하나의 sub string이 됨 int index = 0; int offset = 0; for (auto i = 0 ; i &amp;lt; s.size() ; ++i) { index = std::max(items[s[i]], index); if (i == index) { res.push_back(i - offset + 1); offset = i + 1; } } return res; }};" }, { "title": "LeetCode - 1630. Arithmetic Subarrays", "url": "/posts/ps-leetcode-1630/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Sort", "date": "2021-09-28 06:29:00 +0900", "snippet": " 1630. Arithmetic Subarrays - Medium문제A sequence of numbers is called arithmetic if it consists of at least two elements, and the difference between every two consecutive elements is the same. More formally, a sequence s is arithmetic if and only if s[i+1] - s[i] == s[1] - s[0] for all valid i.For example, these are arithmetic sequences:1, 3, 5, 7, 97, 7, 7, 73, -1, -5, -9The following sequence is not arithmetic:1, 1, 2, 5, 7You are given an array of n integers, nums, and two arrays of m integers each, l and r, representing the m range queries, where the ith query is the range [l[i], r[i]]. All the arrays are 0-indexed.Return a list of boolean elements answer, where answer[i] is true if the subarray nums[l[i]], nums[l[i]+1], … , nums[r[i]] can be rearranged to form an arithmetic sequence, and false otherwise.제한사항` n == nums.length m == l.length m == r.length 2 &amp;lt;= n &amp;lt;= 500 1 &amp;lt;= m &amp;lt;= 500 0 &amp;lt;= l[i] &amp;lt; r[i] &amp;lt; n -105 &amp;lt;= nums[i] &amp;lt;= 105입출력 예Example 1:Input: nums = [4,6,5,9,3,7], l = [0,0,2], r = [2,3,5]Output: [true,false,true]Explanation:In the 0th query, the subarray is [4,6,5]. This can be rearranged as [6,5,4], which is an arithmetic sequence.In the 1st query, the subarray is [4,6,5,9]. This cannot be rearranged as an arithmetic sequence.In the 2nd query, the subarray is [5,9,3,7]. This can be rearranged as [3,5,7,9], which is an arithmetic sequence.Example 2:Input: nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], l = [0,1,6,4,8,7], r = [4,4,9,7,9,10]Output: [false,true,false,false,true,true]풀이 Sortclass Solution {public: vector&amp;lt;bool&amp;gt; checkArithmeticSubarrays(vector&amp;lt;int&amp;gt;&amp;amp; nums, vector&amp;lt;int&amp;gt;&amp;amp; l, vector&amp;lt;int&amp;gt;&amp;amp; r) { std::vector&amp;lt;bool&amp;gt; res; for (auto i = 0 ; i &amp;lt; l.size() ; ++i) { std::vector&amp;lt;int&amp;gt; sub(nums.begin()+l[i], nums.begin()+r[i]+1); std::sort(sub.begin(), sub.end()); bool flag = true; int val = sub[1] - sub[0]; for (auto j = 1 ; j &amp;lt; sub.size() - 1 ; ++j) { int temp = sub[j+1] - sub[j]; if (val != temp) { flag = false; break; } } res.push_back(flag); } return res; }};" }, { "title": "LeetCode - 167. Two Sum II - Input array is sorted", "url": "/posts/ps-leetcode-167/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Two Pointer", "date": "2021-09-15 06:05:00 +0900", "snippet": " 167. Two Sum II - Input array is sorted - Easy문제Given an array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number.Return the indices of the two numbers (1-indexed) as an integer array answer of size 2, where 1 &amp;lt;= answer[0] &amp;lt; answer[1] &amp;lt;= numbers.length.The tests are generated such that there is exactly one solution. You may not use the same element twice.제한사항` 2 &amp;lt;= numbers.length &amp;lt;= 3 * 104 -1000 &amp;lt;= numbers[i] &amp;lt;= 1000 numbers is sorted in non-decreasing order. -1000 &amp;lt;= target &amp;lt;= 1000 The tests are generated such that there is exactly one solution.입출력 예Example 1:Input: numbers = [2,7,11,15], target = 9Output: [1,2]Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.Example 2:Input: numbers = [2,3,4], target = 6Output: [1,3]Example 3:Input: numbers = [-1,0], target = -1Output: [1,2]풀이 Two Pointerclass Solution {public: vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; numbers, int target) { vector&amp;lt;int&amp;gt; result; int left = 0, right = numbers.size() - 1; while (left &amp;lt; right) { int sum = numbers[left] + numbers[right]; if (sum &amp;gt; target) { --right; } else if (sum &amp;lt; target) { ++left; } else { result.push_back(left + 1); result.push_back(right + 1); break; } } return result; }};" }, { "title": "LeetCode - 848. Shifting Letters", "url": "/posts/ps-leetcode-848/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, String, September LeetCoding Challenge 2021", "date": "2021-09-09 07:25:00 +0900", "snippet": " 848. Shifting Letters - Medium문제You are given a string s of lowercase English letters and an integer array shifts of the same length.Call the shift() of a letter, the next letter in the alphabet, (wrapping around so that ‘z’ becomes ‘a’). For example, shift(‘a’) = ‘b’, shift(‘t’) = ‘u’, and shift(‘z’) = ‘a’.Now for each shifts[i] = x, we want to shift the first i + 1 letters of s, x times.Return the final string after all such shifts to s are applied.제한사항` 1 &amp;lt;= s.length &amp;lt;= 105 s consists of lowercase English letters. shifts.length == s.length 0 &amp;lt;= shifts[i] &amp;lt;= 109입출력 예Example 1:Input: s = &quot;abc&quot;, shifts = [3,5,9]Output: &quot;rpl&quot;Explanation: We start with &quot;abc&quot;.After shifting the first 1 letters of s by 3, we have &quot;dbc&quot;.After shifting the first 2 letters of s by 5, we have &quot;igc&quot;.After shifting the first 3 letters of s by 9, we have &quot;rpl&quot;, the answer.Example 2:Input: s = &quot;aaa&quot;, shifts = [1,2,3]Output: &quot;gfd&quot;풀이 Stringclass Solution {public: string shiftingLetters(string s, vector&amp;lt;int&amp;gt;&amp;amp; shifts) { // modular 연산을 통해 // 각 인덱스별 최종적으로 shift 해야하는 값 계산 int sum = 0; for (auto iter = shifts.rbegin() ; iter != shifts.rend() ; ++iter) { sum = (sum + (*iter % 26)) % 26; *iter = sum; } for (auto i = 0 ; i &amp;lt; s.size() ; ++i) { auto c = s[i] + shifts[i]; if (c &amp;gt; &#39;z&#39;) { auto mod = c % &#39;z&#39;; c = &#39;a&#39; + mod - 1; } s[i] = c; } return s; }};" }, { "title": "LeetCode - 1496. Path Crossing", "url": "/posts/ps-leetcode-1496/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Hash", "date": "2021-09-08 09:04:00 +0900", "snippet": " 1496. Path Crossing - Easy문제Given a string path, where path[i] = ‘N’, ‘S’, ‘E’ or ‘W’, each representing moving one unit north, south, east, or west, respectively. You start at the origin (0, 0) on a 2D plane and walk on the path specified by path.Return true if the path crosses itself at any point, that is, if at any time you are on a location you have previously visited. Return false otherwise.제한사항` 1 &amp;lt;= path.length &amp;lt;= 104 path[i] is either ‘N’, ‘S’, ‘E’, or ‘W’.입출력 예Example 1:Input: path = &quot;NES&quot;Output: false Explanation: Notice that the path doesn&#39;t cross any point more than once.Example 2:Input: path = &quot;NESWW&quot;Output: trueExplanation: Notice that the path visits the origin twice.풀이 Hashclass Solution { struct Point { int x; int y; }; public: bool isPathCrossing(string path) { Point point = {0, 0}; std::map&amp;lt;int, std::map&amp;lt;int, bool&amp;gt;&amp;gt; item; item[0][0] = true; for (const char&amp;amp; c : path) { if (c == &#39;N&#39;) { ++point.y; } else if (c == &#39;S&#39;) { --point.y; } else if (c == &#39;E&#39;) { ++point.x; } else { --point.x; } if (item[point.x][point.y]) { return true; } item[point.x][point.y] = true; } return false; }};" }, { "title": "LeetCode - 1518. Water Bottles", "url": "/posts/ps-leetcode-1518/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Math", "date": "2021-09-08 08:15:00 +0900", "snippet": " 1518. Water Bottles - Easy문제Given numBottles full water bottles, you can exchange numExchange empty water bottles for one full water bottle.The operation of drinking a full water bottle turns it into an empty bottle.Return the maximum number of water bottles you can drink.제한사항` 1 &amp;lt;= numBottles &amp;lt;= 100 2 &amp;lt;= numExchange &amp;lt;= 100입출력 예Example 1:Input: numBottles = 9, numExchange = 3Output: 13Explanation: You can exchange 3 empty bottles to get 1 full water bottle.Number of water bottles you can drink: 9 + 3 + 1 = 13.Example 2:Input: numBottles = 15, numExchange = 4Output: 19Explanation: You can exchange 4 empty bottles to get 1 full water bottle. Number of water bottles you can drink: 15 + 3 + 1 = 19.Example 3:Input: numBottles = 5, numExchange = 5Output: 6Example 4:Input: numBottles = 2, numExchange = 3Output: 2풀이 Mathfunc numWaterBottles(numBottles int, numExchange int) int { sum := numBottles for numBottles / numExchange != 0 { drink := numBottles / numExchange remainBottle := numBottles % numExchange sum += drink numBottles = drink + remainBottle } return sum}" }, { "title": "LeetCode - 1200. Minimum Absolute Difference", "url": "/posts/ps-leetcode-1200/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Sort", "date": "2021-09-08 06:58:00 +0900", "snippet": " 1200. Minimum Absolute Difference - Easy문제Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements.Return a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows a, b are from arr a &amp;lt; b b - a equals to the minimum absolute difference of any two elements in arr제한사항` 2 &amp;lt;= arr.length &amp;lt;= 10^5 -10^6 &amp;lt;= arr[i] &amp;lt;= 10^6입출력 예Example 1:Input: arr = [4,2,1,3]Output: [[1,2],[2,3],[3,4]]Explanation: The minimum absolute difference is 1. List all pairs with difference equal to 1 in ascending order.Example 2:Input: arr = [1,3,6,10,15]Output: [[1,3]]Example 3:Input: arr = [3,8,-10,23,19,-4,-14,27]Output: [[-14,-10],[19,23],[23,27]]풀이 Sortfunc minimumAbsDifference(arr []int) [][]int { result := make([][]int, 0) sort.Ints(arr) minDistinct := int(^uint(0) &amp;gt;&amp;gt; 1) for i := 0 ; i &amp;lt; len(arr) - 1 ; i++ { val := arr[i+1] - arr[i] if (val &amp;lt; minDistinct) { minDistinct = val result = nil } if (val == minDistinct) { result = append(result, []int{arr[i], arr[i+1]}) } } return result}" }, { "title": "LeetCode - 1629. Slowest Key", "url": "/posts/ps-leetcode-1629/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Sort, September LeetCoding Challenge 2021", "date": "2021-09-05 09:48:00 +0900", "snippet": " 1629. Slowest Key - Easy문제A newly designed keypad was tested, where a tester pressed a sequence of n keys, one at a time.You are given a string keysPressed of length n, where keysPressed[i] was the ith key pressed in the testing sequence, and a sorted list releaseTimes, where releaseTimes[i] was the time the ith key was released. Both arrays are 0-indexed. The 0th key was pressed at the time 0, and every subsequent key was pressed at the exact time the previous key was released.The tester wants to know the key of the keypress that had the longest duration. The ith keypress had a duration of releaseTimes[i] - releaseTimes[i - 1], and the 0th keypress had a duration of releaseTimes[0].Note that the same key could have been pressed multiple times during the test, and these multiple presses of the same key may not have had the same duration.Return the key of the keypress that had the longest duration. If there are multiple such keypresses, return the lexicographically largest key of the keypresses.제한사항` releaseTimes.length == n keysPressed.length == n 2 &amp;lt;= n &amp;lt;= 1000 1 &amp;lt;= releaseTimes[i] &amp;lt;= 109 releaseTimes[i] &amp;lt; releaseTimes[i+1] keysPressed contains only lowercase English letters.입출력 예Example 1:Input: releaseTimes = [9,29,49,50], keysPressed = &quot;cbcd&quot;Output: &quot;c&quot;Explanation: The keypresses were as follows:Keypress for &#39;c&#39; had a duration of 9 (pressed at time 0 and released at time 9).Keypress for &#39;b&#39; had a duration of 29 - 9 = 20 (pressed at time 9 right after the release of the previous character and released at time 29).Keypress for &#39;c&#39; had a duration of 49 - 29 = 20 (pressed at time 29 right after the release of the previous character and released at time 49).Keypress for &#39;d&#39; had a duration of 50 - 49 = 1 (pressed at time 49 right after the release of the previous character and released at time 50).The longest of these was the keypress for &#39;b&#39; and the second keypress for &#39;c&#39;, both with duration 20.&#39;c&#39; is lexicographically larger than &#39;b&#39;, so the answer is &#39;c&#39;.Example 2:Input: releaseTimes = [12,23,36,46,62], keysPressed = &quot;spuda&quot;Output: &quot;a&quot;Explanation: The keypresses were as follows:Keypress for &#39;s&#39; had a duration of 12.Keypress for &#39;p&#39; had a duration of 23 - 12 = 11.Keypress for &#39;u&#39; had a duration of 36 - 23 = 13.Keypress for &#39;d&#39; had a duration of 46 - 36 = 10.Keypress for &#39;a&#39; had a duration of 62 - 46 = 16.The longest of these was the keypress for &#39;a&#39; with duration 16.풀이 Sortbool compare(const std::pair&amp;lt;int,char&amp;gt;&amp;amp; a, const std::pair&amp;lt;int,char&amp;gt;&amp;amp; b) { if (a.first == b.first) { return a.second &amp;gt; b.second; } return a.first &amp;gt; b.first;}class Solution {public: char slowestKey(vector&amp;lt;int&amp;gt;&amp;amp; releaseTimes, string keysPressed) { vector&amp;lt;std::pair&amp;lt;int,char&amp;gt;&amp;gt; calculate; calculate.push_back({releaseTimes[0], keysPressed[0]}); for (auto i = 1 ; i &amp;lt; releaseTimes.size() ; ++i) { calculate.push_back({releaseTimes[i] - releaseTimes[i - 1], keysPressed[i]}); } std::sort(calculate.begin(), calculate.end(), compare); return calculate[0].second; }};" }, { "title": "LeetCode - 228. Summary Ranges", "url": "/posts/ps-leetcode-228/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, String", "date": "2021-09-05 09:48:00 +0900", "snippet": " 228. Summary Ranges - Easy문제You are given a sorted unique integer array nums.Return the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.Each range [a,b] in the list should be output as: “a-&amp;gt;b” if a != b “a” if a == b제한사항` 0 &amp;lt;= nums.length &amp;lt;= 20 -231 &amp;lt;= nums[i] &amp;lt;= 231 - 1 All the values of nums are unique. nums is sorted in ascending order.입출력 예Example 1:Input: nums = [0,1,2,4,5,7]Output: [&quot;0-&amp;gt;2&quot;,&quot;4-&amp;gt;5&quot;,&quot;7&quot;]Explanation: The ranges are:[0,2] --&amp;gt; &quot;0-&amp;gt;2&quot;[4,5] --&amp;gt; &quot;4-&amp;gt;5&quot;[7,7] --&amp;gt; &quot;7&quot;Example 2:Input: nums = [0,2,3,4,6,8,9]Output: [&quot;0&quot;,&quot;2-&amp;gt;4&quot;,&quot;6&quot;,&quot;8-&amp;gt;9&quot;]Explanation: The ranges are:[0,0] --&amp;gt; &quot;0&quot;[2,4] --&amp;gt; &quot;2-&amp;gt;4&quot;[6,6] --&amp;gt; &quot;6&quot;[8,9] --&amp;gt; &quot;8-&amp;gt;9&quot;Example 3:Input: nums = []Output: []Example 4:Input: nums = [-1]Output: [&quot;-1&quot;]Example 5:Input: nums = [0]Output: [&quot;0&quot;]풀이 Stringclass Solution {public: std::string RangeStr(const vector&amp;lt;int&amp;gt;&amp;amp; nums, int start, int last) { std::string ans; if (start != last) { ans = std::to_string(nums[start]) + &quot;-&amp;gt;&quot; + std::to_string(nums[last]); } else { ans = std::to_string(nums[start]); } return ans; } vector&amp;lt;string&amp;gt; summaryRanges(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (!nums.size()) { return {}; } std::vector&amp;lt;string&amp;gt; result; int start_index = 0; int last_index = 0; for (auto i = 0 ; i &amp;lt; nums.size() - 1 ; ++i) { if (nums[i] + 1 == nums[i + 1]) { last_index = i + 1; } else { result.push_back(RangeStr(nums, start_index, last_index)); start_index = i + 1; last_index = i + 1; } } if (last_index != nums.size()) { result.push_back(RangeStr(nums, start_index, last_index)); } return result; }};" }, { "title": "LeetCode - 500. Keyboard Row", "url": "/posts/ps-leetcode-500/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, String", "date": "2021-09-03 08:00:00 +0900", "snippet": " 500. Keyboard Row - Easy문제Given an array of strings words, return the words that can be typed using letters of the alphabet on only one row of American keyboard like the image below.In the American keyboard: the first row consists of the characters “qwertyuiop”, the second row consists of the characters “asdfghjkl”, and the third row consists of the characters “zxcvbnm”.제한사항 1 &amp;lt;= words.length &amp;lt;= 20 1 &amp;lt;= words[i].length &amp;lt;= 100 words[i] consists of English letters (both lowercase and uppercase).입출력 예Example 1:Input: words = [&quot;Hello&quot;,&quot;Alaska&quot;,&quot;Dad&quot;,&quot;Peace&quot;]Output: [&quot;Alaska&quot;,&quot;Dad&quot;]Example 2:Input: words = [&quot;omk&quot;]Output: []Example 3:Input: words = [&quot;adsdf&quot;,&quot;sfd&quot;]Output: [&quot;adsdf&quot;,&quot;sfd&quot;]풀이 Stringfunc search(keyboard string, word string) bool { for _, c := range(word) { if (!strings.Contains(keyboard, strings.ToLower(string(c)))) { return false } } return true}func findWords(words []string) []string { const firstWord = &quot;qwertyuiop&quot; const secondWord = &quot;asdfghjkl&quot; const thirdWord = &quot;zxcvbnm&quot; var result []string for _, str := range(words) { if (search(firstWord, str) || search(secondWord, str) || search(thirdWord, str)) { result = append(result, str) } } return result}" }, { "title": "LeetCode - 565. Array Nesting", "url": "/posts/ps-leetcode-565/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Array, DFS, September LeetCoding Challenge 2021", "date": "2021-09-03 07:48:00 +0900", "snippet": " 565. Array Nesting - Mediaum문제You are given an integer array nums of length n where nums is a permutation of the numbers in the range [0, n - 1].You should build a set s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], … } subjected to the following rule: The first element in s[k] starts with the selection of the element nums[k] of index = k. The next element in s[k] should be nums[nums[k]], and then nums[nums[nums[k]]], and so on. We stop adding right before a duplicate element occurs in s[k].Return the longest length of a set s[k].제한사항 1 &amp;lt;= nums.length &amp;lt;= 105 0 &amp;lt;= nums[i] &amp;lt; nums.length All the values of nums are unique.입출력 예Example 1:Input: nums = [5,4,0,3,1,6,2]Output: 4Explanation: nums[0] = 5, nums[1] = 4, nums[2] = 0, nums[3] = 3, nums[4] = 1, nums[5] = 6, nums[6] = 2.One of the longest sets s[k]:s[0] = {nums[0], nums[5], nums[6], nums[2]} = {5, 6, 2, 0}Example 2:Input: nums = [0,1,2]Output: 1풀이 Array, DFStype Item struct { Depth int NextIndex int }func arrayNesting(nums []int) int { // 불필요한 검색을 피하기 위해 // 이미 확인한 index를 표시 depth := 0 cheker := make([]bool, len(nums)) for i, _ := range(nums) { var s []Item s = append(s, Item{1, nums[i]}) cheker[i] = true for len(s) != 0 { item := s[len(s) - 1] s = s[:len(s) - 1] if (cheker[item.NextIndex]) { if (depth &amp;lt; item.Depth) { depth = item.Depth } } else { s = append(s, Item{item.Depth + 1, nums[item.NextIndex]}) cheker[item.NextIndex] = true } } } return depth}" }, { "title": "LeetCode - 496. Next Greater Element I", "url": "/posts/ps-leetcode-496/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, String", "date": "2021-09-03 07:48:00 +0900", "snippet": " 496. Next Greater Element I - Easy문제The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.For each 0 &amp;lt;= i &amp;lt; nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.Return an array ans of length nums1.length such that ans[i] is the next greater element as described above.제한사항 1 &amp;lt;= nums1.length &amp;lt;= nums2.length &amp;lt;= 1000 0 &amp;lt;= nums1[i], nums2[i] &amp;lt;= 104 All integers in nums1 and nums2 are unique. All the integers of nums1 also appear in nums2.입출력 예Example 1:Input: nums1 = [4,1,2], nums2 = [1,3,4,2]Output: [-1,3,-1]Explanation: The next greater element for each value of nums1 is as follows:- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.Example 2:Input: nums1 = [2,4], nums2 = [1,2,3,4]Output: [3,-1]Explanation: The next greater element for each value of nums1 is as follows:- 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3.- 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1.풀이 Stringfunc nextGreaterElement(nums1 []int, nums2 []int) []int { var result []int for _, num1Value := range(nums1) { compStart := false findValue := -1 for _, num2Value := range(nums2) { if (compStart &amp;amp;&amp;amp; num1Value &amp;lt; num2Value) { findValue = num2Value break } if (num1Value == num2Value) { compStart = true; } } result = append(result, findValue) } return result}" }, { "title": "LeetCode - 111. Minimum Depth of Binary Tree", "url": "/posts/ps-leetcode-111/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, BFS, DFS", "date": "2021-09-02 08:23:00 +0900", "snippet": " 111. Minimum Depth of Binary Tree - Easy문제Given a binary tree, find its minimum depth.The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.Note: A leaf is a node with no children.제한사항 The number of nodes in the tree is in the range [0, 105]. -1000 &amp;lt;= Node.val &amp;lt;= 1000입출력 예Example 1:Input: root = [3,9,20,null,null,15,7]Output: 2Example 2:Input: root = [2,null,3,null,4,null,5,null,6]Output: 5풀이 DFS, BFS/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: // DFS int minDepth(TreeNode* root) { if (!root) { return 0; } int depth = INT_MAX; std::stack&amp;lt;std::pair&amp;lt;int, TreeNode*&amp;gt;&amp;gt; s; s.push({1, root}); while(!s.empty()) { auto item = s.top(); s.pop(); TreeNode* node = item.second; if ((!node-&amp;gt;left &amp;amp;&amp;amp; !node-&amp;gt;right) &amp;amp;&amp;amp; item.first &amp;lt; depth) { depth = item.first; } if (node-&amp;gt;left) { s.push({item.first + 1, node-&amp;gt;left}); } if (node-&amp;gt;right) { s.push({item.first + 1, node-&amp;gt;right}); } } return depth; }};/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */type Item struct { Depth int Node *TreeNode}// BFSfunc minDepth(root *TreeNode) int { if (root == nil) { return 0; } depth := int(^uint(0) &amp;gt;&amp;gt; 1) q := []Item{} q = append(q, Item{1, root}) for len(q) != 0 { item := q[0] q = q[1:] node := item.Node if (node.Left == nil &amp;amp;&amp;amp; node.Right == nil &amp;amp;&amp;amp; item.Depth &amp;lt; depth) { depth = item.Depth } if (node.Left != nil) { q = append(q, Item{item.Depth + 1, node.Left}) } if (node.Right != nil) { q = append(q, Item{item.Depth + 1, node.Right}) } } return depth}" }, { "title": "LeetCode - 144. Binary Tree Preorder Traversal", "url": "/posts/ps-leetcode-144/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Tree", "date": "2021-09-02 08:01:00 +0900", "snippet": " 144. Binary Tree Preorder Traversal - Easy문제Given the root of a binary tree, return the preorder traversal of its nodes’ values.제한사항 The number of nodes in the tree is in the range [0, 100]. -100 &amp;lt;= Node.val &amp;lt;= 100입출력 예Example 1:Input: root = [1,null,2,3]Output: [1,2,3]Example 2:Input: root = []Output: []Example 3:Input: root = [1]Output: [1]Example 4:Input: root = [1,2]Output: [1,2]Example 5:Input: root = [1,null,2]Output: [1,2]풀이 Tree/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func preorderTraversal(root *TreeNode) []int { if (root == nil) { return []int{} } var res []int res = append(res, root.Val) left := preorderTraversal(root.Left) if (len(left) != 0) { res = append(res, left...) } right := preorderTraversal(root.Right) if (len(right) != 0) { res = append(res, right...) } return res}" }, { "title": "LeetCode - 145. Binary Tree Postorder Traversal", "url": "/posts/ps-leetcode-145/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Tree", "date": "2021-09-02 07:48:00 +0900", "snippet": " 145. Binary Tree Postorder Traversal - Easy문제Given the root of a binary tree, return the postorder traversal of its nodes’ values.제한사항 The number of the nodes in the tree is in the range [0, 100]. -100 &amp;lt;= Node.val &amp;lt;= 100입출력 예Example 1:Input: root = [1,null,2,3]Output: [3,2,1]Example 2:Input: root = []Output: []Example 3:Input: root = [1]Output: [1]Example 4:Input: root = [1,2]Output: [2,1]Example 5:Input: root = [1,null,2]Output: [2,1]풀이 Tree/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: vector&amp;lt;int&amp;gt; postorderTraversal(TreeNode* root) { if (!root) { return {}; } vector&amp;lt;int&amp;gt; res; vector&amp;lt;int&amp;gt; left = postorderTraversal(root-&amp;gt;left); if (!left.empty()) { res.insert(res.end(), left.begin(), left.end()); } vector&amp;lt;int&amp;gt; right = postorderTraversal(root-&amp;gt;right); if (!right.empty()) { res.insert(res.end(), right.begin(), right.end()); } res.push_back(root-&amp;gt;val); return res; }};" }, { "title": "LeetCode - 119. Pascal&#39;s Triangle II", "url": "/posts/ps-leetcode-119/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Dynamic Programming", "date": "2021-09-02 07:01:00 +0900", "snippet": " 119. Pascal’s Triangle II - Easy문제Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal’s triangle.In Pascal’s triangle, each number is the sum of the two numbers directly above it as shown:제한사항 0 &amp;lt;= rowIndex &amp;lt;= 33입출력 예Example 1:Input: rowIndex = 3Output: [1,3,3,1]Example 2:Input: rowIndex = 0Output: [1]Example 3:Input: rowIndex = 1Output: [1,1]풀이 Dynamic Programmingclass Solution {public: vector&amp;lt;int&amp;gt; getRow(int rowIndex) { if (rowIndex == 0) { return {1}; } else if (rowIndex == 1) { return {1, 1}; } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; item(rowIndex + 1, vector&amp;lt;int&amp;gt;(rowIndex + 1, 1)); for (auto i = 2 ; i &amp;lt;= rowIndex ; ++i) { for (auto j = 1 ; j &amp;lt; i ; ++j) { item[i][j] = item[i - 1][j - 1] + item[i - 1][j]; } } return item.back(); }};" }, { "title": "LeetCode - 581. Shortest Unsorted Continuous Subarray", "url": "/posts/ps-leetcode-581/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Sort, February LeetCoding Challenge 2021", "date": "2021-02-25 06:43:00 +0900", "snippet": " 581. Shortest Unsorted Continuous Subarray - Medium문제Given an integer array nums, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order.Return the shortest such subarray and output its length.제한사항 1 &amp;lt;= nums.length &amp;lt;= 104 -105 &amp;lt;= nums[i] &amp;lt;= 105입출력 예Example 1:Input: nums = [2,6,4,8,10,9,15]Output: 5Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.Example 2:Input: nums = [1,2,3,4]Output: 0Example 3:Input: nums = [1]Output: 0풀이 Sortclass Solution {public: int findUnsortedSubarray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { std::vector&amp;lt;int&amp;gt; sorted = nums; std::sort(sorted.begin(), sorted.end()); int start = 0; int last = nums.size() - 1; while(start &amp;lt; last) { if ((sorted[start] != nums[start]) &amp;amp;&amp;amp; (sorted[last] != nums[last])) { break; } if (sorted[start] == nums[start]) { ++start; } if (sorted[last] == nums[last]) { --last; } } return start == last ? 0 : last - start + 1; }};" }, { "title": "LeetCode - 856. Score of Parentheses", "url": "/posts/ps-leetcode-856/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Stack, February LeetCoding Challenge 2021", "date": "2021-02-25 06:43:00 +0900", "snippet": " 856. Score of Parentheses - Medium문제Given a balanced parentheses string S, compute the score of the string based on the following rule: () has score 1 AB has score A + B, where A and B are balanced parentheses strings. (A) has score 2 * A, where A is a balanced parentheses string.제한사항 S is a balanced parentheses string, containing only ( and ). 2 &amp;lt;= S.length &amp;lt;= 50입출력 예Example 1:Input: &quot;()&quot;Output: 1Example 2:Input: &quot;(())&quot;Output: 2Example 3:Input: &quot;()()&quot;Output: 2Example 4:Input: &quot;(()(()))&quot;Output: 6풀이 Stackclass Solution {public: int scoreOfParentheses(string S) { std::stack&amp;lt;int&amp;gt; items; items.push(0); // (()(())) // // 0 : &#39;(&#39;, [0, 0] // 1 : &#39;(&#39;, [0, 0, 0] // 2 : &#39;)&#39;, [0, 1] // 3 : &#39;(&#39;, [0, 1, 0] // 4 : &#39;(&#39;, [0, 1, 0, 0] // 5 : &#39;)&#39;, [0, 1, 1] // 6 : &#39;)&#39;, [0, 3] // 7 : &#39;)&#39;, [6] for (const char&amp;amp; c : S) { if (c == &#39;)&#39;) { int temp1 = items.top(); items.pop(); int temp2 = items.top(); items.pop(); items.push(temp2 + std::max(2 * temp1, 1)); } else { items.push(0); } } return items.top(); }};" }, { "title": "LeetCode - 524. Longest Word in Dictionary through Deleting", "url": "/posts/ps-leetcode-524/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Array, Sort, February LeetCoding Challenge 2021", "date": "2021-02-23 07:43:00 +0900", "snippet": " 524. Longest Word in Dictionary through Deleting - Medium문제Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.제한사항 All the strings in the input will only contain lower-case letters. The size of the dictionary won’t exceed 1,000. The length of all the strings in the input won’t exceed 1,000.입출력 예Example 1:Input:s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]Output: &quot;apple&quot;Example 2:Input:s = &quot;abpcplea&quot;, d = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]Output: &quot;a&quot;풀이 Array, Sortclass Solution {public: string findLongestWord(string s, vector&amp;lt;string&amp;gt;&amp;amp; d) { std::vector&amp;lt;std::string&amp;gt; items; for (const std::string&amp;amp; str : d) { int sIndex = 0; int strIndex = 0; while (sIndex &amp;lt; s.size() &amp;amp;&amp;amp; strIndex &amp;lt; str.size()) { if (s[sIndex] == str[strIndex]) { ++sIndex; ++strIndex; } else { ++sIndex; } if (strIndex == str.size()) { items.emplace_back(str); } } } std::sort(items.begin(), items.end(), [](const std::string&amp;amp; a, const std::string&amp;amp; b) { if (a.size() == b.size()) { return a &amp;lt; b; } return a.size() &amp;gt; b.size(); }); return items.empty() ? &quot;&quot; : items[0]; }};" }, { "title": "LeetCode - 413. Arithmetic Slices", "url": "/posts/ps-leetcode-413/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Dynamic Programming, February LeetCoding Challenge 2021", "date": "2021-02-19 08:44:00 +0900", "snippet": " 413. Arithmetic Slices - Medium문제A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.For example, these are arithmetic sequences:1, 3, 5, 7, 97, 7, 7, 73, -1, -5, -9The following sequence is not arithmetic.1, 1, 2, 5, 7A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 &amp;lt;= P &amp;lt; Q &amp;lt; N.A slice (P, Q) of the array A is called arithmetic if the sequence:A[P], A[P + 1], …, A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 &amp;lt; Q.The function should return the number of arithmetic slices in the array A.제한사항입출력 예Example:A = [1, 2, 3, 4]return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.풀이 Dynamic Programmingclass Solution {public: int numberOfArithmeticSlices(vector&amp;lt;int&amp;gt;&amp;amp; A) { if (A.size() &amp;lt; 2) { return 0; } std::vector&amp;lt;int&amp;gt; items(A.size(), 0); // index : 0, 1, 2, 3, 4, 5, 6, 7 // ------------------------------------ // example : 1, 3, 5, 7, 9, 15, 20, 25 // dp : 0, 0, 1, 2, 3, 0, 0, 1 for (int i = 2 ; i &amp;lt; A.size() ; ++i) { if (A[i] - A[i-1] == A[i-1] - A[i-2]) { items[i] = items[i-1] + 1; } } return std::accumulate(items.begin(), items.end(), 0); }};" }, { "title": "LeetCode - 11. Container With Most Water", "url": "/posts/ps-leetcode-11/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Array, February LeetCoding Challenge 2021", "date": "2021-02-18 07:44:00 +0900", "snippet": " 11. Container With Most Water - Medium문제Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0). Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.Notice that you may not slant the container.제한사항 n == height.length 2 &amp;lt;= n &amp;lt;= 3 * 104 0 &amp;lt;= height[i] &amp;lt;= 3 * 104입출력 예Examples 1:Input: height = [1,8,6,2,5,4,8,3,7]Output: 49Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.Example 2:Input: height = [1,1]Output: 1Example 3:Input: height = [4,3,2,1,4]Output: 16Example 4:Input: height = [1,2,1]Output: 2풀이 Arrayclass Solution {public: int maxArea(vector&amp;lt;int&amp;gt;&amp;amp; height) { int result = 0; int i = 0; int j = height.size() - 1; // 담을수 있는 물의 양의 높이를 결정하는건 // 두 막대중 낮은 막대의 길이로 결정된다. // 즉, 두 막대 사이에 둘중 낮은 막대의 양만큼 물을 채울수 있으므로, // 담을수 있는 물의 양은 min * (j - i) 가 된다. while (i != j) { int min = std::min(height[i], height[j]); result = std::max(result, min * (j - i)); // 두 막대중 더 높은 막대일수록 더 많은 물을 // 담을수 있기 때문에 두 막대중 낮은 길이의 막대의 // 인덱스를 변경한다. if (height[i] == min) { ++i; } else { --j; } } return result; }};" }, { "title": "LeetCode - 784. Letter Case Permutation", "url": "/posts/ps-leetcode-784/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Recursive, BackTracking, February LeetCoding Challenge 2021", "date": "2021-02-17 07:56:00 +0900", "snippet": " 784. Letter Case Permutation - Medium문제Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string. Return a list of all possible strings we could create.제한사항 S will be a string with length between 1 and 12. S will consist only of letters or digits.입출력 예Examples:Input: S = &quot;a1b2&quot;Output: [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]Input: S = &quot;3z4&quot;Output: [&quot;3z4&quot;, &quot;3Z4&quot;]Input: S = &quot;12345&quot;Output: [&quot;12345&quot;]풀이 Recursive, BackTrackingclass Solution {public: void backTracking(std::string S, int index, std::vector&amp;lt;std::string&amp;gt;&amp;amp; items) { // index가 문자열만큼 커지면 리턴 if (index &amp;gt;= S.size()) { items.push_back(S); return; } backTracking(S, index + 1, items); // 현재 문자가 소문자일때 대문자로 바꿔 현재까지의 문자열에 저장 // 현재 문자가 대문자일때 소문자로 바꿔 현재까지의 문자열에 저장 if (&#39;a&#39; &amp;lt;= S[index] &amp;amp;&amp;amp; S[index] &amp;lt;= &#39;z&#39;) { S[index] -= 32; backTracking(S, index + 1, items); } else if (&#39;A&#39; &amp;lt;= S[index] &amp;amp;&amp;amp; S[index] &amp;lt;= &#39;Z&#39;) { S[index] += 32; backTracking(S, index + 1, items); } } vector&amp;lt;string&amp;gt; letterCasePermutation(string S) { std::vector&amp;lt;std::string&amp;gt; res; backTracking(S, 0, res); return res; }};" }, { "title": "LeetCode - 1337. The K Weakest Rows in a Matrix", "url": "/posts/ps-leetcode-1337/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Array, February LeetCoding Challenge 2021", "date": "2021-02-16 06:24:00 +0900", "snippet": " 1337. The K Weakest Rows in a Matrix - easy문제Given a m * n matrix mat of ones (representing soldiers) and zeros (representing civilians), return the indexes of the k weakest rows in the matrix ordered from the weakest to the strongest.A row i is weaker than row j, if the number of soldiers in row i is less than the number of soldiers in row j, or they have the same number of soldiers but i is less than j. Soldiers are always stand in the frontier of a row, that is, always ones may appear first and then zeros.제한사항 m == mat.length n == mat[i].length 2 &amp;lt;= n, m &amp;lt;= 100 1 &amp;lt;= k &amp;lt;= m matrix[i][j] is either 0 or 1.입출력 예Example 1:Input: mat = [[1,1,0,0,0], [1,1,1,1,0], [1,0,0,0,0], [1,1,0,0,0], [1,1,1,1,1]], k = 3Output: [2,0,3]Explanation: The number of soldiers for each row is: row 0 -&amp;gt; 2 row 1 -&amp;gt; 4 row 2 -&amp;gt; 1 row 3 -&amp;gt; 2 row 4 -&amp;gt; 5 Rows ordered from the weakest to the strongest are [2,0,3,1,4]Example 2:Input: mat = [[1,0,0,0], [1,1,1,1], [1,0,0,0], [1,0,0,0]], k = 2Output: [0,2]Explanation: The number of soldiers for each row is: row 0 -&amp;gt; 1 row 1 -&amp;gt; 4 row 2 -&amp;gt; 1 row 3 -&amp;gt; 1 Rows ordered from the weakest to the strongest are [0,2,3,1]풀이 Araryclass Solution {public: vector&amp;lt;int&amp;gt; kWeakestRows(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; mat, int k) { std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt;&amp;gt; items; std::vector&amp;lt;int&amp;gt; result; int row_index = 0; for (const auto&amp;amp; row : mat) { int sum = std::accumulate(row.begin(), row.end(), 0); items.push_back({sum, row_index}); ++row_index; } std::sort(items.begin(), items.end(), [](const std::pair&amp;lt;int, int&amp;gt;&amp;amp; a, const std::pair&amp;lt;int, int&amp;gt;&amp;amp; b){ if (a.first == b.first) { return a.second &amp;lt; b.second; } return a.first &amp;lt; b.first; } ); for (int i = 0 ; i &amp;lt; k ; ++i) { result.push_back(items[i].second); } return result; }};" }, { "title": "LeetCode - 284. Peeking Iterator", "url": "/posts/ps-leetcode-284/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Degign, February LeetCoding Challenge 2021", "date": "2021-02-09 06:40:00 +0900", "snippet": " 284. Peeking Iterator - medium문제Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation – it essentially peek() at the element that will be returned by the next call to next().Follow up: How would you extend your design to be generic and work with all types, not just integer?제한사항입출력 예Example:Assume that the iterator is initialized to the beginning of the list: [1,2,3].Call next() gets you 1, the first element in the list.Now you call peek() and it returns 2, the next element. Calling next() after that still return 2. You call next() the final time and it returns 3, the last element. Calling hasNext() after that should return false.풀이 Degign/* * Below is the interface for Iterator, which is already defined for you. * **DO NOT** modify the interface for Iterator. * * class Iterator { * struct Data; * Data* data; * Iterator(const vector&amp;lt;int&amp;gt;&amp;amp; nums); * Iterator(const Iterator&amp;amp; iter); * * // Returns the next element in the iteration. * int next(); * * // Returns true if the iteration has more elements. * bool hasNext() const; * }; */class PeekingIterator : public Iterator {public: PeekingIterator(const vector&amp;lt;int&amp;gt;&amp;amp; nums) : Iterator(nums) { // Initialize any member here. // **DO NOT** save a copy of nums and manipulate it directly. // You should only use the Iterator interface methods. index = 0; size = nums.size(); } // Returns the next element in the iteration without advancing the iterator. int peek() { if (Iterator::hasNext()) { cache.push_back(Iterator::next()); } return cache[index]; } // hasNext() and next() should behave the same as in the Iterator interface. // Override them if needed. int next() { if (Iterator::hasNext()) { cache.push_back(Iterator::next()); } int val = cache[index]; ++index; return val; } bool hasNext() const { return index &amp;lt; size; }private: int index; int size; std::vector&amp;lt;int&amp;gt; cache;};/* * Below is the interface for Iterator, which is already defined for you. * **DO NOT** modify the interface for Iterator. * * class Iterator { * struct Data; * Data* data; * Iterator(const vector&amp;lt;int&amp;gt;&amp;amp; nums); * Iterator(const Iterator&amp;amp; iter); * * // Returns the next element in the iteration. * int next(); * * // Returns true if the iteration has more elements. * bool hasNext() const; * }; */class PeekingIterator : public Iterator {public: PeekingIterator(const vector&amp;lt;int&amp;gt;&amp;amp; nums) : Iterator(nums) { // Initialize any member here. // **DO NOT** save a copy of nums and manipulate it directly. // You should only use the Iterator interface methods. } // Returns the next element in the iteration without advancing the iterator. int peek() { return Iterator(*this).next(); } // hasNext() and next() should behave the same as in the Iterator interface. // Override them if needed. int next() { return Iterator::next(); } bool hasNext() const { return Iterator::hasNext(); }};" }, { "title": "LeetCode - 71. Simplify Path", "url": "/posts/ps-leetcode-71/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, String, Simulate, February LeetCoding Challenge 2021", "date": "2021-02-06 07:40:00 +0900", "snippet": " 71. Simplify Path - medium문제Given a string path, which is an absolute path (starting with a slash ‘/’) to a file or directory in a Unix-style file system, convert it to the simplified canonical path.In a Unix-style file system, a period ‘.’ refers to the current directory, a double period ‘..’ refers to the directory up a level, and any multiple consecutive slashes (i.e. ‘//’) are treated as a single slash ‘/’. For this problem, any other format of periods such as ‘…’ are treated as file/directory names.The canonical path should have the following format: The path starts with a single slash ‘/’. Any two directories are separated by a single slash ‘/’. The path does not end with a trailing ‘/’. The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period ‘.’ or double period ‘..’)Return the simplified canonical path.제한사항 1 &amp;lt;= path.length &amp;lt;= 3000 path consists of English letters, digits, period ‘.’, slash ‘/’ or ‘_’. path is a valid absolute Unix path.입출력 예Example 1:Input: path = &quot;/home/&quot;Output: &quot;/home&quot;Explanation: Note that there is no trailing slash after the last directory name.Example 2:Input: path = &quot;/../&quot;Output: &quot;/&quot;Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.Example 3:Input: path = &quot;/home//foo/&quot;Output: &quot;/home/foo&quot;Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.Example 4:Input: path = &quot;/a/./b/../../c/&quot;Output: &quot;/c&quot;풀이 String, Simulateclass Solution {public: string simplifyPath(string path) { std::string result; std::vector&amp;lt;std::string&amp;gt; dir_list; if (path.back() != &#39;/&#39;) { path.push_back(&#39;/&#39;); } int index = 0; for (int i = 1 ; i &amp;lt; path.size() ; ++i) { if (path[i] == &#39;/&#39;) { std::string dir = path.substr(index + 1, i - index - 1); index = i; if (dir.empty()) { continue; } if (dir == &quot;..&quot;) { if (!dir_list.empty()) { dir_list.pop_back(); } } else if (dir == &quot;.&quot;) { continue; } else { dir_list.emplace_back(dir); } } } for (const auto&amp;amp; dir : dir_list) { result += &quot;/&quot; + dir; } return result.empty() ? &quot;/&quot; : result; }};" }, { "title": "LeetCode - 594. Longest Harmonious Subsequence", "url": "/posts/ps-leetcode-594/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Hash, February LeetCoding Challenge 2021", "date": "2021-02-05 08:00:00 +0900", "snippet": " 594. Longest Harmonious Subsequence - easy문제We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1.Given an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences.A subsequence of array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements.제한사항 1 &amp;lt;= nums.length &amp;lt;= 2 * 104 -109 &amp;lt;= nums[i] &amp;lt;= 109입출력 예Example 1:Input: nums = [1,3,2,2,5,2,3,7]Output: 5Explanation: The longest harmonious subsequence is [3,2,2,2,3].Example 2:Input: nums = [1,2,3,4]Output: 2Example 3:Input: nums = [1,1,1,1]Output: 0풀이 Hashclass Solution {public: int findLHS(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int max = 0; std::unordered_map&amp;lt;int, int&amp;gt; item; for(auto &amp;amp;i : nums){ ++item[i]; if(item.count(i + 1)) { max = std::max(max, item[i] + item[i+1]); } if(item.count(i - 1)) { max = std::max(max, item[i] + item[i-1]); } } return max; }};" }, { "title": "LeetCode - 141. Linked List Cycle", "url": "/posts/ps-leetcode-141/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Linked List, February LeetCoding Challenge 2021", "date": "2021-02-04 07:00:00 +0900", "snippet": " 141. Linked List Cycle - easy문제Given head, the head of a linked list, determine if the linked list has a cycle in it.There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter.Return true if there is a cycle in the linked list. Otherwise, return false.제한사항입출력 예Example 1:Input: head = [3,2,0,-4], pos = 1Output: trueExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).Example 2:Input: head = [1,2], pos = 0Output: trueExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.Example 3:Input: head = [1], pos = -1Output: falseExplanation: There is no cycle in the linked list.풀이 Linked List/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: bool hasCycle(ListNode *head) { if (!head || !head-&amp;gt;next) { return false; } ListNode *first = head; ListNode *second = head-&amp;gt;next; while (first-&amp;gt;next &amp;amp;&amp;amp; second-&amp;gt;next &amp;amp;&amp;amp; second-&amp;gt;next-&amp;gt;next) { if (first == second) { return true; } first = first-&amp;gt;next; second = second-&amp;gt;next-&amp;gt;next; } return false; }};" }, { "title": "LeetCode - 669. Trim a Binary Search Tree", "url": "/posts/ps-leetcode-669/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Tree, Recusive, February LeetCoding Challenge 2021", "date": "2021-02-03 07:49:00 +0900", "snippet": " 669. Trim a Binary Search Tree - medium문제Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node’s descendant should remain a descendant). It can be proven that there is a unique answer.Return the root of the trimmed binary search tree. Note that the root may change depending on the given bounds.제한사항입출력 예Example 1:Input: root = [1,0,2], low = 1, high = 2Output: [1,null,2]Example 2:Input: root = [3,0,4,null,2,null,null,1], low = 1, high = 3Output: [3,2,null,1]Example 3:Input: root = [1], low = 1, high = 2Output: [1]Example 4:Input: root = [1,null,2], low = 1, high = 3Output: [1,null,2]Example 5:Input: root = [1,null,2], low = 2, high = 4Output: [2]풀이 Tree, Recusive/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: TreeNode* trimBST(TreeNode* root, int low, int high) { if (root == nullptr) { return nullptr; } if (root-&amp;gt;val &amp;lt; low) { return trimBST(root-&amp;gt;right, low, high); } if (root-&amp;gt;val &amp;gt; high) { return trimBST(root-&amp;gt;left, low, high); } root-&amp;gt;left = trimBST(root-&amp;gt;left, low, high); root-&amp;gt;right = trimBST(root-&amp;gt;right, low, high); return root; }};" }, { "title": "LeetCode - 191. Number of 1 Bits", "url": "/posts/ps-leetcode-191/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Bit Manipulate, February LeetCoding Challenge 2021", "date": "2021-02-03 06:11:00 +0900", "snippet": " 191. Number of 1 Bits - easy문제Write a function that takes an unsigned integer and returns the number of ‘1’ bits it has (also known as the Hamming weight).Note: Note that in some languages such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 3 above, the input represents the signed integer. -3.Follow up: If this function is called many times, how would you optimize it?제한사항입출력 예Example 1:Input: n = 00000000000000000000000000001011Output: 3Explanation: The input binary string 00000000000000000000000000001011 has a total of three &#39;1&#39; bits.Example 2:Input: n = 00000000000000000000000010000000Output: 1Explanation: The input binary string 00000000000000000000000010000000 has a total of one &#39;1&#39; bit.Example 3:Input: n = 11111111111111111111111111111101Output: 31Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one &#39;1&#39; bits.풀이 Bit Manipulateclass Solution {public: int hammingWeight(uint32_t n) { int count = 0; while(n) { if (n &amp;amp; 1) { ++count; } n &amp;gt;&amp;gt;= 1; } return count; }};" }, { "title": "LeetCode - 1094. Car Pooling", "url": "/posts/ps-leetcode-1094/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Greedy", "date": "2020-09-24 08:12:00 +0900", "snippet": " 1094. Car Pooling - medium문제You are driving a vehicle that has capacity empty seats initially available for passengers. The vehicle only drives east (ie. it cannot turn around and drive west.)Given a list of trips, trip[i] = [num_passengers, start_location, end_location] contains information about the i-th trip: the number of passengers that must be picked up, and the locations to pick them up and drop them off. The locations are given as the number of kilometers due east from your vehicle’s initial location.Return true if and only if it is possible to pick up and drop off all passengers for all the given trips.제한사항 trips.length &amp;lt;= 1000 trips[i].length == 3 1 &amp;lt;= trips[i][0] &amp;lt;= 100 0 &amp;lt;= trips[i][1] &amp;lt; trips[i][2] &amp;lt;= 1000 1 &amp;lt;= capacity &amp;lt;= 100000입출력 예Example 1:Input: trips = [[2,1,5],[3,3,7]], capacity = 4Output: falseExample 2:Input: trips = [[2,1,5],[3,3,7]], capacity = 5Output: trueExample 3:Input: trips = [[2,1,5],[3,5,7]], capacity = 3Output: trueExample 4:Input: trips = [[3,2,7],[3,7,9],[8,3,9]], capacity = 11Output: true풀이 Greedyfunc carPooling(trips [][]int, capacity int) bool { // 시작지점(trips[i][1]) 기준으로 정렬 sort.SliceStable(trips, func(i, j int) bool { if trips[i][1] == trips[j][1] { return trips[i][2] &amp;lt; trips[j][2] } else { return trips[i][1] &amp;lt; trips[j][1] } }) var passengerCount = 0 for i, item := range trips { // 현재 index 이전의 path를 조사하는데, // 현재 index의 시작지점이 이전 index의 도착지점보다 크다면 // 이미 도착지점이 지난것 이므로 도착지점에 도착한 승객을 뺌 // 내린 승객을 중복으로 계산하지 않도록 0을 대입 for j := 0 ; j &amp;lt; i ; j++ { if item[1] &amp;gt;= trips[j][2] { passengerCount -= trips[j][0] trips[j][0] = 0 } } // 현재 탑승하는 승객을 더해 용량보다 큰지 검사 passengerCount += item[0] if passengerCount &amp;gt; capacity { return false } } return true;}" }, { "title": "LeetCode - 1221. Split a String in Balanced Strings", "url": "/posts/ps-leetcode-1221/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Hash", "date": "2020-09-24 07:11:00 +0900", "snippet": " 1221. Split a String in Balanced Strings - easy문제Balanced strings are those who have equal quantity of ‘L’ and ‘R’ characters.Given a balanced string s split it in the maximum amount of balanced strings.Return the maximum amount of splitted balanced strings.제한사항입출력 예Example 1:Input: s = &quot;RLRRLLRLRL&quot;Output: 4Explanation: s can be split into &quot;RL&quot;, &quot;RRLL&quot;, &quot;RL&quot;, &quot;RL&quot;, each substring contains same number of &#39;L&#39; and &#39;R&#39;.Example 2:Input: s = &quot;RLLLLRRRLR&quot;Output: 3Explanation: s can be split into &quot;RL&quot;, &quot;LLLRRR&quot;, &quot;LR&quot;, each substring contains same number of &#39;L&#39; and &#39;R&#39;.Example 3:Input: s = &quot;LLLLRRRR&quot;Output: 1Explanation: s can be split into &quot;LLLLRRRR&quot;.Example 4:Input: s = &quot;RLRRRLLRLL&quot;Output: 2Explanation: s can be split into &quot;RL&quot;, &quot;RRRLLRLL&quot;, since each substring contains an equal number of &#39;L&#39; and &#39;R&#39;풀이 Hashfunc balancedStringSplit(s string) int { var m = make(map[rune]int) var count = 0 for _, v := range s { m[v]++ if m[&#39;L&#39;] == m[&#39;R&#39;] { count++ } } return count}" }, { "title": "LeetCode - 229. Majority Element II", "url": "/posts/ps-leetcode-229/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Sort, Array", "date": "2020-09-23 05:31:00 +0900", "snippet": " 229. Majority Element II - medium문제Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.제한사항 The algorithm should run in linear time and in O(1) space.입출력 예Example 1:Input: [3,2,3]Output: [3]Example 2:Input: [1,1,1,3,3,2,2,2]Output: [1,2]풀이 Sort, Arrayclass Solution {public: vector&amp;lt;int&amp;gt; majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.empty()) { return std::vector&amp;lt;int&amp;gt;(); } std::vector&amp;lt;int&amp;gt; res; int n = nums.size(); int N = n / 3; std::sort(nums.begin(), nums.end()); int count = 1; for (auto i = 0 ; i &amp;lt; n - 1 ; ++i) { if (nums[i] == nums[i+1]) { ++count; } else { if (count &amp;gt; N) { res.push_back(nums[i]); } count = 1; } } if (count &amp;gt; N) { res.push_back(nums[n-1]); } return res; }};func majorityElement(nums []int) []int { var res []int var n = len(nums) var N = n / 3 if n &amp;lt; 1 { return res } sort.Slice(nums, func(i, j int) bool { return nums[i] &amp;lt; nums[j] }) var count = 1 for i := 0 ; i &amp;lt; n - 1 ; i++ { if nums[i] == nums[i+1] { count++ } else { if count &amp;gt; N { res = append(res, nums[i]) } count = 1 } } if count &amp;gt; N { res = append(res, nums[n-1]) } return res}" }, { "title": "LeetCode - 299. Bulls and Cows", "url": "/posts/ps-leetcode-299/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Hash", "date": "2020-09-16 08:28:00 +0900", "snippet": " 299. Bulls and Cows - medium문제You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number.Write a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows.Please note that both secret number and friend’s guess may contain duplicate digits.제한사항 1 &amp;lt;= secret.length, guess.length &amp;lt;= 1000 secret.length == guess.length secret and guess consist of digits only.입출력 예Example 1:Input: secret = &quot;1807&quot;, guess = &quot;7810&quot;Output: &quot;1A3B&quot;Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1, and 7.Example 2:Input: secret = &quot;1123&quot;, guess = &quot;0111&quot;Output: &quot;1A1B&quot;Explanation: The 1st 1 in friend&#39;s guess is a bull, the 2nd or 3rd 1 is a cow.Example 3:Input: secret = &quot;1&quot;, guess = &quot;0&quot;Output: &quot;0A0B&quot;Example 4:Input: secret = &quot;1&quot;, guess = &quot;1&quot;Output: &quot;1A0B&quot;풀이 Hashclass Solution {public: string getHint(string secret, string guess) { int n = secret.size(); std::map&amp;lt;char, int&amp;gt; guessMap; int bullsCount = 0; int cowsCount = 0; for (auto i = 0 ; i &amp;lt; n ; ++i) { if (secret[i] == guess[i]) { ++bullsCount; secret[i] = &#39;.&#39;; guess[i] = &#39;.&#39;; } } for (auto c : guess) { ++guessMap[c];} for (auto i = 0 ; i &amp;lt; n ; ++i) { if ((secret[i] != &#39;.&#39;) &amp;amp;&amp;amp; (guessMap.find(secret[i]) != guessMap.end()) &amp;amp;&amp;amp; (guessMap[secret[i]] &amp;gt; 0)) { ++cowsCount; --guessMap[secret[i]]; } } std::string bulls = std::to_string(bullsCount) + &#39;A&#39;; std::string cows = std::to_string(cowsCount) + &#39;B&#39;; return bulls + cows; }};" }, { "title": "LeetCode - 58. Length of Last Word", "url": "/posts/ps-leetcode-58/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, String", "date": "2020-09-16 07:39:00 +0900", "snippet": " 58. Length of Last Word - easy문제Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word (last word means the last appearing word if we loop from left to right) in the string.If the last word does not exist, return 0.Note: A word is defined as a maximal substring consisting of non-space characters only.제한사항입출력 예Input: &quot;Hello World&quot;Output: 5풀이 Stringclass Solution {public: int lengthOfLastWord(string s) { std::vector&amp;lt;std::string&amp;gt; tokens; std::string buf; std::stringstream ss(s); while(ss &amp;gt;&amp;gt; buf) { tokens.emplace_back(buf); } if (tokens.empty()) { return 0; } return tokens.back().size(); }};" }, { "title": "LeetCode - 890. Find and Replace Pattern", "url": "/posts/ps-leetcode-890/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Hash", "date": "2020-09-10 07:50:00 +0900", "snippet": " 890. Find and Replace Pattern - esay문제You have a list of words and a pattern, and you want to know which words in words matches the pattern.A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.(Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.)Return a list of the words in words that match the given pattern.You may return the answer in any order.제한사항 1 &amp;lt;= words.length &amp;lt;= 50 1 &amp;lt;= pattern.length = words[i].length &amp;lt;= 20입출력 예Input: words = [&quot;abc&quot;,&quot;deq&quot;,&quot;mee&quot;,&quot;aqq&quot;,&quot;dkd&quot;,&quot;ccc&quot;], pattern = &quot;abb&quot;Output: [&quot;mee&quot;,&quot;aqq&quot;]Explanation: &quot;mee&quot; matches the pattern because there is a permutation {a -&amp;gt; m, b -&amp;gt; e, ...}. &quot;ccc&quot; does not match the pattern because {a -&amp;gt; c, b -&amp;gt; c, ...} is not a permutation,since a and b map to the same letter.풀이 Hashclass Solution {public: vector&amp;lt;string&amp;gt; findAndReplacePattern(vector&amp;lt;string&amp;gt;&amp;amp; words, string pattern) { std::vector&amp;lt;string&amp;gt; answer; for (const auto&amp;amp; str : words) { bool flag = true; std::map&amp;lt;char, char&amp;gt; m1; std::map&amp;lt;char, char&amp;gt; m2; // 두 map에 순차적으로 word, pattern의 문자를 서로 교차 저장하며, // key가 이미 저장되어 있지 않다면 새로 해당 문자를 key로 하여 상대 문자를 저장하고, // 지금 저장할 key와 매칭되는 상대의 문자가 같은지 검사 for (auto i = 0 ; i &amp;lt; str.size() ; ++i) { char s = str[i]; char p = pattern[i]; if (m1.find(s) == m1.end()) { m1[s] = p; } if (m2.find(p) == m2.end()) { m2[p] = s; } if (m1[s] != p || m2[p] != s) { flag = false; break; } } if (flag) { answer.push_back(str); } } return answer; }};" }, { "title": "LeetCode - 835. Image Overlap", "url": "/posts/ps-leetcode-835/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Array", "date": "2020-09-09 07:10:00 +0900", "snippet": " 835. Image Overlap - medium문제Two images A and B are given, represented as binary, square matrices of the same size. (A binary matrix has only 0s and 1s as values.)We translate one image however we choose (sliding it left, right, up, or down any number of units), and place it on top of the other image. After, the overlap of this translation is the number of positions that have a 1 in both images.(Note also that a translation does not include any kind of rotation.)What is the largest possible overlap?제한사항 1 &amp;lt;= A.length = A[0].length = B.length = B[0].length &amp;lt;= 30 0 &amp;lt;= A[i][j], B[i][j] &amp;lt;= 1입출력 예Input: A = [[1,1,0], [0,1,0], [0,1,0]] B = [[0,0,0], [0,1,1], [0,0,1]]Output: 3Explanation: We slide A to right by 1 unit and down by 1 unit.풀이 Arrayclass Solution {public: int largestOverlap(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; A, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; B) { int m = A.size(); int n = A[0].size(); int answer = 0 ; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; count(2*m+1, vector&amp;lt;int&amp;gt;(2*n+1, 0)); for(auto i = 0 ; i &amp;lt; m ; ++i){ for(auto j = 0 ; j &amp;lt; n ; ++j){ if(A[i][j]){ for(auto t = 0 ; t &amp;lt; m ; ++t){ for(auto k = 0 ; k &amp;lt; n ; ++k){ if(B[t][k]) count[i - t + m][j - k + n] += 1; } } } } } for(auto&amp;amp; i : count){ for(auto&amp;amp; j : i){ answer = max(j, answer); } } return answer; }};" }, { "title": "LeetCode - 1022. Sum of Root To Leaf Binary Numbers", "url": "/posts/ps-leetcode-1022/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Tree", "date": "2020-09-09 07:05:00 +0900", "snippet": " 1022. Sum of Root To Leaf Binary Numbers - esay문제Given a binary tree, each node has value 0 or 1. Each root-to-leaf path represents a binary number starting with the most significant bit. For example, if the path is 0 -&amp;gt; 1 -&amp;gt; 1 -&amp;gt; 0 -&amp;gt; 1, then this could represent 01101 in binary, which is 13.For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.Return the sum of these numbers.제한사항 The number of nodes in the tree is between 1 and 1000. node.val is 0 or 1. The answer will not exceed 2^31 - 1.입출력 예Input: [1,0,1,0,1,0,1]Output: 22Explanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22풀이 Tree/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int sumRootToLeaf(TreeNode* root) { return root == NULL ? 0 : getBinary(root, 0); } int getBinary(const TreeNode* root, int val){ val = val &amp;lt;&amp;lt; 1; if(root-&amp;gt;val == 1) ++val; if(root-&amp;gt;left == NULL &amp;amp;&amp;amp; root-&amp;gt;right == NULL) return val; return (root-&amp;gt;left == NULL ? 0 : getBinary(root-&amp;gt;left, val)) + (root-&amp;gt;right == NULL ? 0 : getBinary(root-&amp;gt;right, val)); }};" }, { "title": "Programmers - 영어 끝말잇기", "url": "/posts/ps-programmers-43/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, String, Hash", "date": "2020-09-08 08:03:00 +0900", "snippet": " 영어 끝말잇기 - lv.2문제1부터 n까지 번호가 붙어있는 n명의 사람이 영어 끝말잇기를 하고 있습니다. 영어 끝말잇기는 다음과 같은 규칙으로 진행됩니다. 1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다. 마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작합니다. 앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다. 이전에 등장했던 단어는 사용할 수 없습니다. 한 글자인 단어는 인정되지 않습니다.다음은 3명이 끝말잇기를 하는 상황을 나타냅니다.tank → kick → know → wheel → land → dream → mother → robot → tank위 끝말잇기는 다음과 같이 진행됩니다. 1번 사람이 자신의 첫 번째 차례에 tank를 말합니다. 2번 사람이 자신의 첫 번째 차례에 kick을 말합니다. 3번 사람이 자신의 첫 번째 차례에 know를 말합니다. 1번 사람이 자신의 두 번째 차례에 wheel을 말합니다. (계속 진행)끝말잇기를 계속 진행해 나가다 보면, 3번 사람이 자신의 세 번째 차례에 말한 tank 라는 단어는 이전에 등장했던 단어이므로 탈락하게 됩니다.사람의 수 n과 사람들이 순서대로 말한 단어 words 가 매개변수로 주어질 때, 가장 먼저 탈락하는 사람의 번호와 그 사람이 자신의 몇 번째 차례에 탈락하는지를 구해서 return 하도록 solution 함수를 완성해주세요.제한사항 끝말잇기에 참여하는 사람의 수 n은 2 이상 10 이하의 자연수입니다. words는 끝말잇기에 사용한 단어들이 순서대로 들어있는 배열이며, 길이는 n 이상 100 이하입니다. 단어의 길이는 2 이상 50 이하입니다. 모든 단어는 알파벳 소문자로만 이루어져 있습니다. 끝말잇기에 사용되는 단어의 뜻(의미)은 신경 쓰지 않으셔도 됩니다. 정답은 [ 번호, 차례 ] 형태로 return 해주세요. 만약 주어진 단어들로 탈락자가 생기지 않는다면, [0, 0]을 return 해주세요.입출력 예 n words result 3 [“tank”, “kick”, “know”, “wheel”, “land”, “dream”, “mother”, “robot”, “tank”] [3,3] 5 [“hello”, “observe”, “effect”, “take”, “either”, “recognize”, “encourage”, “ensure”, “establish”, “hang”, “gather”, “refer”, “reference”, “estimate”, “executive”] [0,0] 2 [“hello”, “one”, “even”, “never”, “now”, “world”, “draw”] [1,3] 입출력 예 #13명의 사람이 끝말잇기에 참여하고 있습니다. 1번 사람 : tank, wheel, mother 2번 사람 : kick, land, robot 3번 사람 : know, dream, tank와 같은 순서로 말을 하게 되며, 3번 사람이 자신의 세 번째 차례에 말한 tank라는 단어가 1번 사람이 자신의 첫 번째 차례에 말한 tank와 같으므로 3번 사람이 자신의 세 번째 차례로 말을 할 때 처음 탈락자가 나오게 됩니다.입출력 예 #25명의 사람이 끝말잇기에 참여하고 있습니다. 1번 사람 : hello, recognize, gather 2번 사람 : observe, encourage, refer 3번 사람 : effect, ensure, reference 4번 사람 : take, establish, estimate 5번 사람 : either, hang, executive와 같은 순서로 말을 하게 되며, 이 경우는 주어진 단어로만으로는 탈락자가 발생하지 않습니다. 따라서 [0, 0]을 return하면 됩니다.입출력 예 #32명의 사람이 끝말잇기에 참여하고 있습니다. 1번 사람 : hello, even, now, draw 2번 사람 : one, never, world와 같은 순서로 말을 하게 되며, 1번 사람이 자신의 세 번째 차례에 &#39;r&#39;로 시작하는 단어 대신, n으로 시작하는 now를 말했기 때문에 이때 처음 탈락자가 나오게 됩니다.풀이 String, Hashvector&amp;lt;int&amp;gt; solution(int n, vector&amp;lt;string&amp;gt; words) { vector&amp;lt;int&amp;gt; answer = {}; map&amp;lt;string, int&amp;gt; recode; recode.insert({words[0], 1}); int cycle = 1; int count = 2; for (auto i = 1 ; i &amp;lt; words.size() ; ++i) { if (words[i-1].back() == words[i].front() &amp;amp;&amp;amp; recode.find(words[i]) == recode.end()) { recode[words[i]] = count; ++count; } else { break; } if (count &amp;gt; n) { count = 1; ++cycle; } } if (cycle &amp;gt; words.size() / n) { answer.push_back(0); answer.push_back(0); } else { answer.push_back(count); answer.push_back(cycle); } return answer;}" }, { "title": "Programmers - 피보나치 수", "url": "/posts/ps-programmers-42/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Math", "date": "2020-09-08 07:12:00 +0900", "snippet": " 피보나치 수 - lv.2문제피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 입니다.예를들어 F(2) = F(0) + F(1) = 0 + 1 = 1 F(3) = F(1) + F(2) = 1 + 1 = 2 F(4) = F(2) + F(3) = 1 + 2 = 3 F(5) = F(3) + F(4) = 2 + 3 = 5와 같이 이어집니다.2 이상의 n이 입력되었을 때, n번째 피보나치 수를 1234567으로 나눈 나머지를 리턴하는 함수, solution을 완성해 주세요.제한사항 n은 1이상, 100000이하인 자연수입니다.입출력 예 n return 3 2 5 5 풀이 Mathint solution(int n) { int answer = 0; int temp1 = 0; int temp2 = 1; for (auto i = 2 ; i &amp;lt;= n ; ++i) { answer = (temp1 + temp2) % 1234567; temp1 = temp2 % 1234567; temp2 = answer % 1234567; } return answer;}" }, { "title": "Programmers - 튜플", "url": "/posts/ps-programmers-41/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, String, Hash", "date": "2020-09-08 06:54:00 +0900", "snippet": " 튜플 - lv.2문제셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다. n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다. (a1, a2, a3, …, an)튜플은 다음과 같은 성질을 가지고 있습니다. 중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2) 원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다. ex : (1, 2, 3) ≠ (1, 3, 2) 튜플의 원소 개수는 유한합니다.원소의 개수가 n개이고, 중복되는 원소가 없는 튜플 (a1, a2, a3, …, an)이 주어질 때(단, a1, a2, …, an은 자연수), 이는 다음과 같이 집합 기호 ‘{‘, ‘}’를 이용해 표현할 수 있습니다. ((a1), (a1, a2), (a1, a2, a3), (a1, a2, a3, a4), … (a1, a2, a3, a4, …, an))예를 들어 튜플이 (2, 1, 3, 4)인 경우 이는 (2), (2, 1), (2, 1, 3), (2, 1, 3, 4))와 같이 표현할 수 있습니다. 이때, 집합은 원소의 순서가 바뀌어도 상관없으므로 ((2), {2, 1), (2, 1, 3), (2, 1, 3, 4)) ((2, 1, 3, 4), (2), (2, 1, 3), (2, 1)) ((1, 2, 3), (2, 1), (1, 2, 4, 3), (2))는 모두 같은 튜플 (2, 1, 3, 4)를 나타냅니다.특정 튜플을 표현하는 집합이 담긴 문자열 s가 매개변수로 주어질 때, s가 표현하는 튜플을 배열에 담아 return 하도록 solution 함수를 완성해주세요.제한사항 s의 길이는 5 이상 1,000,000 이하입니다. s는 숫자와 ‘{‘, ‘}’, ‘,’ 로만 이루어져 있습니다. 숫자가 0으로 시작하는 경우는 없습니다. s는 항상 중복되는 원소가 없는 튜플을 올바르게 표현하고 있습니다. s가 표현하는 튜플의 원소는 1 이상 100,000 이하인 자연수입니다. return 하는 배열의 길이가 1 이상 500 이하인 경우만 입력으로 주어집니다.입출력 예풀이 String, Hashvector&amp;lt;int&amp;gt; solution(string s) { vector&amp;lt;int&amp;gt; answer; map&amp;lt;int, vector&amp;lt;int&amp;gt;&amp;gt; items; map&amp;lt;int, int&amp;gt; checker; size_t N = s.size(); // 주어진 문자열을 2D vector형태로 재구성 // 2D vector형태로 재구성할때, 크기순 으로 정렬 vector&amp;lt;int&amp;gt; temp; int index = 0; for (auto i = 1 ; i &amp;lt; N - 1 ; ++i) { if (s[i] == &#39;{&#39;) { temp.clear(); index = i + 1; } else if (s[i] == &#39;,&#39;) { temp.push_back(std::stoi(s.substr(index, i - index))); index = i + 1; } else if (s[i] == &#39;}&#39;) { int val = std::stoi(s.substr(index, i - index)); temp.push_back(val); items.insert({temp.size(), temp}); } } // 재구성한 2D vector를 순차적으로 탐색하여 // 이전 vector에는 없는 값을 하나씩 추가 for (const auto&amp;amp; item : items) { for (auto&amp;amp; val : item.second) { if (checker.find(val) == checker.end()) { answer.push_back(val); ++checker[val]; } } } return answer;}" }, { "title": "Programmers - 크레인 인형뽑기 게임", "url": "/posts/ps-programmers-40/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Stack", "date": "2020-09-03 06:18:00 +0900", "snippet": " 크레인 인형뽑기 게임 - lv.3문제게임개발자인 “죠르디”는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다.“죠르디”는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다.게임 화면은 “1 x 1” 크기의 칸들로 이루어진 “N x N” 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다. (위 그림은 “5 x 5” 크기의 예시입니다). 각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸입니다. 모든 인형은 “1 x 1” 크기의 격자 한 칸을 차지하며 격자의 가장 아래 칸부터 차곡차곡 쌓여 있습니다. 게임 사용자는 크레인을 좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올릴 수 있습니다. 집어 올린 인형은 바구니에 쌓이게 되는 데, 이때 바구니의 가장 아래 칸부터 인형이 순서대로 쌓이게 됩니다. 다음 그림은 [1번, 5번, 3번] 위치에서 순서대로 인형을 집어 올려 바구니에 담은 모습입니다.만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 됩니다. 위 상태에서 이어서 [5번] 위치에서 인형을 집어 바구니에 쌓으면 같은 모양 인형 두 개가 없어집니다.크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동시키는 경우에는 아무런 일도 일어나지 않습니다. 또한 바구니는 모든 인형이 들어갈 수 있을 만큼 충분히 크다고 가정합니다. (그림에서는 화면표시 제약으로 5칸만으로 표현하였음)게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 solution 함수를 완성해주세요.제한사항 board 배열은 2차원 배열로 크기는 “5 x 5” 이상 “30 x 30” 이하입니다. board의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다. 0은 빈 칸을 나타냅니다. 1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나타냅니다. moves 배열의 크기는 1 이상 1,000 이하입니다. moves 배열 각 원소들의 값은 1 이상이며 board 배열의 가로 크기 이하인 자연수입니다.입출력 예 board moves result [[0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]] [1,5,3,5,1,2,1,4] 4 풀이 Stackint solution(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; board, vector&amp;lt;int&amp;gt; moves) { int answer = 0; int n = board.size(); std::stack&amp;lt;int&amp;gt; s; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; temp(n); for (auto i = 0 ; i &amp;lt; n ; ++i) { for (auto j = 0 ; j &amp;lt; n ; ++j) { if (board[j][i] != 0) { temp[i].insert(temp[i].begin(), board[j][i]); } } } for (const auto index : moves) { if (temp[index-1].empty()) { continue; } int item = temp[index-1].back(); temp[index-1].pop_back(); if (!s.empty() &amp;amp;&amp;amp; s.top() == item) { ++answer; s.pop(); } else { s.push(item); } } return answer * 2;}" }, { "title": "LeetCode - 674. Longest Continuous Increasing Subsequence", "url": "/posts/ps-leetcode-674/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Array", "date": "2020-08-28 06:41:00 +0900", "snippet": " 674. Longest Continuous Increasing Subsequence - easy문제Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).제한사항 Length of the array will not exceed 10,000.입출력 예Example 1:Input: [1,3,5,4,7]Output: 3Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. Even though [1,3,5,7] is also an increasing subsequence, it&#39;s not a continuous one where 5 and 7 are separated by 4.Example 2:Input: [2,2,2,2,2]Output: 1Explanation: The longest continuous increasing subsequence is [2], its length is 1.풀이 Arrayclass Solution {public: int findLengthOfLCIS(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.empty()) { return 0; } int maxLength = 0; int count = 1; for (auto i = 0 ; i &amp;lt; nums.size() - 1; ++i) { if (nums[i] &amp;lt; nums[i+1]) { ++count; } else { maxLength = std::max(count, maxLength); count = 1; } } maxLength = std::max(count, maxLength); return maxLength; }};" }, { "title": "LeetCode - 1160. Find Words That Can Be Formed by Characters", "url": "/posts/ps-leetcode-1160/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Hash", "date": "2020-08-28 06:26:00 +0900", "snippet": " 1160. Find Words That Can Be Formed by Characters - easy문제You are given an array of strings words and a string chars.A string is good if it can be formed by characters from chars (each character can only be used once).Return the sum of lengths of all good strings in words.제한사항 1 &amp;lt;= words.length &amp;lt;= 1000 1 &amp;lt;= words[i].length, chars.length &amp;lt;= 100 All strings contain lowercase English letters only.입출력 예Example 1:Input: words = [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars = &quot;atach&quot;Output: 6Explanation: The strings that can be formed are &quot;cat&quot; and &quot;hat&quot; so the answer is 3 + 3 = 6.Example 2:Input: words = [&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;], chars = &quot;welldonehoneyr&quot;Output: 10Explanation: The strings that can be formed are &quot;hello&quot; and &quot;world&quot; so the answer is 5 + 5 = 10.풀이 Hashclass Solution {public: int countCharacters(vector&amp;lt;string&amp;gt;&amp;amp; words, string chars) { int result = 0; std::map&amp;lt;char, int&amp;gt; m; for (auto&amp;amp; c : chars) { ++m[c]; } ` for (const auto&amp;amp; str : words) { int matchCount = 0; auto tempMap = m; for (auto&amp;amp; c : str) { if (tempMap[c] &amp;gt; 0) { --tempMap[c]; ++matchCount; } } if (matchCount == str.size()) { result += str.size(); } } return result; }};" }, { "title": "LeetCode - 110. Balanced Binary Tree", "url": "/posts/ps-leetcode-110/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Tree, DFS", "date": "2020-08-11 07:26:00 +0900", "snippet": " 110. Balanced Binary Tree - easy문제Given a binary tree, determine if it is height-balanced.For this problem, a height-balanced binary tree is defined as: a binary tree in which the left and right subtrees of every node differ in height by no more than 1.제한사항입출력 예Example 1:Given the following tree [3,9,20,null,null,15,7]: 3 / \\ 9 20 / \\ 15 7Return true.Example 2:Given the following tree [1,2,2,3,3,null,null,4,4]: 1 / \\ 2 2 / \\ 3 3 / \\ 4 4Return false.풀이 Tree, DFS/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int dfs(TreeNode* root) { if (!root) { return 0; } int depth = 0; std::stack&amp;lt;std::pair&amp;lt;TreeNode*, int&amp;gt;&amp;gt; s; s.push({root, 1}); while (!s.empty()) { auto node = s.top(); s.pop(); if (!node.first-&amp;gt;left &amp;amp;&amp;amp; !node.first-&amp;gt;right) { depth = std::max(depth, node.second); } if (node.first-&amp;gt;left) { s.push({node.first-&amp;gt;left, node.second + 1}); } if (node.first-&amp;gt;right) { s.push({node.first-&amp;gt;right, node.second + 1}); } } return depth; } bool isBalanced(TreeNode* root) { if (!root || (!root-&amp;gt;left &amp;amp;&amp;amp; !root-&amp;gt;right)) { return true; } bool left = isBalanced(root-&amp;gt;left); bool right = isBalanced(root-&amp;gt;right); int leftDepth = dfs(root-&amp;gt;left); int rightDepth = dfs(root-&amp;gt;right); int val = std::abs(leftDepth - rightDepth); return val &amp;gt; 1 ? false : true &amp;amp;&amp;amp; left &amp;amp;&amp;amp; right; }};" }, { "title": "LeetCode - 171. Excel Sheet Column Number", "url": "/posts/ps-leetcode-171/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Math", "date": "2020-08-11 07:26:00 +0900", "snippet": " 171. Excel Sheet Column Number - easy문제Given a column title as appear in an Excel sheet, return its corresponding column number.For example: A -&amp;gt; 1 B -&amp;gt; 2 C -&amp;gt; 3 ... Z -&amp;gt; 26 AA -&amp;gt; 27 AB -&amp;gt; 28 ...제한사항 1 &amp;lt;= s.length &amp;lt;= 7 s consists only of uppercase English letters. s is between “A” and “FXSHRXW”.입출력 예Example 1:Input: &quot;A&quot;Output: 1Example 2:Input: &quot;AB&quot;Output: 28Example 3:Input: &quot;ZY&quot;Output: 701풀이 Mathclass Solution {public: int titleToNumber(string s) { int result = 0; for(auto i = 0 ; i &amp;lt; s.size() ; ++i) result += pow(26, (s.size() - i) - 1) * ((int)(s[i] - &#39;A&#39;) + 1); return result; }};" }, { "title": "LeetCode - 125. Valid Palindrome", "url": "/posts/ps-leetcode-125/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, String", "date": "2020-08-04 06:31:00 +0900", "snippet": " 125. Valid Palindrome - easy문제Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.Note: For the purpose of this problem, we define empty string as valid palindrome.제한사항 s consists only of printable ASCII characters.입출력 예Example 1:Input: &quot;A man, a plan, a canal: Panama&quot;Output: trueExample 2:Input: &quot;race a car&quot;Output: false풀이 Stringclass Solution {public: bool isPalindrome(string s) { string onlyS; for(auto &amp;amp;i : s){ if((&#39;A&#39; &amp;lt;= i &amp;amp;&amp;amp; i &amp;lt;= &#39;Z&#39;) || (&#39;0&#39; &amp;lt;= i &amp;amp;&amp;amp; i &amp;lt;= &#39;9&#39;)) onlyS.push_back(i); else if(&#39;a&#39; &amp;lt;= i &amp;amp;&amp;amp; i &amp;lt;= &#39;z&#39;) onlyS.push_back(std::toupper(i)); } if(onlyS.size() &amp;lt; 2) return true; for(auto i = 0 ; i &amp;lt; onlyS.size() ; ++i) if(onlyS[i] != onlyS[onlyS.size() -1 - i]) return false; return true; }};" }, { "title": "LeetCode - 520. Detect Capital", "url": "/posts/ps-leetcode-520/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, String", "date": "2020-08-04 06:27:00 +0900", "snippet": " 520. Detect Capital - easy문제Given a word, you need to judge whether the usage of capitals in it is right or not.We define the usage of capitals in a word to be right when one of the following cases holds: All letters in this word are capitals, like “USA”. All letters in this word are not capitals, like “leetcode”. Only the first letter in this word is capital, like “Google”.Otherwise, we define that this word doesn’t use capitals in a right way.제한사항입출력 예Example 1:Input: &quot;USA&quot;Output: TrueExample 2:Input: &quot;FlaG&quot;Output: False풀이 Stringclass Solution {public: bool detectCapitalUse(string word) { int count = 0; bool first = false; for(auto i = 0 ; i &amp;lt; word.size() ; ++i){ if(&#39;A&#39; &amp;lt;= word[i] &amp;amp;&amp;amp; word[i] &amp;lt;= &#39;Z&#39;){ if(i == 0) first = true; ++count; } } if((count == 0) || (count == 1 &amp;amp;&amp;amp; first) || (count == word.size())) return true; return false; }};" }, { "title": "LeetCode - 662. Maximum Width of Binary Tree", "url": "/posts/ps-leetcode-662/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Tree, DFS, BFS", "date": "2020-07-30 08:21:00 +0900", "snippet": " 662. Maximum Width of Binary Tree - medium문제Given a binary tree, write a function to get the maximum width of the given tree. The maximum width of a tree is the maximum width among all levels.The width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level, where the null nodes between the end-nodes are also counted into the length calculation.It is guaranteed that the answer will in the range of 32-bit signed integer제한사항 The given binary tree will have between 1 and 3000 nodes.입출력 예Example 1:Input: 1 / \\ 3 2 / \\ \\ 5 3 9 Output: 4Explanation: The maximum width existing in the third level with the length 4 (5,3,null,9).Example 2:Input: 1 / 3 / \\ 5 3 Output: 2Explanation: The maximum width existing in the third level with the length 2 (5,3).Example 3:Input: 1 / \\ 3 2 / 5 Output: 2Explanation: The maximum width existing in the second level with the length 2 (3,2).Example 4:Input: 1 / \\ 3 2 / \\ 5 9 / \\ 6 7Output: 8Explanation:The maximum width existing in the fourth level with the length 8 (6,null,null,null,null,null,null,7).풀이 Tree, DFS, BFS/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int widthOfBinaryTree(TreeNode* root) { if (!root) { return 0; } // Tree의 level별 값이 있는 위치의 인덱스를 저장하는 map std::map&amp;lt;int,std::vector&amp;lt;uint64_t&amp;gt;&amp;gt; m; std::queue&amp;lt;std::pair&amp;lt;TreeNode*, std::pair&amp;lt;uint64_t, uint64_t&amp;gt;&amp;gt;&amp;gt; q; q.push({root, {1, 1}}); // BFS while (!q.empty()) { auto item = q.front(); q.pop(); // 현재 node위치의 인덱스 계산하여 queue에 저장 // left node는 부모 node의 인덱스에 2*index, // right node는 부모 node의 인덱스에 2*index + 1 이다 if (item.first-&amp;gt;left) { uint64_t index = item.second.second * 2; m[item.second.first + 1].push_back(index); q.push({item.first-&amp;gt;left, {item.second.first + 1, index}}); } if (item.first-&amp;gt;right) { uint64_t index = (item.second.second * 2) + 1; m[item.second.first + 1].push_back(index); q.push({item.first-&amp;gt;right, {item.second.first + 1, index}}); } } int res = 1; for (auto&amp;amp; level : m) { if (level.second.size() &amp;lt; 2) { continue; } int val = level.second.back() - level.second.front() + 1; if (res &amp;lt; val) { res = val; } } return res; }};" }, { "title": "LeetCode - 1480. Running Sum of 1d Array", "url": "/posts/ps-leetcode-1480/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Array", "date": "2020-07-28 08:30:00 +0900", "snippet": " 1480. Running Sum of 1d Array - easy문제Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.Find all the elements of [1, n] inclusive that do not appear in this array.Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.제한사항입출력 예Example:Input:[4,3,2,7,8,2,3,1]Output:[5,6]풀이 Arrayclass Solution {public: vector&amp;lt;int&amp;gt; findDisappearedNumbers(vector&amp;lt;int&amp;gt;&amp;amp; nums) { std::vector&amp;lt;int&amp;gt; res; // nums의 값과 index를 매칭 // nums의 값에 대응하는 nums의 인덱스의 값(nums[nums[i]])을 // * -1 하여 해당 인덱스는 존재하는 것을 표시 // 최종적으로 nums에 남아있는 양수값의 값을 가진 인덱스들이 // nums 배열의 값에 존재하지 않는 인덱스가 된다. for (auto i = 0 ; i &amp;lt; nums.size() ; ++i) { int index = nums[i] &amp;gt; 0 ? nums[i] - 1 : (nums[i] * -1) - 1 ; if (nums[index] &amp;gt; 0) { nums[index] *= -1; } } for (auto i = 0 ; i &amp;lt; nums.size() ; ++i) { if (nums[i] &amp;gt; 0) { res.push_back(i+1); } } return res; }};" }, { "title": "LeetCode - 448. Find All Numbers Disappeared in an Array", "url": "/posts/ps-leetcode-448/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Array", "date": "2020-07-28 07:23:00 +0900", "snippet": " 448. Find All Numbers Disappeared in an Array - easy문제Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]).Return the running sum of nums.제한사항 1 &amp;lt;= nums.length &amp;lt;= 1000 10^6 &amp;lt;= nums[i] &amp;lt;= 10^6입출력 예Example :Input: nums = [1,2,3,4]Output: [1,3,6,10]Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].풀이 Arrayclass Solution {public: vector&amp;lt;int&amp;gt; runningSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; res; int val = 0; for (auto&amp;amp;i : nums) { val += i; res.push_back(val); } return res; }};" }, { "title": "LeetCode - 797. All Paths From Source to Target", "url": "/posts/ps-leetcode-797/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Graph, BFS", "date": "2020-07-25 06:45:00 +0900", "snippet": " 797. All Paths From Source to Target - medium문제Given a directed, acyclic graph of N nodes. Find all possible paths from node 0 to node N-1, and return them in any order.The graph is given as follows: the nodes are 0, 1, …, graph.length - 1. graph[i] is a list of all nodes j for which the edge (i, j) exists.제한사항 The number of nodes in the graph will be in the range [2, 15]. You can print different paths in any order, but you should keep the order of nodes inside one path.입출력 예Example:Input: [[1,2], [3], [3], []] Output: [[0,1,3],[0,2,3]] Explanation: The graph looks like this:0---&amp;gt;1| |v v2---&amp;gt;3There are two paths: 0 -&amp;gt; 1 -&amp;gt; 3 and 0 -&amp;gt; 2 -&amp;gt; 3.풀이 Graph, BFSclass Solution {public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; allPathsSourceTarget(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; graph) { int n = graph.size(); int dst = n - 1; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; for (auto&amp;amp; index : graph[0]) { std::queue&amp;lt;std::pair&amp;lt;int, std::vector&amp;lt;int&amp;gt;&amp;gt;&amp;gt; q; q.push({index, {index}}); // BFS while(!q.empty()) { auto item = q.front(); q.pop(); if (item.first == dst) { item.second.insert(item.second.begin(), 0); res.push_back(item.second); } for (auto&amp;amp; k : graph[item.first]){ std::vector&amp;lt;int&amp;gt; temp(item.second); temp.push_back(k); q.push({k, temp}); } } } return res; }};" }, { "title": "Chromium - Getting Around the Chromium Source Code Directory Structure", "url": "/posts/chromium_Getting_Around_the_Chromium_Source_Code_Directory_Structure/", "categories": "Chromium", "tags": "Chromium", "date": "2020-07-24 08:23:00 +0900", "snippet": "Getting Around the Chromium Source Code Directory StructureHigh-level overviewChromium is separated into two main parts (excluding other libraries): the browser and the renderer (which includes Blink, the web engine). The browser is the main process and represents all the UI and I/O. The renderer is the (often) per-tab sub-process that is driven by the browser. It embeds Blink to do layout and rendering.You will want to read and become familiar with our multi-process architecture and how Chromium displays web pages.Top-level projectsWhen you check out Chromium, you will notice a number of top-level directories. These projects are as follows: android_webview : Provides a facade over src/content suitable for integration into the android platform. NOT intended for usage - individual android applications (APK). More information about the Android WebView source code organization. apps : Chrome packaged apps. base : Common code shared between all sub-projects. This contains things like string manipulation, generic utilities, etc. - things here only if it must be shared between more than one other top-level project. breakpad : Google’s open source crash reporting project. This is pulled directly from Google Code’s Subversion repository. build : Build-related configuration shared by all projects. cc : The Chromium compositor implementation. chrome : The Chromium browser (see below). chrome /test/data: Data files for running certain tests. components : directory for components that have the Content Module as the uppermost layer they depend on. content : The core code needed for a multi-process sandboxed browser (see below). More information about why we have separated - this code. device : Cross-platform abstractions of common low-level hardware APIs. net : The networking library developed for Chromium. This can be used separately from Chromium when running our simple - in the webkit repository. See also chrome/common/net. sandbox : The sandbox project which tries to prevent a hacked renderer from modifying the system. skia + third_party/skia : Google’s Skia graphics library. Our additional classes in ui/gfx wrap Skia. sql : Our wrap around sqlite. testing : Contains Google’s open-sourced GTest code which we use for unit testing. third_party : 200+ small and large “external” libraries such as image decoders, compression libraries and the web engine Blink (here because it inherits license limitations from WebKit). Adding new packages. …/blink/renderer: The web engine responsible for turning HTML, CSS and scripts into paint commands and other state changes. tools ui/gfx : Shared graphics classes. These form the base of Chromium’s UI graphics. ui/views : A simple framework for doing UI development, providing rendering, layout and event handling. Most of the browser UI implemented in this system. This directory contains the base objects. Some more browser-specific objects are in chrome/browser/ui views. url : Google’s open source URL parsing and canonicalization library. v8 : The V8 Javascript library. This is pulled directly from Google Code’s Subversion repository.For historical reasons, there are some small top level directories. Going forward, the guidance is that new top level directories are for applications (e.g. Chrome, Android WebView, Ash). Even if these applications have multiple executables, the code should be in subdirectories of the applicationHere’s a slightly dated diagram of the dependencies. In particular, WebKit is replaced by blink/renderer. A module that is lower can’t include code from a higher module directly (i.e. content can’t include a header from chrome), but talks to it using embedder APIs.Quick reference for the directory tree under “content/”browser: The backend for the application which handles all I/O and communication with the child processes . This talks to the renderer to manage web pages.common: Files shared between the multiple processes (i.e. browser and renderer, renderer and plugin, etc...). This is the code specific to Chromium (and not applicable to being in base).gpu: Code for the GPU process, which is used for 3D compositing and 3D APIs.plugin: Code for running browser plugins in other processes.ppapi_plugin: Code for the Pepper plugin process.renderer: Code for the subprocess in each tab. This embeds WebKit and talks to browser for I/O.utility: Code for running random operations in a sandboxed process. The browser process uses it when it wants to run an operation on untrusted data.worker: Code for running HTML5 Web Workers.Quick reference for the directory tree under “chrome/”app: The &quot;app&quot; is the most basic level of the program. It is run on startup, and dispatches to either the browser or renderer code depending on which capabilities the current process is in. It contains the projects for chrome.exe and chrome.dll. You won&#39;t generally need to change this stuff except for resources like images and strings. locales: Projects for building localized DLLs. resources: Icons and cursors. theme: Images for the theme of the window. browser: The frontend including the main window, UI, and the backend for the application which handles all I/O and storage. This talks to the renderer to manage web pages. ui model, view and controller code for UI features and functionalitycommon: Files shared between the browser and the renderer that is specific to the Chrome module. net: Some Chromium-specific stuff on top of the net top-level module. This should be merged with browser/net.installer: Source files and projects for making the installer (MSI package).renderer: Chrome specific code that runs in the renderer process. This adds Chrome features like autofill, translate etc to the content module.test: automation: Used by tests to drive the browser UI, for example, in test/ui, test/startup, etc. This communicates with browser/automation in the browser. page_cycler: Code for running page cycler tests (for performance measurement). See tools/perf/dashboard. reliability: Reliability tests for distributed testing of page loads for reliability metrics and crash finding. selenium: Code for running the selenium tests, which is a third-party test suite for Ajaxy and JavaScript stuff. See test/third_party/selenium_core. startup: Tests for measuring startup performance. See tools/perf/dashboard and tools/test/reference_build. ui: UI tests for poking at the browser UI, opening tabs, etc. It uses test/automation for doing most operations. unit: The base code for the unit tests. The test code for individual tests is generally alongside the code it is testing in a *_unittest.cc file. third_party: Third party libraries that are specific to Chromium. Some other third party libraries are in the top-level third_party library.tools build: Tools and random stuff related to building. buildbot: Buildbot configuration. Buildbot manages our automated build system. See third_pary/buildbot. win: Windows build stuff, including some .vsprops files used for project properties and scripts. memory: Tools for memory stuff. Currently includes gflags for setting page heap options. perf/dashboard: Code for converting performance logs (for example test/startup_test) into data and graphs. profiles: Generator for random history data. Used to make test profiles.A personal learning planEventually you’ll have your build setup, and want to get to work. In a perfect world, we would have all the time we needed to read every line of code and understand it before writing our first line of code. In practice, we’d have a hard time reading just the checkins that happen in one day if we did nothing else, so none of us will ever be able to read all of the code. So, what can we do? We suggest you develop your own plan for learning what you need, here are some suggested starting points.Fortunately for us, Chromium has some top quality design docs here. While these can go a bit stale (for instance, when following along, you may find references to files that have been moved or renamed or refactored out of existence), it is awesome to be able to comprehend the way that the code fits together overall.Read the most important dev docsmulti-process-architecturedisplaying-a-web-page-in-chromeinter-process-communicationthreadingSee if your group has any startup docsThere may be some docs that people working on the same code will care about while others don’t need to know as much detail.Learn some of the code idioms:important-abstractions-and-data-structures smart-pointer-guidelineschromium-string-usageLater, as time permits, skim all the design docs, reading where it seems relevant.Get good at using code search (or your code browsing tool of choice)Learn who to ask how the code works hints here.Debug into the code you need to learn, with a debugger if you can, log statements and grepping if you cannot.Look at the differences in what you need to understand and you currently understand. For instance, if your group does a lot of GUI programming, then maybe you can invest time in learning GTK+, Win32, or Cocoa programming.Code paths for common operationsThere is additional information and more examples on how Chromium displays web pages.Application startup Our WinMain function is in chrome/app/main.cc, and is linked in the chrome project. WinMain launches the Google Update Client, which is the installer/autoupdater. It will find the subdirectory for the current version, and load chrome.dll from there. It calls ChromeMain in the newly loaded library, which is in chrome_main.cc in the chrome_dll project.ChromeMain does initialization for common components, and then forwards to either RendererMain in chrome/renderer/renderer_main.cc if the command line flag indicates that this should be a subprocess, or BrowserMain in chrome/browser/browser_main.cc if not to load a new copy of the application. Since this is startup, we’re launching the browser. BrowserMain does common browser initialization. It has different modes for running installed webapps, connecting to the automation system if the browser is being tested, etc. It calls LaunchWithProfile in browser_init.cc which creates a new Browser object in chrome/browser/ui/browser.cc. This object encapsulates one toplevel window in the application. The first tab is appended at this time.Tab startup &amp;amp; initial navigation Browser::AddTab in chrome/browser/ui/browser.cc is called to append a new tab. It will create a new TabContents object from browser/tab_contents/tab_contents.cc TabContents creates a RenderViewHost (chrome/browser/renderer_host/render_view_host.cc) via the RenderViewHostManager’s Init function in chrome/browser/tab_contents/render_view_host_manager.cc). Depending on the SiteInstance, the RenderViewHost either spawns a new renderer process, or re-uses an existing RenderProcessHost. RenderProcessHost is the object in the browser that represents a single renderer subprocess. The NavigationController in chrome/browser/tab_contents/navigation_controller.cc which is owned by the tab contents, is instructed to navigate to the URL for the new tab in NavigationController::LoadURL. “Navigating from the URL bar” from step 3 onward describes what happens from this point.Navigating from the URL barWhen the user types into or accepts an entry in the URL bar, the autocomplete edit box determines the final target URL and passes that to AutocompleteEdit::OpenURL. (This may not be exactly what the user typed - for example, an URL is generated in the case of a search query.)The navigation controller is instructed to navigate to the URL in NavigationController::LoadURL.The NavigationController calls TabContents::Navigate with the NavigationEntry it created to represent this particular page transition. It will create a new RenderViewHost if necessary, which will cause creation of a RenderView in the renderer process. A RenderView won&#39;t exist if this is the first navigation, or if the renderer has crashed, so this will also recover from crashes.Navigate forwards to RenderViewHost::NavigateToEntry. The NavigationController stores this navigation entry, but it is marked as &quot;pending&quot; because it doesn&#39;t know for sure if the transition will take place (maybe the host can not be resolved).RenderViewHost::NavigateToEntry sends a ViewMsg_Navigate to the new RenderView in the renderer process.When told to navigate, RenderView may navigate, it may fail, or it may navigate somewhere else instead (for example, if the user clicks a link). RenderViewHost waits for a ViewHostMsg_FrameNavigate from the RenderView.When the load is &quot;committed&quot; by WebKit (the server responded and is sending us data), the RenderView sends this message, which is handled in RenderViewHost::OnMsgNavigate.The NavigationEntry is updated with the information on the load. In the case of a link click, the browser has never seen this URL before. If the navigation was browser-initiated, as in the startup case, there may have been redirects that have changed the URL.The NavigationController updates its list of navigations to account for this new information.Navigations and session historyEach NavigationEntry stores a page ID and a block of history state data. The page ID is used to uniquely identify a page load, so we know which NavigationEntry it corresponds to. It is assigned when the page is committed commit, so a pending NavigationEntry will have a page ID of -1. The history state data is simply a WebCore::HistoryItem serialized to a string. Included on this item are things like the page URL, subframe URLs, and form data. When the browser initiates the request (typing in the URL bar, or clicking back/forward/reload) A WebRequest is made representing the navigation, along with extra information like a page ID for bookkeeping. New navigations have an ID of -1. Navigations to old entries have the ID assigned to the NavigationEntry when the page was first visited. This extra information will be queried later when the load commits. The main WebFrame is told to load the new request. When the renderer initiates the request (user clicks a link, javascript changes the location, etc): WebCore::FrameLoader is told to load the request via one of its bajillion varied load methods. In either case, when the first packet from the server is received, the load is committed (no longer “pending” or “provisional”). If this was a new navigation, WebCore will create a new HistoryItem and add it to the BackForwardList, a WebCore class. In this way, we can differentiate which navigations are new, and which are session history navigations. RenderView::DidCommitLoadForFrame handles the commit for the load. Here, the previous page’s state is stored in session history, via the ViewHostMsg_UpdateState message. This will tell the browser to update the corresponding NavigationEntry (identified by RenderView’s current page ID) with the new history state. RenderView’s current page ID is updated to reflect the committed page. For a new navigation, a new unique page ID is generated. For a session history navigation, it will be the page ID originally assigned when it was first visited, which we had stored on the WebRequest when initiating the navigation. A ViewHostMsg_FrameNavigate message is sent to the browser, updating the corresponding NavigationEntry (identified by RenderView’s newly updated page ID) with the new URL and other information." }, { "title": "LeetCode - 79. Word Search", "url": "/posts/ps-leetcode-79/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Back Tracking, DFS", "date": "2020-07-22 20:56:00 +0900", "snippet": " 79. Word Search - medium문제Given a 2D board and a word, find if the word exists in the grid.The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.제한사항 board and word consists only of lowercase and uppercase English letters. 1 &amp;lt;= board.length &amp;lt;= 200 1 &amp;lt;= board[i].length &amp;lt;= 200 1 &amp;lt;= word.length &amp;lt;= 10^3입출력 예Example:board =[ [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;], [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;], [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]]Given word = &quot;ABCCED&quot;, return true.Given word = &quot;SEE&quot;, return true.Given word = &quot;ABCB&quot;, return false.풀이 Back Tracking, DFSclass Solution {public: bool backTracking(std::string&amp;amp; word, int wordIndex, vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board, int i, int j) { if (wordIndex &amp;gt;= word.size()) { return true; } if ((0 &amp;gt; i || i &amp;gt;= height) || (0 &amp;gt; j || j &amp;gt;= width) || wordIndex &amp;gt;= word.size() || board[i][j] != word[wordIndex]) { return false; } char temp = board[i][j]; board[i][j] = &#39;0&#39;; bool res = backTracking(word, wordIndex + 1, board, i + 1, j) || backTracking(word, wordIndex + 1, board, i - 1, j) || backTracking(word, wordIndex + 1, board, i, j + 1) || backTracking(word, wordIndex + 1, board, i, j - 1); board[i][j] = temp; return res; } bool exist(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board, string word) { height = board.size(); width = board[0].size(); for (int i = 0 ; i &amp;lt; height ; ++i) { for (int j = 0 ; j &amp;lt; width ; ++j) { if(backTracking(word, 0, board, i, j)) { return true; } } } return false; }private: int height; int width;};" }, { "title": "Chromium - Multi-process Architecture", "url": "/posts/chromium_/", "categories": "Chromium", "tags": "Chromium", "date": "2020-07-22 08:56:00 +0900", "snippet": "Multi-process ArchitectureThis document describes Chromium’s high-level architecture.Problem절대 Crash 나 hang이 발생하지 않는 Rendering engine을 구성하는것은 거의 불가능 하다. 완벽하게 안전한 Rendering engine을 구성하는 것 또한 거의 불가능 하다.2006년도 무렵의 Web browser는 단일 사용자인 co-operatively한 multi-tasked 운영체제와 비슷하다. 잘못 동작하는 application으로 인하여 운영체제의 모든 시스템이 멈추는 것 처럼 잘못 동작하는 web page가 web browser의 동작이 멈췄다. 하나의 browser 또는 plug-in의 버그로 인하여 전체 browser 그리고 실행중인 모든 탭이 다운될수 있었다.현대의 운영체제는 application이 서로가 분리된 프로세스로 동작하기 때문에 더 강력하다. 하나의 application의 crash는 다른 application이나 운영체제의 무결성을 손상시키지 않고, 각각의 사용자는 다른 사용자 데이터의 접근이 제한되어 진다.Architectural overviewChromium은 rendering engine에서의 버그나 결함으로 부터 전체 application을 보호하기 위해 browser tab에 별도의 프로세스를 사용한다. 또한 rendering engine 프로세스가 다른 프로세스나 나머지 시스템에 접근하는 것을 금지한다. 이는 web browsing하는데 있어 memory protection과 access control에 대한 이점을 준다.Chromium은 UI를 실행하고 tab과 plugin processes를 “browser process”또는 “browser”로써 관리하는 main process를 제공한다. 아와 비슷하게, tab별 프로세스를 “render processes”또는 “renderers”라고 부른다. renderer는 HTML을 해석하고 표현하기위해 오픈소스 layout engine인 Blink를 사용한다.Managing render processes각 render 프로세스는 parent browser 프로세스와 통신을 관리하고, global state를 유지하는 global RenderProcess object를 가지고 있다. browser는 각 render 프로세스와 대응되는 RenderProcessHost를 유지한다. RenderProcessHost는 browser state를 관리하고 renderer와 통신하는 역활을 한다. browser와 renderer들은 Chromium의 IPC system을 이용하여 통신한다.Managing views각 render 프로세스는 RenderProcess에 의해 관리되고 tab들의 content에 해당하는 RenderView objects를 하나이상 가지고 있다. 이 RenderProcessHost는 각 render가 가지고 있는 view와 대응되는 RenderViewHost를 유지한다. 각각의 view에는 동일한 renderer에서 여러 view들과 구별하기 위해, view ID가 주어진다. 이 view ID들은 하나의 renderer안에서는 유일하지만, 상위 영역인 browser안에서는 유일하지 않다. 그렇기 때문에 browser에서 view를 구별하기 위해 view ID뿐만아니라 RenderProcessHost도 필요하다. contents의 browser에서 특정 tab로의 통신은, RenderProcessHost에서 RenderProcess와 RenderView에게 message들을 보내는 방법을 알고 있는 RenderViewHost objects를 통해 이루어진다.Components and interfacesIn the render process: RenderProcess는 browser상에서 RenderProcess와 대응되는 RenderProcessHost와의 IPC를 handling한다. 정확히 하나의 render process당 하나의 RenderProcess object가 있다. 이것이 모든 browser와 renderer간의 통신 방식이다. RenderView object는 RenderProcess를 통해 자신과 대응되는 browser 프로세스에 속한 RenderViewHost 와 통신하고, WebKit의 embedding layer이다. 이 object는 tab이나 popup window의 한 web page의 contents를 표현한다.In the browser process: Browser object는 최상위 browser window을 나타낸다. RenderProcessHost object는 browser side에서 하나의 browser ↔ renderer 간 IPC 연결을 나타낸다. browser 프로세스의 하나의 RenderProcessHost는 render 프로세스와 대응된다. RenderViewHost object는 원격 RenderView를 encapsulates 하고, RenderWidgetHost는 browser안의 RenderWidget의 input과 painting을 다룬다.이 동작에 대해 더 상세한 정보를 원하면, How Chromium displays web pages design 문서를 참고하여라.Sharing the render process일반적으로, 새로운 window 또는 tab은 매번 새로운 프로세스에서 열린다. browser는 새로운 프로세스를 생성하고 단일 RenderView를 생성하도록 지시한다.때때로 render 프로세스를 tab이나 window와 공유하도록 해야한다거나 하도록 하고싶을때가 있다. 하나의 web application은, 예를 들면 JavaScript의 window.open를 이용할때, 동기적으로 통신하는 것을 예상하는 새로운 window를 연다. 이와 같은 경우, 새로운 window또는 tab을 생성할때, 이미 열려있는 window와 함께 프로세스를 재사용할 필요가 있다. 또한 만약 프로세스의 수가 너무 많거나, 이미 가고자 하는 domain을 가리키는 프로세스에 새로운 tab을 할당하는 전략을 가지고 있다. 이러한 전략은 Process Models 에서 설명한다.Detecting crashed or misbehaving renderersbrowser 프로세스에 대한 각 IPC 연결은 프로세스 handle을 감시한다. 만역 handle이 신호를 받으면, render 프로세스는 crash 되어지고 tab에 crash를 알린다. 이후, renderer가 crash되었다는 것을 유저에게 알리는 “sad tab” 화면을 보여준다. 이 페이지는 reload 버튼을 누르거나 새로운 탐색을 시작하여 다시 로드 될 수 있다. 이렇게 되면 새로운 프로세스가 없는 것을 알게되고, 새로운 프로세스를 만든다.Sandboxing the rendererrenderer가 별도의 분리된 프로세스로 운영되는 상황에서 sandboxing를 통해 시스템 자원에 대한 접근을 제한하는 기회를 가진다. 예를 들어 renderer의 네트워크에 대한 접근은 오직 parent browser 프로세스만 가능하도록 보장한다. 이와 비슷하게 운영체제의 기본 접근권한을 이용하여 파일시스템에 대한 접근을 제한한다.renderer의 파일시스템과 네트워크 접근제한 이외에, 사용자의 display와 관련된 object에 대한 접근도 제한할 수 있다. 각 render 프로세스는 사용자에게 보이지 않는 별도의 Windows “Desktop“에서 실행되며, 이는 손상된 renderer가 새 창을 열거나 키 입력을 캡처하는 것을 방지할 수 있도록 한다.Giving back memory분리된 프로세스에서 실행되는 renderer의 경우, 숨겨진 tab을 낮은 우선순위로 간주하는 것이 간단해 진다. 일반적으로 Windows상의 최소화된 프로세스는 “available memory” pool에 자동으로 메모리를 넣는다. low-memory 상황에서 Windows는 우선순위가 높은 메모리를 스왑하기 전에 이 메모리를 디스크로 교환하여 사용자가 볼 수 있는 프로그램의 응답성을 높힌다. 이와 같은 원칙을 숨겨진 tab에 적용할 수 있다. render 프로세스가 상위 tab이 없는 경우, 필요한 경우 먼저 메모리를 디스크로 스왑하기 위해 해당 프로세스의 “working set” 크기를 시스템에 힌트로 release 할 수 있다. “working set” 크기를 줄이면 사용자가 두 탭 사이를 전환할 때 탭 전환 성능도 떨어진다는 것을 알게 되었기 때문에, 우리는 이 메모리를 점진적으로 해제한다. 즉, 사용자가 최근에 사용한 탭으로 다시 전환하면 해당 탭의 메모리가 최근에 사용되지 않은 탭보다 호출될 가능성이 더 높다는 것을 의미한다. 모든 프로그램을 실행하기에 충분한 메모리를 가진 사용자들은 이 과정을 전혀 알아차리지 못할 것이다(Windows는 실제로 필요한 경우에만 그러한 데이터를 회수할 것이기 때문에 충분한 메모리가 있을 때 성능 적중 현상이 일어나지 않는다.)이것은 우리가 low-memory 상황에서 더 최적의 메모리 공간을 얻을 수 있도록 도와준다. 거의 사용하지 않는 background tab과 관련된 메모리는 완전히 교환될 수 있고 foreground tab의 데이터는 메모리에 완전히 로드될 수 있다. 이와는 대조적으로, 단일 프로세스 browser는 모든 tab의 데이터를 메모리에 무작위로 분산시킬 것이며, 사용한 데이터와 사용하지 않은 데이터를 이렇게 깨끗하게 분리하는 것은 불가능하여 메모리와 성능을 모두 낭비하게 된다.Plug-ins and Extensions파이어폭스 스타일의 NPAPI 플러그인은 renderer와 별도로 자체 프로세스로 실행되었다. 이것은 Plugin Architecture에 자세히 설명되어 있다.Site Isolation 프로젝트는 renderers간에 더 많은 격리를 제공하는 것을 목표로 하며, 이 프로젝트의 초기 결과물에는 분리된 프로세스에서 Chrome의 HTML/JavaScript 콘텐츠 확장을 실행하는 것이 포함된다. https://www.chromium.org/developers/design-documents/multi-process-architecture" }, { "title": "Chromium - Multi-process Architecture", "url": "/posts/chromium_Multi-process_Architecture/", "categories": "Chromium", "tags": "Chromium", "date": "2020-07-22 08:56:00 +0900", "snippet": "Multi-process ArchitectureThis document describes Chromium’s high-level architecture.Problem절대 Crash 나 hang이 발생하지 않는 Rendering engine을 구성하는것은 거의 불가능 하다. 완벽하게 안전한 Rendering engine을 구성하는 것 또한 거의 불가능 하다.2006년도 무렵의 Web browser는 단일 사용자인 co-operatively한 multi-tasked 운영체제와 비슷하다. 잘못 동작하는 application으로 인하여 운영체제의 모든 시스템이 멈추는 것 처럼 잘못 동작하는 web page가 web browser의 동작이 멈췄다. 하나의 browser 또는 plug-in의 버그로 인하여 전체 browser 그리고 실행중인 모든 탭이 다운될수 있었다.현대의 운영체제는 application이 서로가 분리된 프로세스로 동작하기 때문에 더 강력하다. 하나의 application의 crash는 다른 application이나 운영체제의 무결성을 손상시키지 않고, 각각의 사용자는 다른 사용자 데이터의 접근이 제한되어 진다.Architectural overviewChromium은 rendering engine에서의 버그나 결함으로 부터 전체 application을 보호하기 위해 browser tab에 별도의 프로세스를 사용한다. 또한 rendering engine 프로세스가 다른 프로세스나 나머지 시스템에 접근하는 것을 금지한다. 이는 web browsing하는데 있어 memory protection과 access control에 대한 이점을 준다.Chromium은 UI를 실행하고 tab과 plugin processes를 “browser process”또는 “browser”로써 관리하는 main process를 제공한다. 아와 비슷하게, tab별 프로세스를 “render processes”또는 “renderers”라고 부른다. renderer는 HTML을 해석하고 표현하기위해 오픈소스 layout engine인 Blink를 사용한다.Managing render processes각 render 프로세스는 parent browser 프로세스와 통신을 관리하고, global state를 유지하는 global RenderProcess object를 가지고 있다. browser는 각 render 프로세스와 대응되는 RenderProcessHost를 유지한다. RenderProcessHost는 browser state를 관리하고 renderer와 통신하는 역활을 한다. browser와 renderer들은 Chromium의 IPC system을 이용하여 통신한다.Managing views각 render 프로세스는 RenderProcess에 의해 관리되고 tab들의 content에 해당하는 RenderView objects를 하나이상 가지고 있다. 이 RenderProcessHost는 각 render가 가지고 있는 view와 대응되는 RenderViewHost를 유지한다. 각각의 view에는 동일한 renderer에서 여러 view들과 구별하기 위해, view ID가 주어진다. 이 view ID들은 하나의 renderer안에서는 유일하지만, 상위 영역인 browser안에서는 유일하지 않다. 그렇기 때문에 browser에서 view를 구별하기 위해 view ID뿐만아니라 RenderProcessHost도 필요하다. contents의 browser에서 특정 tab로의 통신은, RenderProcessHost에서 RenderProcess와 RenderView에게 message들을 보내는 방법을 알고 있는 RenderViewHost objects를 통해 이루어진다.Components and interfacesIn the render process: RenderProcess는 browser상에서 RenderProcess와 대응되는 RenderProcessHost와의 IPC를 handling한다. 정확히 하나의 render process당 하나의 RenderProcess object가 있다. 이것이 모든 browser와 renderer간의 통신 방식이다. RenderView object는 RenderProcess를 통해 자신과 대응되는 browser 프로세스에 속한 RenderViewHost 와 통신하고, WebKit의 embedding layer이다. 이 object는 tab이나 popup window의 한 web page의 contents를 표현한다.In the browser process: Browser object는 최상위 browser window을 나타낸다. RenderProcessHost object는 browser side에서 하나의 browser ↔ renderer 간 IPC 연결을 나타낸다. browser 프로세스의 하나의 RenderProcessHost는 render 프로세스와 대응된다. RenderViewHost object는 원격 RenderView를 encapsulates 하고, RenderWidgetHost는 browser안의 RenderWidget의 input과 painting을 다룬다.이 동작에 대해 더 상세한 정보를 원하면, How Chromium displays web pages design 문서를 참고하여라.Sharing the render process일반적으로, 새로운 window 또는 tab은 매번 새로운 프로세스에서 열린다. browser는 새로운 프로세스를 생성하고 단일 RenderView를 생성하도록 지시한다.때때로 render 프로세스를 tab이나 window와 공유하도록 해야한다거나 하도록 하고싶을때가 있다. 하나의 web application은, 예를 들면 JavaScript의 window.open를 이용할때, 동기적으로 통신하는 것을 예상하는 새로운 window를 연다. 이와 같은 경우, 새로운 window또는 tab을 생성할때, 이미 열려있는 window와 함께 프로세스를 재사용할 필요가 있다. 또한 만약 프로세스의 수가 너무 많거나, 이미 가고자 하는 domain을 가리키는 프로세스에 새로운 tab을 할당하는 전략을 가지고 있다. 이러한 전략은 Process Models 에서 설명한다.Detecting crashed or misbehaving renderersbrowser 프로세스에 대한 각 IPC 연결은 프로세스 handle을 감시한다. 만역 handle이 신호를 받으면, render 프로세스는 crash 되어지고 tab에 crash를 알린다. 이후, renderer가 crash되었다는 것을 유저에게 알리는 “sad tab” 화면을 보여준다. 이 페이지는 reload 버튼을 누르거나 새로운 탐색을 시작하여 다시 로드 될 수 있다. 이렇게 되면 새로운 프로세스가 없는 것을 알게되고, 새로운 프로세스를 만든다.Sandboxing the rendererrenderer가 별도의 분리된 프로세스로 운영되는 상황에서 sandboxing를 통해 시스템 자원에 대한 접근을 제한하는 기회를 가진다. 예를 들어 renderer의 네트워크에 대한 접근은 오직 parent browser 프로세스만 가능하도록 보장한다. 이와 비슷하게 운영체제의 기본 접근권한을 이용하여 파일시스템에 대한 접근을 제한한다.renderer의 파일시스템과 네트워크 접근제한 이외에, 사용자의 display와 관련된 object에 대한 접근도 제한할 수 있다. 각 render 프로세스는 사용자에게 보이지 않는 별도의 Windows “Desktop“에서 실행되며, 이는 손상된 renderer가 새 창을 열거나 키 입력을 캡처하는 것을 방지할 수 있도록 한다.Giving back memory분리된 프로세스에서 실행되는 renderer의 경우, 숨겨진 tab을 낮은 우선순위로 간주하는 것이 간단해 진다. 일반적으로 Windows상의 최소화된 프로세스는 “available memory” pool에 자동으로 메모리를 넣는다. low-memory 상황에서 Windows는 우선순위가 높은 메모리를 스왑하기 전에 이 메모리를 디스크로 교환하여 사용자가 볼 수 있는 프로그램의 응답성을 높힌다. 이와 같은 원칙을 숨겨진 tab에 적용할 수 있다. render 프로세스가 상위 tab이 없는 경우, 필요한 경우 먼저 메모리를 디스크로 스왑하기 위해 해당 프로세스의 “working set” 크기를 시스템에 힌트로 release 할 수 있다. “working set” 크기를 줄이면 사용자가 두 탭 사이를 전환할 때 탭 전환 성능도 떨어진다는 것을 알게 되었기 때문에, 우리는 이 메모리를 점진적으로 해제한다. 즉, 사용자가 최근에 사용한 탭으로 다시 전환하면 해당 탭의 메모리가 최근에 사용되지 않은 탭보다 호출될 가능성이 더 높다는 것을 의미한다. 모든 프로그램을 실행하기에 충분한 메모리를 가진 사용자들은 이 과정을 전혀 알아차리지 못할 것이다(Windows는 실제로 필요한 경우에만 그러한 데이터를 회수할 것이기 때문에 충분한 메모리가 있을 때 성능 적중 현상이 일어나지 않는다.)이것은 우리가 low-memory 상황에서 더 최적의 메모리 공간을 얻을 수 있도록 도와준다. 거의 사용하지 않는 background tab과 관련된 메모리는 완전히 교환될 수 있고 foreground tab의 데이터는 메모리에 완전히 로드될 수 있다. 이와는 대조적으로, 단일 프로세스 browser는 모든 tab의 데이터를 메모리에 무작위로 분산시킬 것이며, 사용한 데이터와 사용하지 않은 데이터를 이렇게 깨끗하게 분리하는 것은 불가능하여 메모리와 성능을 모두 낭비하게 된다.Plug-ins and Extensions파이어폭스 스타일의 NPAPI 플러그인은 renderer와 별도로 자체 프로세스로 실행되었다. 이것은 Plugin Architecture에 자세히 설명되어 있다.Site Isolation 프로젝트는 renderers간에 더 많은 격리를 제공하는 것을 목표로 하며, 이 프로젝트의 초기 결과물에는 분리된 프로세스에서 Chrome의 HTML/JavaScript 콘텐츠 확장을 실행하는 것이 포함된다. https://www.chromium.org/developers/design-documents/multi-process-architecture" }, { "title": "LeetCode - 151. Reverse Words in a String", "url": "/posts/ps-leetcode-151/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, String", "date": "2020-07-21 07:38:00 +0900", "snippet": " 151. Reverse Words in a String - medium문제Given an input string, reverse the string word by word.제한사항 A word is defined as a sequence of non-space characters. Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces. You need to reduce multiple spaces between two words to a single space in the reversed string.입출력 예Example 1:Input: &quot;the sky is blue&quot;Output: &quot;blue is sky the&quot;Example 2:Input: &quot; hello world! &quot;Output: &quot;world! hello&quot;Explanation: Your reversed string should not contain leading or trailing spaces.Example 3:Input: &quot;a good example&quot;Output: &quot;example good a&quot;Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.풀이 Stringclass Solution {public: string reverseWords(string s) { std::string result; std::vector&amp;lt;std::string&amp;gt; v; int startIndex = 0; for (auto i = 0 ; i &amp;lt; s.size() ; ++i){ if(s[i+1] == &#39; &#39; || i+1 == s.size()){ std::string sub = s.substr(startIndex, i + 1 - startIndex); sub.erase(remove(sub.begin(), sub.end(), &#39; &#39;), sub.end()); if (sub.size() != 0) { v.push_back(sub); } startIndex = i+2; } } for (auto iter = v.rbegin() ; iter != v.rend() ; ++iter) { if (iter == v.rend() - 1) { result += *iter; } else { result += *iter + &quot; &quot;; } } return result; }};" }, { "title": "LeetCode - 557. Reverse Words in a String III", "url": "/posts/ps-leetcode-557/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, String", "date": "2020-07-21 07:23:00 +0900", "snippet": " 557. Reverse Words in a String III - easy문제Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.제한사항입출력 예Example 1:Input: &quot;Let&#39;s take LeetCode contest&quot;Output: &quot;s&#39;teL ekat edoCteeL tsetnoc&quot;풀이 Stringclass Solution {public: string reverseWords(string s) { std::string result; int startIndex = 0; for(auto i = 0 ; i &amp;lt; s.size() ; ++i){ if(s[i+1] == &#39; &#39; || i+1 == s.size()){ std::string sub = s.substr(startIndex, i + 1 - startIndex); std::reverse(sub.begin(), sub.end()); i+1 == s.size() ? result += sub : result += sub + &#39; &#39;; startIndex = i+2; } } return result; }};" }, { "title": "LeetCode - 347. Top K Frequent Elements", "url": "/posts/ps-leetcode-347/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Hash", "date": "2020-07-21 07:10:00 +0900", "snippet": " 347. Top K Frequent Elements - medium문제Given a non-empty array of integers, return the k most frequent elements.제한사항 You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size. It’s guaranteed that the answer is unique, in other words the set of the top k frequent elements is unique. You can return the answer in any orde입출력 예Example 1:Input: nums = [1,1,1,2,2,3], k = 2Output: [1,2]Example 2:Input: nums = [1], k = 1Output: [1]풀이 Hashbool compare(std::pair&amp;lt;int,int&amp;gt; a, std::pair&amp;lt;int,int&amp;gt; b){ if(a.second == b.second) return a.first &amp;lt; b.first; else return a.second &amp;gt; b.second;}class Solution {public: vector&amp;lt;int&amp;gt; topKFrequent(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { std::vector&amp;lt;int&amp;gt; result; std::vector&amp;lt;std::pair&amp;lt;int,int&amp;gt;&amp;gt; item; std::unordered_map&amp;lt;int, int&amp;gt; m; for(auto &amp;amp;i : nums) ++m[i]; for(auto &amp;amp;[key, val] : m) item.push_back(std::make_pair(key, val)); std::sort(item.begin(), item.end(), compare); for(auto i = 0 ; i &amp;lt; k ; ++i) result.push_back(item[i].first); return result; }};" }, { "title": "LeetCode - 203. Remove Linked List Elements", "url": "/posts/ps-leetcode-203/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Linked List", "date": "2020-07-21 07:05:00 +0900", "snippet": " 203. Remove Linked List Elements - easy문제Remove all elements from a linked list of integers that have value val.제한사항입출력 예Example:Input: 1-&amp;gt;2-&amp;gt;6-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6, val = 6Output: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5풀이 Linked List/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* removeElements(ListNode* head, int val) { if(!head) return NULL; ListNode *node = new ListNode(0); node-&amp;gt;next = head; head = node; while(node-&amp;gt;next != NULL){ if(node-&amp;gt;next-&amp;gt;val == val) node-&amp;gt;next = node-&amp;gt;next-&amp;gt;next; else node = node-&amp;gt;next; } return head-&amp;gt;next; }};" }, { "title": "LeetCode - 100. Same Tree", "url": "/posts/ps-leetcode-100/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Tree, July LeetCoding Challenge", "date": "2020-07-17 08:30:00 +0900", "snippet": " 100. Same Tree - easy문제Given two binary trees, write a function to check if they are the same or not.Two binary trees are considered the same if they are structurally identical and the nodes have the same value.제한사항입출력 예Example 1:Input: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3]Output: trueExample 2:Input: 1 1 / \\ 2 2 [1,2], [1,null,2]Output: falseExample 3:Input: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2]Output: false풀이 Tree/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool isSameTree(TreeNode* p, TreeNode* q) { if (p == nullptr &amp;amp;&amp;amp; q == nullptr) { return true; } else if(p != nullptr &amp;amp;&amp;amp; q == nullptr) { return false; } else if(p == nullptr &amp;amp;&amp;amp; q != nullptr) { return false; } return p-&amp;gt;val == q-&amp;gt;val &amp;amp;&amp;amp; isSameTree(p-&amp;gt;left, q-&amp;gt;left) &amp;amp;&amp;amp; isSameTree(p-&amp;gt;right, q-&amp;gt;right); }};" }, { "title": "LeetCode - 190. Reverse Bits", "url": "/posts/ps-leetcode-190/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Bit Manipulate, July LeetCoding Challenge", "date": "2020-07-17 08:13:00 +0900", "snippet": " 190. Reverse Bits - easy문제Reverse bits of a given 32 bits unsigned integer.제한사항 Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 2 above the input represents the signed integer -3 and the output represents the signed integer -1073741825.입출력 예Example 1:Input: 00000010100101000001111010011100Output: 00111001011110000010100101000000Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.Example 2:Input: 11111111111111111111111111111101Output: 10111111111111111111111111111111Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.풀이 Bit Manipulateclass Solution {public: uint32_t reverseBits(uint32_t n) { string result; uint32_t comp = 1; for(int i = 0 ; i &amp;lt; 32 ; ++i) { result.push_back((char)(((n &amp;gt;&amp;gt; i) &amp;amp; comp) + &#39;0&#39;)); } return std::stoul(result, nullptr, 2); }};" }, { "title": "LeetCode - 15. 3Sum", "url": "/posts/ps-leetcode-15/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Sort, Array, July LeetCoding Challenge", "date": "2020-07-17 07:43:00 +0900", "snippet": " 15. 3Sum - medium문제Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.제한사항 The solution set must not contain duplicate triplets.입출력 예Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]]풀이 Sort, Arrayclass Solution {public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; threeSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.size() &amp;lt; 1) { return {}; } int len = nums.size(); std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; result; // 정렬 sort(nums.begin(), nums.end()); for (auto i = 0 ; i &amp;lt; len - 2 ; ++i) { // 중복을 피하기 위해 이전값과 같은 값이면 넘어감 if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i-1]) { continue; } int one = i; int two = i + 1; int three = len - 1; // nums[one]의 값을 기준으로 다음 두 인덱스의 값을 찾는데, // 이때 Binary Search와 유사하게 검색 while (two &amp;lt; three) { int val = nums[one] + nums[two] + nums[three]; // 정렬 되어 있으므로, // val &amp;lt; 0 이면 두번재 인덱스를 증가 // val &amp;gt; 0 이면 세번째 인덱스를 감소 if (val &amp;lt; 0) { ++two; } else if(val &amp;gt; 0) { --three; } else { result.push_back({nums[one], nums[two], nums[three]}); // 중복을 피하기 위해 같은 값의 인덱스를 넘김 while (two &amp;lt; three &amp;amp;&amp;amp; nums[two] == nums[two+1]) { ++two; } // 중복을 피하기 위해 같은 값의 인덱스를 넘김 while (two &amp;lt; three &amp;amp;&amp;amp; nums[three] == nums[three-1]) { --three; } ++two; --three; } } } return result; }};" }, { "title": "LeetCode - 263. Ugly Number", "url": "/posts/ps-leetcode-263/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Math", "date": "2020-07-08 06:32:00 +0900", "snippet": " 263. Ugly Number - easy문제Write a program to check whether a given number is an ugly number.Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.제한사항 1 is typically treated as an ugly number. Input is within the 32-bit signed integer range: [−231, 231 − 1].입출력 예Example 1:Input: 6Output: trueExplanation: 6 = 2 × 3Example 2:Input: 8Output: trueExplanation: 8 = 2 × 2 × 2Example 3:Input: 14Output: false Explanation: 14 is not ugly since it includes another prime factor 7.풀이 mathfunc isUgly(num int) bool { if (num == 0) { return false } else if (num == 1 || num == 2 || num == 3 || num == 5) { return true; } res := false if (num % 2 == 0) { res = res || isUgly(num/2) } if (num % 3 == 0) { res = res || isUgly(num/3) } if (num % 5 == 0) { res = res || isUgly(num/5) } return res}" }, { "title": "LeetCode - 66. Plus One", "url": "/posts/ps-leetcode-66/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Math, July LeetCoding Challenge", "date": "2020-07-08 06:20:00 +0900", "snippet": " 66. Plus One - easy문제Given a non-empty array of digits representing a non-negative integer, plus one to the integer.The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.You may assume the integer does not contain any leading zero, except the number 0 itself.제한사항입출력 예Example 1:Input: [1,2,3]Output: [1,2,4]Explanation: The array represents the integer 123.Example 2:Input: [4,3,2,1]Output: [4,3,2,2]Explanation: The array represents the integer 4321.풀이 mathclass Solution {public: vector&amp;lt;int&amp;gt; plusOne(vector&amp;lt;int&amp;gt;&amp;amp; digits) { int carry = 0; ++digits[digits.size()-1]; for(auto i = digits.rbegin() ; i != digits.rend() ; ++i){ if(*i + carry &amp;gt;= 10){ *i = (*i + carry) % 10; carry = 1; } else{ *i = (*i + carry); carry = 0; } } if(carry == 1) digits.insert(digits.begin(), 1); return digits; }};" }, { "title": "LeetCode - 463. Island Perimeter", "url": "/posts/ps-leetcode-463/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Math, July LeetCoding Challenge", "date": "2020-07-08 06:15:00 +0900", "snippet": " 463. Island Perimeter - easy문제You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water.Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island.제한사항입출력 예Input:[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]]Output: 16Explanation: The perimeter is the 16 yellow stripes in the image below:풀이 mathclass Solution {public: int islandPerimeter(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { if (grid.size() &amp;lt; 1) { return 0; } int countCell = 0; int countAdjacentCell = 0; int height = grid.size(); int width = grid[0].size(); for (auto i = 0 ; i &amp;lt; height ; ++i) { for (auto j = 0 ; j &amp;lt; width ; ++j) { if (!grid[i][j]) { continue; } ++countCell; if (i-1 &amp;gt;= 0 &amp;amp;&amp;amp; grid[i-1][j]) { ++countAdjacentCell; } if (j-1 &amp;gt;= 0 &amp;amp;&amp;amp; grid[i][j-1]) { ++countAdjacentCell; } } } return (4*countCell) - (2*countAdjacentCell); }};" }, { "title": "LeetCode - 957. Prison Cells After N Days", "url": "/posts/ps-leetcode-957/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Hash, July LeetCoding Challenge", "date": "2020-07-04 08:25:00 +0900", "snippet": " 957. Prison Cells After N Days - medium문제There are 8 prison cells in a row, and each cell is either occupied or vacant.Each day, whether the cell is occupied or vacant changes according to the following rules: If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied. Otherwise, it becomes vacant.(Note that because the prison is a row, the first and the last cells in the row can’t have two adjacent neighbors.)We describe the current state of the prison in the following way: cells[i] == 1 if the i-th cell is occupied, else cells[i] == 0.Given the initial state of the prison, return the state of the prison after N days (and N such changes described above.)제한사항 cells.length == 8 cells[i] is in {0, 1} 1 &amp;lt;= N &amp;lt;= 10^9입출력 예Example 1:Input: cells = [0,1,0,1,1,0,0,1], N = 7Output: [0,0,1,1,0,0,0,0]Explanation: The following table summarizes the state of the prison on each day:Day 0: [0, 1, 0, 1, 1, 0, 0, 1]Day 1: [0, 1, 1, 0, 0, 0, 0, 0]Day 2: [0, 0, 0, 0, 1, 1, 1, 0]Day 3: [0, 1, 1, 0, 0, 1, 0, 0]Day 4: [0, 0, 0, 0, 0, 1, 0, 0]Day 5: [0, 1, 1, 1, 0, 1, 0, 0]Day 6: [0, 0, 1, 0, 1, 1, 0, 0]Day 7: [0, 0, 1, 1, 0, 0, 0, 0]Example 2:Input: cells = [1,0,0,1,0,0,1,0], N = 1000000000Output: [0,0,1,1,1,1,1,0]풀이 hashclass Solution {public: vector&amp;lt;int&amp;gt; prisonAfterNDays(vector&amp;lt;int&amp;gt;&amp;amp; cells, int N) { std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; item; // 순환되는 횟수를 찾을때 까지 계산한 모든 cells를 저장 while (N--) { std::vector&amp;lt;int&amp;gt; temp(8, 0); for (int i = 1; i &amp;lt; 7; i++) { temp[i] = (cells[i - 1] == cells[i + 1]) ? 1 : 0; } // 순환되는 것을 찾으면 인덱스 계산 if (item.size() &amp;amp;&amp;amp; item.front() == temp) { return item[N % item.size()]; } else { item.emplace_back(temp); } cells = temp; } return cells; }};" }, { "title": "LeetCode - 107. Binary Tree Level Order Traversal II", "url": "/posts/ps-leetcode-107/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Hash, BFS, Tree, July LeetCoding Challenge", "date": "2020-07-03 08:31:00 +0900", "snippet": " 107. Binary Tree Level Order Traversal II - easy문제Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).제한사항입출력 예Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7return its bottom-up level order traversal as:[ [15,7], [9,20], [3]]풀이 Hash, BFS, Tree/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrderBottom(TreeNode* root) { if (!root) { return {}; } std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; res; std::map&amp;lt;int, std::vector&amp;lt;int&amp;gt;&amp;gt; m; std::queue&amp;lt;std::pair&amp;lt;TreeNode*, int&amp;gt;&amp;gt; q; // BFS q.push({root, 0}); while (!q.empty()) { auto node = q.front(); q.pop(); // Map에 해당 level의 vector가 없으면 새로 추가 m[node.second].push_back(node.first-&amp;gt;val); if (node.first-&amp;gt;left) { q.push({node.first-&amp;gt;left, node.second + 1}); } if (node.first-&amp;gt;right) { q.push({node.first-&amp;gt;right, node.second + 1}); } } // Map에 저장된 key(트리의 level)의 반대순으로 저장 for (auto iter = m.rbegin() ; iter != m.rend() ; ++iter) { res.emplace_back(iter-&amp;gt;second); } return res; }};}" }, { "title": "LeetCode - 441. Arranging Coins", "url": "/posts/ps-leetcode-441/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Math", "date": "2020-07-03 07:51:00 +0900", "snippet": " 441. Arranging Coins - easy문제You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins.Given n, find the total number of full staircase rows that can be formed.n is a non-negative integer and fits within the range of a 32-bit signed integer.제한사항입출력 예Example 1:n = 5The coins can form the following rows:¤¤ ¤¤ ¤Because the 3rd row is incomplete, we return 2.Example 2:n = 8The coins can form the following rows:¤¤ ¤¤ ¤ ¤¤ ¤Because the 4th row is incomplete, we return 3.풀이 Mathfunc arrangeCoins(n int) int { res, item := 1, 0 sum := 0 for true { sum = res + item if sum &amp;lt; n { item = sum res++; } else if sum == n { return res } else { return res - 1 } } return 0}" }, { "title": "LeetCode - 49. Group Anagrams", "url": "/posts/ps-leetcode-49/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Hash", "date": "2020-07-03 07:22:00 +0900", "snippet": " 49. Group Anagrams - medium문제Given an array of strings, group anagrams together.제한사항 All inputs will be in lowercase. The order of your output does not matter.입출력 예Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],Output:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]]풀이 Hashbool compare(vector&amp;lt;string&amp;gt; a, vector&amp;lt;string&amp;gt; b){ return a.size() &amp;lt; b.size();}class Solution {public: vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; groupAnagrams(vector&amp;lt;string&amp;gt;&amp;amp; strs) { vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; result; unordered_map&amp;lt;string, vector&amp;lt;string&amp;gt;&amp;gt; item; for(auto i = 0 ; i &amp;lt; strs.size() ; ++i){ string copy = strs[i]; sort(strs[i].begin(), strs[i].end()); item[strs[i]].push_back(copy); } for(auto &amp;amp;i : item){ vector&amp;lt;string&amp;gt; sub; for(auto j = 0 ; j &amp;lt; i.second.size() ; ++j) sub.push_back(i.second[j]); result.push_back(sub); } return result; }};" }, { "title": "LeetCode - 226. Invert Binary Tree", "url": "/posts/ps-leetcode-226/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Tree, June LeetCoding Challenge", "date": "2020-06-08 04:02:00 +0900", "snippet": " 226. Invert Binary Tree - easy문제Invert a binary tree.제한사항입출력 예Example 1:Input: 4 / \\ 2 7 / \\ / \\1 3 6 9Output: 4 / \\ 7 2 / \\ / \\9 6 3 1풀이 Tree/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func invertTree(root *TreeNode) *TreeNode { if root == nil { return root } invertTree(root.Left) invertTree(root.Right) head := root.Right root.Right = root.Left root.Left = head return root}" }, { "title": "Effective C++ - Item.10", "url": "/posts/effective_c++_item_10/", "categories": "C++, Effective C++", "tags": "C++, Effective C++", "date": "2020-05-23 22:09:00 +0900", "snippet": "대입 연산자는 *this의 참조자를 반환하게 하자내용대입 연산자의 반환 값C++의 대입 연산은 여러 개가 사슬처럼 엮일 수 있는 성질을 가지고 있다.int x, y, z;x = y = z = 15; // 대임이 사슬처럼 이어진다.대입 연산이 가진 또 하나의 특성은 바로 우측 연관(right-associative) 연산이라는 점이다.x = ( y = ( z = 15));위와 같이 대입 연산이 사슬처럼 엮이려면 대입 연잔자가 좌변 인자에 대한 참조자를 반환하도록 구현되어 있을 것이다. 이러한 구현은 일종의 관예(convention)인데, 이는 프로그래머가 만드는 클래스에 대입 연산자가 혹시 들어간다면 이를 따르는 것이 좋다.class Widget { public; ... // 반환 타입은 현재의 클래스에 대한 참조자 이다. Widget&amp;amp; operator=(const Widget&amp;amp; rhs) { ... return *this; // 좌변 객체(의 참조자)를 반환한다. } ...};‘좌변 객체의 참조자를 반환하게 만들자’ 라는 규약은 위의 단순 대입형 연산자 말고도 모든 형태의 대입 연산자에서 지켜져야 한다.class Widget { public; ... // +=, -+, *= 등에도 동일한 규약이 적용된다. Widget&amp;amp; operator+=(const Widget&amp;amp; rhs) { ... return *this; } // 대입 연산자의 매개변수 타이이 일반적이지 않을 때도 동일한 규약을 적용한다. Widget&amp;amp; operator=(int rhs) { ... return *this; } ...};이와 같은 관례를 따르지 않아도 컴파일이 안된다거나 에러를 발생하지는 않는다. 하지만 이 관례는 모든 기본제공 타입들이 따르고 있을 뿐만 아니라 표준 라이브러리에 속한 모든 타입에서도 따르고 있다는 점은 무시할 수 없을 것이다.요점 대입 연산자는 *this의 참조자를 반환하도록 만들자!참고. Effective C++ 3/E - Scott Meyers" }, { "title": "Effective C++ - Item.9", "url": "/posts/effective_c++_item_9/", "categories": "C++, Effective C++", "tags": "C++, Effective C++", "date": "2020-05-23 21:14:00 +0900", "snippet": "객체 생성 및 소멸 과정 중에는 절대로 가상 함수를 호출하지 말자내용파생 클래스 생성시 주의점파생 클래스 객체의 기본 클래스 부분이 생성되는 동안에는, 그 객체의 타입은 바로 기본 클래스이다. 호출되는 가상 함수는 모두 기본 클래스의 것으로 결정(resolve)될 뿐만 아니라, 런타임 타입 정보를 사용하는 언어요소(dynamic_cast, typeid 등)을 사용한다고 해도 이 순간엔 모두 기본 클래스 타입의 객체로 취급한다.객체 생성 과정중에서 가상함수 호출객체 생성 및 소멸 과정에서 가상함수를 호출하면 안된다. 크게 두가지 이유가 있는데, 우선 호출 결과가 원하는대로 돌아가지 않을 것이고, 원하는대로 돌아 간다고 해도 잠재적인 위험를 가지고 있다.주식 거래에 대한 클래스 계통 구조를 구현한다면 아래와 같이 할 수 있다.//모든 거래에 대한 기본 클래스class Transaction { public: Transaction() { ... logTransaction(); // 동작에 대한 로그 기록 } // 타입에 따라 달라지는 로그 기록 virtual void logTransaction() const = 0; ...};// Transaction의 파생 클래스class BuyTransaction : public Transaction { public: // 이 타입에 대한 거래내역의 로깅 구현 virtual void logTransaction() const { ... }};// Transaction의 파생 클래스class SellTransaction : public Transaction { public: // 이 타입에 대한 거래내역의 로깅 구현 virtual void logTransaction() const { ... }};... BuyTransaction b;...BuyTransaction 생성자가 호출되기 전에 Transaction 생성자가 먼저 호출된다. 파생 클래스 객체가 생성될 때 그 객체의 기본 클래스 부분이 파생 클래스 부분보다 먼저 호출되는것이 정석이기 때문이다. Transaction 클래스의 생성자 마지막에 logTransaction() 를 호출하여 로깅을 하게되는데, 이때 호출되는 logTransaction() 는 파생클래스인 BuyTransaction의 logTransaction() 가 아닌 기본 클래스인 Transaction의 logTransaction() 이다. 이와같이 기본 클래스의 생성자가 호출될 동안에는, 가상 함수는 절대로 파생 클래스 쪽으로 내려가지 않는다. 그 대신, 객체 자신이 기본 클래스 타입인 것처럼 동작한다. 즉, 기본 클래스 생성 과정에서는 가상 함수가 동작하지 않는다.위와 같이 동작하는 이유는, 기본 클래스 생성자는 파생 클래스 생성자보다 앞서서 실행되기 때문에, 기본 클래스 생성자가 돌아가고 있는 시점에 파생 클래스 데이터 멤버는 아직 초기화된 상태가 아니라는 것이 핵심이다. 이때 기본 클래스 생성자에서 어떠다 호출된 가상 함수가 파생클래스 쪽으로 내려간다면 어떻게 될 것인가? 파생 클래스 버전의 가상 함수는 파생 클래스만의 데이터 멤버에 접근하여 사용할 것인데, 이때 이 데이터 멤버들은 초기화되기 전 일 것이다. 즉, 파생 클래스의 가상 함수는 초기화되지 않은 데이터 멤버에 접근하여 사용할 것이고, 이는 치명적인 위험을 내포하고 있다.객체 소멸 과정중에서 가상함수 호출객체가 소멸될(소멸자가 호출될) 때도 생성될 때와 똑같이 생각하면 된다. 파생 클래스의 소멸자가 일단 호출되고 나면 파생 클래스만의 데이터 멤버는 정의되지 않은 값으로 가정하기 때문에, 이제부터 이들을 없는 것처럼 취급하고 진행한다. 기본 클래스 소멸자에 진입할 당시의 객체는 기본 클래스 타입의 객체가 되며, 모든 C++ 기능(가상 함수, dynamic_cast, 등) 역시 기본 클래스 객체의 자격으로 처리한다.대처 방법위와 같이 객체 생성, 소멸과정중에 가상함수를 호출하는 문제에 대한 대처 방법은 여러가지가 있는데, 그중 한가지 방법은 가상 함수를 비가상 함수로 바꾸는 것이다.class Transaction { public: explicit Transaction(const std::string&amp;amp; log) { ... // 비가상 함수를 호출 logTransaction(log); } // 비가상 함수로 변경 void logTransaction(const std::string&amp;amp; log) const; ...};class BuyTransaction : public Transaction { public: // 로그 정보를 기본 클래스 생성자로 전달 BuyTransaction( parameters ) : Transaction(createLog( parameters )) { ... } ... private: static std::string createLog( parameters );};기본 클래스 부분이 생성될 떄는 가상 함수를 호출한다 해도 기본 클래스의 울타리를 넘어 내려갈 수 없기 때문에, 필요한 초기화 정보를 파생 클래스 쪽에서 기본 생성자로 ‘올려‘주도록 하여 부족한 부분을 역으로 채울 수 있게 된다.BuyTransaction 클래스애서 선언된 createLog() 이라는 정적 함수가 사용되고 있는 부분에 대하여, 이 함수는 기본 클래스 생성자 쪽으로 넘길 값을 생성하는 용도로 쓰이는 도우미 함수이다. 이 함수는 기본 클래스에 멤버 초기화 리스트가 여러가지로 달려 있는 경우에 특히 유용하게 쓰일수 있다. 정적 멤버로 되어 있기 때문에, 생성이 채 끝나지 않은 BuyTransaction 객체의 초기화 되지 않은 데이터 멤버를 자칫 실수로 접근할 위엄도 없다. 이는 매우 중요한데, ‘초기화 되지 않은 데이터 멤버는 정의되지 않은 상태에 있다’ 라는 사실 때문이다. 비로 이것 때문에 기본 클래스 부분의 생성과 소멸이 진행되고 있는 동안에 호출되는 가상 함수가 무턱대고 파생 클래스 쪽으로 내려가지 않는 것이다.요점 가상 함수라고 해도, 실행중인 생성자나 소멸자에 해당되는 클래스의 파생 클래스 쪼으로 내려가지 않기 때문에 생성자 혹은 소멸자 안에서 가상함수를 호출하지 않는다.참고. Effective C++ 3/E - Scott Meyers" }, { "title": "LeetCode - 402. Remove K Digits", "url": "/posts/ps-leetcode-402/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Greedy, May LeetCoding Challenge", "date": "2020-05-12 06:46:00 +0900", "snippet": " 402. Remove K Digits - medium문제Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.제한사항 The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero.입출력 예Example 1:Input: num = &quot;1432219&quot;, k = 3Output: &quot;1219&quot;Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.Example 2:Input: num = &quot;10200&quot;, k = 1Output: &quot;200&quot;Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.Example 3:Input: num = &quot;10&quot;, k = 2Output: &quot;0&quot;Explanation: Remove all the digits from the number and it is left with nothing which is 0.풀이 Greedyclass Solution {public: string removeKdigits(string num, int k) { string answer; int index = 0; answer.push_back(num[0]); for(auto i = 1 ; i &amp;lt; num.size() &amp;amp;&amp;amp; k &amp;gt;= 0 ; ++i){ while(!answer.empty() &amp;amp;&amp;amp; answer.back() - &#39;0&#39; &amp;gt; num[i] - &#39;0&#39; &amp;amp;&amp;amp; k &amp;gt; 0){ answer.pop_back(); --k; } answer.push_back(num[i]); } for( ; answer.size() &amp;amp;&amp;amp; k &amp;gt; 0 ; --k) answer.pop_back(); size_t first_not_zero = answer.find_first_not_of(&#39;0&#39;); return (first_not_zero == string::npos) ? &quot;0&quot; : answer.substr(first_not_zero); }};" }, { "title": "LeetCode - 540. Single Element in a Sorted Array", "url": "/posts/ps-leetcode-540/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Binary Search, May LeetCoding Challenge", "date": "2020-05-12 06:46:00 +0900", "snippet": " 540. Single Element in a Sorted Array - medium문제You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Find this single element that appears only once.제한사항 Your solution should run in O(log n) time and O(1) space.입출력 예Example 1:Input: [1,1,2,3,3,4,4,8,8]Output: 2Example 2:Input: [3,3,7,7,10,11,11]Output: 10풀이 Binary Search(Best), Divide and Conquer, Hashfunc divide(m map[int]int, nums[] int) { half := len(nums) / 2 if len(nums) &amp;lt;= 1{ m[nums[0]]++ return } leftNums := nums[0 : half] rightNums := nums[half : ] divide(m, leftNums) divide(m, rightNums)}func singleNonDuplicate(nums []int) int { m := make(map[int]int) divide(m, nums) for k, v := range m { if v == 1 { return k } } return 0}" }, { "title": "LeetCode - 733. Flood Fill", "url": "/posts/ps-leetcode-733/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, DFS, BFS, May LeetCoding Challenge", "date": "2020-05-12 06:46:00 +0900", "snippet": " 733. Flood Fill - easy문제An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, “flood fill” the image.To perform a “flood fill”, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on. Replace the color of all of the aforementioned pixels with the newColor.At the end, return the modified image.제한사항 The length of image and image[0] will be in the range [1, 50]. The given starting pixel will satisfy 0 &amp;lt;= sr &amp;lt; image.length and 0 &amp;lt;= sc &amp;lt; image[0].length. The value of each color in image[i][j] and newColor will be an integer in [0, 65535].입출력 예Input: image = [[1,1,1],[1,1,0],[1,0,1]]sr = 1, sc = 1, newColor = 2Output: [[2,2,2],[2,2,0],[2,0,1]]Explanation: From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected by a path of the same color as the starting pixel are colored with the new color.Note the bottom corner is not colored 2, because it is not 4-directionally connectedto the starting pixel.풀이 DFS,BFSclass Solution {public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; floodFill(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; image, int sr, int sc, int newColor) { int n = image.size(); int m = image[0].size(); vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; visited(n, vector&amp;lt;bool&amp;gt;(m, true)); queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; // BFS q.push({sr, sc}); while(!q.empty()){ auto index = q.front(); q.pop(); // 현재 픽셀방문 체크 visited[index.first][index.second] = false; // 현재 픽셀의 4방향 탐샘 for(const auto&amp;amp; i : cardinal){ // 4방향의 index 계산 pair&amp;lt;int, int&amp;gt; newIndex = {index.first + i.first, index.second + i.second}; // image의 index가 범위 이내이며, // 현재 픽셀과 같은 값을 가지며, // 방문한적이 없는 위치의 픽셀을 BFS로 탐색 if( 0 &amp;lt;= newIndex.first &amp;amp;&amp;amp; newIndex.first &amp;lt;= n - 1 &amp;amp;&amp;amp; 0 &amp;lt;= newIndex.second &amp;amp;&amp;amp; newIndex.second &amp;lt;= m - 1 &amp;amp;&amp;amp; image[index.first][index.second] == image[newIndex.first][newIndex.second] &amp;amp;&amp;amp; visited[newIndex.first][newIndex.second]) { q.push(newIndex); } } image[index.first][index.second] = newColor; } return image; }};func floodFill(image [][]int, sr int, sc int, newColor int) [][]int { n := len(image) m := len(image[0]) newImage := image checker := make([][]bool, n) for i := 0 ; i &amp;lt; n ; i++ { checker[i] = make([]bool, m) } offset := [][]int{ {-1, 0}, {1, 0}, {0, 1}, {0, -1} } queue := [][]int{ {sr, sc} } for len(queue) &amp;gt; 0 { index := queue[0] queue = queue[1:] checker[index[0]][index[1]] = true for _, i := range offset { newIndex := []int{ index[0] + i[0], index[1] + i[1] } if (0 &amp;lt;= newIndex[0] &amp;amp;&amp;amp; newIndex[0] &amp;lt; n) &amp;amp;&amp;amp; (0 &amp;lt;= newIndex[1] &amp;amp;&amp;amp; newIndex[1] &amp;lt; m) &amp;amp;&amp;amp; (image[index[0]][index[1]] == image[newIndex[0]][newIndex[1]]) &amp;amp;&amp;amp; (!checker[newIndex[0]][newIndex[1]]) { queue = append(queue, newIndex) } } newImage[index[0]][index[1]] = newColor } return newImage}" }, { "title": "LeetCode - 997. Find the Town Judge", "url": "/posts/ps-leetcode-997/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Array, May LeetCoding Challenge", "date": "2020-05-11 05:36:00 +0900", "snippet": " 997. Find the Town Judge - easy문제In a town, there are N people labelled from 1 to N. There is a rumor that one of these people is secretly the town judge.If the town judge exists, then: The town judge trusts nobody. Everybody (except for the town judge) trusts the town judge. There is exactly one person that satisfies properties 1 and 2.You are given trust, an array of pairs trust[i] = [a, b] representing that the person labelled a trusts the person labelled b.If the town judge exists and can be identified, return the label of the town judge. Otherwise, return -1.제한사항 1 &amp;lt;= N &amp;lt;= 1000 trust.length &amp;lt;= 10000 trust[i] are all different trust[i][0] != trust[i][1] 1 &amp;lt;= trust[i][0], trust[i][1] &amp;lt;= N입출력 예Example 1:Input: N = 2, trust = [[1,2]]Output: 2Example 2:Input: N = 3, trust = [[1,3],[2,3]]Output: 3Example 3:Input: N = 3, trust = [[1,3],[2,3],[3,1]]Output: -1Example 4:Input: N = 3, trust = [[1,2],[2,3]]Output: -1Example 5:Input: N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]Output: 3풀이 Arrayfunc findJudge(N int, trust [][]int) int { item := make([][]int, N+1) for i := range item { item[i] = make([]int, N+1) } for _, row := range trust { item[row[0]][row[1]] = 1 } for i := 1 ; i &amp;lt;= N ; i++ { for j := 1 ; j &amp;lt;=N ; j += 1 { item[0][i] += item[j][i]; item[i][0] += item[i][j]; } } for i := 1 ; i &amp;lt;= N ; i++ { if(item[0][i] == N-1 &amp;amp;&amp;amp; item[i][0] == 0) { return i; } } return -1}" }, { "title": "LeetCode - 1143. Longest Common Subsequence", "url": "/posts/ps-leetcode-1143/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, DP", "date": "2020-05-10 06:24:00 +0900", "snippet": " 1143. Longest Common Subsequence - medium문제Given two strings text1 and text2, return the length of their longest common subsequence.A subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, “ace” is a subsequence of “abcde” while “aec” is not). A common subsequence of two strings is a subsequence that is common to both strings.If there is no common subsequence, return 0.제한사항 1 &amp;lt;= text1.length &amp;lt;= 1000 1 &amp;lt;= text2.length &amp;lt;= 1000 The input strings consist of lowercase English characters only.입출력 예Example 1:Input: text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; Output: 3 Explanation: The longest common subsequence is &quot;ace&quot; and its length is 3.Example 2:Input: text1 = &quot;abc&quot;, text2 = &quot;abc&quot;Output: 3Explanation: The longest common subsequence is &quot;abc&quot; and its length is 3.Example 3:Input: text1 = &quot;abc&quot;, text2 = &quot;def&quot;Output: 0Explanation: There is no such common subsequence, so the result is 0.풀이 DPfunc longestCommonSubsequence(text1 string, text2 string) int { grid := make([][]int, len(text1)+1) for i := 0 ; i &amp;lt;= len(text1) ; i++ { grid[i] = make([]int, len(text2)+1) } for m := 1 ; m &amp;lt;= len(text1) ; m++ { for n := 1 ; n &amp;lt;= len(text2) ; n++ { if text1[m-1] == text2[n-1] { grid[m][n] = grid[m-1][n-1] + 1 } else { if grid[m-1][n] &amp;gt;= grid[m][n-1] { grid[m][n] = grid[m-1][n] } else { grid[m][n] = grid[m][n-1] } } } } return grid[len(text1)][len(text2)]}" }, { "title": "LeetCode - 599. Minimum Index Sum of Two Lists", "url": "/posts/ps-leetcode-599/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Hash", "date": "2020-05-09 09:13:00 +0900", "snippet": " 599. Minimum Index Sum of Two Lists - easy문제Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings.You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement.You could assume there always exists an answer.제한사항 The length of both lists will be in the range of [1, 1000]. The length of strings in both lists will be in the range of [1, 30]. The index is starting from 0 to the list length minus 1. No duplicates in both lists.입출력 예Example 1:Input:[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;][&quot;Piatti&quot;, &quot;The Grill at Torrey Pines&quot;, &quot;Hungry Hunter Steakhouse&quot;, &quot;Shogun&quot;]Output: [&quot;Shogun&quot;]Explanation: The only restaurant they both like is &quot;Shogun&quot;.Example 2:Input:[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;][&quot;KFC&quot;, &quot;Shogun&quot;, &quot;Burger King&quot;]Output: [&quot;Shogun&quot;]Explanation: The restaurant they both like and have the least index sum is &quot;Shogun&quot; with index sum 1 (0+1).풀이 Hashfunc findRestaurant(list1 []string, list2 []string) []string { min := math.MaxInt32 list2Map := make(map[string]int) interestRateMap := make(map[int][]string) for i, v := range list2 { list2Map[v] = i } for i, v := range list1 { val, exist := list2Map[v] if exist { calInterestRate := i + val interestRateMap[calInterestRate] = append(interestRateMap[calInterestRate], v) if calInterestRate &amp;lt; min { min = calInterestRate } } } return interestRateMap[min]}" }, { "title": "LeetCode - 1389. Create Target Array in the Given Order", "url": "/posts/ps-leetcode-1389/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Array", "date": "2020-05-09 09:13:00 +0900", "snippet": " 1389. Create Target Array in the Given Order - easy문제Given two arrays of integers nums and index. Your task is to create target array under the following rules: Initially target array is empty. From left to right read nums[i] and index[i], insert at index index[i] the value nums[i] in target array. Repeat the previous step until there are no elements to read in nums and index. Return the target array.It is guaranteed that the insertion operations will be valid.제한사항 1 &amp;lt;= nums.length, index.length &amp;lt;= 100 nums.length == index.length 0 &amp;lt;= nums[i] &amp;lt;= 100 0 &amp;lt;= index[i] &amp;lt;= i입출력 예Example 1:Input: nums = [0,1,2,3,4], index = [0,1,2,2,1]Output: [0,4,1,3,2]Explanation:nums index target0 0 [0]1 1 [0,1]2 2 [0,1,2]3 2 [0,1,3,2]4 1 [0,4,1,3,2]Example 2:Input: nums = [1,2,3,4,0], index = [0,1,2,3,0]Output: [0,1,2,3,4]Explanation:nums index target1 0 [1]2 1 [1,2]3 2 [1,2,3]4 3 [1,2,3,4]0 0 [0,1,2,3,4]Example 3:Input: nums = [1], index = [0]Output: [1]풀이 Arrayfunc createTargetArray(nums []int, index []int) []int { var target []int for i := 0 ; i &amp;lt; len(nums) ; i++ { target = append(target, 0) copy(target[index[i]+1 : ], target[index[i] : ]) target[index[i]] = nums[i] } return target}" }, { "title": "LeetCode - 1232. Check If It Is a Straight Line", "url": "/posts/ps-leetcode-1232/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Math, May LeetCoding Challenge", "date": "2020-05-09 05:27:00 +0900", "snippet": " 1232. Check If It Is a Straight Line - easy문제You are given an array coordinates, coordinates[i] = [x, y], where [x, y] represents the coordinate of a point.Check if these points make a straight line in the XY plane.제한사항 2 &amp;lt;= coordinates.length &amp;lt;= 1000 coordinates[i].length == 2 -10^4 &amp;lt;= coordinates[i][0], coordinates[i][1] &amp;lt;= 10^4 coordinates contains no duplicate point.입출력 예Input: coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]Output: trueInput: coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]Output: false풀이 Mathfunc checkStraightLine(coordinates [][]int) bool { // x좌표 기반으로 정렬 sort.Slice(coordinates, func(i int, j int) bool { return coordinates[i][0] &amp;lt; coordinates[j][0] }) // 기울기를 구함 var gradient float64 = 0.0 if coordinates[1][0] - coordinates[0][0] != 0 { gradient = float64((coordinates[1][1] - coordinates[0][1])) / float64((coordinates[1][0] - coordinates[0][0])) } for i := 0 ; i &amp;lt; len(coordinates) - 1 ; i++ { // 현재좌표와 다음좌표 사이의 기울기를 구함 calGradient := float64(coordinates[i+1][1] - coordinates[i][1]) / float64(coordinates[i+1][0] - coordinates[i][0]) // 기반 기울기와 현재 계산한 기울기의 값을 비교 if(gradient != calGradient) { return false } } return true}" }, { "title": "LeetCode - 993. Cousins in Binary Tree", "url": "/posts/ps-leetcode-993/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Tree, DFS, BFS, Recursive, May LeetCoding Challenge", "date": "2020-05-09 03:17:00 +0900", "snippet": " 993. Cousins in Binary Tree - easy문제In a binary tree, the root node is at depth 0, and children of each depth k node are at depth k+1.Two nodes of a binary tree are cousins if they have the same depth, but have different parents.We are given the root of a binary tree with unique values, and the values x and y of two different nodes in the tree.Return true if and only if the nodes corresponding to the values x and y are cousins.제한사항 The number of nodes in the tree will be between 2 and 100. Each node has a unique integer value from 1 to 100.입출력 예Input: root = [1,2,3,4], x = 4, y = 3Output: falseInput: root = [1,2,3,null,4,null,5], x = 5, y = 4Output: trueInput: root = [1,2,3,null,4], x = 2, y = 3Output: false풀이 Tree, DFS, BFS, Recursive/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func isCousins(root *TreeNode, x int, y int) bool { xDepth := findDepth(root, x) yDepth := findDepth(root, y) checkSameParent := isSameParent(root, x, y) if (xDepth == yDepth) &amp;amp;&amp;amp; !checkSameParent { return true } return false}// 재귀를 통해 해당 값을 가진 노드의 depth를 구함func findDepth(root *TreeNode, x int) int { if root == nil { return -100 } if root.Val == x { return 0 } depth, left, right := 0, 1, 1 left += findDepth(root.Left, x) right += findDepth(root.Right, x) if left &amp;gt;= 0 { depth = left } else { depth = right } return depth}// 재귀를 통해 해당 값들을 가진 노드들이 같은 부모를 가지고 있는지 검사func isSameParent(root *TreeNode, x int, y int) bool { if root == nil { return false } if root.Left == nil &amp;amp;&amp;amp; root.Right == nil { return false } if root.Left != nil &amp;amp;&amp;amp; root.Right != nil { if (root.Left.Val == x &amp;amp;&amp;amp; root.Right.Val == y) || (root.Left.Val == y &amp;amp;&amp;amp; root.Right.Val == x) { return true } } return isSameParent(root.Left,x,y) || isSameParent(root.Right,x,y)}" }, { "title": "LeetCode - 169. Majority Element", "url": "/posts/ps-leetcode-169/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Divide and Conquer, Hash, May LeetCoding Challenge", "date": "2020-05-07 06:33:00 +0900", "snippet": " 169. Majority Element - easy문제Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.You may assume that the array is non-empty and the majority element always exist in the array.제한사항입출력 예Example 1:Input: [3,2,3]Output: 3Example 2:Input: [2,2,1,1,1,2,2]Output: 2풀이 Divide and Conquer, Hashclass Solution {public: int majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int majorityCount = nums.size() / 2; map&amp;lt;int, int&amp;gt; m; for(auto&amp;amp; i : nums) ++m[i]; for(auto&amp;amp; i : m){ if(i.second &amp;gt; majorityCount) return i.first; } return 0; }};func majorityElement(nums []int) int { result := 0 comp := 0 m := make(map[int]int) for _, v := range(nums) { m[v]++ if(comp &amp;lt; m[v]) { comp = m[v] result = v } } return result}" }, { "title": "LeetCode - 387. First Unique Character in a String", "url": "/posts/ps-leetcode-387/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Hash, May LeetCoding Challenge", "date": "2020-05-06 03:37:00 +0900", "snippet": " 387. First Unique Character in a String - easy문제Given a string, find the first non-repeating character in it and return it’s index.If it doesn’t exist, return -1.제한사항입출력 예Example :s = &quot;leetcode&quot;return 0.s = &quot;loveleetcode&quot;,return 2.풀이 Hashfunc firstUniqChar(s string) int { m := make(map[rune]int) for _, v := range(s) { m[v]++ } for i, v := range(s) { if(m[v] &amp;lt; 2) { return i } } return -1}" }, { "title": "LeetCode - 476. Number Complement", "url": "/posts/ps-leetcode-476/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Bit Manipulate, May LeetCoding Challenge", "date": "2020-05-05 05:40:00 +0900", "snippet": " 476. Number Complement - easy문제Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.제한사항 The given integer is guaranteed to fit within the range of a 32-bit signed integer. You could assume no leading zero bit in the integer’s binary representation.입출력 예Example 1:Input: 5Output: 2Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.Example 2:Input: 1Output: 0Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.풀이 Bit Manipulatefunc findComplement(num int) int { mask := ^0 for ; (num &amp;amp; mask) &amp;gt; 0 ; mask &amp;lt;&amp;lt;= 1 {} return (^mask) ^ num;}" }, { "title": "Effective C++ - Item.8", "url": "/posts/effective_c++_item_8/", "categories": "C++, Effective C++", "tags": "C++, Effective C++", "date": "2020-05-04 23:14:00 +0900", "snippet": "예외가 소멸자를 떠나지 못하도록 붙잡아 놓자내용예외 발생시 소멸자의 입장소멸자에서 예외가 터져 나가는 경우를 C++ 언어에서 막는 것은 아니지만, 실제 상황을 들춰보면 확실히 프로그래머가 직접 막을 수 밖에 없다.class Widget {public: ~Widget() { ... } ...};void doSomething() { std::vector&amp;lt;Widget&amp;gt; v; ...}vector 타입의 객체 v, 다시 말해 벡터 v가 소멸될 때, 자신이 가지고 있는 Widget들 전부를 소멸시킬 책임은 이 벡터에게 있다.v에 들어 있는 Widget이 10개 일 때, 첫번째 것을 소멸시키는 도중에 예외가 발생했다고 가정한다. 나머지 9개는 여전히 소멸되어야 하므로(그렇지 않으면 이들이 가지고 있을지 모르는 자원이 누출된다), v는 이들에 대해 소멸자를 호출해야 할 것이다. 그런데 이 과정에서 문제가 또 발생했다고 했을때, 두 번째 Widget에 대해 호출된 소멸자에서 예외가 던져지면 어떻게 되는가? 현재 활성화된 예외가 동시에 두개나 만들어진 상태이고, C++의 입장에서는 감당하기에 버거워지는 문제가 발생하게 되는 것이다. 이 두 예외가 동시에 발생한 조건이 어떤 미묘한 조건이냐에 따라 프로그램 실행이 종료되는지 아니면 정의되지 않은 동작을 보이게 될 것인데, 이 경우에는 프로그램이 정의되지 않은 동작을 보이게 될 것이다.이는 다른 STL 컨테이너 라든지 TR1 컨테이너, 심지어 배열을 써도 결과는 마찬가지 이다. 그러나 이러한 완전하지 못한 프로그램 종료나 미정의 동작이 발생하는 원인은, 컨테이너나 배열을 썻기 때문에 발생한 문제가 아니라 예외가 터져나오는 것을 내버려 두는 소멸자에게 있다.사용자측에서의 예외처리와 소멸자에서의 예외처리class DBConnection {public: ... static DBConnection create(); // DBConnection 객체를 반환 void close(); // 연결을 끊음. 이때, 연결이 실패하면 예외 발생};위 예제는 사용자가 DBConnection 객체에 대해 close를 직접 호출해야 하는 설계이다. 사용자의 실수를 사전에 차단하는 좋은 방법이라면 DBConnection에 대한 자원 관리 클래스를 만들어서 그 클래스의 소멸자에서 close를 호출하게 만드는 것이 있다.// DBConnection 객체의 관리 클래스class DBConn {public: ... // 연결이 항상 닫히도록 확실히 챙기는 소멸자 ~DBConn() { db.close(); }private: DBConnection db};...{ // 블록 시작 DBConn dbc(DBConnection::create()) // DBConnection 객체를 생성하고, // 이를 DBConn 객체로 넘겨 관리를 위임 ... // DBConn 인터페이스를 통하여 // DBConnection 객체를 사용} // 블록의 끝 // DBConn 객체가 소멸하고, // DBConnection 객체에 대한 // close 함수의 호출이 자동으로 이루어짐위 예제에서, close 일사천리로 성공하면 아무 문제될 것이 없는 코드이다. 그러나 close를 호출 했는데 여기서 예외가 발생했다고 가정하면 어떻게 될 것인가? DBConn의 소멸자는 분명히 이 예외를 전파할 것이다. 즉, 그 소멸자에서 예외가 나가도록 내버려 둔다는 것이다. 바로 이것이 문제이다. 예외를 던지는 소멸자는 곧 ‘걱정거리’를 의미하기 때문이다.이를 피하는 방법은 두가지가 있다. DBConn의 소멸자는 이 두가지 방법중 하나를 선탱할 수 있을 것이다. close에서 예외가 발생하면 프로그램을 바로 종료한다. 대개 abort를 호출한다. DBConn::~DBConn() { try { db.close(); } catch( ... ) { ... // close 호출이 실패했다는 로그 작성 std::abort(); }} close를 호출한 곳에서 일어난 예외를 삼켜 버린다. DBConn::~DBConn() { try { db.close(); } catch( ... ) { ... // close 호출이 실패했다는 로그 작성 }} 대부분의 경우 예외 삼키기는 좋은 발상이 아니다. 무엇이 잘못되었는지를 알려주는 정보와 같이 중요한 정보가 묻혀 버리기 때문이다. 그러나 때에 따라서는 불완전한 프로그램 종요 혹은 미정의 동작으로 인해 입는 위험을 감수하는 것 보다 그냥 예외를 먹어버리는 게 나을 수도 있다. 단, 이 ‘예외 삼키기‘가 제대로 빛을 보려면, 발생 한 예외를 그냥 무시한 뒤라도 프로그램이 쇤뢰성 있게 실행을 지속할 수 있어야 한다.위의 두가지 선택방법 모두 문제점이 보이는 방법들이다. 중요한 것은 close가 최초로 예외를 던지게 된 요인에 대해 프로그램이 어떤 조치를 취할 수 있는가인데, 이러한 부분에 대한 대책이 전부한 상태이다.class DBConn {public: void close() { // 사용자 호출을 위한 인터페이스 제공 db.close; closed = true; } void ~DBConn() { if(!closed) { // 사용자가 연결을 닫지 않았으면, // 소멸자에서 닫는다 try { db.close(); } catch(...) { // 연결을 닫다가 실패하면, // 실패를 알린후에 // 실행을 끝내거나 예외를 삼킨다 ... // close 호출이 실패했다는 로그 작성 } } }private: DBConnection db; bool closed;};close 호출의 책임을 DBConn의 소멸자에서 DBConn의 사용자로 떠넘기는 아이디어는 무책임한 책임전가로 보일 수 있다. 그러나, 어떤 동작이 예외를 일으키면서 실패할 가능성이 있고 또 그 예외를 처리해야 할 필요가 있다면, 그 예외는 소멸자가 아닌 다른 함수에서 비롯된 것이어야 한다 라는 것이 포인트 이다. 이유는 위에서 설명한 바와 같이 예외를 일으키는 소멸자는 시한폭탄이나 마찬가지라서 프로그램의 불완전 종료 혹은 미정의 동작의 위험을 내포하고 있기 때문이다.위 예제에서 사용자가 호출할 수 있는 close 함수를 두고 있기는 하지만 부담을 떠넘기는 모양새가 아니다. 사용자에게 에러를 처리할 수 있는 기회를 주는 것이다. 이것 마저 없다면 사용자는 예외에 대처할 기회를 못잡게 된다. 물론 이 에러를 미리 처리할 것인지, 그냥 무시하여 DBConn의 소멸자에서 에러를 처리할 것인지 선택하는 것은 사용자의 몫이다.요점 소멸자에서는 예외가 빠져나가면 안된다. 만약 소멸자 안에서 호출된 함수가 예외를 던질 가능성이 있다면, 어떤 예외이든지 소멸자에서 모두 받아낸 후에 삼켜 버리든지, 프로그램을 끝내든지 해야 한다. 어떤 클래스의 연산이 진행되다가 던진 예외에 대해 사용자가 반응해야할 필요가 있다면, 해당 연산을 제공하는 함수는 반드시 보통의 함수 즉, 소멸자가 아닌 함수 이여야 한다.참고. Effective C++ 3/E - Scott Meyers" }, { "title": "Effective C++ - Item.7", "url": "/posts/effective_c++_item_7/", "categories": "C++, Effective C++", "tags": "C++, Effective C++", "date": "2020-05-04 22:18:00 +0900", "snippet": "다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자내용가상 소멸자C++의 규정에 의하면, 기본 클래스 포인터를 통해 파생 클래스 객체가 삭제 될때, 그 기본 클래스에 비가상 소멸자가 있으면 프로그램 동작은 미정의 사항이라고 되어 있다. 대개 그 객체의 파생 클래스 부분이 소멸되지 않게 된다.이러한 문제를 해결하기 위한 해결방법으로는 간단하게 기본클래스의 소멸자를 가상 소멸자로 선언하는 것이다.class Base {public: virtual ~Base(); // 가상 소멸자 선언 ...};class Derived : public Base { ... }일반적으로, 가상 함수를 하나라도 가진 클래스는 가상 소멸자를 가져야 하는 것이 대부분 맞는 말이다.어느 경우를 막론하고, 소멸자를 전부 virtual로 선언하는 일은 virtual로 절대 선언하지 않는 것만큼이나 좋지 않은 생각이다. 가상 소멸자를 선언하는 것은 그 클래스에 가상 함수가 하나라도 들어있는 경우에만 한정하는 것이 좋다.Virtual Table가상 소멸자를 가지고 있지 않은 클래스를 만나면 컴파일러는 ‘저 클래스는 기본 클래스로 쓰이지 않는 클래스 구나’ 라고 생각한다. 반대로 생각해도 마찬가지 인데, 기본 클래스로 의도하지 않은 클래스에 대해 가상 소멸자를 선언하는 것은 좋지 않은 경우이다.class Point {public: Point(int xCoord, int yCoord); ~Point();private: int x, y;};int가 32비트를 차지한다고 가정하면, 이 Point 객체는 64비트 레지스터에 딱 맞게 들어 갈수 있을 것이다. 그런데, Point 클래스가 가상 소멸자로 들어가게 되는 순간, 사정이 변하게 된다.가상 함수를 C++에서 구현하려면 클래스에 별도의 자료구조가 하나 더 들어가야 한다. 이 자료구조는 프로그램 실행 중에 주어진 객체에 대해 어떤 가상 함수를 호출해야 하는지를 결정하는데 쓰이는 정보인데, 실체로는 포인터의 형태를 가지는 것이 대부분이고, 대개 vptr(Virtual Table Pointer) 이라는 이름으로 불린다. vptr은 가상함수의 주소, 즉 포인터들의 배열을 가리키고 있으며 가상 함수 테이블 포인터의 배열은 vtbl(Virtual Table) 이라고 불린다.가상함수를 하나라도 가지고 있는 클래스는 반드시 그와 관련된 vtbl을 가지고 있다. 어떤 객체에 대해 어떤 가상함수가 호출되려고 하면, 호출되는 실제 함수는 그 객체의 vptr이 가르키는 vtbl에 따라 결정된다. vtbl에 있는 함수 포인터들 중 적절한 것이 연결되는 것이다.가장 중요한 것은 예제 Point 클래스에 가상 함수가 들어가게 되면, Point 타입 객체의 크기가 커진다는 점이다. 프로그램 실행환경이 32비트 아키텍처라면, 크기가 64비트(int 두개)에서 96비트(int 두개에 vptr하나)로 커지게 된다. 64비트 아키텍처에서는 포인터 크기는 64비트이므로, Point 객체의 크기가 64비트에서 128비트로 커질 수 있다.Point 객체는 가상 함수 테이블 포인터가 하나 추가되었을 뿐인데 크기가 무려 50% 에서 100% 까지 커지게 된다. 또한 C 등의 다른 언어로 선언된 동일한 자료구조와도 호환성이 없어지게 된다. 왜냐하면 다른 언어로 Point와 겉보기가 똑같은 데이터 배치를 써서 선언했다고 해도 vptr만은 어떻게 만들 수 없기 때문이다. 결국, 다른 언어로 작성된 함수에 Point 객체를 전달하고 또 그 함수로부터 전달받을 수 있게 하려면 vptr부분을 어떻게든 보충해 주어야 하는데, 이 부분부터는 구현환결에 따라 세부사항이 달라지는 문제이기 때문에 이식성에 대한 기대는 할 수 없게 된다.가상 소멸자가 없는 클래스들가상함수가 전혀 없는데도 비가상 소멸자 때문에 함정에 빠지는 경우도 있다. 한 예가 표준 string 타입이다. 이 타입은 가상함수를 가지고 있지 않지만, 전후 사정을 무시하고 이 타입을 기본 클래스로 잡아버리는 일부 프로그래머가 있다.// std::string 에는 가상 소멸자가 없다class MyString : public std::string { ... }...MyString* pss = new MyString(&quot;Hello World&quot;);std::string *ps;ps = pss; // MyString* ==&amp;gt; std::string*delete ps; // 정의되지 않은 동작이 발생한다 // 실질적으로는 *ps의 MyString 부분에 있는 자원이 누출되는데, // 그 이유는 MyString의 소멸자가 호출되지 않기 때문이다위와 같은 현상은 가상 소멸자가 없는 클래스면 어떤 것에는 전부 적용 된다. string과 같은 STL 컨테이너 타입 전부가 여기에 속한다.순수 가상 소멸자경우에 따라 순수 가상 소멸자를 두면 편리하게 사용 할 수도 있다. 순수 가상 함수는 해당 클래스를 추상 클래스(Abstract Calss : 그 타입의 객체를 생성할 수 없는) 로 만든다. 하지만 어떤 클래스가 추상 클래스였으면 좋겠는데 마땅히 넣은 만할 순수 가상 함수가 없을 때도 종종 생기게 된다.추상 클래스는 본래 기본 클래스로 쓰일 목적으로 만들어진 것이고, 기본 클래스로 쓰이려는 클래스는 가상 소멸자를 가져야 한다. 한편 순수 가상 함수가 있으면 바로 추상 클래스가 된다. 종합해보면, 추상 클래스로 만들고 싶은 클래스에 순수 가상 소멸자를 선언하는 것이다.class AWOV {public: virtual ~AWOV() = 0; ...};AWOV 클래스는 순수 가상 함수를 가지고 있으므로, 우선 추상 클래스이고, 순수 가상 함수가 가상 소멸자 이므로 앞에서 말한 소멸자 호출 문제로 고민할 필요가 없어지게 된다. 그러나 한가지 짚고 넘어가야 하는 것은, 이 순수 가상 소멸자의 정의를 두지 않으면 안된다는 것이다.// 순수 가상 소멸자의 정의AWOV::~AWOV() {}소멸자가 동작하는 순서는, 상속 계통 구조에서 가장 말단에 있는 파생클래스의 소멸자가 먼저 호출되는 것을 시작으로, 기본 클래스 쪽으로 거쳐 올라가면서 각 기본 클래스의 소멸자가 하나씩 호출된다. 컴파일러는 ~AWOV의 호출 코드를 만들기 위해 파생 클래스의 소멸자를 사용할 것이므로, 잊지 말고 이 함수의 본문을 준비해 두어야 하는 것이다. 만약 이부분을 잊으면 링커 에러가 발생하게 된다.소멸자와 다형성기본 클래스 안에 가상 소멸자를 선언하자는 규칙은 다형성(Polymorphic) 을 가진 기본 클래스, 즉 기본 클래스 인터페이스를 통해 파생 클래스 타입의 조작을 허용하도록 설계된 기본 클래스에만 적용 된다.모든 기본 클래스가 다형성을 가지게 되도록 설계되는 것은 아니다. 앞에서 언급된 string 타입과 , STL 컨테이너 타입과 같이 기본 클래스는 커녕 다형성의 흔적조차 볼 수 없는 클래스도 존재한다. 한편, 기본 클래스로는 쓰일수 있지만 다형성은 가지지 않도록 설계된 클래스도 존재하는데, 이런 클래스는 기본 클래스의 인터페이스를 통한 파생 클래스 객체의 조작이 허용되지 않는다. 이들에게서 가상 소멸자를 볼 수 없는 것은 이러한 이유 때문이다.요점 다형성을 가진 기본 클래스에는 반드시 가상 소멸자를 선언해야 한다. 즉, 어떤 클래스가 가상 함수를 하나라도 가지고 있다면, 이 클래스의 소멸자도 가상 소멸자 이여야 한다. 기본 클래스로 설계되지 않았거나 다형성을 가지도록 설계되지 않은 클래스에는 가상 소멸자를 선언하지 말아야 한다.참고. Effective C++ 3/E - Scott Meyers" }, { "title": "LeetCode - 383. Ransom Note", "url": "/posts/ps-leetcode-383/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Hash, May LeetCoding Challenge", "date": "2020-05-04 04:59:00 +0900", "snippet": " 383. Ransom Note - easy문제Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.Each letter in the magazine string can only be used once in your ransom note.제한사항 You may assume that both strings contain only lowercase letters.입출력 예Example 1:canConstruct(&quot;a&quot;, &quot;b&quot;) -&amp;gt; falsecanConstruct(&quot;aa&quot;, &quot;ab&quot;) -&amp;gt; falsecanConstruct(&quot;aa&quot;, &quot;aab&quot;) -&amp;gt; true풀이 Hashfunc canConstruct(ransomNote string, magazine string) bool { m := make(map[rune]int) for _,v := range(magazine) { m[v]++ } for _,v := range(ransomNote) { i, exist := m[v] if(!exist || i == 0) { return false; } else { m[v]-- } } return true;}" }, { "title": "LeetCode - 771. Jewels and Stones", "url": "/posts/ps-leetcode-771/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Hash, May LeetCoding Challenge", "date": "2020-05-03 04:14:00 +0900", "snippet": "771. Jewels and Stones - easy문제You’re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels.The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so “a” is considered a different type of stone from “A”.제한사항 S and J will consist of letters and have length at most 50. The characters in J are distinct.입출력 예Example 1:Input: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;Output: 3Example 2:Input: J = &quot;z&quot;, S = &quot;ZZ&quot;Output: 0풀이 Hashfunc numJewelsInStones(J string, S string) int { result := 0 m := make(map[rune]int) for _, v := range(J) { m[v]++ } for _,v := range(S) { _, exist := m[v] if(exist) { result++ } } return result}" }, { "title": "Effective C++ - Item.6", "url": "/posts/effective_c++_item_6/", "categories": "C++, Effective C++", "tags": "C++, Effective C++", "date": "2020-05-02 21:08:00 +0900", "snippet": "컴파일러가 만들어낸 함수가 필요 없으면 확실히 이들의 사용을 금하자내용private 멤버로 선언 하기기본적으로 컴파일러가 생성하는 함수는 모두 공개가 되는 public 멤버가 된다. 이러한 컴파일러가 생성하는 함수가 저절로 만들어지는 것을 막기위해 프로그래머가 직접 선언해야 한다는 점은 맞지만, 이들을 public 멤버로 선언해야 한다는 것은 아니다.이러한 함수들을 public이 아닌 private 멤버로 선언하도록 한다면, 일단 클래스 멤버 함수가 명시적으로 선언되기 때문에, 컴파일러는 자신의 시본 버전을 만들 수 없게 된다. 또란 이 함수들은 private의 접근성을 가지므로 외부로부터의 호출을 차단할 수 있다.정의(define) 하지 않기private로 명시적으로 선언된다 하더라도, 그 클래스의 멤버 및 friend 함수가 호출할 수 있다는 허점이 존재한다. 이 허점마저 극복하기 위해서, 해당 함수의 ‘정의(define)’ 자체를 하지 않는 방법이 있다.정의되지 않은 함수를 누군가가 호출하려 했다면, 분명히 링크 시점에 에러를 발생시킬 것이다.class HomeForSales { public: ... private: ... // 선언만 한다 HomeForSales(const HomeForSales&amp;amp;); HomeForSales&amp;amp; operator=(const HomeForSales&amp;amp;);};사용자가 HomeForSales 객체의 복사를 시도하려고 하면, 컴파일러에서 에러를 낼 것이고, 멤버 함수 및 friend 함수안에서 호출한다면 링커에서 에러를 낼 것이다.추가적으로 링크 시점의 에러를 컴파일 시점의 에러로 옮길 수 있다. 이는 에러 탐지를 나중에 미루는 것보다 미리 아는 것이 좋기 때문에 유용하다. 이 방법은 복사 생성자와 복사 대입 연산자를 private로 선언하되, 이것을 HomeForSales 자체에 넣지 말고 별도의 기본 클래스에 넣고 이것으로부터 HoomeForSales를 파생시키는 것이다. 그리고 그 별도의 기본 클래스는 복사 방지만 맡는다는 특별한 의미를 부여한다.class UnCopyable { protected: // 파생된 객체에 대해서 생성과 소멸을 허용 UnCopyable() {} ~UnCopyable() {} private: // 복사에 대해 방지 UnCopyable(const UnCopyable&amp;amp;); UnCopyable&amp;amp; operator=(const UnCopyable&amp;amp;);};// 기본 클래스를 private로 상속함으로써// 복사 생성자도, 복사 대입 연산자도 이제는 선언되지 않는다class HomeForSales : private UnCopyable { ...};복사 방지 기본클래스의 구현와 사용법위의 예의 복사 방지를 위한 기본 클래스(UnCopyable)의 구현과 사용법에 대하여 몇가지 중점이 있다.UnCopyable로부터의 상속은 public일 필요가 없다. 그리고 UnCopyable의 소멸자는 가상 소멸자가 아니여도 된다. 또한 UnCopyable 클래스는 데이터 멤버가 전혀 없기 때문에 추후 Item.39에서 공부하게될 공백 기본 클래스 최적화(Empty Base Class Optimization) 기법이 적용될 여지가 있지만, UnCopyable 클래스는 기본 클래스이기 때문에 이 기법을 사용하게 되면 다중 상속으로 갈 가능성이 있다. 그렇게 되면 다중 상속이 문제가 되는데, 다중 상속 시에는 공백 기본 클래스 최적화가 돌아가지 못할 때가 종종 존재한다.요점 컴파일러에서 자동으로 제공하는 기능을 허용하지 않으려면, 대응되는 멤버 함수를 private로 선언한 후에 구현은 하지 않은 채로 둔다. UnCopyable과 같이 복사 방지 기본 클래스를 사용하는것도 좋은 방법이다.참고. Effective C++ 3/E - Scott Meyers" }, { "title": "LeetCode - 278. First Bad Version", "url": "/posts/ps-leetcode-278/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Binary Search, May LeetCoding Challenge", "date": "2020-05-02 06:24:00 +0900", "snippet": " 278. First Bad Version - easy문제You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad.You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.제한사항#입출력 예Example :Given n = 5, and version = 4 is the first bad version.call isBadVersion(3) -&amp;gt; falsecall isBadVersion(5) -&amp;gt; truecall isBadVersion(4) -&amp;gt; trueThen 4 is the first bad version. 풀이 Binary Search/** * Forward declaration of isBadVersion API. * @param version your guess about first bad version * @return true if current version is bad * false if current version is good * func isBadVersion(version int) bool; */func firstBadVersion(n int) int { low := 1 high := n for low &amp;lt; high { var mid int = low + (high - low) / 2 if(isBadVersion(mid)) { high = mid } else { low = mid + 1 } } return low}" }, { "title": "Effective C++ - Item.5", "url": "/posts/effective_c++_item_5/", "categories": "C++, Effective C++", "tags": "C++, Effective C++", "date": "2020-05-01 21:08:00 +0900", "snippet": "C++가 은근슬쩍 만들어 호출해 버리는 함수들에 촉각을 세우자내용컴파일러가 저절로 선언해주는 멤버 함수C++의 어떤 멤버 함수는 클래스 안에 직접 선언해 주지 않으면 컴파일러가 저절로 선언해 주도록 되어 있다. 바로 복사 생성자(Copy Constructor), 복사 대입 생성자(Copy Assignment Operator), 소멸자(Destructor) 이다. 이러한 컴파일러가 저절로 만들어주는 함수의 형태는 모두 기본형이다. 그리고, 생성자조차도 선언되어 있지 않으면 역시 컴파일러가 프로그래머를 대신하여 기본 생성자를 선언해 놓는다. 이들은 모두 public 멤버이며 inline 함수 이다.// 두 클래스는 근본적으로 같다.class Empty {};class Empty {public: // 기본 생성자 Empty() { ... } // 복사 생성자 Empty(const Empty&amp;amp; rhs) { ... } // 소멸자 ~Empty() { ... } // 복사 대입 연산자 Empty&amp;amp; operator=(const Empty&amp;amp; rhs) { ... } };이들은 꼭 필요하다고 컴파이러가 판단할 때만 만들어 진다. Empty e1; // 기본 생성자, 소멸자 Empty e2(e1); // 복사 생성자 e2 = e1; // 복사 대입 연산자#기본 생성자와 소멸자가 하는 일은 일차적으로 컴파일러에게 “배후의 코드”를 깔 수 있는 자리를 마련하는 것이다. 기본 클래스 및 비정적 데이터 멤버의 생정자와 소멸자를 호출하는 코드가 여기서 생기게 된다. 이때, 소멸자는 이 클래스가 상속한 기본 클래스의 소멸자가 가상 소멸자로 되어 있지 않으면 역시 비가상 소멸자로 만들어지게 되니 이를 주의해야 한다.컴파일러가 만들어낸 복사 생성자, 복사 대입 연산자가 하는 일은, 원본 객체의 비정적 데이터를 사본 객체 쪽으로 그냥 복사하는 것이 전부 이다.template&amp;lt;class T&amp;gt;class NameObject {public: NameObject(const char* name, const T&amp;amp; value); NameObject(const std::string&amp;amp; name, const T&amp;amp; value); ...private: std::string nameValue; T objectValue;};이 NameObject 템플릿 안에는 생성자가 성언되어 있으므로, 컴파일러는 기본 생성자를 만들어내지 않을 것이다. 즉, 만약 생성자 인자가 꼭 필요한 클래스를 만드는 것이 프로그래머의 결정이고 그렇게 했다면, 인자를 받지 않는 생성자를 컴파일러가 만들 걱정은 하지 않아도 된다.반면, 복사 생성자나 복새 대입 연산자는 NameObject에 선언되어 있지 않기 때문에, 이 두 함수의 기본형이 컴파일러에 의해 만들어진다.NameObject&amp;lt;int&amp;gt; no1(&quot;Hello World&quot;);NameObject&amp;lt;int&amp;gt; no2(no1); // 복사 생성자 호출컴파일러가 만들어낸 복사 생성자는 no1.nameValue와 no1.objectValue를 사용하여 no2.nameValue와 no2 objectValue를 각각 초기화해야 한다.nameValue의 타입은 std::string 인데, 표준 string 타입은 자체적으로 복사 생성자를 가지고 있으므로 no2.nameValue의 초기화는 string 복사 생성자에 no1.nameValue를 인자로 넘겨 호출함 으로써 이루어지게 된다.NameObject::objectValue의 타입은 현재의 템플릿 인스턴스화에서 T를 int로 선언하였으므로 int인데, int는 기본제공형 타입이므로 no2.objectValue의 초기화는 no1.objectValue의 각 비트를 그대로 복사해 오는것으로 끝난다.컴파일러가 만들어 주는 NmaeObject의 복사 대입 연산자도 근본적으로는 동작 원리가 같다. 하지만 일반적인것을 보면, 이 복사 대입 연산자의 동작이 위의 설명대로 되려면 최종 결과 코드가 *&#39;적법해야(legal)&#39;* 해야 하고, *&#39;합당해야(resonable)&#39;* 한다. 둘 중 어느 검사도 통과하지 못한다면 컴파일러는 operator=의 자동생성을 거부한다.class NameObject {public: NameObject(std::string&amp;amp; name, const T&amp;amp; value); ...private: std::string&amp;amp; nameValue; const T objectValue;};...std::string newDog(&quot;NewDog&quot;);std::string oldDog(&quot;OldDog&quot;);NameObject&amp;lt;int&amp;gt; n(newDog, 2);NameObject&amp;lt;int&amp;gt; o(oldDog, 36);p = s; // p에 들어있는 데이터 멤버에서 일어난 일?대입 연산이 일어나기 전, n.nameValue 및 o.nameValue는 string 객체를 참조하고 있다. 물론 같은 string 객체는 아니다. 이때 대입 연산이 일어나면 n.nameValue가 어떻게 되어야 하는가?o.nameValue가 참조하는 string을 가리켜야 하는가? 즉, 참조자 자체가 바뀌어야 하는 건가? 이는 불가능 하다. C++의 참조자는 원해 자신이 참조하고 있는 것과 다른 객체를 참조할 수 없기 때문이다.그렇다면 n.nameValue가 참조하는 string 객체 자체가 바뀌는 것이 맞는건가? 이렇게 되면 그 string에 대한 포인터나 참조자를 품고 있는 다른 객체들, 즉 실제 대입 연산에 직접적으로 관여하지 않는 객체까지 영향을 받게 된다.어느쪽은 정하더라도 이 문제에 대해 컴파일러는 오류를 발생시킨다. 그렇기 때문에 참조자를 데이터 멤버로 가지고 있는 클레스에 대입 연산을 지원하려면 프로그래머가 직접 복사 대입 연산자를 정의해 주어야 한다.데이터 멤버가 상수 객체인 경우(위 예제에서의 objectValue 멤버와 같은 경우)에도 컴파일러가 비슷하게 동작한다. 상수 멤버를 수정하는 것은 문법에 어긋나기 때문에, 자동으로 컴파일러에 의해 만들어진 암시적 복사 대입 연산자 내부에서는 상수 멤버를 어떨게 처리해야할지 애매해지게 된다.추가적인 결정적인 포인트는, 복사 대입 연산자를 private로 선언한 기본 클래스로 부터 파생된 서브클래스의 경우, 이 클래스는 암시적 복사 대입 연산자를 가질수 없게 된다. 컴파일러가 거부하기 때문이다. 파생 클래스에 대해 컴파일러가 만들어 주는 복사 대입 연산자는 기본 클래스 부분을 맡도록 되어 있긴 하지만, 이렇게 하더라도 파생 클래스 쪽에서 호출할 권한이 없는 멤버 함수는 암시적 복사 대입 연산자에서 호출할 수는 없기 때문이다.요점 컴파일러는 경우에 따라 클래스에 대해 기본 생성자, 복사 생성자, 복사 대입 연산자, 소멸자를 암시적으로 만들어 놓을 수 있다.참고. Effective C++ 3/E - Scott Meyers" }, { "title": "LeetCode - 849. Maximize Distance to Closest Person", "url": "/posts/ps-leetcode-849/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Array", "date": "2020-05-01 01:46:00 +0900", "snippet": " 849. Maximize Distance to Closest Person - easy문제In a row of seats, 1 represents a person sitting in that seat, and 0 represents that the seat is empty.There is at least one empty seat, and at least one person sitting.Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized.Return that maximum distance to closest person.제한사항 1 &amp;lt;= seats.length &amp;lt;= 20000 seats contains only 0s or 1s, at least one 0, and at least one 1.입출력 예Example 1:Input: [1,0,0,0,1,0,1]Output: 2Explanation: If Alex sits in the second open seat (seats[2]), then the closest person has distance 2.If Alex sits in any other open seat, the closest person has distance 1.Thus, the maximum distance to the closest person is 2.Example 2:Input: [1,0,0,0]Output: 3Explanation: If Alex sits in the last seat, the closest person is 3 seats away.This is the maximum distance possible, so the answer is 3.풀이 Arrayfunc MaxVal(a int, b int) int { if(a &amp;gt;= b) { return a } else { return b }}func MinVal(a int, b int) int { if(a &amp;lt;= b) { return a } else { return b }}func maxDistToClosest(seats []int) int { res := 0 for i, v := range(seats) { if(v == 1) { continue } countLeft := 200000 countRignt := 200000 // 현재 인덱스의 -1 부터 처음 인덱스 까지, // 1이 나올때 까지 검사 for j := i-1 ; j &amp;gt;= 0 ; j-- { if(seats[j] == 1){ countLeft = i - j break; } } // 현재 인덱스의 +1 부터 마지막 인덱스 까지, // 1이 나올때 까지 검사 for j := i+1 ; j &amp;lt; len(seats) ; j++ { if(seats[j] == 1){ countRignt = j - i break; } } res = MaxVal(res, MinVal(countLeft, countRignt)) } return res}" }, { "title": "Effective C++ - Item.4", "url": "/posts/effective_c++_item_4/", "categories": "C++, Effective C++", "tags": "C++, Effective C++, Initial", "date": "2020-04-30 22:15:00 +0900", "snippet": "객체를 사용하기 전에 반드시 그 객체를 초기화하자내용객체의 초기화초기화되지 않은 값을 읽도록 내버려 두면 정의되지 않은 동작이 그대로 흘러 나오게 된다. 일반적인 경우에 적당히 무작위 비트의 값을 읽고 객체의 내부가 이상한 값을 가지게 된다.C++에서 객체의 초기화 보장 유무C++의 객체(변수) 초기화가 중구난방인 것은 절대 아니다. 언제 초기화가 보장되며 언제 그렇지 않은지에 대한 규칙이 명확하게 정의되어 있다. 다만 한가지 안타까운 점은, 규칙 자체가 아주 복합하다는 것이다.일반적인 사항부터 확일해보면, C++의 C 부분만을 쓰고 있으며 초기화에 런타임 비용이 소모될 수 있는 상황이라면 값이 초기화 된다는 보장이 없다. 그렇지만 C가 아닌 부분으로 진입하게 되면 사정이 때떄로 달라지게 된다. 배열(C++의 C부분)은 각 원소가 확실히 초기화 된다는 보장이 없으나, vector(C++의 STL부분)는 그러한 보장을 가지게 되는 이유가 바로 이런 법칙 때문이다.가장 좋은 방법은 모든 객체를 사용하기 전에 항상 초기화 하는 것이다.int x = 0; // int의 직접 초기화const char* text = &quot;Hello World!&quot;; // 포인터의 직접 초기화double d; // 입력 스트림을 통한 초기화 수행std::cin &amp;gt;&amp;gt; d;클래스 생성자에서의 초기화위와 같은 변수의 초기화 부분을 제외하면, C++의 초기화의 나머지 부분은 생성자로 귀결된다.생성자에서 지킬 규칙은 “객체의 모든 것을 초기화 한다” 라는 것만 지키면 된다는 것을 기억하자. 다만, 한가지 주의할 점은 대입(assignment)을 초기화(initialization)으로 착각하지 않는 다는 것이 가장 중요하다.class PhoneNumber { ... };class ABEntry {public: ABEntry(const std::string&amp;amp; name, const std::string&amp;amp; address, const std::list&amp;lt;PhoneNumber&amp;gt;&amp;amp; phones) { // 아래와 같은 코드는 &quot;초기화&quot;가 아닌 &quot;대입&quot; 이다 theName = name; theAddress = address; thePhones = phones; numTimesConsulted = 0; }private: std::string theName; std::string theAddress; std::list&amp;lt;PhoneNumber&amp;gt; thePhones; int numTimesConsulted;};위의 예제와 같은 경우, ABEntry 객체는 원하는 값을 가지게 되지만, 그 내부를 확인해 보면 생성자에서 각 멤버변수에 대한 초기화가 진행되는 것이 아닌 대입을 하고 있다. 즉, theName, theAddress, thePhones 멤버 변수의 경우, 생성자에서 초기화 되는 것이 아니라 어떤 값이 대입됨으로써 ABEntry 생성자에 진입하기도 전에 이들 세 데이터 멤버 변수의 기본 생성자가 호출되어 진다. 다만 numTimesConsulted 멤버 변수의 경우 기본 데이터 타입인 int이므로, 생성자에서 대입되기 전에 초기화 되리란 보장이 없다.위와같이 생성자에서 대입 대신 초기화를 하기 위해서는 멤버 초기화 리스트를 사용하면 된다.class PhoneNumber { ... };class ABEntry {public: ABEntry(const std::string&amp;amp; name, const std::string&amp;amp; address, const std::list&amp;lt;PhoneNumber&amp;gt;&amp;amp; phones) : theName(name), // 대입이 아닌 초기화를 한다 theAddress(address), thePhones(phones), numTimesConsulted(0) {} // 생성자 본문은 비어있다private: std::string theName; std::string theAddress; std::list&amp;lt;PhoneNumber&amp;gt; thePhones; int numTimesConsulted;};멤버 변수에 사용자가 원하는 값을 주고 시작한다는 점에서는 동일하지만, 위의 생성자(초기화)에서는 먼저 정의한 생성자(대입)보다 효율적일 가능성이 크다.대입만 사용한 버전의 경우 theName, theAddress, thePhones 멤버 변수에 대해 기본 생성자를 호출해서 초기화를 미리 해 놓은 후에 생성자에서 곧바로 새로운 값을 대입하고 있다. 따라서 먼저 호출된 각 멤버 변수의 기본 생성자에서 해 놓은 초기화는 아깝게도 그냥 헛짓이 되어 버리고 만다.이러한 문제는 멤버 초기화 리스트를 통해 피해갈 수 있다. 초기화 리스트에 들어가는 인자는 바로 멤버 변수에 대한 생성자의 인자로 쓰이기 때문이다. 두번째의 초기화 버전의 생성자의 경우, theName은 name으로 부터 복사 생성자에 의해 초기화 고, theAddress는 address으로 부터 복사 생성자에 의해 초기화되며, thePhones도 동일하게 phones로 부터 초기화 된다.대부분의 데이터 타입에 대해서는, 기본 생성자 호출 후에 복사 대입 연산자를 연달아 호출하는 이전의 방법보다 복사 생성자를 한 번 호출하는 쪽이 더 효율적이다.기본제공 타입의 객체는 초기화와 대입에 걸리는 비용의 차이가 없지만, 역시 멤버 초기화 리스트에 모두 넣어 주는 쪽이 바람직하다. 또 멤버 변수를 기본 생성자로 초기화 하고 싶을 때도 멤버 초기화 리스트를 사용하는 습관을 들이는 것이 좋다.ABEntry::ABEntry() : theName(), theAddress(), thePhones(), numTimesConsulted(0) {}기본제공 타입의 멤버를 초기화 리스트로 넣는 일이 선택이 아니라 의무가 될 때도 있다. 바로 멤버 변수가 상수 이거나 참조자로 되어있을 때 이다. 이는 상수와 참조자는 대입 자체가 불가능하기 때문에 반드시 초기화 리스트를 통해 초기화 되어야 한다.객체를 구성하는 데이터의 초기화 순서객체를 구성하는 데이터의 초기화 순서는 어떤 컴파일러를 막론하고 항상 똑같다. 기본 클래스는 파생 클래스보다 먼저 초기화 된다. 클래스 멤버 변수는 그들이 선언된 순서대로 초기화 된다.위의 ABEntry 클래스를 예로들면, theName이 항상 첫 번째로 초기화 되고, theAddress가 두번째, thePhones 세번째, numTimesConsulted가 마지막으로 초기화 된다. 즉, 선언된 순서대로 초기화 된다. 만약 어쩌다 멤버 초기화 리스트에 이들이 넣어진 순서가 다르더라도(이러한 경우 컴파일은 가능하다) 초기화 순서는 그대로 이다.비지역 정적 객체의 초기화 순서는 개별 번역 단위에서 정해진다정적 객체(static object) 는 자신이 생성된 시점부터 프로그램이 끝날 떄 까지 살아 있는 객체를 일컫는다. 즉, 스택 객체 및 힙 기반 객체는 애초부터 정적 객체가 될 수 없다.정적 객체의 범주에 들어가는 것들은 아래와 같다. 전역 객체 네입스페이스 유효범위에서 정의된 객체 클래스 안에서 static으로 정의된 객체 함수 안에서 static으로 정의된 객체 파일 유효범위에서 static으로 정의된 객체이중 함수 안에 있는 정적 객체는 함수에 대해서 지역성을 가지고 있으므로 지역 정적 객체(local static object) 이라 하고, 나머지 정적 객체 들은 비지역 정적 객체(non local static object) 라고도 불린다.이러한 다섯가지의 정적 객체들은 프로그램이 끝날 때 자동으로 소멸된다. 다시 말해, main() 함수의 실행이 끝날 때 정적 객체의 소멸자가 호출된다.비지역 정적 객체의 초기화 순서 문제의 시작은 컴파일에서 부터 시작된다.번역 단위(translation unit) 는 컴파일을 통해 하나의 목적 파일(object file)을 만드는 바탕이 되는 소스 코드를 일컫는다. 여기서 번역은 소스의 언어를 기계어로 옮긴다는 의미이다. 기본적으로는 소스 파일 하나가 되는데, 그 파일이 #include하는 파일들까지 합쳐서 하나의 번역 단위가 된다.별도로 컴파일된 소스 파일이 두 개 이상 있으며 각 소스 파일에 비지역 정적 객체(전역 객체, 네임스페이스에 있는 객체, 클래스 혹은 파일에 있는 정적 객체) 가 한개 이상 들어 있는 경우에 문제가 발생한다. 실질적인 문제는 한쪽 번역 단위에 있는 비지역 정적 객체의 초기화가 진행되면서 다른 쪽 번역 단위에 있는 비지역 정적 객체가 사용되는데, 불행히도 다른 쪽 번역 단위에 있는 객체가 초기화되어 있지 않을 지도 모른다는 점이다. 이유는 별개의 번역 단위에서 정의된 비지역 정적 객체들의 순서는 ‘정해져 있지 않다’ 라는 사실 때문이다.// 사용자가 사용하는 라이브러리에 포함된 클래스class FileSystem {public: // 멤버 함수들 ... std::size_t numDisks() const(); ...};// 사용자가 쓰게 될 객체extern FileSystem tfs;// 사용자가 정의한 클래스class Direcotry {public: Direcotry( params ) { ... // 외부 파일에 정의한 tfs 객체를 사용 std::size_t disks = tfs.numDisks(); ... } ...};...// 임시 파일을 담는 디렉토리Direcotry tempDir( params );위의 예제에서, 정적 객체의 초기화 순서 때문에 문제가 심각해질 수도 있는 상황이 들어났다. tfs가 tempDir보다 먼저 초기화 되지 않으면, tempDir의 생성자는 tfs가 초기화되지도 않았는데 tfs를 사용하려고 할 것이다. 그러나 tfs와 temDir은 제작자도, 만들어진 시기도, 소스파일 또한 다르다. 즉, 이들은 다른 번역 단위 안에서 정의된 비지역 정적 객체 이다.tempDir 전에 tfs가 초기화되게 만들고 싶을때, 이 목표를 어떻게 달성할 것인가. 결론부터 이야기 하자면 불가능 하다. 서로 다른 번역 단위에 정의된 비지역 정적 객체들 사이의 상대적인 초기화 순서는 정해져 있지 않기 때문이다.위의 문제를 해결하는 방법은 초기화 순서 문제를 사전에 봉쇄하는 것이다. 비지역 정적 객체를 하나씩 맡는 함수를 준비하고 이 안에 객체를 넣는 방법이다. 함수 속에서도 이들은 정적 객체로 선어하고, 그 함수에서는 이들에 대한 참조자를 반환하는 것이다. 사용자 쪽에서는 비지역 정적 객체를 직접 참조하는 것이 아닌 함수 호출로 참조하도록 하는 것이다. 즉, 비지역 정적 객체를 지역 정적 객체로 바꾸는 것이다. 이는 디자인 패턴중 Singleton Pattern의 전형적인 구현양식과 동일하다.지역 정적 객체는 함수 호출중에 그 객체의 정의에 최초로 닿았을 때 초기화되도록 만들어져 있다. 이는 C++에서 보장하는 사실이며, 위의 방법은 그 사실을 이용한 방법이다. 따라서 비지역 정적 객체를 직접 접근하지 않고 지역 정적 객체에 대한 참조자를 반환하는 쪽으로 바꾸었다면, 얻어낸 참조자는 반드시 초기화된 객체를 참조하도록 맞춰주어야 한다.비지역 정적 객체 대신에 준비한 ‘지역 객체 참조자 반환’ 함수를 호출할 일이 없다면 해당 객체의 생성/소멸 비용도 생기지 않도록 막아야 한다.// 이전과 같은 클래스class FileSystem { ... };// tfs 객체를 함수로 대체한다// 이 함수는 클래스안에 정적 멤버로 들어가도 된다FileSystem&amp;amp; tfs() { // 지역 정적 객체를 정의하고 초기화 static FileSystem fs; // 이 객체에 대한 참조자를 반환 return fs;};// 이전과 같은 클래스// 다만 tfs가 함수로 바뀌었으므로 이제는 함수호출로 바뀜class Direcotry { ... };// tempDir 객체를 함수로 대체한다// 이 함수는 클래스안에 정적 멤버로 들어가도 된다Direcotry&amp;amp; tempDir() { // 지역 정적 객체를 정의하고 초기화 static Directory td; // 이 객체에 대한 참조자를 반환 return td;};위의 경우에 대한 문제점을 생각했을 때, 참조자 반환 함수는 내부적으로 정적 객체를 쓰기 때문에, 다중스레드 시스템에서는 동작에 장애가 생길 수도 있다. 다중스레드 시스템상에서는 비상수 정적 객체(지역 객체이든 비지역 객체이든) 은 온갖 문제를 발생 시킬수 있다. 이 문제를 다루기 위한 한가지 방법으로 프로그램이 다중스레드로 돌입하기 전의 시동 단계에서 참조자 반환 함수를 전부 직접 호출해 줄 수 있다. 이렇게 하면 초기화에 관계된 경쟁 상태(race condition) 가 없어지게 된다.물론 초기화 순서 문제를 방지하기 위해 이처럼 참조자 반환 함수를 사용하는 아이디어는 객체들의 초기화 순서를 제대호 맞춰 둔자는 전제조건이 뒷바침되어야 한다. 이를테면 객체 B가 초기화되기 전에 객체 A가 초기화 되어야 하는데, A의 초기화가 B의 초기화에 의족하도록 되어 있다면 이는 제대로 동작하지 않을 것이다.요점 기본제공 타입의 객체는 경우에 따라 저절로 되기도 하고 안되기도 하기 때문에 직접 초기화한다. 셍성자에서는, 데이터 멤버에 대한 대입문을 생성자 본문 내부에 넣는 방법으로 멤버를 초기화 하지 말고 멤버 초기화 리스트를 사용한다. 초기화 리스트에 데이터 멤버를 나열할 때는 클래스에 각 데이터 멤버가 선언된 순서와 똑같이 나열한다. 여러 번역 단위에 있는 비지역 정적 객체들의 초기화 순서 문제는 피해서 설계해야 한다. 비지역 정적 객체를 지역 정적 객체로 바꾼다.참고. Effective C++ 3/E - Scott Meyers" }, { "title": "Effective C++ - Item.3", "url": "/posts/effective_c++_item_3/", "categories": "C++, Effective C++", "tags": "C++, Effective C++, Const", "date": "2020-04-30 20:23:00 +0900", "snippet": "낌새만 보이면 const를 들이대 보자!내용Const 키워드const의 가장 눈에 띄는 특징이라면, const가 붙은 객체는 외부 변경을 불가능 하게 한다라는 ‘의미적인 제약’을 소스코드 수준에서 행해진다는 점과 컴파일러가 이 제약을 단단히 지켜준다는 점이다.const 키워드는 클래스 바깥에서 전역 혹은 네임스페이스 유효범위의 상수를 선언하는데도 쓸 수 있으며, 파일, 함수, 블록 유효범위에서 static으로 선언한 객체에도 const를 붙일 수 있다. 클래스 내부의 경우에는 정적 멤버 및 비정적 멤버 모두를 상수로 선언 할 수 있다. 뿐만 아니라 포인터 역시 포인터 자체를 상수로, 혹은 포인터가 가리키는 값을 상수로, 아니면 둘다 상수로 선언하는 것이 가능하다.char greeting[] = &quot;Hellp&quot;; // 비상수 포인터char* p = greeting; // 비상수 데이터const char* p = greeting; // 비상수 포인터, // 상수 데이터char* const p = greeting; // 상수 포인터, // 비상수 데이터const char* const p = greeting; // 상수 포인터, // 상수 데이터STL Iterator의 ConstSTL의 반복자(Iterator)는 포인터를 본뜬 것이기 때문에, 기본적인 동작 원리가 T* 포인터와 매우 흡사하다. 어떤 반복자를 const로 선언하는 일은 포인터를 const T* 와 같이 상수로 선언하는 것과 같다. 반복자는 자신이 가리키는 대상이 아닌 것을 가리키는 경우가 허용되지 않지만, 반복자가 가리키는 대상 자체는 변경이 가능하다. 만약 변경이 불가능한 객체를 가리키는 반복자가 필요하다면 const_iterator를 사용하면 된다.std::vector&amp;lt;int&amp;gt; vec;// iter는 &#39;T* const&#39; 처럼 동작한다const std:::vector&amp;lt;int&amp;gt;::iterator iter = vec.begin();*iter = 10; // 성공, iter가 가리키는 대상을 변경한다++iter; // 에러, iter는 상수이다// citer는 &#39;const T*&#39; 처럼 동작한다const std:::vector&amp;lt;int&amp;gt;::const_iterator citer = vec.begin();*citer = 10; // 에러, *citer가 상수이기 때문에 대상의 변경이 불가능하다++citer; // 성공, 대상이 아닌 자신을 변경하므로 가능하다함수 선언에서의 Constconst의 가장 강력한 용도는 함수 선언에 사용할 경우이다. 함수 선언문에 있어서 const는 함수 반환 값, 각각의 매개변수, 멤버 함수 앞에 붙을 수 있고, 함수 전체에 대해 const의 성질을 붙일 수 있다.함수 반환 값을 상수로 정해 주면, 안정성이나 효율을 포기하지 않고도 사용자측의 에러 발생 상황을 줄이는 효과를 줄 수 있다.class Rational { ... };const Rational operator* (const Rational&amp;amp; lhs, const Rational&amp;amp; rhs);...// 프로그래머의 실수에 대해 사전에 방지Rational a,b,c;(a * b) = c; // a*b의 결과에 operator= 호출if((a * b) = c) // 비교문 오타로 인해 잘못된 연산 호출const 매개변수는 단순히 const 타입의 지역 객체과 특성이 같다. 물론 가능한 항상 사용하는 것이 좋다. 매개변수, 혹은 지역 객체를 수정할 수 없게 하는 것이 목적이라면, const로 선언하는 것을 잊어버리면 안된다.상수 멤버 함수멤버 함수에 붙은 const 키워드의 역할은 “해당 멤버 함수가 상수 객체에 대해 호출될 함수이다” 라는 사실을 알려 주는 것이다.실제 프로그램에서 상수 객체가 생기는 경우는 아래와 같다. 상수 객체에 대한 포인터로 객체가 전달될 떄 상수 객체에 대한 참조자로 객체로 전달될 때이러한 상수 멤버 함수가 중요한 이유는 아래와 같이 두가지가 있다. 클래스의 인터페이스를 이해하기 좋게 해준다 클래스로 만들어진 객체를 변경할 수 있는 함수는 무엇이고, 또 변경할 수 없는 함수는 무엇인가를 사용자측에서 알고 있어야 한다. const 키워드를 통해 상수 객체를 사용할 수 있게 한다 C++ 프로그램의 실행 성능을 높히는 핵심 기법중 하나는 객체 전달을 “상수 객체에 대한 참조자(Reference to const)“로 진행하는 것인데, 이 기법이 제대로 동작하려면 상수 상태로 전달된 객체를 조작할 수 있는 const 멤버 함수가 준비되어 있어야 한다. C++의 const에 대하여 굉장히 중요한 성질중 하나는, “*const 키워드가 있고 없고의 차이만 있는 멤버 함수들은 오버로딩이 가능하다*” 라는 점이다.class TextBook {public: ... // 상수 객체에 대한 operator[] const char&amp;amp; operator[](std::size_t pos) const { return text[pos]; } // 비상수 객체에 대한 operator[] const char&amp;amp; operator[](std::size_t pos) const { return text[pos]; }private: std::string text;};void print(cosnt TextBook&amp;amp; ctb) { // 상수 멤버를 호출 std::cout &amp;lt;&amp;lt; ctb[0]; ...}...TextBook tb(&quot;Hello&quot;);TextBook ctb(&quot;World&quot;);// 비상수 버전의 TextBook 객체를 읽는다std::cout &amp;lt;&amp;lt; tb[0];// 비상수 버전의 TextBook 객체를 사용한다tb[0] = &#39;x&#39;;// 상수 버전의 TextBook 객체를 읽는다std::cout &amp;lt;&amp;lt; ctb[0];// 컴파일 에러, 상수 버전의 TextBook 객체에 대한 쓰기는 금지되어 있다// ctb[0] = &#39;x&#39;;operator[]를 오버로드하여 각 버전마다 변환 타입을 다르게 가져갔기 때문에, “TextBook”의 상수 객체과 비상수 객체의 쓰임새가 달라지게 된다.위 예제에서 주의할 점은, “ctb[0] = ‘x’;” 부분에서 발생한 에러는 const char&amp;amp; 타입에 대입 연산을 시도했기 때문에 생긴 순전히 operator[]의 반환 타입(return type) 때문이다. 즉, oprtator[] 호출이 잘못된 점은 없다.또한 한가지 더 주의할 점은, operator[]의 비상수 멤버는 char의 참조자(Reference) 를 반한한다는 것인데, char 하나만 쓰면 안된다는 점이다. 만약 operator[]가 그냥 char을 반환하게 되어 있다면 다음과 같은 문장은 컴파일 되지 않을 것이다.tb[0] = &#39;x&#39;;이는 기본제공 타입을 반환하는 함수의 반환 값을 수정하는 일은 절대로 없기 때문이다. 만약 이것이 합법적으로 통한다고 하더라도, 반환시 “값의 의한 반환“을 수행하는 기본 성질이 존재한다. 즉, 수정되는 값은 tb.text[0]의 사본이지 tb.text[0] 자체가 아니다.비트수준 상수성(Bitwise Constness)과 논리수준 상수성(Logical Constness)어떤 멤버 함수가 상수 멤버라는 것이 어떤 의미인가 라고 할때, 크게 두가지 개념이 자리잡고 있다. 비트수준 상수성(Bitwise Constness) 물리적 상수성(Physical Constness)라고도 한다 어떤 멤버 함수가 그 객체의 어떤 데이터 멤버도 건드리지 않아야 그 멤버 함수가 ‘const’ 임을 인정 객체를 구성하는 비트들 중 어떤 것도 바꾸면 안됨 정적(static) 멤버는 제외 C++에서 정의되어 있는 상수성이 여기에 해당 논리수준(Logical Constness) 객체의 한 비트도 수정할 수 없게 하는 것이 아닌, 일부 몇 비트 정도는 바꿀 수 있되, 그것을 사용자 측에서 알아채지 못하게 함 한가지, ‘제대로 const‘로 동작하지 않는데도 이 비트수준 상수성 검사를 통과하는 멤버 함수들이 있을 수 있다. 어떤 포인터가 가리키는 대상을 수정하는 멤버 함수들 중 상당수가 이와 같은 경우이다. 그 포인터가 객체의 멤버로 들어 있는 한, 이 함수는 비트수준 상수성을 가지는 것으로 판별하고, 컴파일러도 에러를 발생하지 않는다.class CTextBook {public: ... // 부적절한, 그러나 비트수준 상수성에 있어 허용되는 상수 멤버 함수 char&amp;amp; operator[](std::size_t pos) const { return pText[pos]; }private: char *pText;};...// 상수 객체를 선언const CTextBook cctb(&quot;Hello&quot;);// 상수 버전의 operator[]를 호출하여 cctb의 내부 데이터에 대한 포인터를 획득char* pc = &amp;amp;cctb[0];// cctb의 값이 변경되어 이제 &quot;Jello&quot; 라는 값을 가짐*pc = &#39;J&#39;;논리적 상수성에 대한 예시는 아래와 같다.claclass CTextBook {public: ... std::size_t length() const { if(!lengthValid) { // 에러, 상수 멤버 함수 안에서는 멤버 변수에 대입이 불가능하다 textLength = std::strlen(pText); lengthValid = true; } return textLength; }private: char *pText; std::size_t textLength(); // 바로 직전에 계산한 텍스트 길이 bool lengthValid; // 이 길이가 유효한지};내부 데이터를 변경하지만 위와 같이 사용자에게는 숨겨저 있어 논리적 상수성을 만족한다고 하지만, 결국 C++의 컴파일러는 비트수준 상수성을 만족해야지만 에러 없이 작동한다. 즉, 위와 같은 예제는 논리적 상수성은 만족하지만 비트수준 상수정을 만족하지 못하여 에러를 발생시키게 되는 것이다.이러한 상황일 때, 컴파일러의 비트수준 상수성을 회피하기 위해서는 mutable 키워드를 사용한다. mutable은 비정적 데이터를 비트수준 상수성의 족쇄에서 풀어 주는 효과를 보여준다.class CTextBook {public: ... // 부적절한, 그러나 비트수준 상수성에 있어 허용되는 상수 멤버 함수 char&amp;amp; operator[](std::size_t pos) const { return pText[pos]; }private: char *pText;};...// 상수 객체를 선언const CTextBook cctb(&quot;Hello&quot;);// 상수 버전의 operator[]를 호출하여 cctb의 내부 데이터에 대한 포인터를 획득char* pc = &amp;amp;cctb[0];// cctb의 값이 변경되어 이제 &quot;Jello&quot; 라는 값을 가짐*pc = &#39;J&#39;;논리적 상수성에 대한 예시는 아래와 같다.claclass CTextBook {public: ... std::size_t length() const { if(!lengthValid) { // mutable로 선언된 멤버변수 이므로 문제 없다 textLength = std::strlen(pText); lengthValid = true; } return textLength; }private: char *pText; // 이 멤버변수들은 어떤 순간에도 수정이 가능해진다. // 심지어 상수 멤버 함수안에서도 수정이 가능하다. mutable std::size_t textLength(); mutable bool lengthValid;};상수 멤버 및 비상수 멤버 함수에서 코드 중복 현상을 피하는 방법class TextBook {public: ... // 상수 버전의 operator[] const char&amp;amp; operator[](std::size_t pos) const { // 경계 검사, 접근 데이터 로깅, 자료 무결성 검증 등 ... return text[pos]; } // 비상수 버전의 operator[] char&amp;amp; operator[](std::size_t pos){ // 경계 검사, 접근 데이터 로깅, 자료 무결성 검증 등 ... return text[pos]; }private: std::string text;};위와 같은 상황일때, 두 멤버 함수의 차이는 상수 멤버인가, 비상수 멤버 인가 라는 점만 다를뿐 그 내용을 동일하다. 즉, 두 함수 사이에는 그 내용이 동일 하기 때문에 코드의 중복 문제가 발생하게 되는 것이다.이러한 코드 중복을 피하기 위해, 비상수 멤버 함수에서 캐스팅을 통해 상수 멤버 함수를 호출하도록 하는 방법이 있다.class TextBook {public: ... // 이전과 동일 const char&amp;amp; operator[](std::size_t pos) const { // 경계 검사, 접근 데이터 로깅, 자료 무결성 검증 등 ... return text[pos]; } // 상수 버전의 operator[]를 호출 char&amp;amp; operator[](std::size_t pos){ return const_cast&amp;lt;char&amp;amp;&amp;gt;( // operator[]의 반환타입에 캐스팅 적용하여, // const를 떼어냄 static_cast&amp;lt;const TextBook&amp;amp;&amp;gt; // *this의 타입에 const를 붙임 (*this)[pos] // operator[]의 상수 버전을 호출 ); }private: std::string text;};이렇게 비상수 멤버 함수에서 상수 멤버 함수를 호출하는 것과 반대로 상수 멤버 함수에서 비상수 멤버 함수를 호출하는 것은, 위험을 초래할 수 있다. 상수 멤버 함수는 해당 객체의 논리적인 상태를 바꾸지 않겠다고 컴파일러와 약속한 함수인 반면, 비상수 멤버 함수는 이런 약속을 일절 하지 않는 다. 즉, 상수 멤버에서 비상수 멤버를 호출하게 되면, 수정하지 않겠다고 약속한 그 객체를 배신하게 되고, 그 객체는 변경될 위험이 있다.요점 const를 붙여 선언하면 컴파일러가 사용상의 에러를 잡아내는데 도움을 준다. const는 어떤 유효번위에 있는 객체에도 붙을수 있드며, 함수 매개변수 및 반환 타입, 멤버 함수에도 붙을 수 있다. 컴파일러 쪽에서 보면 비트수준 상수성을 지켜야 하지만, 프로그래머는 논리적 상수성을 사용하여 프로그래밍 해야 한다. 상수 멤버 및 비상수 멤버가 기능적으로 서로 똑같이 구현되어 있을 경우에는 코드의 중복을 피하는 것이 좋은데, 이때 비상수 버전이 상수 버전을 호출하도록 구현해야 한다.참고. Effective C++ 3/E - Scott Meyers" }, { "title": "Design Patterns - Visitor", "url": "/posts/design_patterns-visitor/", "categories": "Design Patterns", "tags": "Design Patterns, Behavioral Patterns, Visitor, C++", "date": "2020-04-28 06:32:00 +0900", "snippet": "Behavioral Patterns - VisitorIntent객체의 구조와 기능을 분리시킨다.구조는 변하지 않으며 기능만 따로 추거되거나 확장될 경우 사용할 수 있는 패턴이다.객체 구조를 이루는 원소에 대해 수행할 연산을 표현한다.연산을 적용할 원소의 클래스를 변경하지 않고도 새로운 연산을 정의할 수 있게 한다.Utility 다른 인터페이스를 가진 클래스가 객체 구조에 포함되어 있어며, 구체 클래스에 따라 달라진 연산을 이들 클래스의 객체에 대해 수행하고자 할 때 각각 트깅이 있고, 관련되지 않은 연산들이 한 객체 구조에 속해있는 객체들에 대해 수행될 필요가 있으며, 연산으로 클래스들을 “더럽히고” 싶지 않을 때 Visitor 클래스는 관련된 모든 연산을 하나의 클래스 안에다 정의해 놓음으로써 관련된 연산이 함께 있을수 있게 해 준다. 어떤 객체 구조가 많은 응용프로그램으로 공유돌 때, Visitor 클래스를 이용하면 이 객체 구조가 필요한 응용프로그램에만 연산을 둘 수 있다. 객체 구조를 정의한 클래스는 거의 변하지 않지만, 전체 구조에 걸쳐 새로운 연산을 추가하고 싶을 떄 객체 구조를 변경하려면 모든 방문자에 대한 인터페이스를 재정의해야 하는데, 이 작업에 잠재된 비용이 클 수 있다. 객체 구조가 자주 변경될 때는 해당 연산을 클래스에 정의하는 편이 더 낫다. StructureBasic StructureStructure ExampleElements Visitor NodeVisitor에 해당 객체 구조 내에 있는 각 ConcreteElement 클래스를 위한 Visit() 연산을 선언 연산의 이름과 인터페이스 형태를 통해, Visit() 요청을 방문자에게 보내는 클래스를 식별 방문자는 방문된 원소의 구체 클래스를 결정 가능 방문자는 원소가 제공하는 인터페이스를 통해 원소에 직접 접근 가능 ConcreteVisitor TypeCheckingVisitor에 해당 Visitor 클래스에 선언된 연산을 구현 각 연산은 구조 내에 있는 객체의 대응 클래스에 정의된 일부 알고리즘을 구현 ConcreteVisitor 클래스는 알고리즘이 운영될 수 있는 상황 정보를 제공하며 자체 상태를 저장 Element Node에 해당 방문자를 인자로 받아들이는 Accept() 연산 정의 ConcreteElement AssignmentNode, VariableRefNode에 해당 인자로 방문자 객체를 받아들이는 Accept() 연산 구현 ObjectStructure Program에 해당 객체 구조 내의 원소들을 나옇 방문자가 원소에 접근하게 하는 상위 수준 인터페이스를 제공 ObjectStructure는 Composite Pattern으로 만든 복함체 일 수도 있고, 리스트나 집합등 컬렉션으로 구현 가능 Elements CommunicationVisitor Pattern을 사용하는 사용자는 ConcreteVisitor 클래스의 객체를 생성하고 객체 구조를 따라서 각 원소를 방문하여 순회해야 한다.방문자가 구성 원소들을 방문할 때, 구성 원소는 해당 클래스의 Visitor 연산을 호출한다. 이 원소들은 자신을 Visitor 연산에 필요한 인자로 제공하여 방문자 자신의 상태에 접근할 수 있도록 한다.다음의 상호작용 다이어그램은 방문자 객체와 두 원소 사이의 협력 관계를 보여준다.FeatureVisitor 클래스는 새로운 연산을 쉽게 추가한다Visitor 클래스는 복잡한 객체를 구성하는 요소에 속한 연산을 쉽게 추가할 수 있다. 새로운 방문자를 추가하면 객체 구조에 대한 새로운 연산을 추가할 것이 된다.방문자를 통해 관련된 연산들을 한 군데로 모으고 관련되지 않은 연산을 떼어낼 수 있다관련된 행동들이 객체 구조를 정의하는 클래스에 분산되지 않게되며, 방문자 클래스에 모인다. 관련되지 않은 행동들은 그 자신의 방문자 서브클래스로 나뉜다.이는 원소를 정의하는 클래스 및 방문자에 정의되어 있는 알고리즘 모두를 간단하게 만든다. 알고리즘에 특화된 자료 구존는 어떤 것이든지 방문자 속에 숨겨진다.새로운 ConcreteElement 클래스를 추가하기 어렵다Visitor Pattern을 사용하면 Element 클래세에 대한 새로운 서브클래스를 추가하기 어려워 진다.ConcreteElement 클래스가 새로 생길때 마다, Visitor 클래스에 대한 새로운 추상 연산 및 모든 ConcreteVisitor 클래스에 그 연산에 대응하는 구현을 제공해야 한다. Visitor 클래스에 기본적인 구현이 간혹 제공되기는 하지만, 일반적인 상황은 아니다.Visitor Pattern을 적용할 때 중요하개 고려해야 하는 사항은, 객체의 구조에 적용될 알고리즘의 변화가 자주 발생하는가, 아니면 이 같은 구조를 구성하는 객체의 클래스의 변화가 자주 발생하는가 이다.Visitor 클래스 계통은 새로운 ConcreteElement 클래스가 자주 추가되는 상활에서는 유지하기가 상당히 까다롭다.클래스 계층 구조에 겅쳐서 방문한다Iterator는 객체 구조 내 원소를 순회하면서 그 원소의 연산을 호출하여 객체 방문을 수행할 수 있다. 그러나 서로다른 타입의 원소를 가지는 객체 구조를 오가면서 순회를 진행할 수는 없다.template&amp;lt;class Item&amp;gt;class Iterator { ... Item CurrentItem() const;};즉, Iterator가 방문할 수 있는 모든 원소에는 공통적으로 Item 부모 클래스가 있다는 뜻이다.방문자는 위와같은 Iterator의 제약을 가지지 않는다. 방문자는 동일한 부모 클래스가 없는 객체들도 방문 가능하다. Visitor 인터페이스에 어떤 객체의 타입이라도 추가할 수 있다.class Visitor {public: ... void VisitMyType(MyType*); void VisitYourType(YourType*);};MyType 및 YourType은 상속 등을 통해 관련될 필요가 전혀 없다.상태를 누적할 수 있다방문자는 객체 구조 내 각 원소들을 방문하면서 샅태를 누적 할 수 있다. 만일 방문자가 없다면, 이 상태는 별도의 다른 인자로서 순회를 담당하는 연산에 전달되든지, 아니면 전역 변수로 존재해야 할 것이다.데이터 은닉을 깰 수 있다Visitor Pattern은 ConcreteElement 인터페이스가 방문자에게 필요한 작업을 수행시킬만큼 충분히 강력하다는 가정을 깔고간다.즉, Visitor Pattern을 쓰면 개발자는 원소의 내부 상태에 접근하는 데 필요한 연산들을 모두 공개 인터페이스로 만들 수 밖에 없는데, 이는 캡슐화전략을 위배하는 것이다.ImplementationConsiderations point in implementaion일반적으로 Visitor 클래스, Element 클래스, ConcreteElement 클래스, CompositeElement 클래스는 C++에서 아래와 같이 구현된다.class Visitor {public: virtual void VisitElementA(ElementA*); virtual void VisitElementB(ElementB*); // 다른 구체연 요소들에 대한 visitor 연산 ...private: Visitor();};class Element {public: virtual ~Element(); virtual void Accept(Visitor&amp;amp;) = 0;protected: Element();}class ElementA : public Element {public: ElementA(); void Accept(Visitor&amp;amp; v) override { v.VisitorElementA(this); }};class CompositeElement : public Element {public: void Accept(Visitor&amp;amp; v) override { std::vector&amp;lt;Element*&amp;gt; i(m_child); for(const auto&amp;amp; iter : i) { iter-&amp;gt;Accept(v); } v.VisitCompositeElement(this); }private: std::vector&amp;lt;Element*&amp;gt; m_child;};Visitor Pattern을 적용할 때 생기는 구현 이슈 두가지에 대하여 아래와 같이 정리될 수 있다.이중 디스패치실질적으로 따지고보면, Visitor Pattern은 사용자가 클래스를 변경하지 않고 연산을 클래스에 추가하도록 만드는 패턴이다. 이를 위해 이중 디스패치(Double Dispatch) 라는 기법을 사용한다.C++의 경우 단일 디스패치(Single Dispatch)를 지원한다. 단일 디스패치 언어에서 어떤 연산이 요청을 처리할 것인지 결정하는 기준은 두가지 이다. 요청의 이름 수신자의 타입예를들어, C++에서 VariableRefNode 인스턴스에 대해 GernerateCode를 호출하는 것은 VariableRefNode::GernerateCode() 를 호출하는 것이 된다. 즉, 실행되는 연산은 요청의 종류과 수신자의 타입에 따라 달라지게 되는 것이다.이중 디스패치는 실행되는 연산이 요청의 종류와 두 수신자의 타입에 따라 달라진다는 뜻이다. 위 예의 Accept() 연산은 이중 디스패치 연산으로, Visitor의 타입과 Element의 타입에 따라 달라지게 된다. 즉, 이중 디스패치를 쓰면 방문자는 원소의 각 클래스에 대해 서로 다른 연사늘 요청할 수 있다.실제로 실행되는 연산은 Visitor의 타입과 그것이 방문하는 Element의 타입에 따라 달라진다는 점이 Visitor Pattern의 주요 핵심이다. 연산과 Element 인터페이스를 정적으로 바인딩하는 대신에, Visitor 내 연산들을 한 군데로 모으고 Accept() 연산을 사용해서 런타임에 바인딩을 진행 할 수 있다.Element 인터페이스를 확장하는 작업은 새로운 Element 서브클래스를 많이 정의하게 되는 것이 아니라, 하나의 방문자 서브클래스를 정의하는 정도의 작업으로 단순해진다.객체구조 순회의 책임방문자는 각 객체 구조 요소에 방문해야 한다.순회를 위한 연산은 세곳 중 어떤곳이라도 놓일 수 있다. 객체 구조 컬렉션은 Accept() 연산을 호출함으로써 자신의 원소들을 순회 복합체는 각 Accept() 연산이 그 원소의 자식을 순회하고 다시 자식들에 대해 재귀적으로 Accept() 를 호출함으로써 순회를 진행 방문자 ConcreteElement에 대한 ConcreteVisitor 마다 동일한 순회 알고리즘 코드를 중복시켜야 함 객체 구조에 대한 연산 호출의 결과에 따라 다른 복잡한 순회 방법을 구현 가능 별도의 Iterator 객체 내부 반복자, 외부 반복자를 통해 원소들을 순회 Implement Example/*** @brief Element - Equiment* @details*/class Equiment {public: virtual ~Equiment(); const char* name() { return m_name; } virtual Watt power(); virtual Currency netPrice(); virtual Currency discountPrice(); virtual void accept(EquimentVisitor&amp;amp;);protected: Equiment(const char*);private: const char* m_name;};/*** @brief Visitor - EquimentVisitor* @details */class EquimentVisitor {public: virtual ~EquimentVisotor(); virtual void VisitFloppyDisk(FloppyDisk*); virtual void VisitCard(Card*); virtual void VisitChassis(Chassis*); virtual void VisitBus(Bus*); // Equiment의 구체 서브클래스를 위한 기타 연산들 ...protected: EquimenVisitor();};/*** @brief ConcreteElement - FloppyDisk* @details */class FloppyDisk : public Equiment {public: FloppyDisk(); void accept(EquimentVisitor&amp;amp; visitor) override { visitor.VisitFloppyDisk(this); } ...};/*** @brief ConcreteElement - Chassis* @details*/class Chassis : public Equiment {public: Chassis(); void accept(EquimentVisitor&amp;amp; visitor) override { for(const auto&amp;amp; iter : m_equimentVec){ iter.accept(visitor); } visitor.VisitChassis(this); } ...private: std::vector&amp;lt;Equiment*&amp;gt; m_equimentVec;};/*** @brief ConcreteVisitor - Equiment* @details*/class PricingVisitor : public EquimentVisitor {public: PricingVisitor(); Currency&amp;amp; getTotalPrice(); void VisitFloppyDisk(FloppyDisk* e) override { m_total += e-&amp;gt;netPrice(); } void VisitCard(Card* e) override { ... } void VisitChassis(Chassis* e) override { m_total += e-&amp;gt;discountPrice(); } void VisitBus(Bus* e) override { ... } ...private: Currency m_total;};/*** @brief ConcreteVisitor - Equiment* @details*/class InventoryVisitor : public EquimentVisitor {public: InventoryVisitor(); Inventory&amp;amp; getInventory(); void VisitFloppyDisk(FloppyDisk* e) override { m_inventory.push(e); } void VisitCard(Card* e) override { ... } void VisitChassis(Chassis* e) override { m_inventory.push(e); } void VisitBus(Bus* e) override { ... } ...private: Inventory m_inventory;};... Equiment* component; InventoryVisitor visitor; component-&amp;gt;accept(visitor); std::cout &amp;lt;&amp;lt; &quot;Inventory&quot; &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &quot;Name : &quot; &amp;lt;&amp;lt; component-&amp;gt;name() &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &quot;Inventory List : &quot; &amp;lt;&amp;lt; visitor.getInventory() &amp;lt;&amp;lt; std::endl; ...Related PatternComposite Pattern이 정의하는 복합 객체 구조에 대해 연산을 적용하는 데 Visitor Pattern를 사용할 수 있다. Visitor Pattern은 Interpreter Pattern의 해석과정에도 사용 가능하다.참고. Design Patterns : Elements of Reusable Object-Oriented Software - Erich Gamma" }, { "title": "Design Patterns - Template Method", "url": "/posts/design_patterns-template_method/", "categories": "Design Patterns", "tags": "Design Patterns, Behavioral Patterns, Template Method, C++", "date": "2020-04-28 06:32:00 +0900", "snippet": "Behavioral Patterns - Template MethodIntent객체의 연산에는 알고리즘의 뼈대만을 정의하고 각 단계에서 수행할 구체적 처리는 서브클래스 쪽으로 미룬다.알고리즘의 구조자페는 그대로 놔둔채 알고리즘 각 단계 처리를 서브클래스에서 재정의할 수 있게 한다.Utility 어떤 한 알고리즘을 이루는 부분 중 변하지 않는 부분을 한 번 정의해 놓고 다양해질 수 있는 부분은 서브클래스에서 정의할 수 있도록 남겨두고자 할 떄 서브클래스 사이의 공통적인 행동을 추출하여 하나의 공통 클래스에 몰아둠으로써 코드 중복을 피하고 싶을 떄 기존 코드에서 나타나는 차이점을 뽑아 이를 별도의 새로운 연산들로 구분한 뒤, 달라진 코드 부분을 이 새로운 연산을 호출하는 템플릿 메소드로 대체하는 것이다. 서브클래스의 확장을 제어할 수 있다. 템플릿 메소드가 어떤 특정한 시점에 “훅(Hook)” 연산을 호출하도록 정의하여 그 특정 시점에만 확장되도록 한다. StructureBasic StructureStructure ExampleElements AbstractClass Application에 해당 서브클래스들이 재정의를 통해 구현해야 하는 알고리즘 처리 단계 내의 기본연산을 정의 알고리즘의 뼈대를 정의하는 Template Method를 구현 Template Method는 AbstractClass에 정의된 연산 또는 다른 객체 연산뿐만 아니라 기본 연산도 호출 ConcreteClass MyApplication에 해당 서브클래스마다 달라진 알고리즘 처리 단계를 수행학기 위한 기본 연산을 구현 Elements CommunicationConcreteClass는 AbstractClass를 통하여 알고리즘의 변하지 않는 처리 단계를 구현한다.FeatureTemplate Method는 코드 재사용을 위한 기본 기술이다. 특히, 클래스 라이브러리 구현 시, 라이브러리에 정의할 클랫스들의 공통 부분을 분리하는 수단이기 때문에 자주 사용된다.Template Method는 역전된 제어 구조를 끌어낸다. 즉, 부모 클래스는 서브클래스에 정의된 연산을 호출할 수 있지만 반대 방향의 호출은 안된다.Template Method는 여러 종류의 연산 중 하나를 호출한다. 구체 연산(Concrete Operation) ConcreteClass나 사용자 클래스에 정의된 연산 AbstractClass 구체 연산 서브클래스에서 일반적으로 유용한 연산 기본 연산 추상화된 연산 Factory Method 훅 연산(Hook Operation) 필요하다면 서브클래스에서 확장할 수 있는 기본 행동을 제공하는 연산 기본적으로는 아무 내용도 정의하지 않는다 Template Method Pattern에서는 어떤 연산이 오버라이드가 가능한 훅 연산인지, 꼭 오버라이드를 해야하는 추상 연산인지를 지정해 두는 것이 매우 중요하다.훅 연산은 반드시 재정의 해야하는 연산이며 추상할 클래스를 효과적으로 재사용하기 위해서, 서브클래스 작성자는 어떤 연산들이 오버라이드용으로 설계되었는지를 명확히 이해하고 있어야 한다. 서브클래스는 부모 클래스에 정의된 연산을 명시적으로 호출하고 또 재정의함으로써 부모 클래스 연산을 확장한다.void DerivedClass::Operation() { ParentClass::Operation(); // 확장할 내용을 추가한다 ...}서브클래스가 부모 클래스의 행동을 확장하는 연산들을 Template Method로 옮겨 놓음으로써 부모 클래스에게 서브클래스의 확장을 제어할 수 있는 권한을 부여할 수 있다. 이 아이디어는 부모 클래스의 Template Method에서 훅 연산을 호출하도록 하는 것이다. 서브클래스는 이 훅 연산을 재정의할 수 있다.void ParentClass::Operation(){ // 부모 클래스가 정의한 행동 HookOperation();}일반적으로 ParentClass에 정의된 HookOperation() 은 아무런 행동도 정의하지 않는다.void ParentClass::HookOpertaion() {}서브클래스에서는 행동을 확장하려고 HookOperation() 을 재정의한다.void DerivedClass::HookOperation() { // 상속받는 클래스가 확장항 코드 ...}ImplementationConsiderations point in implementaionC++의 접근 제한 방법을 이용C++로 구현시, Template Method에서 호출하는 기본 연산들을 protected 멤버로 구현한다. 이렇게 하면 이 연산들을 Template Method만 호출할 수 있게 된다. 오버라이드해야 하는 기본 연산은 반드시 순수 가상함수로 정의한다. Template Method 자체를 재정의되면 안되므로, Template Method는 비사강 멤버 함수로 만든다.기본 연산의 수를 최소화Template Method를 구현하는 중요한 목적 중 하나는 서브클래스가 알고리즘을 실체화하기 위해 오버라이드해야 하는 기본 연산의 갯수를 줄이는 것이다.이름을 짓는 규칙 정의재정의가 필요한 연산은 식별이 잘 되도록 접두사를 붙이는 것이 좋다.Implement Example/*** @brief AbstractClass - AbstractClass* @details*/class AbstractClass {public: void TemplateMethod() const { this-&amp;gt;BaseOperation1(); this-&amp;gt;RequiredOperations1(); this-&amp;gt;BaseOperation2(); this-&amp;gt;Hook1(); this-&amp;gt;RequiredOperation2(); this-&amp;gt;BaseOperation3(); this-&amp;gt;Hook2(); }protected: void BaseOperation1() const { std::cout &amp;lt;&amp;lt; &quot;AbstractClass says: I am doing the bulk of the work\\n&quot;; } void BaseOperation2() const { std::cout &amp;lt;&amp;lt; &quot;AbstractClass says: But I let subclasses override some operations\\n&quot;; } void BaseOperation3() const { std::cout &amp;lt;&amp;lt; &quot;AbstractClass says: But I am doing the bulk of the work anyway\\n&quot;; } virtual void RequiredOperations1() const = 0; virtual void RequiredOperation2() const = 0; virtual void Hook1() const {} virtual void Hook2() const {}};/*** @brief ConcreteClass - ConcreteClass1* @details*/class ConcreteClass1 : public AbstractClass { protected: void RequiredOperations1() const override { std::cout &amp;lt;&amp;lt; &quot;ConcreteClass1 says: Implemented Operation1\\n&quot;; } void RequiredOperation2() const override { std::cout &amp;lt;&amp;lt; &quot;ConcreteClass1 says: Implemented Operation2\\n&quot;; }};/*** @brief ConcreteClass - ConcreteClass2* @details*/class ConcreteClass2 : public AbstractClass { protected: void RequiredOperations1() const override { std::cout &amp;lt;&amp;lt; &quot;ConcreteClass2 says: Implemented Operation1\\n&quot;; } void RequiredOperation2() const override { std::cout &amp;lt;&amp;lt; &quot;ConcreteClass2 says: Implemented Operation2\\n&quot;; } void Hook1() const override { std::cout &amp;lt;&amp;lt; &quot;ConcreteClass2 says: Overridden Hook1\\n&quot;; }};/*** @brief Client - ConcreteClass2* @details*/void ClientCode(AbstractClass *class_) { // ... class_-&amp;gt;TemplateMethod(); // ...}... ConcreteClass1 *concreteClass1 = new ConcreteClass1; ClientCode(concreteClass1); ConcreteClass2 *concreteClass2 = new ConcreteClass2; ClientCode(concreteClass2);...Related PatternFactory Method Pattern은 종종 Template Method Pattern 이라고도 한다.Template Method Pattern은 상속을 이용하여 다양한 알고리즘을 만들어 낸다. 이점은 Strategy Pattern과도 관계가 있으며, 각 전략들은 위임을 통해 전체 알고리즘을 다양화한다.참고. Design Patterns : Elements of Reusable Object-Oriented Software - Erich Gamma" }, { "title": "Design Patterns - Strategy", "url": "/posts/design_patterns-strategy/", "categories": "Design Patterns", "tags": "Design Patterns, Behavioral Patterns, Strategy, C++", "date": "2020-04-25 23:32:00 +0900", "snippet": "Behavioral Patterns - StrategyIntent동일 계열의 알고리즘군을 정의하고, 각 알고리즘을 캡슐화하며, 이들을 상호교환이 가능하도록 만든다.알고리즘을 사용하는 클라이언트와 상관없이 독립적으로 알고리즘을 다양하게 변경할 수 있게 한다.정책(Policy)이라고도 불린다.Utility 행동들이 조금씩 다를 뿐 개념적으로 관련된 많은 클래스들이 존재할 때 Strategy Pattern은 많은 행동 중 하나를 가진 클래스를 구성할 수 있는 방법을 제공한다. 알고리즘의 변형이 필요할 때 예를 들어, 기억공간과 처리속도 간의 절충에 따라 서로 다른 알고리즘을 정의할 수 있을 것이다. 이러한 변형물들이 알고리즘의 상속 관계로 구현될 떄 Strategy Pattern을 사용할 수 있을것이다. 사용자가 몰라야 하는 데이터를 사용하는 알고리즘이 있을 떄 노출하지 말아야 할 복잡한 자료구조는 Strategy 클래스에만 두면 되므로 사용자는 몰라도 된다. 하나의 클래스가 많은 행동을 정의하고, 어떤 행동들이 그 클래스의 연산 안에서 복잡한 다중 조건문의 모습을 취할 때 많은 조건문보다는 각각을 Strategy 클래스로 옮겨놓는 것이 좋다. StructureBasic StructureStructure ExampleElements Strategy Composite에 해당 제공하는 모든 알고리즘에 대한 공통의 연산들은 인터페이스로 정의 Comtext 클래스는 ConcreteStrategy 클래스에 정의한 힌터페이스를 통해서 실제 알고리즘을 사용 ConcreteStrategy SimpleCompositer, TeXcompositor, ArrayCompositor에 해당 인터페이스를 통해 실제 알고리즘을 구현 Context Composition에 해당 ConcreteStrategy 객체를 통해 구성 Strategy 객체에 대한 참조자를 관리하고, 실제로는 Strategy 서브클래스의 인스턴스를 가지고 있음으로써 구체화 함 Strategy 객체가 자료에 접근해가는 데 필요한 인터페이스를 정의 Elements CommunicationStrategy 클래스와 Context 클래스는 의사교환을 통해 선택한 알고리즘을 구현한다. 즉, Context 클래스는 알고리즘에 해당하는 연산이 호출되면, 알고지름 처리에 필요한 모든 데이터를 Strategy 클래스로 보낸다. 이때, Context 객체 자체를 Strategy 연산에 인자로 전송할 수도 있다.Context 클래스는 사용자 쪽에서 온 요청을 각 Strategy 객체로 전달한다. 이를 위해 사용자는 필요한 알고리즘에 해당하는 ConcreteStrategy 객체를 생성하여 이를 Context 클래스에 전송하는데, 이 과정을 거치면 사용자는 Context 객체와 전달한 ConcreteStrategy 객체와 함께 동작한다.Feature동일 계열의 관련 알고리즘군이 생긴다Strategy 클래스 계층은 동일 계열의 알고리즘군 혹은 행동군을 정의한다. 이러한 알고리즘 자체의 재사용도 가능하다. 즉, 상속을 통해 알고리즘 공통의 기능성들을 추출하고 이를 재사용 할 수 있다.서브클래싱을 사용하지 않는 대안이다상속은 다양한 알고리즘이나 행동을 지원하는 또 다른 방법이다.서로 다른 행동을 제공하기 위해 Context 클래스를 직접 상속받을 수도 있다. 그러나 이렇게 행동의 처리 방법을 Context에 직접 하드코딩하게 되면, 후에 수정이 어렵게 된다. 그러므로 다양한 알고리즘을 만들어 낼 수 없게된다.알고리즘을 Strategy 클래스로 독립시키면 Context와 무관하게 알고리즘을 변형시킬수 있고, 알고리즘을 바꾸거나 이래하거나 확장하기도 쉬워진다.조건문을 없앨 수 있다Strategy Pattern을 사용하면 원하는 행동들을 선택하는 조건문을 없앨 수 있다.// Strategy Pattern 미사용시 조건문을 통해 알고리즘을 선택한다void Composittion::repair() { switch(m_breakingStrategy) { case SimpleStrategy : ComposeWithSimpleCompositor() break; case Texstrategy : ComposeWithTexCompositor() break; ... } // 필요하다면 기존 복합으로 결과를 병합한다. ...}// Strategy Pattern 사용시 조건문이 필요없게 된다.void Composittion::repair() { m_compositor-&amp;gt;compose(); // 필요하다면 기존 복합으로 결과를 병합한다. ...}구현의 선택이 가능하다동일한 행동에 대하여 서로 다른 구현을 제공한다. 사용자는 서로 다른 시간과 공간이 필요한 여러 Strategy들 중 하나를 선택할 수 있다.사용자(프로그램)은 서로 다른 전략을 알아야 한다동일한 행동에 대하여 서로 다른 전략을 선택하기 전에 전략들이 어떻게 다른지 이해해야 한다. 즉, 사용자는 구현 내용을 모두 알고 있어야 하며, 사용자가 이렇게 서로 다른 행동 각각의 특징을 미리 알고 있을 때 Strategy Pattern을 사용할 수 있다.Strategy 객체와 Context 객체 사이에 의사소통 오버헤드가 있다서브클래스에서 구현할 알고리즘의 복잡함과는 상관없이 모든 ConcreteStrategy 클래스는 Strategy 인터페이스를 공유한다. 따라서 어떤 ConcreteStrategy 클래스는 이 인터페이스를 통해 들어온 모든 정보를 다 사용하지 않는데도 이 정보를 떠안아야 할 경우가 생기게된다. 즉, 사용하지도 않을 매개변수를 Context 객체가 생성하고 초기화할 때도 있다는 말이 된다.위와같은 상황이라면, Strategy와 Context 클래스 사이에 좀더 높은 결합도가 필요하게 된다.객체의 수가 증가한다Strategy들로 인해 응용프로그램 내의 객체 수가 증가한다.간혹, Context 객체들이 공유 가능한 상태 없는 객체로서 Strategy를 구현하여 불필요한 오버헤드를 줄일 수도 있다. 이때. 처리에 필요한 상태는 Context 클레스에서 관리한다. 공유한 Strategy들은 호출사이의 상태를 관리하지 말아야 한다.이러한 방법을 더울 자세히 만든 것이 바로 Flyweight Pattern 이다.ImplementationConsiderations point in implementaionStrategy 및 Context 인터페이스를 정의Strategy와 Context 인터페이스는 ConcreteStrategy가 Context에서 어떠한 정보가 필요할 떄, 효율적으로 접근 가능해야 하고, 그 반대로 Context에서 ConcreteStrategy의 접근 또한 가능하도록 만들어져야 한다. 이러한 접근을 구현하기 위해 아래 두가지 방법이 있다. Context가 Strategy의 연산 쪼으로 데이터를 매개변수에 담아 보내지도록 한다. 데이터를 Strategy으로 보내는 것이다. Strategy 클래스와 Context 클래스 간의 결합도를 낮출수 있다. Context는 Strategy에 필요없는 데이터를 전달할 수도 있다. Context 객체가 자기 자신을 Strategy 객체에 인자로 보내고, Strategy 객체는 Context 객체에서 데이터를 요청 하거나, Strategy 클래스는 Context 클래스에 대한 참조정보를 저장한다. Strategy 객체가 Context에 정의된 인터페이스를 이용하여 정의한 정보들을 매번 얻어야 하기 때문에, Context는 데이터에 접근할 수 있는 인터페이스를 더욱이 정교하게 정의해야 한다. Strategy 클래스와 Context 클래스간 결합도가 높아진다. 전략을 템플릿 매개변수로 사용C++의 템플릿 기능을 사용하여 Strategy을 가진 클래스를 구성할 수 있다. 이 기법은 두가지 조건이 만족되어야만 적용가능하다. Strategy 객체를 컴파일 타임에 결정할 수 있을 떄 Strategy 객체가 런타임에 바꿀 필요가 없을 때두 조건이 만족하면, 구성할 클래스를 템플릿 클래스로 정의하고, Strategy 클래스 이 템플릿의 매개변수로 정의한다.template&amp;lt;class Astrategy&amp;gt;class Context { void operate() { m_strategy.doAlgorithm(); } ...private: Astrategy m_strategy;};class MyStrategy {public: void doAlgorithm();};... Context&amp;lt;MyStrategy&amp;gt; context;...템플릿을 이용하면 Strategy 인터페이스를 정의하는 추상 클래스를 정의할 필요가 없게된다. Strategy를 템플릿의 매개변수로 사용하기 때문에 Strategy와 Context는 정적으로 바인딩됨으로써 효율이 증가하는 효과를 볼수 있게 된다.Strategy 객체에 선택성을 부여Strategy 객체를 가지지 않는 편이 나을 때, Context 객체를 단순하게 만들 수도 있다.Context는 Strategy 객체가 접근하기 전 자신에게 Strategy 객체가 있는지를 확인한다. Strategy 객체가 있다면 그냥 그것을 사용하고, 없다면 기본 행동을 수행한다. 이 방법은 사용자가 기본 행동을 사용해도 무방하다면 Strategy 객체를 꼭 사용하지 않아도 된다는 이점이 있다.Implement Example/*** @brief Context - Container* @details 구현한 ConcreteStrategy를 선택하여 해당 객체가 가지는 알고리즘 동작*/class Container {public: Container(Filter* filter) : m_filter(Container) {} // 선택한 ConcreteStrategy의 알고리즘을 실행하는 인터페이스 정의 및 구현 void separateData() { m_filter-&amp;gt;filtering(m_vec); } ...private: Filter* m_filter = nullptr; std::vector&amp;lt;int&amp;gt; m_vec;};/*** @brief Strategy - Filter* @details 구현할 알고리즘의 기본이 되는 인터페이스 정의*/class Filter {public: // ConcreteStrategy에서 구현해야할 알고리즘의 인터페이스 정의 virtual void filtering() = 0;protected: Filter();};/*** @brief ConcreteStrategy - OddFilter* @details Strategy의 인터페이스를 구현하여 독자적인 알고리즘을 가짐*/class OddFilter : public Filter {public: OddFilter(); // 자신만의 알고리즘 구현 void filtering(std::vector&amp;lt;int&amp;gt;&amp;amp; vec) override { std::vector&amp;lt;int&amp;gt; oddVec; for(const auto* i : vec){ if(i &amp;amp; 1 != 0) oddVec.push_back(); } vec.clear(); vec.resize(oddVec.size()); std::copy(oddVec.begin(), oddVec.end(), vec.begin()); }};/*** @brief ConcreteStrategy - EvenFilter* @details Strategy의 인터페이스를 구현하여 독자적인 알고리즘을 가짐*/class EvenFilter : public Filter {public: EvenFilter(); // 자신만의 알고리즘 구현 void filtering() override { std::vector&amp;lt;int&amp;gt; evenVec; for(const auto* i : vec){ if(i &amp;amp; 1 == 0) evenVec.push_back(); } vec.clear(); vec.resize(evenVec.size()); std::copy(evenVec.begin(), evenVec.end(), vec.begin()); }};... // Context 객체 및 Strategy 선택 Container* oddContainer = new Container(new OddFilter()); Container* evneContainer = new Container(new EvenFilter()); ... // 자신이 선택한 ConcreteStrategy의 알고리즘 실행 oddContainer-&amp;gt;separateData(); evneContainer-&amp;gt;separateData();...Related PatternStrategy 객체는 규모가 작은 클래스들이므로 Flyweight Pattern으로 정의하는것이 바람직하다.참고. Design Patterns : Elements of Reusable Object-Oriented Software - Erich Gamma" }, { "title": "Design Patterns - State", "url": "/posts/design_patterns-state/", "categories": "Design Patterns", "tags": "Design Patterns, Behavioral Patterns, State, C++", "date": "2020-04-25 21:12:00 +0900", "snippet": "Behavioral Patterns - StateIntent객체 내부 상태에 따라 스스로 행동을 변경할 수 있개 허가하는 패턴으로, 이렇게 하면 객체는 마치 자신의 클래스를 바꾸는 것과 같은 효과를 보인다.상태 표현 객체(Object for State) 라고도 불린다.Utility 객체의 행동이 상태에 따라 달라질 수 있고, 객체의 상태에 따라서 런타임에 행동이 바뀌어야 할 때 어떤 연산안에 그 객체의 상태에 따라 달라지는 다중 분기 조건 처리가 너무 많이 들어있을 때 객체의 상태를 표현하기 위해 상태를 하나 이상의 나열형 상수(enum)으로 정의해야 한다. 동일한 조건 문장들을 하나 이상의 연산에 중복 정의해야 할 때 객체의 상태를 별도의 객체로 정의하면, 다른 객체들과 상관없이 그 객체의 상태를 다양화 할 수 있다. StructureBasic StructureStructure ExampleElements Context TCPConnection에 해당 사용자가 관심 있는 인터페이스를 정의 객체의 현재 상태를 정의한 ConcreteState 서브클래스의 인스턴스를 유지, 관리 State TCPState에 해당 Context의 각 상태별로 필요한 행동을 캡슐화하여 인터페이스로 정의 ConcreteState TCPEstabilished, TCPListen, TCPClosed에 해당 State의 각 서브클래스들은 Context의 상태에 따라 처리되어야 할 실제 행동을 구현 Elements Communication상태에 따라 다른 요청을 받으면 Context 클래스는 현재의 ConcreteState 객체로 전달한다. 이 ConcreteState 클래스의 객체는 State 클래스를 상속하는 서브클래스들 중 하나의 인스턴스 이다.Context 클래스는 실제 연산을 처리할 State 객체에 자신을 매개변수로 전달한다. 이로써 State 객체는 Context 클래스에 정의된 정보에 접근할 수 있게된다.Context 클래스는 사용자가 사용할 수 있는 기본 인텀페이스를 제공한다. 사용자는 State 객체를 Context 객체와 연결시킨다. 즉, Context 클래스에 현재 상태를 정의하는 것이다. 이렇게 Context 객체를 만들고 나면 사용자는 더는 State 객체를 직접 다루지 않고 Context 객체에 요청을 보내기만 하면 된다.Context 클래스 또는 ConcreteState 서브클래스들은 자기 다음의 상태가 무엇이고, 어떤 환경에서 다음 상태로 가는지 결정할 수 있다. 즉, 상태는 상태 전이 규칙이 있으므로 각각 한 상태에서 다른 상태로 전이하는 규칙을 알아야 한다.Feature상태에 따른 행동을 국소화하며, 서로 다른 상태에 대한 행동을 별도의 객체로 관리한다State Pattern을 사용하면 임의의 한 상태에 관련된 모든 행동을 하나의 객체로 모을수 있다.State Pattern을 사용하지 않는다면, 내부 상태를 저장해 둘 변수를 선언하고, Context의 연산이 그 데이터를 명시적으로 점검해야 한다. 즉, 이 변수를 통해 상태를 계속 확인하기 위해 case문을 통해 구현한다. 그러나 각 연산마다 태별 처리방법이 다르다면 동일한 case문이 여러 연산에 걸처 반복적으로 나타나게 되고, 새로운 상태가 추가될 떄마다 여러 연산을 변경하게 된다.State Patten은 위와 같은 문제를 해결할 수 있다. 한 상태에 종속적인 코드를 State 클래스의 서브클래스에 모두 정의하기 때문에 새로운 상태와 새로운 전이 규칙이 발견되면 새로운 서브클래스만 정의하면 되기 때문이다. 그러나 이 패턴은 상태에 따른 행동을 여러 클래스에 나누어 정의하기 때문에 클래스의 수가 많아 질 수 있고, 단일 클래스보다 콤팩트하지 않다.State Pattern 상태별 거대한 코드를 구조화하는데 도움을 준다. 상태 전이에 필요한 코드를 if-else문으로 처리하지 않고, 각 상태 클래스의 연산을 독립적으로 구현하여 처리한다.상태 전이를 명확하게 만든다어떤 객체가 자신의 현재 상태를 오직 내부 데이터 값으로만 정의하면, 상태 전이는 명확한 표현을 가지지 못한다. 단지 이 상태 변수에 값을 항당하는 문장 정도밖에는 되지 않는다.각 상태별로 별도의 객체를 만드는 것은 상태 전이를 명백하게 해주는 결과가 된다. 상태 전이가 Context 클래스의 관점과 상관없이 원자적이기 때문에, State 객체는 Context 객체가 일관되지 않은 상태가 되는 것을 막아줄 수 있다.상태는 여러 개의 변수가 아니라 하나의 변수, 즉 Context의 State 객체 변수를 재바인딩함으로써 전이될 뿐이다.상태 객체는 공유될 수 있다상태는 단지 타입으로만 표현되므로, State 객체는 인스턴스 변수 없이 여러 Context 클래스의 인스턴스로도 객체를 공유할 수 있다.상태가 위와같이 공유될 때, 이 공유된 상태는 실질적으로 Flyweight 객체라고 해도 무방하다.ImplementationConsiderations point in implementaion상태 전이를 정하는 주체State Pattern은 어떤 참여자가 상태 전이를 책임질지 명시하지 않는다.상태 전이의 기준을 Context 클래스안에 구현할 수도 있고, State 클래스의 서브클래스들이 자신 다음에 오는 상태가 무엇이고 상태 전이가 언제 될지를 정할 수도 있다. 일반적으로 후자의 경우가 더 유연하고 적절한 방법이다.상태 전이 코드가 여기저기 분산된다면, State의 새로운 서브클래스를 만드는 것이 더 쉬워진다. 그러나 State 서브클래스가 적어도 자신 다음에 나오는 다음 State 서브클래스를 알아야 하기 때문에 서브클래스 사이의 구현 종속성이 생길 수 있다.테이블 기반의 대안테이블 기반의 대안은 입력 값과 상태 전이를 매핑하는 방법이다. 각 상태마다 테이블을 이용하여 그 상태에서 처리 가능한 입력과 그 입력으로 생길 수 있는 다음 상태를 매핑하는 것이다. 이 방법을 사용하면 조건식 코드(State Patten의 경우 가상함수도 포함된다)가 테이블 탐색 코드로 바뀌게 된다.테이블을 이용하는 구현의 경우, 프로그램을 바꾸지 않고 테이블에 저장한 값만 바꾸면 새로운 전이 기준으로 바꿀수 있다는 장점이 있다. 즉, 테이블이라는 형식에 전이 기준을 맞춘다는 점에서 규칙성(Regularity)가 있다는 것이다.그러나 아래와 같은 단점도 존재한다. 테이블 탐색은 간혹 가상함수 및 일반함수 호출보다 비효율적일 때가 있다. 상태 전이에 관한 논리 흐름을 테이블이라는 규칙적인인 형식에 맞추면 전이 기준이 불명확해지며 이해하지 어려워진다. 상태 전이에 따른 처리 동작을 추가하기가 복잡하다. 테이블을 이용한 벙법은 상태와 전이를 테이블에 저장하여 어느 상태로 전이해야 하는지 알아야 하며, 각 전이를 위해 임의로 처리해야 하는 연산을 수행하려면 각각의 처리 내용도 추가해야 한다. 테이블 기반의 대안과 State Pattern 사이에 존재하는 가장 큰 차이는, State Pattern 주 목적은 상태별로 다른 행동을 별도의 클래스로 만드는 것인 반면, 테이블 기반의 방법은 상태 전이를 정의하는 쪽에 초점을 맞추는 것이다.상태 객체의 생성과 소멸상태 객체의 생성과 소멸을 구현할 떄 가장 일반적인 선택사항은 아래 두가지가 있다. 상태 객체를 필요할 때만 생성하고 필요 없게 되면 없앤다. 상태가 실행되기 전까지는 어떤 상태여야 하는지 모르거나 상황에 따라 상태가 자주 바뀌지 않을때 유용하다. “사용하지 않는 객체는 생성하지 않는다”는 원칙으로, State 객체가 많은 정보를 가지고 있을때 유용하다. 필요하기 전에 미리 만들어 둔 후 없애지 않고 계속 둔다. 필요할 떄마다 생성하고 다시 없애는 것을 반복할 필요가 없기 때문에, 상태 변화가 수시로 일어날 경우에 유용하다. Context 클래스가 언제나 모든 상태에 대한 참조자를 계속 관리해야 하는 부담이 생긴다. Implement Example/*** @brief Context - TCPConnection* @details 사용자측에서 사용할 인터페이스 정의*/class TCPConnection {public: TCPConnection() { // TCPConnection의 초기상태를 TCPClosed으로 설정 m_state = TCPClosed::Instance(); } void processOctet(TCPOctetStream*); // State에 대한 Context의 행동의 인터페이스 정의 // 행동에 대한 실제 구현은 ConcreteState에서 구현 // 해당 함수가 실제로 동작하는 행동은 현재 State에 위임 void activeOpen() { m_state-&amp;gt;activeOpen(this); } void passiveOpen() {m_state-&amp;gt;passiveOpen(this); } void close() { m_state-&amp;gt;close(this); } void send(void* data) { m_state-&amp;gt;send(data, this); } void acknowledge() { m_state-&amp;gt;acknowledge(this); } void synchronize() { m_state-&amp;gt;synchronize(this); }protected: friend class TCPState; void changeState(TCPState* state) { m_state = state; }private: TCPState* m_state;};/*** @brief State - TCPState* @details Context의 상태와 그 행동에 대한 인터페이스 정의*/class TCPState{public: virtual ~State(); virtual void transmit(TCPConnection* connection, tcpOctetStream* stream) {} virtual void activeOpen(TCPConnection* connection) {} virtual void passiveOpen(TCPConnection* connection) {} virtual void close(TCPConnection* connection) {} virtual void synchronize(TCPConnection* connection) {} virtual void acknoweldge(TCPConnection* connection) {} virtual void send(TCPConnection* connection) {}protected: void changeState(TCPConnection* connection, TCPState* state) { // Context의 상태를 매개변수로 받은 ConcreteState로 변경 connection-&amp;gt;changeState(state); }};/*** @brief ConcreteState - Established* @details 해당하는 State의 인터페이스에 대해 행동을 구현*/class TCPEstablished : public TCPState { static TCPState* instence(); void transmit(TCPConnection* connection, tcpOctetStream* stream) override { connection-&amp;gt;processOctet(stream); } void close(TCPConnection* connection) override { // 행동 정의 ... // TCPConnection의 상태를 TCPListen으로 상태 변경 changeState(connection, TCPListen::Insctence()); } ...};/*** @brief ConcreteState - Established* @details 해당하는 State의 인터페이스에 대해 행동을 구현*/class TCPListen : public TCPState { static TCPState* instence(); void send(TCPConnection* connection) override { // 행동 정의 ... // TCPConnection의 상태를 TCPListen으로 상태 변경 changeState(connection, TCPEstablished::Insctence()); } ...};/*** @brief ConcreteState - Established* @details 해당하는 State의 인터페이스에 대해 행동을 구현*/class TCPClosed : public TCPState { static TCPState* instence(); void activeOpen(TCPConnection* connection) override { // 행동 정의 ... // TCPConnection의 상태를 TCPEstablished으로 상태 변경 changeState(connection, TCPEstablished::Insctence()); } void passiveOpen(TCPConnection* connection) override { // 행동 정의 ... // TCPConnection의 상태를 TCPListen 상태 변경 changeState(connection, TCPListen::Insctence()); } ...};Related PatternState 객체의 공유 시점과 공유 방법을 정의하는 데는 Flyweight Pattern 을 이용한다.State 객체는 종종 하나만 존재할 때가 많은데, 이때는 *Singleton Pattern을 이용한다.참고. Design Patterns : Elements of Reusable Object-Oriented Software - Erich Gamma" }, { "title": "Design Patterns - Observer", "url": "/posts/design_patterns-observer/", "categories": "Design Patterns", "tags": "Design Patterns, Behavioral Patterns, Observer, C++", "date": "2020-04-25 01:44:00 +0900", "snippet": "Behavioral Patterns - ObserverIntent객체 사이에 일 대 다의 의존 관계를 정의해 두어, 어떤 객체의 상태 변할 때 그 샛체에 의존성을 가진 다른 객체들이 그 변화를 통지 받고 자동으로 갱신될 수 있도록 한다.종속자(Dependent), 게시-구독(Publish-Subscribe) 라고도 불린다.Utility 어떤 추상 개념이 두 가지 양상을 가지고 하나가 다른 하나에 종속적일 때 각 걍상을 별도로 객체로 캡슐하여 이들 각각을 재사용 할 수 있다. 한 객체에 가해진 변경으로 다른 객체를 변경해야 하고, 프로그래머들은 얼마나 많은 객체들이 변경되어야 하는지 몰라도 될 때 어떤 객체가 다른 객체에 다른 변화를 통보할 수 있는데, 그 변화에 관심있어 하는 객체들이 누구인지에 대한 가정 없이도 그러한 통보가 될 때StructureBasic StructureStructure ExampleElements Subjects Observer들을 알고 있는 주체 임의 개수의 Observer 객체는 Subject를 감시 Subject는 Observer 객체를 붙이거나 떼는데 필요한 인터페이스를 제공 ConcreteSubjects ConcreteObserver 객체에게 알려주어야 하는 상태를 저장 상태가 변경될 떄 Observer에게 통보 Observers Subject에 생긴 변화에 관심 있는 객체를 갱신하는데 필요한 인텀페이스를 정의 Subject의 변경에 따라 변화되어야 하는 객체들의 일관성 유지 ConcreteObservers ConcreteSubject 객체에 대한 참조자를 관리 Subject의 상태와 일관성을 유지해야 하는 상태를 저장 Subject의 상태과 Observer의 상태를 일관되게 유지하는 데 사용되는 사용자 인터페이스를 구현 ConcreteSubject는 Observer의 상태와 자신의 상태가 달라지는 변경이 발생할 떄마다 Observer에게 통보한다.ConcreteSubject에서 변경이 통보된 후, ConcreteObserver는 필요한 정보를 Subject에게 질의하여 얻어온다. ConcreteObserver는 이 정보를 이용하여 Subject의 상태와 자신의 상태를 일치시킨다.다음 다이어그램은 하나의 Subject와 두 Observer 사시의 협력관계를 표현한 것이다.Notify() 연산은 Subject로만 호출되는 것이 아니고, Observer나 다른 객체들로도 호출이 가능하다.FeatureSubject와 Observer 클래스간에는 추상적인 결합도만이 존재한다Subject가 아는 것은 Observer들의 리스트일 뿐이다.Observer들은 Observer 클래스에 정의된 인터페이스를 따르지만, Subject는 어떤 ConcreteObserver 클래스가 있는지에 대해서는 알 필요가 없다. 그러므로 Subject와 Observer 간의 결합도는 추상적이며, 그 조차도 최소화 되어있다.Subject와 Observer 클래스가 강결합되어 있지 않기 때문에, 이들은 시스템의 여러 추상화 계층에 속할 수 있다. 하위 수준의 Subject라 할지라도 상위 수준의 Observer와 연결되어 교류할 수 있다.Broadcast 방식의 교류를 가능하게 한다Observer Pattern에서 Subject가 보내는 통보는 구체적인 수신자를 지정할 필요가 없다. 이 통보는 Subject의 정보를 원하는 모든 객체에 자동으로 전달되어야 한다.Subject는 얼마나 많은 객체들이 이 변화 정보를 원하는지 알 필요가 없으며, 단지 자신의 Observer에게만 상태 변화 사실을 알려주면, Observer가 이 통보를 처리할지 혹은 무시할지를 결정한다.예측하지 못한 정보를 갱신한다Observer는 다른 Observer의 존재를 모르기 때문에 Subject를 변경하는 비용이 궁극적으로 어느 정도인지 모른다.Subject에 계속적으로 어떤 연산이 가해질 떄, Observer와 Subject에 종속된 다른 객체들의 연속적인 수정을 일으킬수 있게 된다. 게다가, 잘 정의된 것도, 잘 유지된 것도 아닌 종속성 기준 때문에 불필요한 갱신이 일어날 수 있게된다.이러한 문제는, 단순한 갱신 프로토콜로는 Subject의 무엇을 변경했는지에 대한 상세한 정보를 알 수 없다는 사실 때문에 더욱 좋지 않다. Observer가 무엇이 변했는지 알 수 있게 해 주는 별도의 프로토콜이 추가되지 않는한, 변경을 유추하는 작업은 어렵게 된다.ImplementationConsiderations point in implementaionSubject와 그에 해당하는 Observer를 대응자신이 통보해 주어야 하는 Observer들을 Subject가 지속적으로 관리하도록 해야 한다.이를 구현하기 위해 Subject에 Observer에 대한 참조자를 저장하는 방법과, 별도의 탐색용 자료구조(해시 테이블 등)를 두고 Subject와 Observer 간의 대응 관계를 관리하게 하는 방법이 있다.하나 이상의 Subject를 감시어떨 때는 하나 이상의 Subject에 종속된 Observer가 있을 수 있다.Observer가 어떤 Subject에서 통보가 전달되었는지 알아야 한다면 Update() 연산을 확장할 필요가 있다. Subject는 Update() 연산에서 자신을 매개변수화하여 Observer가 어떤 Subject를 확인하고 있는지 알 수 있도록 한다.갱신을 촉발(trigger)시키는 존재Subject와 Observer가 각각 자신의 값을 정확하게 유지하기 위해서는 통보 매커니즘에 의존할 수 밖에 없다.값을 갱신하기 위해, 어느 객체에서 Notify() 연산을 호출할 것인지에 대해 두가지 선택사항이 있다. Subject 클래스의 상태 변경 후 상태를 지정하는 연산에서 NOtify() 연산을 호출 Subject가 정의한 Notify() 를 사용자가 호출할 필요없다. 계속되는 연산의 수행으로 여러 번 수정해야 하므로 비효율적이다. 사용자가 적시에 Notify() 연산을 호출하는 책임을 짐 사용자가 일련의 상태 변경이 될 떄까지 갱신의 시작을 미룰 수 있기 때문에, 중간 중간 불필요한 수정이 일어나지 않는다. 사용자측에서 Notify() 연산의 호출을 책임을 지므로, 해당 연산을 호출하는 것을 잊는 등의 오류가 있을 수 있다. 삭제한 Subject에 대한 무효(Dangling) 참조자를 계속 유지할 때Subject의 삭제로 Observer가 무효 참조자를 가자게 되도록 만들면 안된다.무효 참조자를 피하는 한가지 방법은 Subject가 Observer에게 “자신이 삭제되었으니 Observer에 대한 참조자를 지워라” 라고 통보하는 것이다. 다른 객체들이 Observer를 참조할 수 있고, 또 Observer들이 다른 Subject를 관찰해야 하기 때문에, 이러한 Observer의 삭제는 있을 수 있는 일이다.통보 전에 Subject의 상태가 자체 일관성을 가지도록 보장Observer는 자신의 상태를 변경하기 위해 Subject에게서 현재 상태를 질의한다. 이러한 자체 일관성(self- consistency) 규칙은 Subject 클래스에 정의한 연산이 상속한 연산을 호출하게 되면 뜻하지 않게 깨지기 쉽다./*** 기반클래스의 연산을 먼저 호출하고 자신의 상태를 바꾸게 될 떄,* 기반클래스의 연산으로 통보가 되고 자신이 변경한 상태는 반영되지 않는다.*/void MySubject::Operation(int newValue){ // 통보를 실행 BaseClassSubject::Operation(newValue); // 이미 늦은 서브클래스의 상태를 변경 m_myValue += newValue;}이 문제를 피하기 위해, Subject 클래스에 Template Method Pattern을 적용하여 이 Template Method를 통해 통보를 처리한다./*** 재정의할 서브클래스에서 오버라이드할 기본 연산을 정의하고,* Template Method의 마지막 연산에서 실제 Notify() 연산을 수행한다.* 이렇게 하면, *Subject* 연산을 서브클래스에서 오버라이드할 때 그 객체는* 자기 일관성을 유지할 수 있게 된다.*/void Text::Car(TextRange r){ // 이 부분은 후에 서브클래스가 재정의 ReplaceRange(r); notify();}여담으로, 어떤 Subject 클래스가 통지를 촉발시키는지에 대한 사항을 문서화하면 도움이 많이 된다.Observer별 갱신 프로토콜의 회피(Push Model &amp;amp; Pull Model)Observer Pattern을 구현하려고 변경이 발생할 떄, Subject가 추가적인 정보를 브로드캐스트하게 만들 때가 많다. Subject는 Update() 연산의 인자로 이 추가적인 정보를 전달해야 한다.Subject가 자신의 변경에 대한 상세한 정보를 Observer에게 전달하는 Push Model을 이용할 수 있다. 이 모델에서는 Subject가 Observer의 요청이 무엇인지 알아야 한다. 즉, Subject 클래스는 Observer 클래스에 대한 어떤 가정을 하게 되는데, 이런 가정이 항상 맞는것은 아니기 때문에 Observer 클래스의 재사용성이 떨어지게 된다Subject가 최소한의 정보만을 전달하고 Observer가 다시 상세 정보를 요청해 오는 Pull Model을 이용할 수 있다. 이 모델에서는 Subject가 Observer를 몰라도 된다. Pull Model을 사용하면 Observer 클래스가 subject와 상관없이 무엇이 변했는지를 확인해야 한다는 점에서 비효율적일 수 있다.자신이 관심 있는 변경이 무엇인지 명확하게 지정Subject 클래스에 자신이 관심 있는 이벤트에 대한 Observer를 등록하는 인터페이스를 정의함으로써 갱신의 과정을 좀더 효율화할 수 있다. 이렇게 관심 있는 이벤트가 발생할 때, Subject는 등록된 Observer에게만 알려주면 된다.특정 이벤트를 관심있는것으로 등록하려면, Subject는 다음 연산을 이용하여 Observer를 등록한다.void Subject::Attach(Observer*, Aspect&amp;amp; interest);여기서 interest 매개변수는 관심있는 이벤트를 의미한다. 실제로 통보가 일어날때, Subject는 Update() 연산의 매개변수로 관심 있는 변경된 내용을 전달한다.void Observer::Update(Subject*, Aspect&amp;amp; interest);복잡한 갱신의 의미 구조를 캡슐화Subject와 Observer 간에 일어나는 관련성이 복잡하다면, 이들 관련성을 관리하는 별도의 객체를 만들도록 한다.이 객체의 목적은 Observer가 처리해야 하는 Subject의 변경처리를 최소화 하는것이다. 예를 들어, 연산의 수행으로 여러개의 서로 관련된 Subject를 변경해야 한다고 가정했을 떄, 모든 Subject가 수정되고 나서, 이 Subject의 Observer에게는 딱 한 번만 통보 되어야 한다. 즉 Observer들에게 두 번 이상 통보되는 것을 피해야 한다.이러한 Subject와 Observer 사이의 관련성을 관리하는 별도의 객체는 다음과 같은 세가지를 책임져야 한다. Subject와 Observer를 매핑하고 이를 유지하는 인터페이스를 정의해야 한다. Subject는 자신들의 Observer가 누구인지, Observer는 자신들의 Subject가 누구인지 관리할 필요가 없어진다. 관련성 관리 객체는 특별한 갱신 전략이 필요하다. 관련성 관리 객체는 Subject에게 요청이 있을 때, 모든 독립적 Observer들을 다 수정해야 한다.다음의 다이어그램은 이 관련성 관리 객체(ChageManager)와 Subject, Observer 간의 관계도 이다.하나의 ChageManager 클래스가 여러 객체 간의 상태 변화를 총괄한다는 점에서 ChageManager 클래스는 일종의 Mediator Pattern의 예 이다. 일반적으로 이 ChageManager 클래스만 존재하므로, 이 클래스 객체는 전역적으로 Singleton Pattern을 통해 정의하는 것이 유용하다.Implement Example/*** @brief Subject - Subject* @details*/class Subject {public: virtual ~Subject(); virtual void attach(std::string&amp;amp; id, Observer* obj) { m_objMap[id] = obj; } virtual void detatch(std::string&amp;amp; id) { m_objMap.erase(id); }; virtual void notify(){ for(const auto&amp;amp; obj : m_objMap){ obj.update(this); } }protected: Subject();private: std::map&amp;lt;std::string, Observer*&amp;gt; m_objMap;};/*** @brief ConcreteSubject - DataBase* @details*/class ClockTimer : public PushServer {public: Timer(); virtual int getHour(); virtual int getMinute(); virtual int getSecond(); void tick() { // 시간 상태 변경 ... // 등로된 Observer들에게 통지 notify(); }private: ...}/*** @brief Observer - Observer* @details*/class Observer {public: virtual ~Observer(); virtual void update(Subject* chaingedSubject) = 0;protected: Observer();};/*** @brief ConcreteObserver - ClientA* @details*/class DigitalClock : public Widget, public Observer {public: DigitalClock(const std::string&amp;amp; id, ClockTimer* timer) : m_id(id), m_subject(timer){ m_subject-&amp;gt;attach(m_id,this); } virtual ~DigitalClock() { m_suject-&amp;gt;detatch(m_id); } virtual void update(Subject* chaingedSubject){ // 통지해온 Subject와 내가 바라보고 있는 Subject가 일치하는지 확인 if(chaingedSubject == m_subject){ draw(); } } virtual void draw() { // Subject로 부터 새로운 값을 얻어옴 int hour = m_subject-&amp;gt;getHour(); int minute = m_subject-&amp;gt;getMinute(); int second = m_subject-&amp;gt;getSecond(); ... }private: const std::string m_id; ClockTimer* m_subject;}... // Subject 객체 생성 ClockTimer* timer = new ClickTimer(); // Observer 객체 생성 및 Subject 등록 DigitalTimer* digitalTimer = new DigitalTimer(&quot;Digital&quot;, timer); AnalogTimer* analogTimer = new AnalogTimer(&quot;Analog&quot;, timer); // Subject의 상태 변경 // 이후 등록된 모든 Observer에게 상태 변경 통지 timer-&amp;gt;tick();...Related Pattern복잡한 갱신의 의미 구조를 캡슐화함으로써, ChangeManager 객체는 Subject와 Observer 사이의 “Mediator” 역할을 한다. 또한 ChangeManager 객체는 Singleton Patten을 사용하여 시스템에 하나만 존재하고 전역적으로 접급이 가능하도록 할 수 있다.참고. Design Patterns : Elements of Reusable Object-Oriented Software - Erich Gamma" }, { "title": "Design Patterns - Memento", "url": "/posts/design_patterns-memento/", "categories": "Design Patterns", "tags": "Design Patterns, Behavioral Patterns, Memento, C++", "date": "2020-04-25 00:34:00 +0900", "snippet": "Behavioral Patterns - MementoIntent캡슐화를 위배하지 않은 채 어떤 객체의 내부상태를 잡아내고 실체화시켜 둠으로써, 이후 해당 객체가 그 상태로 되돌아올수 있도록 한다.토큰(Tocken)이라고도 불린다.Utility 어떤 객체의 상태에 대한 스냅샷(몇개의 일부)을 저장한 후 나중에 이 상태로 복구해야 할 때 상태를 얻는 데 필요한 직접적인 인터페이스를 두면 그 객체의 구현 세부사항이 드러날 수 밖에 없고, 이것으로 객체의 캡슐화가 깨질 때StructureBasic StructureElements Memento 원조본 객체의 내부 상태를 저장 Memento는 Originator 객체의 내부상태를 필요한 만큼 저장해 둠 클래스 내부에는 크게 두 종류의 인터페이스가 존재 제한 범위(narrow) 인터페이스 : 관리 책임을 가지는 Caretaker 클래스가 접근 광범위(wide) 인터페이스 : 자신의 상태를 이전 상태로 복원하기 위해 필요한 모든 자료에 접근해야하는 Originator 클래스가 접근 이상적으로는 Memento를 생성하는 Originator 객체만이 Memento의 내부 상태에 접근할수 있는 권한을 가짐 Originator 원조본 객체 Memento를 생성하여 현재 객체의 상태를 저장하고 Memento를 사용하여 내부 상태를 복원 Caretaker Memento의 보관을 책임지는 보관자 Memento의 내용을 검사 Memento의 내용을 건드리지는 않음 Caretaker 객체는 원조본 객체에 Memento 객체를 요청한다. 또 요청한 시간을 저장하며, 받은 Memento 객체를 다시 원조본 객체에게 돌려주는데, 이를 상호작용 다이어그램으로 표현하면 다음과 같다.Caretaker 객체는 Memento 객체를 Originator 객체에 전달하지 않을 수 있다. Originator 객체가 이전 상태로 돌아갈 필요가 없을 때는 전달할 필요가 없기 때문이다.Memento 객체는 수동적이다. Memento 객체를 생성한 Originator 객체만이 상태를 설정하고 읽을 수 있다.Feature캡슐화된 경계를 유지할 수 있다Originator만이 Memento를 다룰수 있기 때문에 Memento가 외부에 노출되지 않는다.Memento Patern은 복잡한 Originator 클래스의 내부 상태를 다른 객체로 분리하는 방법으로 상태에 대한 정보의 캡슐화를 보장한다.Originator 클래스를 단순화 할 수 있다사용자가 자신들이 필요한 상태를 별도로 관리하게 되면 Originator 클래스는 간단해지고, 상태를 변경할 때마다 사용자가 이를 Originator에 알려줄 필요도 없다.Memento의 사용으로 더 많은 비용이 들어갈 수 있다Originator 클래스가 많은 양의 정보를 저장해야 할 떄나 상당히 자주 Memento를 반환해야 할 때라면, Memento가 상당한 오버헤드를 유발할 수 있다.Originator 클래스의 상태를 보호하는 비용과 상태 복구의 비용이 싸지 않으면, Memento Pattern은 적합하지 않다.제한 범위 인터페이스와 광범위 인터페이스를 정의해야 한다어떤 프로그래밍 언어에서는 Originator 객체만 Memento의 상태에 접근할 수 있도록 보장하기가 어려울 수 있다.Memento를 관리하는 데 필요한 비용이 숨어있다Caretaker 객체는 자신이 보관하는 Memento를 삭제할 책임이 있다. 그러나 Caretaker 쪽에서는 얼마나 많은 상태가 Memento에 저장되어 있는지 알 방법이 없다. 그러므로 Caretaker 객체가 아무리 가볍다 해도 Memento를 저장할 때 적지 않은 저장 비용을 유발할 수 있다.ImplementationConsiderations point in implementaion언어의 지원 여부Memento에는 두가지 종류의 인터페이스가 있다. 제한 범위 인터페이스 다른 객체들에게 제공할 서비스를 정의 광범위 인터페이스 Originator 클래스에게 제공하는 서비스를 정의 C++에서는 originator 클래스를 Memento 클래스의 프랜드 클래스로 정의하고, Memento 클래스의 광범위 인터페이스를 모두 private 멤버로 만든다. 제한 범위 인터페이스에 해당하는 연산만 public으로 정의해야 한다. 즉, Originator 클래스는 Memento 클래스의 프랜드 클래스이므로, 모든 연산에 접근할 수 있어 광범위 언터페이스를 제공하는 셈이 된다. 그러나 이외의 클래스들은 public으로 정의된 연산만을 사용할 수 있으므로 제한 범위 인터페이스를 제공하는 셈이 된다.// 내부 상태를 표현하는 클래스class State;class Originator{public: Memento* createMemento(); void setMemento(const Memento*); ...private: State* m_state; ...};class Memento {public: virtual ~Memento(); // 제한 범위 인터페이스 정의 ...private: // Originator 클래스만 접근가능한 광범위 인터페이스 정의 friend class Originator; Memento(); void setState(State*); State* getState(); ...private: State* m_state; ...};점즘적 상태 변경을 저장Memento가 생성되어 다시 Originator에게 반환되면 Memento는 Originator의 내부 상태 변경 과정을 지속적으로 저장해야 한다. 이떄, 모든 상태를 다 저장하는 것이 아니라 변경된 정보들만 계속 추가해 간다.Implement Exampleclass Graphic;/*** @brief Originator - ConstraintSolver* @details 상태 정보를 기록해야할 Originator 클래스*/class ConstraintSolver() {public: static ConstraintSolver* Instence(); void addConstraint(Graphic* startConnection, Graphic* endConnection); void removeConstraint(Graphic* startConnection, Graphic* endConnection); // addConstraint() 연산으로 등록한 제약상황들을 처리 void solve(); ConstraintSolverMemento* createMemento(); void setMemento(ConstraintSolverMemento* );private: // 연결을 처리하기 위해 필요한 상태나 연산을 정의 ...}/*** @brief Memento - ConstraintSolverMemento* @details Originator 객체의 상태를 저장하고 이를 반환하는 Memento 클래스*/class ConstraintSolverMemento {public: // 다른 클래스들에게 공개할 제한 범위 인터페이스 정의 virtual ~ConstraintSolverMemento(); ...private: // Originator 클래스들에게만 공개할 광범위 인터페이스 정의 friend class ConstraintSolver; ConstraintSolverMemento(); ...};/*** @brief Caretaker - MoveCommand* @details Memento 객체륿 보관하며 관리하는 Caretaker 클래스*/class MoveCommand() {public: MoveCommand(Graphic* target, const Point&amp;amp; delta); void excute() { ConstraintSolver* solver = ConstraintSolver::instence(); // 현재상태를 저장한 Memento 생성 m_state = solver-&amp;gt;createMemento(); m_target-&amp;gt;move(m_delta); solver-&amp;gt;solve(); } void unExcute() { ConstraintSolver* solver = ConstraintSolver::instence(); m_target-&amp;gt;move(m_delta); // 상태 복구 solver-&amp;gt;setMemento(m_state); solver-&amp;gt;solve(); }private: ConstraintSolverMemento* m_state; Point m_delta; Graphic* m_target;};Related PatternCommand Pattern은 실행 취소가 가능한 연산의 상태를 저장할 떄 Memento Pattern을 사용할 수 있다.Memento Pattern은 Iterator Pattern에서의 반복 과정 상태를 관리할 수 있다.참고. Design Patterns : Elements of Reusable Object-Oriented Software - Erich Gamma" }, { "title": "Design Patterns - Mediator", "url": "/posts/design_patterns-mediator/", "categories": "Design Patterns", "tags": "Design Patterns, Behavioral Patterns, Mediator, C++", "date": "2020-04-24 07:08:00 +0900", "snippet": "Behavioral Patterns - MediatorIntent한 집합에 속해있는 객체의 상호작용을 캡슐화하는 객체를 정의한다.객체들이 서로를 참조하지 않도록 하여 객체 사이의 소결합(Loose Coupling)을 촉진시키며, 개발자가 객체의 상호작용을 독립적으로 다양화 시킬수 있게 만든다.Utility 여러 객체가 잘 정의된 형태이기는 하지만 복잡한 상호작용을 기질 때 객체간의 의존성이 구조화되지 않으며, 잘 이해하기 어려울 떄 한 객체가 다른 객체를 너무 많이 참조하고, 너무 많은 의사소통을 수행해서 그 객체를 재사용하기 힘들 때 여러 클래스에 분산된 행동들이 상속 없이 상황에 맞게 수정되어야 할 떄StructureBasic StructureStructure ExampleElements Mediator DialogDirector에 해당 Colleague 객체와 교류하는 데 필요한 인터페이스를 정의 ConcreteMediator FontDialogDirector에 해당 Colleague 객체와 조화를 이워서 협력 행동을 구현 자신이 맡을 Colleague를 파악하고 관리 Conlleague 클래스들 ListBox, EntryField에 해당 다른 객체와 통신이 필요하면 그 Mediator를 통해 통신되도록 하는 동료 객체를 나타내는 클래스 자신의 Mediator 객체가 무엇인지 파악 Colleague 는 Mediator에서 요청을 송수신한다. Mediator는 필요한 Colleague사이에 요청을 전달할 의무가 있다.Feature서브클레싱을 제한한다Mediator는 다른 객체 사이에 분산된 객체의 행동들을 하나의 객체로 국한한다. 이 행동을 변경하고자 할때, Mediator 클래스를 상속하는 서브클래스만 만들면 된다. Colleague 클래스는 여전히 재사용 가능하다.Colleauge 객체 사이의 종속성을 줄인다Mediator는 행동에 참여하는 객체간의 소결랍을 증진시킨다. 이로써 Mediator 클래스와 Colleague 클래스 각각을 독립적으로 다양화 시킬수 있고 재사용할 수 있다.객체 프로토콜을 단순화 한다Mediator는 다 대 다의 관계를 일 대 다의 관계로 축소시킨다.객체 간의 협력 방법을 추상화 한다객체 사이의 중재를 독립적인 개념으로 만들고 이것을 캡슐화함으로써, 사용자는 각 객체의 행동과 상관없이 객체간 연결방법에만 집중할 수 있다. 결과적으로 시스템에서 객체가 어떻게 동작하는지를 좀더 명확하게 할 수 있다.통제가 집중화 된다Mediator Pattern은 상호작용의 복잡한 모든 것들이 자신 내부에서만 오가게 한다.Mediator 객체는 동료 객체 간의 상호작용에 관련된 프로토콜을 모두 캡슐화 하기 때문에 어느 동료 객체 보다도 훨씬 복잡해질 수 있다. 이 때문에 Mediator 클래스 자체의 유지보수가 어려워 질 수 있다.ImplementationConsiderations point in implementaion추상 클래스인 Mediator 생략만약 관련 객체들이 오직 하나의 Mediator 클래스와 동작한다면 Mediator를 추상 클래스로 정의할 필요가없다.추상 클래스의 목적은 앞으로 또 다른 상호작용을 정의할 새로운 Mediator 서브클래스를 만들 때를 대비하는 것이다.Colleague 객체 - Mediator 객체 간의 의사소통Mediator 클래스를 구현하는 한가지 방법은 Observer Pattern을 사용하는 것이다.Colleague 객체가 주관자(subject) 객체로 동작하여 상태의 변화가 일어날 때마다 Mediator에게 이를 통보하면, Mediator는 처리방법에 따라 다른 객체에게 변경을 통보하여 처리한다.다른 방법으로는 Mediator 클래스 내 특화된 통지(Notification) 인터페이스를 정의하여 Colleague 객체들이 직접 통신하게 만드는 것이다.Implement Example/*** @brief Mediator - EventHandle* @details Colleague 객체들 사이의 통신을 위한 인터페이스 정의*/class EventHandle {public: virtual ~EventHandle() = default; virtual void eventHaneler(Widget* widget, EventCode eventCode) = 0; void addWidget(Widget* widget) { m_widgetMap[widget-&amp;gt;getWidgetID()] = widget; }protected: EventHandle();private: std::map&amp;lt;std::string, Widget*&amp;gt; m_widgetMap;};/*** @brief ConcreteMediator - UIEventHandle* @details Colleague 객체들 사이의 통신을 위한 인터페이스 구현*/class UIEventHandle {public: // 상태 변화 발생시, 해당 변화에 대해 영향이 있는 다른 Colleague 객체에게 전달 void eventHaneler(Widget* widget, EventCode eventCode)) override { switch(widget-&amp;gt;getWidgetType()){ case WIDGET_TYPE_BUTTON: { if(widget-&amp;gt;getWidgetID() == &quot;MyButton&quot;){ m_widgetMap[&quot;MyPictureView&quot;]-&amp;gt;show(); ... } ... break; } case WIDGET_TYPE_TEXTAREA: { ... break; } default: break; } }};/*** @brief Colleague - Widget* @details Colleague 객체들의 인터페이스 정의*/class Widget {public: Widget(cosnt std::string&amp;amp; id, EventHandle* handler) : m_widgetID(id), m_eventHandle(handler) {} virtual ~Widget(); void setWidgetType(WidgetType type) { m_type = type; } WidgetType getWidgetType() const { return m_type; } std::string getWidgetID() const { return m_widgetID; } ...private: std::string m_widgetID = &quot;&quot;; WidgetType m_type; EventHandle* m_eventHandle = nullptr; ...};/*** @brief Colleague - Button* @details Colleague 객체들의 인터페이스 구현*/class Button : public Widget {public: Button(cosnt std::string&amp;amp; id, EventHandle* handler) : Widget(id, handler) { setWidgetType(WIDGET_TYPE_BUTTON); m_eventHandle-&amp;gt;addWidget(this); ... }// 행동들 정의private : void onButtonClick() { m_eventHandle-&amp;gt;eventHaneler(this, EVENT_BUTTON_CLICK); } void onButtonPress() { m_eventHandle-&amp;gt;eventHaneler(this, EVENT_BUTTON_PRESS); } ...};/*** @brief Colleague - TextArea* @details Colleague 객체들의 인터페이스 구현*/class TextArea : public Widget { Button(cosnt std::string&amp;amp; id, EventHandle* handler) : Widget(id, handler) { setWidgetType(WIDGET_TYPE_TEXTAREA); m_eventHandle-&amp;gt;addWidget(this); ... }// 행동들 정의private: void onWrite() { m_eventHandle-&amp;gt;eventHaneler(this, EVENT_TEXTAREA_WIRTE); } void onDelete() { m_eventHandle-&amp;gt;eventHaneler(this, EVENT_TEXTAREA_DELETE); } ...};... // Mediator 객체 생성 UIEventHandle* handle = new UIEventHandle(); // Colleague 객체들 생성 및 Mediator 객체 등록 Button* btn = new Button(&quot;MyButton&quot;, handle); TextArea* textArea = new Button(&quot;MyTextArea&quot;, handle);...Related PatternFacade Pattern은 객체들로 구성된 서브시스템을 추상화하여 좀더 편한 인터페이스를 제공하려는 것으로 Mediator Pattern과는 다르다. Facade 객체는 서브시스템을 구성하는 객체로만 메세지가 전달되고, 반대로 서브시스템을 구성하는 객체가 Facade 객체에 메세지전달은 처리되지 않는다. 그러나 Mediator 객체는 양방향이다.싱호 관련된 객체들은 Observer Pattern을 이용해서 Mediator 객체들과 교류한다.참고. Design Patterns : Elements of Reusable Object-Oriented Software - Erich Gamma" }, { "title": "Design Patterns - Iterator", "url": "/posts/design_patterns-iterator/", "categories": "Design Patterns", "tags": "Design Patterns, Behavioral Patterns, Iterator, C++", "date": "2020-04-23 06:40:00 +0900", "snippet": "Behavioral Patterns - IteratorIntent내부 표현부를 노출하지 않고 어떤 집합 객체에 속한 원소들을 순차적으로 접근할수 있는 방법을 제공한다.커서(Cursor)라고도 불린다.Utility 객체 내부 표현 방식으로 모르고도 집합 객체의 각 원소들에 접근하고 싶을 떄 집합 객체를 순회하는 다양한 방법을 지원하고 싶을 떄 서로 다른 집합 객체 구조에 대해서도 동일한 방법으로 순회하고 싶을 떄StructureBasic StructureStructure ExampleElements Iterator 원소를 접근하고 순회하는 데 필요한 언터페이스를 정의 ConcreteIterator Iterator에 정의된 인터페이스를 구현 순회 과정 중 집합 객체 내에서 현재 위치를 기억 Aggregate Iterator 객체를 생성하는 인터페이스 정의 ConcreteAggregate 해당하는 ConcreteIterator의 인스턴스를 반환하는 Iterator 생성 인터페이스 구현 ConcreteIterator는 집합 객체 내 현재 객체를 계속 추적하고 다음번 방문할 객체를 결정한다.Feature집합 객체의 다양한 순회방법을 제공한다구조가 복잡한 집합 객체는 다양한 방법으로 순회할 수 있다.새로운 순회 방법을 Iterator 서브클래스로 정의하여 기존 순회 방법을 다른 순회 알고리즘 인스턴스로 완전히 교체할 수 있다.Iterator는 Aggregate 클래스의 인터페이스를 단순화한다Iterator의 순회 인터페이스는 Aggregate 클래스에 정의한 자신과 비슷한 인터페이스들을 없애서 Aggregate 인터페이스를 단순화할 수 있다..집합 객체에 따라 하나 이상의 순회 방법이 제공될 수 있다각 Iterator마다 자신의 순회 상태가 있으므로 하나의 집합 객체를 한번에 여러번 순회 시킬수 있다.ImplementationConsiderations point in implementaion반복의 제어 주체어떤 부분에서 반복을 제어할 것인지 결정하는 것이 가장 중요한 안건이다.사용자가 반복을 제어할 때, 이 Iterator는 외부반복자 라고 한다. 반대로 Iterator 자신이 제어를 담당한다면 이는 내부반복자 라고 한다.외부반복자를 사용하는 사용자 프로그램은 순회를 계속하고 다음번 원소를 명시적으로 해당 반복자에게 요청해야 한다.사용자가 내부반복자를 사용한다면, 처리할 연산을 내부반복자에게 넘겨주고, 해당 반복자는 그 연산을 모든 원소에 적용한다.외부반복자가 내부반복자보다는 유연한 방법이다. 외부반복자를 이용하면 두 집합 객체가 동일한 집합인지 비교할 수 있지만, 내부반복자를 이용할 때는 불가능하다.순회 알고리즘의 정의 위치Iterator 클래스에만 순회 알고리즘을 정의할 수 있는 것은 아니다. Aggregate 클래스에도 순회 알고리즘을 정의하고, Iterator에는 순회의 상태만 저장할 수도 있다. 이렇게 구현된 Iterator를 가리켜서 커서(Cursor) 라고 한다. 단순히 집합 구조 내 현재 위치를 가리키기만 하는 것이다. 즉, 집합 객체의 현재 위치만 관리하도록 하고, 사용자는 Next() 연산을 호출하여 현재 위치 정보응 얻고 Cursor의 위치, 즉 Cursor의 상태를 변경한다.만약 Iterator가 순회 알고리즘을 책임진다면 같은 집합 객체에 대해서 다른 순회 알고리즘을 구현하는 것이 쉬워지게 되고, 서로 다른 집합 객체에 동일한 순회 알고리즘을 재사용하는 것도 가능하다. 그러나, 이와같이 구현하기위해 Iterator가 집합 객체에 정의된 private 변수들에 접근해야 할 필요가 있을수 있게 되고, 이는 객체지향의 캡슐화 전략에 위배되게 된다.Iterator를 견고하게 만드는 방안집합 객체를 순회하는 동안 집합 객체를 수정하는 것은 위험한 일이다. 만약 순회 중에 새로운 값이 추가되거나 삭제된다면 동일한 원소를 두번 접근해야 할 수도 있고, 아니면 건너뛸 수도 있다.견고한 반복자(Robust Iterator) 가 되려면 순회중에는 삽입이나 삭제가 일어나지 말아야 하고, 또 집합 객체를 복사하는 방법을 사용하지 않아야 한다.대두분 Robust Iterator를 구현하기 위해 집합 객체에 Iterator를 등록하는 방식을 취한다. 삽입이나 삭제를 할 때, 집합 객체가 자신이 보유한 Iterator의 상태도 함께 변경할 수 있도록 하는 것이다.추가적으로 필요한 연산Iterator에 필요한 최소한의 연산들은 First(), Next(), IsDone(), CurrentItem() 이다.이외에도 순서가 정해진 집합 객체라면 Previous() 연산도 현재 Iterator의 위치를 앞으로 이동 시킬수 있으니 유용하게 쓰일수 있다. 또 인덱스를 가지는 집합 객체는 SkipTo() 연산을 통해, 어떤 조건에 일치하는 객체로 Iterator를 바로 이동시킬 수 있으므로 유용하게 쓰일수 있다.C++에서의 다형성을 지닌 Iterator를 이용하는 방법다형적인 Iterator는 런타임에 Factory Method로 동적으로 Iterator 객체를 제공해야 하기 때문에, 추가 비용을 지불해야 한다. 그렇기 때문에, 필요할 경우에만 다형성을 지닌 Iterator를 사용하고, 이외에는 확장된 Iterator를 사용하는것이 더 나은 일이다.다형적인 Iterator의 단점 중 하나는 사용자가 직접 Iterator를 삭제하는 책임을 져야 한다는 것이다. 이떄, 오류가 발생할 수도 있는데, 이는 삭제하면서 객체에 할당된 힙 메모리를 삭제하지 않았기 때문이다. 즉, 어떤 예외가 발생하게 되면 생성된 Iterator 객체를 메모리에서 없애는 일을 전혀 진행할 수 없다.Proxy Pattern을 쓰면 위와 같은 문제를 해결할 수 있는데, 실제로 스택에 저장한 Proxy를 Iterator처럼 사용하는 것이다. Proxy는 자신의 소멸자에서 Proxy를 삭제하면 된다. 이로써 Proxy 자신이 메모리 정리의 책임을 가지게 된다.Iterator의 특수한 접근 권한Iterator는 그 Iterator를 생성한 집합 객체의 확장으로 바라볼 수도 있는데, 이렇게 되면 Iterator와 집합 객체 간의 결합도가 매우 커지게 된다. C++ 에서 이러한 밀접한 구조를 구현한다면, 집합 객체를 정의할 때의 Iterator를 그 집합 구조의 friend로 정의할 수 있다. 이렇게 되면 단순하게 집합 객체에 접근하는데 필요한 연산들을 정의할 필요가 없다.하지만 이렇게 특권적인 접근을 부여하면 새로운 순회 방법을 정의하기가 어려워진다. friend를 하나 더 추가하는 데에 집합 객체의 인터페이스 변경이 요구되기 때문이다.이런 문제를 해결하기 위한 방법은 집합 객체에 정의된 멤버 변수 중에서 중요하기는 하지만 공개할 수 없는 멤버 변수에 접근하는 연산을 Iterator 클래스 안에서 protected로 정의하는 것이다. 이렇게 되면 Iterator를 상속하는 서브클래스들은 이 연산을 통해 집합 객체에 접근할 수 있는 특권을 부여받고, 다른 사용자들은 집합 객체를 마음대로 사용할 수 없도록 제한된다.Composite을 위한 Iterator외부반복자는 Composite Pattern처럼 재귀적 합성 구조를 처리하도록 구현하기 까다롭다. 이런 구조에서는 현재 위치가 중첩된 집합체의 여러 단계에 걸쳐있기 때문이다. 이때는 Composite Pattern을 이용하여 자신이 거쳐온 단계에 대한 정보를 저장해 두어야 한다.순회 정보를 자체적으로 관리하는 내부반복자는 자기 스스로가 재귀적 호출로 현재 위치를 저장하게 된다.Null IteratorNull Iterator는 영역판단을 하는데 유용하다. Null Iterator는 항상 순회 시에 끝나는 Iterator로 정의된다.Implement Example/*** @brief Aggregate - AbstractList* @details Iterator를 생성하는 Factory Method를 정의한 기반 클래스 */template &amp;lt;class Item&amp;gt;class AbstractList {public: virtual Iterator&amp;lt;Item&amp;gt;* createIterator() const = 0; ...};/*** @brief ConcreteAggregate - List* @details 기반클래스를 상속하여 인터페이스 구현*/template &amp;lt;class Item&amp;gt;class List : public AbstractList {public: List(int size = DEFAULT_SIZE); int count() const; Item&amp;amp; getItem() const; Iterator&amp;lt;Item&amp;gt;* createIterator() const override { return new ListIterator&amp;lt;Item&amp;gt;(this); } ...};/*** @brief Iterator - Iterator* @details Iterator 인터페이스 정의*/template &amp;lt;class Item&amp;gt;class Iterator {public: // 인덱스를 첫번째 원소를 가리키도록 함 virtual void first() = 0; // 인덱스를 다름 원소를 가리키도록 함 virtual void next() = 0; // 리스트 내 다음 원소를 참조하는 인덱스의 유무를 확인 virtual bool isDone() const = 0; // 현재 인덱스의 원소를 반환 virtual Item currentItem() const = 0;protected: Iterator();};/*** @brief ConcreteIterator - ListIterator* @details 자신만의 순회 알고리즘대로 Iterator 인터페이스 구현*/template &amp;lt;class Item&amp;gt;class ListIterator : public Iterator&amp;lt;List&amp;gt; {public: ListIterator(const List&amp;lt;Item&amp;gt;* list) : m_list(list), m_current(0) {} void first() override { m_current = 0; } void next() override { ++m_current; } bool isDone() const override { return m_current &amp;gt;= m_list-&amp;gt;count(); } Item currentItem() const override { if(isDone()) throw OutOfRange; return m_list-&amp;gt;get(m_current); };private: const List&amp;lt;Item&amp;gt;* m_list; int m_current;};/*** @brief 내부반복자 - ListTraverser* @details 내부반복자 인터페이스 정의*/template &amp;lt;class Item&amp;gt;class ListTraverser {public: ListTraverser(List&amp;lt;Item&amp;gt;* list) : m_iter(list) {} // 내부적으로 순회 bool Traverse() { bool result = false; // Iterator를 통해 Aggragaet 순회 for(m_iter.first() ; !m_iter.isDone() ; m_iter.next()) { // 원소가 있으면 true, 없으면 false를 반환 result = processItem(m_iter.currentItem()); if(result == false) break; } return result; }protected: virtual bool ProcessItem(const Item&amp;amp;) = 0;private: ListIterator&amp;lt;Item&amp;gt; m_iter;};/*** @brief 내부반복자 - ListTraverser* @details 내부반복자 인터페이스 정의*/template &amp;lt;class Item&amp;gt;class ViewButtons : public ListTraverser&amp;lt;Button&amp;gt; {public: ButtonList(List&amp;lt;Button*&amp;gt;* list, int n) : m_iter(list), m_total(n), m_count(0) {}protected: bool processItem(Button* const btn) { ++m_count; btn-&amp;gt;show(); return m_count &amp;lt; m_total; }private: int m_total; int m_count;};... // Aggregate 객체 생성 AbstractList&amp;lt;Button*&amp;gt;* btnList; // 생성한 Aggregate 클래스에 대한 Iterator 객체 생성 Iterator&amp;lt;Button*&amp;gt; iter = btnList-&amp;gt;createIterator(); // Iterator를 통한 순회 for(iter.first() ; !iter.isDone() ; iter.next() ){ ... } delete iter; ... // 내부반복자로 순회하기 위한 Aggregate 객체 생성 List&amp;lt;Button*&amp;gt;* btns; // 내부반복자 객체 생성 ViewButtons viewBtns(btns, 10); // 내부반복자를 통한 순회 viewBtns.Traverse(); ......Related PatternIterator Patten은 Composite Patten과 같이 재귀적 구조가 있을 때 자주 사용한다.다양한 Iterator를 사용하여 적당한 Iterator 클래스를 얻으려면 Factory Method Pattern을 사용할 수 있다.Mementor Pattern도 Iterator Pattern과 함께 자주 사용하는데, 이때 Iterator 자신이 반복한 결과를 저장하기 위해서 Memento를 사용한다.참고. Design Patterns : Elements of Reusable Object-Oriented Software - Erich Gamma" }, { "title": "Design Patterns - Command", "url": "/posts/design_patterns-command/", "categories": "Design Patterns", "tags": "Design Patterns, Behavioral Patterns, Command, C++", "date": "2020-04-22 06:27:00 +0900", "snippet": "Behavioral Patterns - CommandIntent요청 자체를 캡슐화하는 것이다. 이를 통해 요청이 서로 다른 사용자를 매개변수로 만들고, 요청을 대기시키거나 로깅하여, 되돌릴 수 있는 연산을 지원한다.작동(Action), 트랜젝션(Transaction) 이라고도 불린다.Utility수행할 동작을 객체로 매개변수화 하고자 할 때콜백함수를 구현하여 매개변수화를 표현할 수 있다.서로다른 시간에 요청을 명시하고, 저장하며, 실행하고 싶을 때요청을 받아 처리하는 객체가 주소 지정 방식과는 독립적으로 표현될 수 있다면, Command 객체를 다른 프로세스에게 넘겨주고 거기서 해당 처리를 진행 할 수 있다.실행 취소 기능을 지원하고 싶을 때Command의 Excute() 연산은 상태를 저장할 수 있는데, 이를 이용해서 지금까지 얻은 결과를 바꿀 수 있다.실행된 명령어를 모두 기록해 두었다가 이 리스트를 역으로 탐색하여 다시 Command 클래스 내에 정의된 UnExcute() 연산을 통해 수행 취소를 한다.시스템이 고장 났을 떄 재적용이 가능하도록 변경 과정에 대한 로깅을 지원하고 싶을 떄Command 인터페이스를 확장하여 Load() 와 Store() 연산을 정의하면 상태의 변화를 지속적(persistent) 저장소에 저장해 둘 수 있다.시스템 장애가 발생했을떄, 해당 저장소에서 저장된 명령어를 읽어 다시 Excute() 연산을 통해 재실행 하면 된다.기본적은 연산의 조합으로 만든 상위 수준의 연산을 써서 시스템을 구조화하고 싶을 떄정보 시스템의 일반적인 특성은 트랜잭션(Transaction) 을 처리해야 한다는 것이다. 트랜잭션은 일련의 과정을 통해 데이터를 변경하는 것이다. Command Pattern은 이런 트랜잭션의 모델링을 가능하게 한다.Command 클래스는 일관된 인터페이스를 정의하는데, 이로써 모든 트랜잭션이 동일한 방식으로 호출된다.새로운 트랜잭션을 만들면 상속으로 Command 클래스를 확장하면 되므로 시스템 확장도 어렵지 않게 가능하다.StructureBasic StructureStructure ExampleElements Command 연산 수행에 필요한 인터페이스를 선언 ConcreteCommand PasteCommand, OpenCommand 에 해당 Receiver 객체와 액션 간의 연결성을 정의 처리 객체에 정의된 연산을 호출하도록 Excute() 연산을 구현 Client Appilication 에 해당 ConcreteCommand 객체를 생성하고 처리 객체로 정의 Invoker MenuItem 에 해당 Command Pattern 에 처리를 수행할 것을 요청 Receiver Document, Appilication 에 해당 요청에 관련된 연산 수행 방법을 저장 어떤 클래스도 요청 수신자로써 동작 가능 사용자는 ConcreteCommand 객체를 생성하고 이를 수신자로 지정한다.Invoker 클래스는 ConcreteCommand 객체를 저장한다.Invoker 클래스는 Command에 정의된 Excute() 를 호출하여 요청을 발생시킨다. 명령어가 취소기능이 가능하다면, ConcreteCommand는 이전에 Excute() 호출 전 상태의 취소 처리를 위해 저장한다.ConcreteCommand 객체는 요청을 실체 처리할 객체에 정의된 연산을 호출한다.다음 다이어그램은 협력자 사이의 상호작용을 보여준다.Command 객체로 요청 발생자(Invoker)가 요청 수신자에서 분리된다.Feature Command는 연산을 호출하는 객체와 연산 수행 방법을 구현하는 객체를 분리한다. Command는 일급 클래스이다. 다른 객체와 같은 방식으로 조작되고 확장할 수 있다. 명령을 여러 개로 복합해서 복합 명령을 만들 수 있다. Composite Pattern으로 요로 명령어를 구성할 수 있다. 새로운 Command 객체를 추가하기 쉽다. 기존 클래스를 변경할 필요 없이 단지 새로운 명령어에 대응하는 클래스만 정의하면 된다. ImplementationImplement Example/*** @brief Command - Command* @details 요청을 표현하는 클래스로써 요청 처리에 대한 인터페이스를 정의*/class Command{public: virtual ~Command() = default; virtual void excute() = 0;protected: Command();};/*** @brief ConcreteCommand - OpenCommand* @details 요청을 구체화하여 요청 처리에 대한 인터페이스를 구현*/class OpenCommand : public : Command {public: OpenCommand(Application* app) : m_app(app) {} void excute() override { const char* name = askUser(); if(name != nullptr) { Document* doc = new Document(name); m_app-&amp;gt;add(doc); doc-&amp;gt;open(); } }protected: virtual const char* askUser();private: Application* m_app = nullptr; char* m_response = nullptr;};/*** @brief ConcreteCommand - PasteCommand* @details 요청을 구체화하여 요청 처리에 대한 인터페이스를 구현*/class PasteCommand : public : Command {public: PasteCommand(Document* doc) : m_doc(doc) {} void excute() override { m_doc-&amp;gt;paste(); }private: Document* m_doc;};/*** @brief ConcreteCommand - SimpleCommand* @details 처리 객체와 함께 처리 내용의 Callback 함수를 받아 요청을 처리*/template&amp;lt;class Receiver&amp;gt;class SimpleCommand : public : Command {public: typedef void (Receiver::*Action)(); SimpleCommand(Receiver* r, Action a) : m_recv(r), m_actionCB(a) {} void excute() override { (m_recv-&amp;gt;*m_actionCB)(); }private: Receiver* m_recv = nullptr; Action* m_actionCB = nullptr;};/*** @brief ConcreteCommand - MacroCommand* @details 여러가지 요청을 일련의 순서대로 실행하는 요청 관리 클래스*/class MacroCommand : public : Command {public: MacroCommand(Receiver* r, Action a) : m_recv(r), m_actionCB(a) {} virtual void add(Command* cmd) { m_cmds.push(cmd); } virtual void remove() { m_cmds.pop(); } void excute() override { for(const auto&amp;amp; iter : m_cmds){ iter.excute(); } }private: std::queue&amp;lt;Command*&amp;gt; m_cmds;};... // 요청에 관련된 연산 수행 방법을 저장한 Reciver 객체 생성 MyClass* receiver = new MyClass(); ... // 요청을 처리하는 객체와 객체 내의 요청 처리 함수를 통해 요청을 처리 Command* cmd = new SimpleCommand&amp;lt;MyClass&amp;gt;(Receiver receiver, &amp;amp;Myclass::Action); // 요청 처리 cmd-&amp;gt;excute(); ......Related Pattern참고. Design Patterns : Elements of Reusable Object-Oriented Software - Erich Gamma" }, { "title": "Design Patterns - Chain of Responsibility", "url": "/posts/design_patterns-chain_of_responsibility/", "categories": "Design Patterns", "tags": "Design Patterns, Behavioral Patterns, Chain of Responsibility, C++", "date": "2020-04-21 02:19:00 +0900", "snippet": "Behavioral Patterns - Chain of ResponsibilityIntent메세지를 보내는 객체와 이를 받아 처리하는 객체들 간의 결합도를 없애기 위한 패턴이다.하나의 요청에 대한 처리가 반드시 한 객체에서만 되지 않고, 여러 객체에게 그 처리 기회를 주려는 것이다.Utility 하나 이상의 객체가 요청을 처리해야 하고, 그 요청 처리자 중 어떤 것이 선행자(Priori) 인지 모를 때. 처리자가 자동으로 확정되어야 한다. 메세지를 받을 객체를 명시하지 않은 채 여러 객체 중 하나에게 처리를 요청하고 싶은 때 요청을 처리할 수 있는 객체 집합이 동적으로 정의되어야 할 때StructureBasic StructureStructure ExampleElements Handler HelpHandler에 해당 요청을 처리하는 인터페이스를 정의 후속 처리자(successor)와 연결을 구현 연결 고리에 연결된 다음 객체에게 다시 메세지를 보냄 ConcreteHandler PrintButton, PrintDialog에 해당 책임져야 할 행동이 있다면 스스로 요청을 처리하여 후속 처리자에 접근 자신이 처리할 행동이 있으면 처리하고, 그렇지 않으면 후속 처리자에 다시 처리를 요청 Client 객체에게 필요한 요청을 보냄 사용자는 처리를 요청하고, 이 처리 요청은 실제로 그 요청을 받을 책임이 있는 ConcreteHandler 객체를 만날 때까지 정의된 연결 고리를 따라서 계속 전달된다.Feature객체 간의 행동적 결합도가 적어짐다른 객체가 요청을 어떻게 처리하는지 몰라도 된다. 단지 요청을 보내는 객체는 이 메세지가 적절하게 처리될 것이라는 바램만 있으면 된다. 메세지를 보내는 쪽이나 받는 쪽 모두 서로를 모르고, 또 연결된 객체들 조차도 그 연결 구조가 어떻게 되는지 모른다. 자신은 단순하게 자신과 연결된 단 하나의 후보 객체만 알면 된다.결과적으로 이 패턴은 객체들 간의 상호작용 과정을 단순화 시킨다.객체에게 책임을 할당하는 것에 대한 유연성 증가객체의 책임을 여러 객체에게 분산 시킬수 있으므로 런타임에 객체 연결 고리를 변경하거나 추가하여 책임을 변경하거나 확장 할 수 있다.메세지 수신이 보장되지 않음어떤 객체가 이 처리에 대한 수신을 담당한다는 것을 명시하지 않았으므로 요청이 처리된다는 보장이 없다. 만약 객체들 간의 연결 고리가 잘 정의되지 않는다면, 요청을 처리되지 못한 채로 버려질 수 있다.ImplementationConsiderations point in implementaion후속 처리자들의 연결 고리 구현후속 처리자들의 연결 고리를 구현하는 방법에는 크게 두가지가 있다. 새로운 연결을 만드는 것 일반적으로는 Handler 클래스에 정의하지만, ConcreteHandler 클래스에 정의할 수도 있다. 이미 있는 연결 정보를 사용하는 것기존 연결을 사용하는 방법은 그 연결이 지금 필요한 연결 정보를 제공할 떄 적절한 방법이다. 명시적으로 별도의 연결 정보를 정의할 필요가 없기 때문이다. 그러나 필요한 연결 고리를 정의할 수 없을 떄라면 중복되더라도 별도의 연결 정보를 위한 변수를 정의해야 한다.후속 처리자 연결연결 정보를 정의하기 위해 미리 정의된 참조자가 없다면 직접 정의해야 한다. 이때 Handler 클래스는 요청 처리에 대한 인터페이스를 정의할 뿐만 아니라, 후속 처리자에 대한 정보 저장의 인스턴스 변수도 정의해야한다. 이 정보를 이용하여 Handler 클래스의 기본 구현은 자신의 후속 처리자로 정의된 객체에 HandleRequest() 메세지를 전달하도록 만든다.ConcreteHandler 서브클래스가 요청받은 메세지에 대해 처리할 내용이 없으면, 기반 클래스에 정의된 구현을 재정의 할 필요 없이 자신의 후속 처리자로 정의된 객체에 메세지를 그대로 전달하면 된다.후속 처리자에 대한 연결을 유지하는 HelpHandler의 기본 클래스의 예는 아래와 같다.class HelpHandler {public: HelpHandler(HelpHandler* s) : _successor(s) {} virtual void HelpHandle() { if(_successor) { _successor-&amp;gt;HandleHelp(); } }private: HelpHandler* _successor;}처리 요청의 표현부를 정의처리 요청을 정의하는 방법에는 여러가지가 있다.첫번째 방안은, 처리를 코드화 하여 개매변수로 받아들이도록 하는 처리자 함수를 하나만 정의하는 것이다. 이렇게 하면 얼마든지 처리 요철을 정의할 수 있다. 이와같이 구현하기 위해선, 메세지 송신과 수신 측 사이에 처리 요청을 어떨게 코드로 만들지에 대해 서로 규약을 정의해야 한다.두번째 방안은, 코드에 따라서 대응하는 처리 요청을 발생시키기 위해 조건문을 정의한다. 만약 매개변수를 전송할 안정적인 방법이 없다면 수동으로 매개변수를 만들고 해석해야 한다. 그러나 이 방법은 정의한 연산을 직접 호출하는 방법보다 안전하지 못하다.세번째 방안은, 매개변수 전송문제를 처리하기 위해, 매개변수를 묶어 별도의 객체로 만드는 것이다. 예를들어, Request 클래스를 이용해서 처리 요청을 명시적으로 정의한다. 만약 새로운 처리 요청이 발생하면, Request 서브클래스로 정의하면 된다. 상속을 이용해서 서로 다른 매개변수를 정의하는 것이다. Handle은 어떤 종류의 처리 요청인지만 알면 필요한 매개변수에 접근할 수 있다.처리요청을 식별하기 위해서 Request 클래스는 클래스에 대한 식별자를 반환하는 멤버 함수를 정이해야 한다. 그렇게 되면, 메세지 수신 측에서 런타임의 타입 정보를 이용할 수 있다. 그러나 이 방법은 언어가 런타임에 타입 정보를 제공하는 기능이 있어야 한다.다음 예는 처리 요청을 식별하기 위해 Request 객체를 사용하는 디스패처(dispatch) 함수의 바탕이다.void Handler::HandleRequest(Request* theRequest) { switch(theRequest-&amp;gt;GetKind()) { case Help: // 인지를 적당한 타입으로 변경 HandleHelp((HelpRequest* theRequest)); break; case Print: // 인지를 적당한 타입으로 변경 HandlePrint((PrintRequest*) theRequest); // ... break; default: // ... break; }}위 예시의 HandleRequest() 연산을 상속한 후 재정의 하면 새로운 처리 방법을 구현할 수 있다. 서브클래스는 관심있는 처리 요청만 담당하도록 정의하면 된다. 다른 처리 요청은 기반 클래스에서 정의된 대로 처리하면 된다.class ExtendedHandler : public Handler {public: virtual void HandleRequest(Request* theRequest){ switch(theRequest-&amp;gt;GetKind()) { case Preview: // 요청 처리 break; default: // 기반 클래스인 Handler가 다른 요청 처리 Handle::HandleRequest(theRequest); break; } } ...};Implement Exampleenum class EVENT : int { BUTTON_PRESS, BUTTON_RELEASE, WINDOW_SHOW, WINDOW_HIDE, ON_REGIST, ...}/*** @brief Handler - EventHandler* @details 요청을 처리하기 위한 인터페이스 정의*/class EventHandler {public: EventHandler(EventHandler* sub = nullptr) : m_evnetHandler(sub) {} virtual ~EventHandler() {} virtual void handler(EVENT eventCode) { if(m_evnetHandler != nullptr) m_evnetHandler-&amp;gt;handler(eventCode); }private: EventHandler* m_evnetHandler = nullptr;};/*** @brief ConcreteHandler - Widget* @details 하위 연결고리들의 인터페이스 정의*/class Widget : public EventHandler {public: Widget(Widget* parent = nullptr) : EventHandler(parent), m_parent(parent) {} virtual ~Widget() {}private: Widget* m_parent;}/*** @brief ConcreteHandler - Window* @details 요청 받은 내용을 처리하기 위해 연결된 하위 요청 처리자*/class Window : public Widget {public: Window(EventHandler* sub = nullptr) : Widget(sub) {} void handler(EVENT eventCode) override { switch(eventCode){ case EVENT::WINDOW_SHOW: ... break; case EVENT::WINDOW_HIDE: ... break; default: // 해당 클레스에서 처리하지 못하는 요청일때, // 요청을 기반클래스로 전파 EventHandler::handler(eventCode); break; } } ...};/*** @brief ConcreteHandler - Button* @details 요청 받은 내용을 처리하기 위해 연결된 하위 요청 처리자*/class Button : public Widget {public: Button(EventHandler* sub = nullptr) : Widget(sub) {} void handler(EVENT eventCode) override { switch(eventCode){ case EVENT::BUTTON_PRESS: ... break; case EVENT::BUTTON_RELEASE: ... break; default: // 해당 클레스에서 처리하지 못하는 요청일때, // 요청을 기반클래스로 전파 EventHandler::handler(eventCode); break; } } ...};/*** @brief ConcreteHandler - Application* @details 요청 받은 내용을 처리하기 위해 연결된 하위 요청 처리자*/class Application : public EventHandler {public: Application(EventHandler* sub = nullptr) : EventHandler(sub) {} void handler(EVENT eventCode) override { switch(eventCode){ case EVENT::ON_REGIST: ... break; default: // 해당 클레스에서 처리하지 못하는 요청일때, // 요청을 기반클래스로 전파 EventHandler::handler(eventCode); break; } } ...}... // 처리에 대한 연결 고리 설정 // app --&amp;gt; window --&amp;gt; btn 순으로 전파 Button* btn = new Button(); Window* window = new Winddow(btn); Application* app = new application(window); // 발생한 이벤트에 대해 처리 요청 app-&amp;gt;handler(EVENT::WINDOW_HIDE);...Related PatternChain of Responsibility Pattern 은 Composite Pattern과 함께 대부분 사용되는데, 이때 구성요소의 부모는 후속 처리자 처럼 동작한다.참고. Design Patterns : Elements of Reusable Object-Oriented Software - Erich Gamma" }, { "title": "Design Patterns - Proxy", "url": "/posts/design_patterns-proxy/", "categories": "Design Patterns", "tags": "Design Patterns, Structural Patterns, Proxy, C++", "date": "2020-04-19 02:19:00 +0900", "snippet": "Structural Patterns - ProxyIntent다른 객체에 대한 접근을 제어하기 위한 대리자 또는 자리채움자 역할을 하는 객체를 둔다.대리자(Surrogate)라고도 불린다.UtilityProxy Pattern은 단순한 포인터보다는 조금 더 다방면에 활용 가능하다. 정교한 객체 참조자가 필요한 때 적용할 수 있다. 원격지 프록시(Remote Proxy) 서로 다른 주소 공간에 존재하는 객체를 가리키는 대표 객체로, 로컬환경에 위치한다. 가상 프록시(Virtual Proxy) 요청이 있을 때만 필요한 고비용 객체를 생성한다. 보호용 프록시(Protection Proxy) 원래 객체레 대한 실제 접근을 제어한다. 객체별로 접근 제어 권한이 다를 때 유용하게 사용 가능하다. 스마트 참조자(Smart Reference) 원시 포인터의 대체용 객체로, 실제 객체에 접근이 일어날때 추가적인 행동을 수행한다. 전형적인 사용예시 실제 객체에 대한 참조 횟수를 저장하다가 더는 참조가 없을 때 해당 객체를 자동으로 없앤다.(스마트포인터) 맨 처음 참조되는 시점에 영속적 저장소의 객체를 메모리로 옮긴다. 실제 객체에 접근하기 전에, 다른 객체가 그것을 변경하지 못하도록 실제 객체에 대해 잠금(lock)을 건다. StructureBasic StructureStructure ExampleElements Proxy ImageProxy에 해당 실제로 참조할 대상에 대한 참조자를 관리 RealSubject와 Subjet 인터페이스가 동일하면 Proxy는 Subject에 대한 참조자를 가짐 Subject와 동일한 인터페이스를 제공하여 실제 대상을 대체할 수 있어야 함 실제 대상에 대한 접근을 제어하고, 실제 대상의 생성과 삭제에대한 챔임을 짐 Proxy의 종류에 따라 다음을 수행 Remote Proxy : 요청 메시지와 인자를 인코딩하여 이를 다른 주소공간에 있는 실제 대상에게 전달 Virtual Proxy : 실제 대상에 대한 추가적 정보를 보유하여 실제 접근을 지연할 수 있도록 해야 함 Protection Proxy : 요청한 대상이 실제 요청할 수 있는 권한인지 확인 Subject Graphic에 해당 RealSubject와 Proxy에 공통적인 인터페이스를 정의하여 RealSubject가 요청되는 곳에 Proxy를 사용할 수 있게 함 RealSubject Image에 해당 Proxy가 대표하는 실제 객체 Proxy 클래스는 자신이 받은 요청을 RealSubject 객체에 전달한다.FeatureProxy Pattern은 어떤 객체에 접근할 떄 추가적인 간접화 통로를 제공한다. Remote Proxy는 객체가 다른 주소 공간에 존재한다는 사실을 숨길수 있게 해준다. Virtual Proxy는 요구에 따라 객체를 생성하는 등의 처리를 최적화할 수 있게 해준다. Protection Proxy및 Smart Reference는 객체의 생성과 삭제를 관리하며, 객체가 접근할 때마다 추가 관리를 책임진다.Proxy Pattern이 사용자에게 숨길수 있는 또 다른 최적화로는, 기록 시점 복사(Copy on Write) 이다. 이 최적화는 요구가 들어올 때만 객체를 생상하는 개념과 관련있다. 덩치가 크고 복잡한 객체를 복사하려면 비용이 매우 커지게 된다. 만약 사본이 변경되지 않고 원본과 똑같다면, 이러한 비용을 지불할 필요가 없게된다. 이때 Proxy를 사용해서 복사 절차를 미룸으로써, 사본이 수정될 때만 실제 복사 비용을 지불하게 한다.이 기록 시점 복사 기능 가능하게 하려면 원본의 참조 카운트를 관리해야 한다. Proxy를 복사하는 연산은 이 원본에 대한 참조 카운트를 증가시키는 일 외에 다른일은 하지 않는다. 사용자가 이 원본을 수정하는 연산을 요청할 때 Proxy가 실제로 복사를 진행하여 사본이 별도의 값을 가지게 한다. 이렇게 되면 원본에 대한 참조자 수는 줄어들게 된다. 이런 과정의 반복속에 참조 카운트가 0이 되면 대상을 삭제한다.ImplementationConsiderations point in implementaionC++에서는 멤버 접근 연산자를 오버로드 하여 구현C++에서의 멤버 접근 연사자인 operator-&amp;gt; 연산을 오버로드하여, 포인터를 통해 해당 객체에 접근할 떄마다 뭔가 추가적인 행동을 할 수 있도록 한다. Proxy가 단순한 포인터의 역할만 수행할 때는 매우 유용한 방식이다.// RealSubjectclass Image;// 외부함수extern Image* LoadAnImageFile(const char*);// ImagePtr Virtual Proxyclass ImagePrt {public: ImagePrt(const char* imageFile){ m_imageFile = imageFile; m_image = 0; } virtual ~ImagePtr(); // LoadImage() 연산을 이용하여 m_image를 호출자에게 반환 virtual Image* operator-&amp;gt;() { return LoadImage(); } // LoadImage() 연산을 이용하여 m_image를 호출자에게 반환 virtual Image&amp;amp; operator*() { return LoadImage(); }private: Image* LoadImage() { if(m_image == 0) m_image = LoadAnImageFile(m_imageFile); return m_image; }private: Image* m_image; const char* m_imageFile;};... ImagePtr iamge = ImagePtr(&quot;anImageFilename&quot;); // (image.operator-&amp;gt;())-&amp;gt;Draw(Point(50, 100)) image-&amp;gt;Draw(Point(50, 100));...멤버 함수로 정의된 접근 연산자를 오버로드하는 것은 모든 종류의 Proxy 구현에 적합한 방법은 아니다. 어떤 Proxy는 어떤 연산이 호출되는지 알아야 사용할 멤버 접근 연산자를 정할 수 있다.이 연산들은 대체로 서로 비슷하게 구현된다. 모든 연산에서는 실제 요청 처리를 담당할 대상에게 전달하기 전에 이 요청이 합당한지 원본 객체가 존재하는지 등 검증한다. 모든 연산마다 이러한 코드를 작성하기에는 비효율적이므로, 일반적으로 이런 반복코드를 자동으로 생성하는 선행 처리자를 두어 처리한다.Proxy가 항상 자신이 상대할 실제 대상을 알 필요는 없음Proxy 클래스는 추상 인터페이스를 통해서만 대상과 일을 하므로, RealSubject별로 Proxy 클래스를 만들 필요가 없다. Proxy는 모든 RealSubject를 마치 하나의 클래스인 것처럼 하나의 인터페이스를 통해 사용하면 된다. 그러나 Proxy는 RealSubject의 인스턴스를 생성해야 하는 시점이 되면 어떤 클래스의 인스턴스를 생성해야 하는지 알아야 한다.대상 인스턴스를 만들기 전에, 그 대상을 어떨게 알 것인가대상이 메모리 또는 디스크에 있던 대상을 항상 참조해야 하는 Proxy가 있을수 있다. 이 말은 객체의 저장 공간과 관계없는 객체 식별자를 사용해야 한다는 말이다. 이때는 파일 이름과 같은 식별자를 사용하여 대상을 추측한다.Implement Example// Clone Minecraft&#39;s block(cube)/*** @brief Subject - Graphic* @details 공통 인터페이스를 정의하여 실제 객체가 요청되는곳에 Proxy를 사용할 수 있게 함*/class Graphic {public: virtual ~Graphic() {} virtual void draw(const Point&amp;amp; at) = 0; virtual void handleMouse(Event&amp;amp; event) = 0; virtual const Point&amp;amp; getExtent() = 0; virtual void load(istream&amp;amp; from) = 0; virtual void save(ostream&amp;amp; to) = 0;private: Graphic();};/*** @brief RealSubject - Image* @details Proxy가 대표하는 실제 객체*/class Image : public Graphic {public: // 파일로부터 이미지를 로드 Image(const cahr* file) {} virtual ~Image() {} virtual void draw(const Point&amp;amp; at); virtual void handleMouse(Event&amp;amp; event); virtual const Point&amp;amp; getExtent(); virtual void load(istream&amp;amp; from); virtual void save(ostream&amp;amp; to);private: ...};/*** @brief Proxy - ImageProxy* @details 실제 객체에 접근하기 위한 Proxy*/class ImageProxy : public Image {public: ImageProxy(const cahr* fileName) { m_fileNmae = strdup(fileName); m_extent = Point::Zero; m_image = 0; } virtual ~ImageProxy() {} virtual void draw(const Point&amp;amp; at) { getImage()-&amp;gt;Draw(at) } virtual void handleMouse(Event&amp;amp; event) {getImage()-&amp;gt;handleMouse(event); } virtual const Point&amp;amp; getExtent() { if(m_extent == Point::Zero) m_extent = getImage()-&amp;gt;getExtent(); return m_extent; } virtual void load(istream&amp;amp; from) { to &amp;lt;&amp;lt; m_extent &amp;lt;&amp;lt; m_fileNmae; } virtual void save(ostream&amp;amp; to) { from &amp;gt;&amp;gt; m_extent &amp;gt;&amp;gt; m_fileNmae; }protected: Image* getImage() { if(m_image == 0) m_image = new Image(m_fileName); return m_image; }private: Image* m_image; Point m_extent; char* m_fileName;};/*** @brief Client - TextDocument* @details RealSubject를 요청하여 Proxy에 접근*/class TextDocument {public: TextDocument(); void insert(Graphic* ); ...};... TextDocument* text -&amp;gt; new TextDocument(); ... text-&amp;gt;insert(new ImageProxy(&quot;anImageFileName&quot;));...Related PatternAdapter는 자신이 개조할 객체가 정의된 인터페이스와 다른 인터페이스를 제공한다. 이에 반해 Proxy는 자신이 상대하는 대상과 동일한 인터페이스를 제공한다. Proxy는 대상이 수행할 연산의 수행을 거부할 수도 있기 때문에, 처리 대상이 제공하는 인터페이스의 부분 집합 일수도 있다.Decorator는 Proxy와 구현 방법이 비슷한데, Decorator는 그 사용 목적이 하나 이상의 서비스를 추가하기 위한 것이고, Proxy는 객체에 대한 접근을 제어하는 목적이라는 점에서 차이가 있다.Proxy는 Decorator와 구현 밥법에도 많은 차이를 보인다. 예를 들어 Protection Proxy는 Decorator 구현 방법이 거의 유사하나, Remote Proxy는 실제 처리 대상을 직접 참조하도록 관리하지 않고 간접적 접근방법을 관리한다. 이 간접적 접근 방법은 호스트 식별자, 호스트 머신 내의 주소 등을 포함한다. Virtual Proxy는 파일 이름과 같은 간접적 참조자를 정의하지만, 궁극적으로는 직접적 참조자를 얻어온 후 이를 사용한다.참고. Design Patterns : Elements of Reusable Object-Oriented Software - Erich Gamma" }, { "title": "Design Patterns - Flyweight", "url": "/posts/design_patterns-flyweight/", "categories": "Design Patterns", "tags": "Design Patterns, Structural Patterns, Flyweight, C++", "date": "2020-04-19 00:22:00 +0900", "snippet": "Structural Patterns - FlyweightIntent공유(sharing)을 통해 많은 수의 소립(fine-grained) 객체들을 효과적으로 지원한다.UtilityFlyweight Pattern은 언제 사용하는가에 따라서 그 효과가 달라지게 된다. 응용프로그램이 대량의 객체를 사용해야 할 때 객체의 수가 너무 많아져 저장 비용이 너무 높아질 때 대부분의 객체 상태를 부가적인 것으로 만들수 있을 때 부가적인 속성들을 제거한 후 객체들을 조사해 보니 객체의 많은 묶음이 비교적 적은 수의 공유된 객체로 대체될 수 있을 떄 현재 서로 다른 객체로 간주한 이유는 이들 부가적인 속성 때문이지 본질이 달랐던 것은 아닐 때 응용프로그램이 객체의 정체성에 의존하지 않을 때 Flyweight 객체들은 공유 될 수 있음을 의미하는데, 식별자가 있다는 것은 서로 다른 객체로 구별해야 한다는 의미 이므로 Flyweight 객체를 사용할 수 없다. StructureBasic StructureStructure ExampleElements Flyweight Graph에 해당 Flyweight가 받아들일 수 있고, 부가적인 상태에서 동작해야 하는 인터페이스를 정의 ConcreteFlyweight Character에 해당 Flyweight 인터페이스를 구현 내부적으로 가지고 있어야 하는 본질적 상태에 대한 저상소를 정의 ConcreteFlyweight 객체는 공유할 수 있어야 하므로, 관리하는 어떤 상태라도 본질적 이여야 함 UnsharedConcreteFlyweight Row, Column에 해당 Flyweight 인터페이스는 공유를 가능하게 하지만, 그것을 강요해서는 안됨. 즉, 모든 Flyweight의 서브클래스들이 공유될 필요는 없음 UnsharedConcreteFlyweight 객체는 ConcreteFlyweight 객체는 자신의 자식으로 가질수도 있음 FlyweightFactory Flyweight 객체를 생성하고 관리하며, Flyweight 객체가 제대로 공유되도록 보장 사용자가 Flyweight 객체를 요청하면, FlyweightFactory 객체는 이미 존재하고 있는 인스턴스를 제공하거나 만약 존재하지 않으면 새로 생성 Client Flyweight 객체레 대한 참조자를 관리하며 객체의 부가적 상태를 저장 Flyweight 객체가 기능을 수행하는데 필요한 상태가 본직적인지, 부가적인 것인지를 구분해야 한다. 본질적인 상태는 ConcreteFlyweight에 저장해야 하고, 부가적인 상태는 사용자가 저장하거나, 연산되어야 하는 다른 상태로 관리해야 한다.사용자는 ConcreteFlyweight의 인스턴스를 직접 만들수 없다. 사용자는 ConcreteFlyweight 객체를 FlyweightFactory 객체에서 얻어야 한다. 이렇게 해야 Flyweight 객체가 공유될 수 있다.FeatureFlyweight Pattern은 예전에는 모두 본질적인 상태로 저장되어 있던 것을 부가적인 상태로 만들어, 부가적인 상태의 연산과 전송에 드는 런타임 비용을 새로 들여올 수 있다. 하지만 이런 비용은 Flyweight 객체의 공유를 통해 저장소 절약이라는 반대급부를 가질 수 있다. 공유해야 하는 인스턴스의 전체 수를 줄일 수 있다. 객체별 본질적 상태의 양을 줄일 수 있다. 부가적인 상태는 연산되거나 저장될 수 있다.더 많은 Flyweight가 공유될 수록 저장소는 절약된다. 또한 공유할 상태가 많아 질수록 절약된다. 대부분의 본질적인 상태가 저장되고 부가적인 상태는 연산될 때라면 절약의 효과가 가장 크다. 이때는 본질적인 상태를 저장하는 비용이 줄어드는 대신, 부가적인 상태를 만들기 위한 연산의 시간이 들게 된다.Flyweight Pattern은 Composite Pattern과 조합하여 그래프와 같이 계층적 구조를 모델링하는데 자주 사용된다. 이렇게 하면, Flyweight 단말 노드들은 자신의 부모에 대한 포인터를 저정할 수 없기 때문에, 부모 포인터를 부가적 상태의 일부로서 Flyweight 객체에다가 매개변수로 전달해야 한다.ImplementationConsiderations point in implementaion부가적 상태를 제외Flyweight Pattern의 활용여부는 얼마나 쉽게 공유할 객체에서 부가적인 상태를 식별하고 이를 분리하는데 달려있다.공유할 객첼를 관리객체는 공유할 수 있으므로, 사용자가 직접 인스턴스를 만들면 안된다. 그렇기 때문에 FlyweightFactory는 사용자가 특정한 Flyweight 객체를 찾아내게 한다.FlyweightFactory 객체는 연관 저장소를 써서 사용자가 자신이 관심있는 Flyweight 객체를 찾아볼 수 있게 한다.Implement Example// Clone Minecraft&#39;s block(cube)/*** @brief Flyweight - CubeInfo* @details 다량으로 생성될 객체들의 집합에서 공유될 공통 인터페이스 정의*/class Cube{public: virtual ~Cube() {} virtual CubeType getCubeType() const = 0; virtual void setColor(ColorType colorType) = 0; virtual ColorType getColor() const = 0; virtual ItemType getItem() const = 0;}/*** @brief ConcreteFlyweight - RockCube* @details Flyweight을 상속받아 공유되는 자신만의 인터페이스를 구현*/class RockCube : public Cube {public: RockCube() { m_type = CUBE_TYPE_ROCK; } virtual ~RockCube() {} CubeType getCubeType() const override { return m_type; } void setColor(ColorType colorType) { m_color = m_color; } ColorType getColor() const override { return m_color; } ItemType getItem() const { return ITEM_TYPE_CUBE_ROCK; };private: ColorType m_color; CubeType m_type;};/*** @brief ConcreteFlyweight - SandCube* @details Flyweight을 상속받아 공유되는 자신만의 인터페이스를 구현*/class SandCube : public Cube {public: SandCube() { m_type = CUBE_TYPE_SAND; } virtual ~SandCube() {} CubeType getCubeType() const override { return m_type; } void setColor(ColorType colorType) { m_color = m_color; } ColorType getColor() const override { return m_color; } ItemType getItem() const { return ITEM_TYPE_CUBE_SAND; };private: ColorType m_color; CubeType m_type;};/*** @brief UnsharedConcreteFlyweight - MasterCube* @details Flyweight을 상속받아 자신만의 인터페이스를 구현하지만 공유되지는 않음`*/class MasterCube : public Cube {public: MasterCube() { m_type = CUBE_TYPE_MASTER; } virtual ~MasterCube() {} CubeType getCubeType() const override { return m_type; } void setColor(ColorType colorType) { m_color = m_color; } ColorType getColor() const override { return m_color; } ItemType getItem() const { return ITEM_TYPE_NONE; }; void getPosition(Position pos) { m_pos = pos; } const Position getPosition() const { return m_pos; }private: Position m_pos; ColorType m_color; CubeType m_type;};/*** @brief FlyweightFactory - CubeFacotory* @details ConcreteFlyweight 객체의 공유 및 생성을 위한 메소드 정의*/class CubeFacotory {public: // 공유되는 성질을 가지는 ConcreteFlyweight 객체 생성 및 반환 Cube* getCubeInstance(CubeType cubeType){ // 현재 FlyweightFactory에 검색하는 타입의 ConcreteFlyweight 객체가 없을시, // 해당하는 타입의 ConcreteFlyweight 객체 생성 if(m_cubeNap.find(cubeType) == m_cubeMap.end()){ switch(cubeType){ case CUBE_TYPE_ROCK : { m_cubeMap[cubeType] = dynamic_cast&amp;lt;Cube*&amp;gt;(new RockCube()); break; } case CUBE_TYPE_SAND : { m_cubeMap[cubeType] = dynamic_cast&amp;lt;Cube*&amp;gt;(new SandCube()); break; } } } return m_cubeMap[cubeType]; } // 공유되지 않은 성질을 가지는 UnsharedConcreteFlyweight 객체 생성 Cube* CreateMasterCube(){ new MasterCube(); }private: std::map&amp;lt;CubeType, Cube*&amp;gt; m_cubeMap;};... CubeFacotory cubFactory; std::vector&amp;lt;Cube*&amp;gt; myCubeList; for(auto i = 0; i &amp;lt; 1000 ; ++i){ CubeType cubeType = randomCubeType(); myCubeList.push_back(cubFactory.getCubeInstance(cubeType)); } myCubeList.push_back(cubFactory.CreateMasterCube());...Related PatternFlyweight은 Composite Pattern 패턴과 함께 사용되는데, 공유되는 단말 노드를 가지는 방향성 비순환 그래프 형태를 써서 논리적으로 계층구조는 구현하는 것이 이에 해당한다.State Pattern또는 Strategy Pattern을 Flyweight 객체로 구현할 수 있다.참고. Design Patterns : Elements of Reusable Object-Oriented Software - Erich Gamma" }, { "title": "Design Patterns - Facade", "url": "/posts/design_patterns-facade/", "categories": "Design Patterns", "tags": "Design Patterns, Structural Patterns, Facade, C++", "date": "2020-04-18 22:22:00 +0900", "snippet": "Structural Patterns - FacadeIntent한 서브시스템 내의 인터페이스 집합에 대한 획일화된 하나의 인터페이스를 제공하는 패턴으로, 서브시스템을 사용하기 쉽도록 상위 수준의 인터페이스를 정의한다.Utility 복잡한 서브시스템에 대한 단순한 인터페이스 제공일 필요할 때 Facade Pattern은 서브시스템에 대한 단순하면서도 기본적인 인터페이스를 제공함으로써 대부분의 개발자들에게 적합한 클래스 형태를 제공한다. 추상 개념에 대한 구현 클래스와 사용자 사이에 너무 많은 종속성이 존재할 때 Facade의 사용을 통해 사용자와 다른 서브시스템 간의 결합도를 줄일 수 있다. 서브시스템에 정의된 모든 인터페이스가 공개되면 빈번한 메서드 호출이 있을수 있으나, 이런 호출은 단순화 형태로 통합하여 제공하고 나머지 부분은 내부적으로 처리함으로써 사용자와 서브시스템 사이의 호출횟수는 실질적으로 감소하게 되는 효과를 가진다. 서브시스템을 계층화시킬 때 Facade Pattern을 사용하여 각 서브시스템의 계층에 대한 접근점을 제공한다. 서브시스템이 다른 서브시스템에 종속적이라 하더라고, 각자가 제공하는 Facade를 통해서만 대화를 진행하게 함으로써 서브시스템 간의 종속성을 줄일 수 있다. 서브시스템 내부 설계의 변경이 다른 서브시스템에 독립적으로 자유롭게 될 수 잇다. StructureBasic StructureStructure ExampleElements Facade Compiler에 해당 단순하고 일관된 통합 인터페이스를 제공 서브시스템을 구성하는 어떤 클래스가 어떤 요청을 처리해야 하는지에 대한 관리 사용자의 요청을 해당 서브시스템 객체에 전달 SubSystem Classes Scanner, Parser, ProgramNode등 에 해당 서브시스템의 기능을 구현하고, Facade 객체로 할당된 작업을 실제로 처리하지만 Facade에 대한 아무런 정보를 가지고 있지 않다. 즉, 이들에 대한 어떠한 참조자도 가지고 있지 않다. Feature서브시스템의 구성요소 보호사용자가 다루어야 할 객체의 수가 줄어들며, 서브시스템을 쉽게 사용할 수 있도록 한다.서브시스템과 사용자 코드 간의 결합도 약화서브시스템내 정의된 요소들은 강하게 결합될 수 있다. 그러나 Facade로 인하여 사용자 코드와 서브시스템은 분리되어 있기 때문에 결합도를 약화시킨다.서브시스템과 사용자 간의 결합이 약하게 되면, 서브시스템 내의 요소를 다양화하는 작업을 원활하게 할 수 있다.응요읖로그램 쪽에서 서브시스템 클래스를 사용하는 것을 완전히 막지 않는다사용자는 Facade를 사용하여 서브시스템에 접근할 것인지, 서브시스템 클래스를 직접 사용할 것인지 결정할 수 있다.ImplementationConsiderations point in implementaion사용자와 서브시스템 간의 결합도 줄이기사용자와 서브시스템 간의 의존성을 줄이는 방안으로는 크게 두가지가 있다.Facade를 추상 클래스로 정의하고 서브시스템을 나타내기 위해 이를 상속하는 구체 서브클래스를 정의하여 다른 구현을 정의하도록 하는 것이다. 그러면, 사용자는 Facade만 사용하기 때문에, 어떤 서브시스템의 구현이 사용되고 있는지 알 필요가 없다.서브클래싱을 하지 않고, 다른 서브시스템의 객체를 조합하여 Facade를 구성할 수도 있다. 또한 Facade를 수정하기 위해서는 하나 이상의 서브시스템 객체를 대체하면 된다.서브시스템 클래스 중 공개할 것과 감출 것서브시스템은 클래스와 유사하다. 둘 다 인터페이스를 가지고 있으며 무엇인가를 감춘다. 클래스는 상태와 연산을, 서브시스템은 클래스를 캡슐화 한다. 클래스의 인터페이스를 정의할 때 공개할지 말지를 고민하는 것처럼 서브시스템의 인터페이스도 공개할지 말지를 결정해야 한다.서브시스템의 공개 인터페이스는 사용자가 직접 접근할 수 있는 클래스들이고, 비공개 클래스는 서브시스템 자체가 된다. Facade 클래스는 공개 인터페이스의 일부이다.Implement Example/*** @brief SubSystem - CameraViewer* @details 하위 시스템 구현*/class Window {public: Window(const int width, const int height) : m_width(width), m_width(height) {} void setScreenBuffer(Buffer* buf) { m_buf = buf; } void showOneFrame() { ... m_buf-&amp;gt;pop(m_img); ... } ...private: ... const int m_width; const int m_height; Buffer* m_buf = nullptr; ...};/*** @brief SubSystem - Camera* @details 하위 시스템 구현*/class Camera {public: Camera(Buffer* buf) : m_buf(buf) {} ... void getImage() const { ... m_buf-&amp;gt;push(img); }private: ... Buffer* m_buf = nullptr; Image img;};/*** @brief SubSystem - Buffer* @details 하위 시스템 구현*/class Buffer {public: Buffer(const int size) : m_buf(std::queue&amp;lt;uint8_t*&amp;gt;(size, 0) {} void push(const Image&amp;amp; img) { if (m_maxSize &amp;gt; 0 &amp;amp;&amp;amp; m_queue.size() &amp;gt; m_maxSize) return; m_queue.push(data); } void pop(Image&amp;amp; img) { if (m_buf.empty()) return; img = m_queue.front(); m_queue.pop(); }private: std::queue&amp;lt;Image&amp;gt; m_buf;};/*** @brief Facade - CameraViewer* @details SybSystem을 기반으로 통합 인터페이스를 구성*/class CameraViwer {public: void initialize() { m_buf = new Buffer(MAX_BUF_SIZE); m_window = new Window(WIDTH, HEIGHT); m_window-&amp;gt;setScreenBuffer(m_buf); m_cam = new Camera(m_buf); } void viewing() { while(g_run){ ... m_cam()-&amp;gt;getImage(); m_window-&amp;gt;showOneFrame() ... } } ...private: ... Window* m_window = nullptr; Buffer* m_buf = nullptr; Camera* m_cam = nullptr; ...};... CameraViwer camView; camView.initialize(); camView.viewing();...Related PatternAbstract Factory Pattern은 서브시스템에 독립적인 방법으로, 서브시스템 객체를 생성하는 인터페이스를 제공하기 위해 Facade와 함께 사용할 수 있다. Abstract Factory는 Facade에 대한 대안으로서, 플렛폼에 종속적인 클래스를 감추는데 사용한다.Mediator Pattern도 기존에 존재하는 클래스의 기능성을 추상화한다는 점에서 Facade Pattern과 유사하다.Mediator의 목적은 여러 객체들 사이의 협력 관계를 추상화하여 기능성의 집중화를 막는것 이다. Mediator Pattern에 참여하는 객체는 서로를 직접 알지 못하고 단지 중재자를 통해서만 상호작용이 된다. 이에 비해 Facade는 서브시스템 인터페이스 자체를 추상화하여 사용을 용이하게 사려는 목적을 가지고 있다. 즉, 새로운 기능성을 추가할 수도 없고, 이런 새로운 추가 기능에 대해서는 알 수도 없다.Facade객체가 하나만 있어도 된다면, Singleton을 이용하여 구현한다.참고. Design Patterns : Elements of Reusable Object-Oriented Software - Erich Gamma" }, { "title": "Design Patterns - Decorator", "url": "/posts/design_patterns-decorator/", "categories": "Design Patterns", "tags": "Design Patterns, Structural Patterns, Decorator, C++", "date": "2020-04-18 20:30:00 +0900", "snippet": "Structural Patterns - DecoratorIntent객체에 동적으로 새로운 책임을 추가할 수 있게 한다.기능을 추가하려면, 서브클래스를 생성하는 것보다 융통성 있는 방법을 제시한다.랩퍼(Wrapper) 라고도 불린다.Utility 동적으로 또한 투명하게(transparent), 즉 다른 객체에 영향을 주지 않고 개개의 객체에 새로운 책임을 추가 할 때 제거될 수 있는 책임에 대해 사용 실제 상속으로 서브클래스를 계속 만드는 방법이 실질적이지 못할 때 너무 많은 수의 독립된 확장이 가능할 때 모든 조합을 지원하기 위해 이를 상속으로 해결하고자 하면 클래스의 수가 너무 많아지게 된다. StructureBasic StructureStructure ExampleElements Component VisualComponent에 해당 동적으로 추가할 서비스를 가질 가능성이 있는 객체에 대한 인터페이스 ConcreteComponent TextView에 해당 추가저긴 서비스가 실제로 정의되어야 할 필요가 있는 객체 Decorator Component 객체에 대한 참조자를 관리하면서 Component에 정의된 인터페이스를 만족하도록 인터페이스를 정의 ConcreteDecorator BorderDecorator, ScrollDecorator에 해당 Component에 새롭게 추가할 서비스를 실제로 구현하는 클래스 Decorator는 자신의 Component 객체 쪽으로 요청을 전달한다. 요청 전달 전 및 전달 후에 자신만의 추가 연산을 선택적으로 수핼할 수도 있다.Feature단순한 상속보다 설계의 융통성을 더 많이 증대시키는 것이 가능Decorator Pattern은 객체에 새로운 행동을 추가할 수 있는 가장 효과적인 방법이다.Decorator를 사용하면 Decorator를 객체에 연결하거나 분리하는 작업을 통해 새로운 책임을 추가하거나 삭제하는 일이 런타임에 가능해 진다. 그러나 상속은 코드에서, 즉 정적으로 새로운 클래스를 추가해야만 추가적인 행동을 정의할 수 있는 방법이다.Decorator Pattern을 사용하면, Decorator의 조합을 통해 새로운 책임도 조합할 수 있다.이는 구조에 나타나는 바와 같이 Decorator 클래스와 Component 클래스 사이에 집합 관계가 정의되어 있어 Decorator는 Component 클래스의 인스턴스를 포함할 수 있는데, 이는 Component의 서브 클래스인 ConcreteDecorator_A 클래스나 ConcreteDecorator_B 클래스의 인스턴스를 포함할 수 있다는 의미가 된다.이렇게 Decorator의 서브클래스를 아무런 코드의 수정없이 포함할 수 있으므로, Decorator 클래스의 서브클래스를 여러개를 포함하면 여러 책임을 조합하는 결과가 된다.클래스 계통의 상부측 클래스에 많은 기능이 누적되는 상황을 회피Decorator Pattern은 책임 추가 작업에서 “필요한 비용만 그때 지불하는” 방법을 제공한다. 즉, 지금까지 예상하지 못한 특성들을 한번에 다 개발하기 위해 고민하고 노력하기보다는 발견하지 못하고 누락된 서비스들을 Decorator 객체를 통해 지속적을 추가할 수 있다. 기능은 단순한 구성요소들의 조합으로 얻어질 수도 있다.Decorator와 해당 그 Decorator의 구성요소가 동일한 것은 아님Decorator는 사용자에게 일관된 인터페이스를 제공하기 위한 껍데기이다. 그러므로 객체 식별자 관점에서 구성요소롸 이를 둘러싼 Decorator 객체가 동일한 식별자를 가질 필요는 없다.Decorator를 사용함 으로써 작은 규모의 객체가 다수 생성클래스들이 어떻게 조합하여 새로운 모습과 기능을 만들어 내는가에 따라서 새로운 객체가 계속 만들어지게 된다. 이러한 객체들은 상호작용하는 방법이 서로다르지만, 클래스가 다르거나 변수에 정의된 값이 다른것이 아니다.ImplementationConsiderations point in implementaion인터페이스 일치시키기Decorator 객체의 인터페이스는 반드시 자신을 둘러싼 구성요소의 인터페이스를 만족해야 한다. 따라서 ConcreteDecorator 클래스는 동일한 부모 클래스를 상속해야 한다.추상 클래스로 정의되는 Decorator 클래스 생략하기간혹 추상 클래스인 Decorator 클래스를 정의할 필요가 없을 때가 있다. 이러한 경우에, Decorator 클래스에 정의할 책임은, 구성요소에게 요청을 전달해야하는 한가지 책임만 존재하게 된다. 이 책임은, 새로운 클래스들을 설계할 때 발생한다기 보단, 기존에 존재하는 클래스 계통을 사용해야 할 떄 자주 일어난다. 이때 구성요소에게 요청을 전달하는 Decorator 클래스의 책임을 ConcreteDecorator 클래스와 합칠수 있다.Component 클래스는 가벼운 무게를 유지시키기인터페이스를 만족하는지 확인하려면 구성요소와 Decorator 모두 동일한 부모 클래스인 Component 클래스를 상속받아야 한다. 이때 Component 클래스를 가볍게 정의하는것은 중요한 일이다.가볍게 장의한다는 의미는 연산에 해당하는 인터페이스만을 정의하고 무언가 저장할수 있는 변수는 정의하지 말라는 의미이다. 데이터를 저장하는 일은 서브클래스에서 할 일이다.객체의 겉을 변경할 것인가, 속을 변경할 것인가흔히 Decorator Pattern은 행동을 변경할 수 있도록 객체에 외장을 입힌것으로 알고 있다. 즉 객체의 겉을 변경시켜 새로운 서비스, 행동을 추가하여 행할 수 있도록 한다.Decorator Pattern은 객체의 외관을 변경하는 것이므로, 구성요소는 자신을 둘러싼 Decorator에 대해서는 전혀 알 필요가 없다. 즉 Decorator는 구성요소에 대해 투명하다고 할 수 이다.Strategy Pattern은 Decorator Pattern과 반대로 객체의 내부를 변경하는 대표적인 패턴이다.Component 클래스가 본질적으로 매우 복잡하고 무거운 특성을 가진다면, Strategy Pattern이 더 나은 해결방안이다. Strategy Pattern에서 구성요소는 자신이 받은 처리 요청을 분리된 Strategy 클래스에 전달한다. Strategy 객체의 대체를 통해서 구성요소의 기능성을 변경하거나 확작하는 방법을 제공한다.Implement Example/*** @brief Component - Viewr* @details 추후 서비스가 추가될 인터페이스 정의*/class Viewer {public: virtual ~Viewer() {} virtual void view() const = 0;};/*** @brief ConcreteComponent - BasicViewr* @details 인터페이스의 기본 행동 구현*/class BasicViewr : public Viewer{public: ... void view() const override{ m_window-&amp;gt;show();};private: Window* m_window = nullptr;};/*** @brief Decorator - ViewrDecorator* @details 기존의 인터페이스에 동작을 추가하기 위해 중간 Decorator 클래스 정의*/class ViewrDecorator : public Viewer{public: ViewrDecorator(Viewer* viewer) : m_viewer(viewer) {} virtual ~ViewrDecorator() {} virtual void view() const override{ m_viwer-&amp;gt;view(); };private: Viewer* m_viwer = nullptr;};/*** @brief ConcreteDecorator - CameraViewer* @details 새롭게 추가할 행동 정의*/class CameraViewer : public ViewrDecorator {public: CameraViewer(Viewer* viwer) : ViewrDecorator(viwer) { m_cam = new Camera(); m_cam-&amp;gt;open(); } ~CameraViewer() { m_cam-&amp;gt;close(); delete m_cam; } void view() const override { // 기존에 정의된 인터페이스에 새로운 행동 추가 getCameraImage(); ViewrDecorator::view(); }private: void getCameraImage() { m_cam-&amp;gt;getImage2Buffer(); }private: Camera* m_cam;};... // 기본이 되는 동작을 구현한 ConcreteComponent 객체 생성 Viewer* viewer = dynamic_cast&amp;lt;Viewer*&amp;gt;(new BasicViewr()); // 기본동작을 가지는 ConcreteComponent에 새로운 서비스를 추가하기위해, // Decorator를 상속한 ConcreteDecorator를 객체를 생성 viewer = dynamic_cast&amp;lt;Viewer*&amp;gt;(new CameraViewer(viewer)); viewer = dynamic_cast&amp;lt;Viewer*&amp;gt;(new LidarViewer(viewer)); viewer = dynamic_cast&amp;lt;Viewer*&amp;gt;(new GNSSViewer(viewer)); // 새로운 서비스가 추가된 인터페이스 실행 viewer-&amp;gt;view();...Related PatternDecorator Pattern은 Adapter Pattern과 관련되어 있다. Adapter는 인터페이스를 변경시켜주는 것이지만, Decorator는 객체의 책임, 행동을 변화 시킨다.Composite Pattern과도 관련된다. Decorator는 한 구성요소만을 가지는 Composite라고 볼수 있다. 그러나 이 목적은 객체의 합성이 아니라 객체에 새로운 행동을 추가하기 위한 것이다.Strategy Pattern과도 관련된다. Decorator는 객체의 겉모양을 변경하고, Strategy는 객체의 내부를 변화시킨다. 객체를 변경하는 두가지 대안인 셈이다.참고. Design Patterns : Elements of Reusable Object-Oriented Software - Erich Gamma" }, { "title": "Design Patterns - Composite", "url": "/posts/design_patterns-composite/", "categories": "Design Patterns", "tags": "Design Patterns, Structural Patterns, Composite, C++", "date": "2020-04-15 22:05:00 +0900", "snippet": "Structural Patterns - CompositeIntent부분과 전체의 계층을 표현하기 위해 객체들을 모아 트리 구조로 구성한다.사용자로 하여금 개별 객체와 복합 객체를 모두 동일하게 두룰수 있게 한다.Utility 부분-전체의 객체 계통을 표현하고 싶을 때 사용자가 객체의 합성으로 생긴 복합 객체와 개개의 객체 사이의 차이를 알지 않고도 자기 일을 할 수 있도록 만들고 싶을 때 사용자는 복합 구조(Composite Structue)의 모든 객체를 똑같이 취급하게 된다. StructureBasic StructureStructure ExampleElements Component Graphic에 해당 집합관계에 정의될 모든 객체에 대한 인터페이스를 정의 모든 클래스에 해당하는 인터페이스에 대해서는 공통의 행동을 구현 전체 클래스에 속한 요소들을 관리하는 데 필요한 인터페이스를 정의 순환 구조에서 요소들을 포함하는 전체 클래스로 접근하는 데 필요한 인터페이스를 정의 및 구현 Leaf Rectangle, Line, Text, … 에 해당 자식이 없는 객체를 나타냄 객체 합성에 가장 기본이 되는 객체의 행동을 정의 Composite Picture에 해당 자식이 있는 구성요소에 대한 행동을 정의 자신이 복합하는 요소들을 저장하면서, Composite 인터페이스에 정의된 자식 관련 연산을 구현 Client 인터페이스를 통해 복합 구조 내의 객체들을 조작 사용자는 복합 구조 내 객체 간의 상호작용을 위해 Component 클래스 인터페이스를 사용한다.요청받은 대상이 Leaf 인스턴스이면 자신이 정의한 행동을 직접 수행하고, 대상이 Composite이면 자식 객체들에게 요청을 위힘한다. 위임하기 전후에 다른 처리를 수행할 수도 있다.Feature기본 객체와 복합 객체로 구성된 하나의 일관된 클래스 계통을 정의기본 객체는 더 복합적인 객체들에 속해 있을수 있다. 그러나 사용자 코드는 일반화된 상위 개념의 객체를 조작하는 방식으로 프로그래밍을 하면, 런타임 기본 객체와 복합 객체를 구분하지 않고 일관되게 프로그래밍이 가능해 진다.사용자의 코드 단순화사용자는 객체의 특성이 복합 구조인지 단일 구조인지 모르고도 개발을 진행 할 수 있다.새로운 구성요소의 쉬운 추가새롭게 정의된 Composite나 Leaf의 서브클래스들은 기존에 존재하는 구조들과 독립적으로 동작이 가능하게 된다. 즉, 새로운 요소가 추가되었다고 해서 사용자의 프로그램이 변경될 필요가 없게 된다.설계가 지나치게 범용성을 많이 가짐새로운 요소를 쉽게 추가할 떄의 단점은 composite의 구성요소에 대한 제약을 가하기 힘들어 진다는 것이다.가끔 composite가 오직 한 개의 구성요소만 가졌으면 할 때가 있지만, Composite 클래스만으로 타입 시스템을 통해 이러한 제약을 가할수가 없다. 런타임 점검이 들어가야 한다.ImplementationConsiderations point in implementaion포함 객체에 대한 명확한 참조자자식 구성요소에서 부모를 가리키는 참조자를 관리하면 composite 구조의 관리를 단순화할 수 있다. 부모에 대한 참조자는 구조를 거슬러 올라가거나 요소를 하나 삭제하는 과정을 단순화 시킨다.composite 구조가 중첩될 떄, composite 구조의 모든 자식들이 또 다른 부모가 되는데, 부모의 참조자가 있으면 이런 composite 구조에서는 반복적으로 자신들의 부모에 대한 참조가 가능해진다.Component 인터페이스를 최소화Composite Pattern의 주요 목표중 하나는 사용자가 어떤 Leaf나 Composite 클래스가 존재하는지 모르도록 하는 것이다.위와같은 목표를 달성하기위해, Component 클래스는 Leaf와 Composite에 정의된 모든 공통의 연산을 다 정의하고 있어야 한다. Component 클래스는는 이들 연산에 대한 기본 구현을 제공하고 Leaf와 Composite 클래스가 이를 재정의 한다.그러나 이런 목표가 종종 상속 구조의 중요한 원칙와 충돌할 때가 있다. 즉, Component 클래스에서는 서브클래스인 Leaf가 정의하지 않는 연산도 정의해야 한다. 또한 Lead 클래스에는 의미 없고 Composite 클래스만 의미 있는 연산도 Component 클래스에 정의해야한다.이러한 충돌을 회피하기 위해, 자식들에 접근하는 인터페이스를 예를 들면, Component 클래스의 자식을 처리하는 연산의 기본 구현 사항으로 아무 것도 반환하지 않도록 기본 구현을 만든다. 그리고 Leaf 클래스는 이 구현을 그대로 사용하고, Composite 클래스는 자식을 반환하도록 재정의 한다.자식을 관리하는 연산 선언Composite 클래스가 Add()와 Remove() 연산을 통해 자식들을 관리하기는 하지만, Composite Pattern에서 매우 중요한 관심사는 Composite 클래스 계통 내의 어느 클래스에 이 연산을 선언할 것인가 결정하는 것이다.이 결정은 크게 투명성과 안전성 사이를 선택해야하는 결정이다.투명성자식을 관리하는 인터페이스를 클래스 계통의 최상위 계층에 정의하면, 서브클래스 모두에게 동일한 인터페이스가 유지되어 이를 사용하는 사용자에게 인터페이스의 투명성을 부여할 수 있다.반대로, 사용자가 Leaf 클래스의 인스턴스에게 Add()나 Remove() 연산을 호출하는 의미없는 행동을 하지 않도록 안전성 유지를 위한 비용을 지불해야 한다.안전성Composite 클래스에만 자식을 관리하는 연산을 정의한다면, 이를 사용하는 사용자는 아예 Leaf 클래스의 인스턴스에 이런 연산을 요청하지 않을 것이므로 안전성을 보장받는다.그러나 Leaf 클래스와 Composite 클래스가 서로 다른 인터페이스를 가지게 되므로 사용자는 이를 동일한 대상으로 간주하고 사용할 수 없게 되어 투명성을 잃어버리게 된다.Component가 Component의 리스트 구현 가능여부자식들의 집합을 Component 클래스의 인스턴스 변수로 관리하고자 할 수도 있다. 그러나 최상위 클래스에 자식 포인터를 정의하는 것은, 자식들을 전혀 가지고 있지 않은 모든 Leaf 클래스의 인스턴스들도 이 집합을 관리하기 위한 메모리를 정의해야 한다는 것이므로 바람직하지 않은 방법이다.이러한 방법은 자식의 갯수가 적을때만 효과적인 방법이다.자식사이의 순서자식간의 순서가 의미 있고 문제가 될 떄는, 자식에게 접근, 관리하는 인터페이스를 설계시 자식들의 순서를 관리할 수 있도록 주의를 기울여야 한다.성능 개선의 위한 캐실(Caching)composite 구조 내부를 수시로 순회하고 탐색해야 한다면, Composite 클래스는 자식을 순회하는 정보를 미리 담고 있을 수도 있다.그러나 구성요소가 변경되면 부모가 캐싱하는 정보는 의미가 없어진다. 그러므로 구성요소가 자신의 부모가 누구인지 아는 상황에서만 이 구현이 의미가 있다.캐싱을 이용하려면, 현재 저장된 캐시의 내용이 유효한지 아닌지 확인하는 연산이 필요하다.누가 구성요소를 삭제하는 책임을 가질지에 대한 여부가비지 컬렉션의 기능을 제공하지 않는 언어에서는 자식이 없어질 떄 Composite 클래스가 보통 그 삭제의 책임을 가진다. 그러나 Leaf 객체가 변경될 수 없는 객체이거나 공유될 수 있는 객체라면 예외적으로 삭제할 수 없다.구성요소를 저장하기 위해 가장 적당한 데이터 구조Composite는 매우 다양한 데이터 구조를 이용하여 자식들을 저장할 수 있는데, Linked List, Arrary, Tree, Hash Table 모두가 사용될 수 있다. 어떤 데이터 구조를 사용할 것인가는 상황에 맞춰 효율적인 데이터 구조를 선택하도록 한다.Implement Example/** * @brief Component - Window * @details 집합관계에서 포함되는 인터페이스를 정의 */class Window { public: virtual ~Window() = default; // 구성요소들의 공통 인터페이스 정의 virtual const std::string&amp;amp; getName() const { return m_name; } virtual void printElementList() = 0; // 자식요소 관리를 위한 인터페이스 정의 virtual void add(Window* window) {}; virtual void remove() {}; protected: Window(const std::string&amp;amp; name) : m_name(name) {}; private: const std::string m_name;};/*** @brief Composite - MediaWindow* @details 하위 구성요소를 가지지면서 관련 인터페이스를 구현 및 정의*/class MediaWindow : public Window {public: MediaWindow(const std::string&amp;amp; name) : Window(name) {}; virtual ~MediaWindow() { for(auto&amp;amp; e : m_elements){ delete e; } } // 구성요소들의 공통 인터페이스 구현 void printElementList() override { std::cout &amp;lt;&amp;lt; this-&amp;gt;getName() &amp;lt;&amp;lt; std::endl; for(const auto&amp;amp; e : m_elements){ e-&amp;gt;printElementList(); } } // 자식요소 관리를 위한 인터페이스 구현 void add(Window* window) override { m_elements.push_back(window); } void remove() override { m_elements.pop_back(); }private: std::vector&amp;lt;Window*&amp;gt; m_elements;};/*** @brief Composite - ImageWindow* @details 하위 구성요소를 가지지면서 관련 인터페이스를 구현 및 정의*/class ImageWindow : public Window {public: ImageWindow(const std::string&amp;amp; name) : Window(name) {}; virtual ~ImageWindow() { for(auto&amp;amp; e : m_elements){ delete e; } } // 구성요소들의 공통 인터페이스 구현 void printElementList() override { std::cout &amp;lt;&amp;lt; this-&amp;gt;getName() &amp;lt;&amp;lt; std::endl; for(const auto&amp;amp; e : m_elements){ e-&amp;gt;printElementList(); } } // 자식요소 관리를 위한 인터페이스 구현 void add(Window* window) override { m_elements.push_back(window); } void remove() override { m_elements.pop_back(); }private: std::vector&amp;lt;Window*&amp;gt; m_elements;};/*** @brief Leaf - TitleBar* @details 자식이 없으며, Component의 인터페이스를 자신에 맞게 구현*/class TitleBar : public Window{public: TitleBar(const std::string&amp;amp; name) : Window(name) {} virtual ~TitleBar() {} // 구성요소들의 공통 인터페이스 구현 void printElementList() override { std::cout &amp;lt;&amp;lt; getName() &amp;lt;&amp;lt; std::endl; }};/*** @brief Leaf - MenuBar* @details 자식이 없으며, Component의 인터페이스를 자신에 맞게 구현*/class MenuBar : public Window{public: MenuBar(const std::string&amp;amp; name) : Window(name) {} virtual ~MenuBar() {} // 구성요소들의 공통 인터페이스 구현 void printElementList() override { std::cout &amp;lt;&amp;lt; getName() &amp;lt;&amp;lt; std::endl; }};/*** @brief Leaf - VideoPlayer* @details 자식이 없으며, Component의 인터페이스를 자신에 맞게 구현*/class VideoPlayer : public MediaWindow{public: VideoPlayer(const std::string&amp;amp; name) : MediaWindow(name) {} virtual ~VideoPlayer() {} // 구성요소들의 공통 인터페이스 구현 void printElementList() override { std::cout &amp;lt;&amp;lt; getName() &amp;lt;&amp;lt; std::endl; }};... // Composite 객체 생성 MediaWindow* mainWindow = new MediaWindow(&quot;MyMediaWindow&quot;); VideoPlayer* videoPlayer = new VideoPlayer(&quot;MyVideoWindow&quot;); ImageWindow* imageWindow = new ImageWindow(&quot;MyImageWindow&quot;); // Leaf 객체 생성 TitleBar* mainTitleBar = new TitleBar(&quot;MyMediaWindowTitleBar&quot;); TitleBar* videoTitleBar = new TitleBar(&quot;MyVideoWindowTitleBar&quot;); TitleBar* imageTitleBar = new TitleBar(&quot;MyImageWindowTitleBar&quot;); // Leaf객체를 Composite의 자식으로 구성 mainWindow-&amp;gt;add(mainTitleBar); mainWindow-&amp;gt;add(new MenuBar(&quot;MyMediaWindowMenuBar&quot;)); videoPlayer-&amp;gt;add(new MenuBar(&quot;MyVideoWindowMenubar&quot;)); videoPlayer-&amp;gt;add(videoTitleBar); imageWindow-&amp;gt;add(imageTitleBar); // Composite을 Composite의 자식으로 구성 mainWindow-&amp;gt;add(videoPlayer); mainWindow-&amp;gt;add(imageWindow); mainWindow-&amp;gt;printElementList(); mainWindow-&amp;gt;remove(); mainWindow-&amp;gt;printElementList();...Related Pattern구성요소-부모 간의 연결은 Chain of Reponsibility Pattern에서 많이 사용되는 예 이다.Decorator Pattern은 자주 Composite Pattern과 함께 사용된다. 이 두 패턴이 함께 사용될 때는 둘 다 동일한 하나의 부모 클래스를 상속 받게 된다. 따라서 Decorator는 Add(), Remove(), GetChild() 와 같은 연산을 통해 Component의 인터페이스를 지원해야 한다.Flyweight Pattern 으로 구성요소의 공유 방법을 알 수 있다. 단 공유되는 구성요소의 부모는 참조할 수 없다.Iterator Pattern을 이용하면, 구성요소를 순회하는 방법을 얻을 수 있다.Visitor Pattern을 이용하면, 이 패턴을 사용하지 않을 때, Composite와 Leaf 클래스에 걸쳐 분산될 수 있는 행동을 국소화시킬 수 있다.참고. Design Patterns : Elements of Reusable Object-Oriented Software - Erich Gamma" }, { "title": "Design Patterns - Bridge", "url": "/posts/design_patterns-bridge/", "categories": "Design Patterns", "tags": "Design Patterns, Structural Patterns, Bridge, C++", "date": "2020-04-15 20:20:00 +0900", "snippet": "Structural Patterns - BridgeIntent구현에서 추상을 분리하여, 이들이 독립적으로 다야엉을 가질 수 있도록 한다.핸들(Hanle), 구현부(Body) 라고도 불린다.Utility 추상적 새념과 이에 대한 구현 사잉의 지속적인 종속 관계를 피하고 싶을 때 런타일에 구현 방법을 선택하거나 구현 내용을 변경하고 싶을 떄 추상적 개념과 구현 모두가 독립적으로 서브클래싱을 통해 확장되어야 할 떄 추상적 개념에 대한 구현 내용을 변경하는 것이 다른 관련 프로그램에 아무런 영향을 주지 않을 때 클래스 계통에서 클래스의 수가 급증하는 것을 방지하고자 할 떄 여러 객체들에 걸쳐 구현을 공유하고자 하며, 이러한 사실을 사용자에게 공개하고 싶지 않을 때 (C++에서 해당) 사용자들은 사용자에게 구현을 완벽하게 은닉하고자 할 때StructureBasic StructureStructure ExampleElements Abstraction window에 해당 추상적 개념에 대한 인터페이스를 제공 객체 구현자(Implmentor)에 대한 참조자를 관리 RefinedAbstraction IconWindw에 해당 추상적 개념에 정의된 인터페이스를 확장 Implementor WindowImp에 해당 추현 클래스에 대한 인터페이스를 제공 실질적인 구현을 제공한 서브클래스들의 공통적인 연산의 시그네처만을 정의 일반적으로 Implementor 인터페이스는 기본적인 구현 연산을 수행하고, Abstraction은 더 추상화된 서비스 관점의 인터페이스를 제공 ConcreteImplementor XWindowImp, PMWindowImp에 해당 Implementor 인터페이스를 구현하여 실질적인 구현 내용 제공 Abstraction 클래스가 사용자 요청을 Implementor 객체에게 전달한다.Feature인터페이스과 구현을 분리구현이 인터페이스에 얽매이지 않게 되면서, 추상적 개념에 대한 어떤 방식의 구현을 선택할 것인지 런타임에 결정 가능해 진다. 이는 런타임에 어떤 객체가 자신의 구현을 수시로 변경할 수 있음을 의미한다.Abstraction과 Implementor의 분리는 컴파일 타임 의존성을 제거할 수 있다. 구현을 변경하더라도 추상적 개념에 대한 클래스를 다시 컴파일할 필요가 없으며, 추상적 개념 클래스과 관련된 다른 코드 역시 다시 컴파일할 필요가 없다.시스템 구조의 계층화(Layering)이 가능해진다. 이러한 시스템의 상위 수준 영역에서는 Abstraction과 Implementor만 알면 된다.확장성 제고Abstraction과 Implementor를 독립적으로 확장 가능하다.구현 세부사항 은닉상세한 구현 내용응 사용자에게서 은닉 시킬수 있다.ImplementationConsiderations point in implementaionImplementor 하나만 둔다구현방법이 오직 하나뿐 일때 Implementor를 추상 클래스로 정의하는 것은 불필요하다. 이는 개념의 추상화와 이를 구현하는 구현 사이에 일대일 관계가 성립되므로써, Bridge Pattern의 의미를 퇴색시킨다.그러나, 그럼에도 추상적 개념과 구현부를 분리하는 것은 여전히 의미가 있는데, 이는 사용자를 클래스 구현의 변경에서 독립시킬수 있기 때문이다. 즉, 클래스의 구현이 변경되었다 하더라도 사용자를 다시 컴파일할 필요는 없고, 단지 링크 과정만 재수행 하면 된다.C++에서는 굳이 이를 두 개의 파일로 구분할 필요 없이 Implementor 클래스의 인터페이스를 사용자에게 보이지 않도록 private영역에 정의하면 된다. 이로써 사용자는 private에 정의된 인터페이스 구현에 접근할 수 없게 된다.정확한 Implementor 객체를 생성Implemetor 클래스가 여러개일때, 어떤 Implementor 클래스를 인스턴스를 언제, 어떻게, 몇개나 생성할지 결정해야 하는데, 이에 대해 아래와 같은 방법이 있다. Abstraction 클래스가 모든 ConcreteImplementor를 알고 있다면, 이들중 하나를 자신의 생성자 안에서 생성한다. 초기에는 기본 구현을 선택한 후, 필요에 따라 다른 것을 선택하도록 한다. 결정을 다른 객체에게 위임한다.Implementor를 공유Coplien은 C++로 구현된 Bridge Pattern(Handle/Body)에서 여러 객체들이 동일한 구현을 공유할수 있는 방법을 제시한다.참조 카운트를 이용하여, 이 카운트를 증가시키고 감소시키면서 참조 횟수가 0이 되면 객체를 자동으로 지우도록 한다.Handle&amp;amp; Handle::operator= (const Handle&amp;amp; rhs) { rhs._body-&amp;gt;Ref(); _body-&amp;gt;UnRef(); if(_body-&amp;gt;RefCount() == 0) delete _body; _body = rhs._body; return *this;}다중상속을 이용C++에서는 다중상속을 이용하여 인터페이스와 구현을 합칠수 있다.그러나 이런방법은 코드의 상속에 기반을 둔 것이디 때문에, 인터페이스에 대한 구현을 영구히 종속시켜 버린다. 따라서 이러한 다중상속을 이용한 구현은, Bridge Pattern의 의미를 퇴색 시킨다.Implement Example/*** @brief Abstraction - Window* @details 추상적 개념의 인터페이스를 제공*/class Window(){public: virtual ~Window() {} // Window가 처리할 요청 virtual void getContents() = 0; // 구현 클래스를 이용하여 처리할 요청 virtual void displayWindow() { Redner* render = getRenderImpl(); render-&amp;gt;renderWindow(); }protected: // Implementor 객체 생성 및 관리 Render* getRenderImpl() { if(!m_impl){#ifdef OS_WINDOW m_impl = dynamic_cast&amp;lt;Render*&amp;gt;(new WinRender());#else m_impl = dynamic_cast&amp;lt;Render*&amp;gt;(new OSXRender()); } return m_impl; }private: Render* m_impl == nullptr;};/*** @brief RefinedAbstraction - ImageWindow* @details 추상적 개념의 인터페이스를 확장* 다른 종류의 window 정의하여 추가적인 서비스를 제공*/class ImageWindow() : public Window {public: void getContents() override { std::cout &amp;lt;&amp;lt; &quot;get Image File&quot; &amp;lt;&amp;lt; std::endl; }};/*** @brief RefinedAbstraction - VideoWindow* @details 추상적 개념의 인터페이스를 확장* 다른 종류의 window 정의하여 추가적인 서비스를 제공*/class VideoWindow() : public Window {public: void getContents() override { std::cout &amp;lt;&amp;lt; &quot;get Video File&quot; &amp;lt;&amp;lt; std::endl; }};/*** @brief Implementor - Render* @details Abstraction의 세부 행위의 인터페이스 정의*/class Render() {public: virtual ~Render() {} virtual void renderWindow() = 0;};/*** @brief ConcreteImplementor - WinRender* @details Implementor를 상속받아 Abstraction의 세부 행위의 인터페이스를 구현*/class WinRender() : public Render {public: void renderWindow() override { std::cout &amp;lt;&amp;lt; &quot;[WINDOW] window rendering &quot; &amp;lt;&amp;lt; std::endl; }};/*** @brief ConcreteImplementor - OSXRender* @details Implementor를 상속받아 Abstraction의 세부 행위의 인터페이스를 구현*/class OSXRender() : public Render {public: void renderWindow() override { std::cout &amp;lt;&amp;lt; &quot;[OSX] window rendering &quot; &amp;lt;&amp;lt; std::endl; }};...#define OS_WINDOW 1 //RefinedAbstraction인 ImageWindow 객체 생성 ImageWindow imgWindow; VideoWindow videoWindow; // Abstraction에서 확장된 각자 자신만의 서비스 구현체 실행 imgWindow.getContents(); videoWindow.getContents(); // 상황에 맞게 선택된 Implementor 실행 imgWindow.displayWindow(); videoWindow.displayWindow();...Related PatternAbstract Factory Pattern은 특정 Bridge를 생성하고 복합할 수 있도록 해준다.Adapter Pattern은 서로 관련이 없는 클래스들이 함께 동작하게 만드는 쪽에 특화시켜 만들어진 패턴이다. 이 패턴은 대게 각 클래스의 설계가 끝난 이후에 적용된다.Bridge Pattern은 설계 단계 초기에 투입되어 추상화 및 구현이 독립적으로 다양화되도록 만드는데 쓰인다.참고. Design Patterns : Elements of Reusable Object-Oriented Software - Erich Gamma" }, { "title": "Design Patterns - Adapter", "url": "/posts/design_patterns-adapter/", "categories": "Design Patterns", "tags": "Design Patterns, Structural Patterns, Adapter, C++", "date": "2020-04-15 06:08:00 +0900", "snippet": "Structural Patterns - AdapterIntent클래스의 인터페이스를 사용자가 기대하는 인터페이스 형태로 정응(변환)시킨다. 서로 일치하지 않는 인터페이스를 가지는 클래스들을 함께 동작시킨다.Utility 기존 클래스를 사용하고 싶은데 인터페이스가 맞지 않을 때 이미 만든 것을 재사용하고자 하나 이 재사용 가능한 라이브러리를 수정할 수 없을 때 [객체 적응자(Object Adapter)만 해당됨] 이미 존재하는 여러개의 서브클래스를 사용해야 하는데, 이 서브클래스들의 상속을 통해서 이들의 인터페이스를 다 수정하는 것에 비용이 많이들 때StructureBasic Structure클래스 적응자(Class Adapter) 활용객체 적응자(Object Adapter) 활용Structure ExampleElements Target Shape에 해당 사용자가 사용할 응용 분야에 종속적인 인터페이스를 정의하는 클래스 Client DrawingEditor에 해당 Target 인터페이스를 만족하는 객체와 동작할 대상 Adaptee TextView에 해당 인터페이스의 적응이 필요한 기존 인터페이스를 정의하는 클래스 Adapter TextShape에 해당 Target 인터페이스에 Adaptee의 인터페이스를 적응시키는 클래스 사용자는 Adapter에 해당하는 클래스의 인스턴스에게 연산을 호출하고, Adapter는 해당 요청을 수행하기 위해 적응대상자의 연산을 호출한다.Feature대체가능(Pluggable) 적응자다른 인터페이스를 원하는 사용자가 Adapter 클래스를 통해 연결하거나, 인터페이스의 개조를 통해 기존에 존재하는 시스템과 함께 연동할 수 있도록 하는 것을 대체가능 적응자(Pluggable Adapter) 라고 한다.양방향 Adapter를 통한 투명성 제공Adapter의 잠재적인 문제는 Adapter가 모든 사용자에게 투명하지 않다는 것이다. 적응된 객체는 더는 Adaptee 인터페이스를 만족하지 않는다. Target의 인터페이스를 만족하기 때문이다. 이렇게 되면 Target이 필요한 사용자는 적응된 클래스를 사용할 수 있지만, Adaptee 객체를 통해 Target을 사용해야 하는 사용자라면 적응된 객체를 사용할 수 없게 된다. 양방향 적을이 되려면 이런 상황에서 모두 지원해야 한다.클래스 적응자(Class Apdater)와 객체 적응자(Object Apdater)클래스 적응자(Class Apdater)Adapter는 명시적으로 Adaptee를 상속박고 있을뿐, Adaptee의 서브클래스들을 상속받는 것이 아니므로, Adaptee의 서브클래스에 정의된 기능들을 사용할 수 없다.Adapter 클래스는 Adaptee 쿨래스를 상속하기 때문에 Adaptee에 정의된 행동을 재정의를 할 수 있다.헌개의 객체(Adapter)만 사용하며, Adaptee로 가기 위한 추가적인 포인터 간접화는 필요로하지 않는다.객체 적응자(Object Apdater)Adapter 객체가 포함하는 Adaptee에 대한 참조자는 Adaptee의 인스턴스를 관리할 수도 있고, Adaptee 클래스를 상속받는 다른 서브클래스들의 인스턴스도 관리할 수 있기 때문에, 하나의 Adapter 클래스로 모든 Adaptee 클래스와 이를 상속받는 서브클래스 모두를 이용가능하다.Adaptee 클래스의 행동을 재정의하기가 매우 어렵다.ImplementationImplementation Method클래스 적응자 구현C++에서 Adapter 클래스는 Target 클래스에서 public으로 상속받고, Adaptee는 private로 상속받아야 한다. 즉, Target에 정의된 인터페이스는 Adapter에서도 public으로 공개되지만, Adaptee는 내부 구현에 필요한 것이므로, Adaptee가 사용자에게 알려질 필요가 없다.위와같이 구현하게 되면 Adapter는 Target의 서브클래스이기는 하지만, Adaptee의 서브클래스는 아니게 된다.Implement Example클래스 적응자(Class Adapter) Example/*** @brief Taget - Shape* @details 재정의할 interface를 가진 class*/class Shape {public: Shape(); virtual void boundingBox(Point&amp;amp; bottomleft, Point&amp;amp; topRight) const; virtual Manipulator* createManipulator() const;};/*** @brief Adaptee - TextView* @details 사용할 함수를 가진 class*/class TextView {public: TextView(); void getOrigin(Coord&amp;amp; x, Coord&amp;amp; y) const; void getExten(Coord&amp;amp; width, Coord&amp;amp; height) const; virtual bool isEmpty() const;};/*** @brief Adapter - TextShape*/class TextShape : public Shape, private TextView {public: TextShape(); // Shape 클래스의 인터페이스를 // TextView 클래스의 멤버함수를 이용하여 기능 정의 void boundingBox(Point&amp;amp; bottomleft, Point&amp;amp; topRight) const override { Coord bottom, left, width, height; getOrigin(bottom, left); getExten(width, height); bottomleft = Point(bottom, left); topRight = Point(bottom + height, left + width); } // Adapter 구현에 공통적인 요청을 직접 전달 bool isEmpty() const override { return TextView::IsEmpty(); } // 완전히 새로운 구현을 통해 새로운 서비스의 추가 Manipulator* createManipulator() const override { return new TextManipulator(this); }};객체 적응자(Object Adapter) Example/*** @brief Taget - Shape* @details 재정의할 interface를 가진 class*/class Shape {public: Shape(); virtual void boundingBox(Point&amp;amp; bottomleft, Point&amp;amp; topRight) const; virtual Manipulator* createManipulator() const;};/*** @brief Adaptee - TextView* @details 사용할 함수를 가진 class*/class TextView {public: TextView() void getOrigin(Coord&amp;amp; x, Coord&amp;amp; y) const; void getExten(Coord&amp;amp; width, Coord&amp;amp; height) const; virtual bool isEmpty() const;};/*** @brief Adapter - TextShape*/class TextShape : public Shape {public: // 다른 클래스의 객체에 대한 포인터를 관리하기 위해, // TextView 인스턴스에 대한 포인터를 초기화 할수 있는 생성자 구현 TextShape(TextView* t) { m_textView = t; } // 객체를 통해 정의된 연산을 호출 void boundingBox(Point&amp;amp; bottomleft, Point&amp;amp; topRight) const override { Coord bottom, left, width, height; // 객체 참조자를 통한 함수 호출 m_textView-&amp;gt;getOrigin(bottom, left); m_textView-&amp;gt;getExten(width, height); bottomleft = Point(bottom, left); topRight = Point(bottom + height, left + width); } // 객체를 통해 정의된 연산을 호출 bool isEmpty() const { return m_textView-&amp;gt;isEmpty(); } // 새롭게 구현하는 부분이기 때문에 클래스 적응자와 차이 없음 Manipulator* createManipulator() const override { return new TextManipulator(this); }private: // TextView에 대한 참조자 TexView* m_textView = nullptr;};Related PatternBridge Pattern은 object Adapter와 클래스 구조가 유사하나 그 사용 목적이 다르다.Bridge Pattern은 구현과 이 구현이 만족할 추상 개념을 분리하여 서로에게 영향을 주지 않고 각각 확장할 수 있도록 하려는 것이고, Adapter Pattern은 존재하는 객체의 인터페이스를 변경하려는 것이다.Decorator Pattern은 다른 인터페이스의 변결 없이도 객체에 새로운 행동을 추가할 수 있도록 한다.Proxy Pattern 다른 객체에 대한 대표자 또는 대리인의 역할을 수행하지만 인터페이스를 변경하는 책임은 없다.참고. Design Patterns : Elements of Reusable Object-Oriented Software - Erich Gamma" }, { "title": "Design Patterns - Singleton", "url": "/posts/design_patterns-singleton/", "categories": "Design Patterns", "tags": "Design Patterns, Creational Patterns, Singleton, C++", "date": "2020-04-14 06:44:00 +0900", "snippet": "Creational Patterns - SingletonIntent오직 한개의 클래스 인스턴스만을 갖도록 보장하고, 이에 대한 전역적인 접근점을 제공한다.Utility 클래스의 인스턴스가 오직 하나여야 함을 보장하고, 잘 정의된 접근점으로 모든 사용자가 접근할 수 있도록 할 때 유일한 인스턴스가 서브클래싱으로 확장되어야 하며, 사용자는 코드의 수정없이 확장된 서브클래스의 인스턴스를 사용할 수 있어야 할 때StructureBasic StructureElements Singleton Instance() 연산을 정의하여, 유일한 인스턴스로 접근할 수 있도록 한다. 유일한 인스턴스를 생성하는 책임을 맡는다. 사용자는 Singleton 클래스에 정의된 Instence() 연산을 통해서 유일하게 생성된 Singleton 인스턴스에 접근할 수 있다.Feature유일하게 존재하는 인스턴스로의 접근을 통제한다Singleton 클래스 자체가 인스턴스를 캡슐화하기 때문에, 이 클래스에서 사용자가 언제, 어떻게 이 인스턴스에 접근할 수 있는지를 제어 가능하다.이름 공간(name space)을 좁힌다전역 변수를 사용하여 이름 공간을 망치는 일이 없기 때문에, 전역 변수를 정의하여 발생하는 디버깅의 어려움 등의 문제를 없앨수 있다.연산 및 표현의 정제를 허용한다Singleton 클래스는 상속될 수 있기 때문에, 이 상속된 서브클래스를 통해서 새로운 인스턴스를 만들수 있다.런타임에 필요한 클래스의 인스턴스를 사용하여 응용프로그램을 구성하는 것도 가능하다.인스턴스의 갯수를 변경하기가 자유롭다Singleton 클래스의 인스턴스에 접근할 수 있는 허용 범위를 결정하는 연산만 추가하면 되기 때문에, 인스턴스 생성 갯수에 대한 변경이 유연하다.클래스 연산을 사용하는 것보다 훨씬 유연한 방법이다C++에서 Singleton Pattern과 동일한 기능을 발휘하는 방법이 static member function을 활용하여, 클래스 연산을 통해 구현하는 방법이 있다. 그러나 static member function는 가상 함수가 아니므로, 서브클래스들이 이 연산을 오버라이드 할 수 없다.ImplementationImplementation Method인스턴스가 유일해야 함을 보장한다Singleton Pattern은 클래스의 인스턴스가 오로지 하나임을 보장해야 한다.C++에서 Singleton Pattern을 구현하기 위해선, static member function을 활용한다.Singleton 클래스에 Instance() 연산을 static member function으로 정의하여 클래스 연산을 정의한다.Singleton 클래스는 또한 static member variable로 m_instance를 정의하여 실제로 생성될 유일한 인스턴스에 대한 참조자를 가지도록 한다.class Singleton {public: static Singleton* Instance() { if(m_instance == 0){ // 처음 접근할시, 새로운 인스턴스 생성 m_instance = new Singleton(); } return m_instance; }protected: // 생성자를 protected로 선언하여 // Instance() 이외의 접근을 막음 Singleton();private: static Singleton* m_instance;};Singleton* Singleton::m_instance = 0;C++를 사용한 구현에서 주의해야 할 것은, Singleton을 전역 변수나 정적 객체로 정의하고 이를 자동 초기화하는 것만으로는 충분하지 않다는 것이다. 그 이유는 아래와 같다. 정적 객체의 유일한 인스턴스만 선언되리라는 보장을 할 수 없다. 정적 객체에서 인스턴스를 얻는 선언문이 프로그램 다른 부분에 존재하더라도 이를 확인하고 방지할 방법이 없다. 정적 초기화 시점에 모든 Singleton을 인스턴스화하기 위해 필요한 정보가 없을 수도 있다. Singleton은 프로그램 실행 중간에 계산으로 자신의 값이 결정될 수 있다. 그러나 정적으로 선언된 객체라면 그 내부에 정의된 변수의 값을 처음에만 정의할 수 있지, 나중에 다시 변결할 수 없다. C++에서는 전역 객체에 대한 생성자를 언제 호출하는지에 대한 명확한 순서를 정의하지 않는다.또한 전역 객체나 정적 객체의 또 다른 문제점은 모든 Singleton의 사용 여부와 상관없이 일단 모두 생성된다는 점이다. 그러나 static member function 기법을 이용하면 실제 호출이 일어나는 시점에서 객체를 생성하는 것이 가능하다.Singleton 클래스를 서브클래싱 한다핵심은 Singleton의 인스턴스를 참조하는 변수가 이들 서브클래스의 인스턴스로 초기화 되어야 한다는 것이다.가장 쉬운 방법은 Singleton 클래스의 Instance() 연산을 사용할 때 어떤 Singleton을 사용할지 결정하는 것으로, 수퍼클래스의 Singleton을 사용할지, 서브클래스의 Singleton을 사용할지를 결정한다.두번째 방법은 Instance() 연산의 구현을 슈퍼클래스가 아닌 서브클래스에서 하는 것이다. 이는 Singleton의 구현 클래스를 연결 시점에 결정할 수 있게 대준다.좀더 유연한 방법은 Singleton에 대한 레지스트리를 사용하는 것이다. Instance() 연산에 가능한 Singleton 클래스 클래스 집합을 정의하는 대신에 Singleton 클래스는 이 Singleton 인스턴스를 레지스트리에 이름을 가지는 인스턴스로 등록한다.class Singleton {public: static void Register(const char* name, Singlton*); static Singlton* Instance() { if(m_instance == 0){ // 사용자 또는 환경변수는 시작 시에 이것을 지원한다 const char* singletonName = getenv(&quot;SINGLETON&quot;); // 해당하는 Singleton이 없다면 0을 반환 m_instance = Lookup(singletonName); } return m_instance; }protected: static Singlton* Lookup(const char* name);private: static Singlton* m_instance; static std::List&amp;lt;NameSingletonPair&amp;gt;* m_registry;};Singleton 클래스가 자신을 어디에 등록할지에 대한 방법은 여러 방법이 있다.그중 한가지 방법은 생성자 이다. 예를 들어, MySingleton이라는 서브클래스는 다음과 같이 구현이 가능하다.MySingleton::MySingleton() { ... Singleton::Register(&quot;MySingleton&quot;, this); ...}생성자는 누군가가 자신을 생성하지 않는 한 호출되지 않는 연산이기 때문에, 이 문제를 해결하기 위해 MySingleton 인스턴스를 정적 객체로 정의한다.Implementation Example/*** @brief SuperClass Singleton - Display*/class Singleton {public: virtual ~Singleton() {} Singleton(const Singleton&amp;amp;) = delete; Singleton&amp;amp; operator= (const Singleton) = delete; static Singleton* getInstance() { if(m_instance == nullptr){ m_instance = new Singleton(); } return m_instance; } void printInfo() {} protected: Singleton();private: static Singleton* m_instance;};Singleton* Singleton::m_instance = 0;... Singleton::getInstance()-&amp;gt;printInfo();...Related PatternAbstract Factory Pattern, Builder Pattern, Prototype Pattern등 많은 패턴들이 Singleton Pattern으로 구현될 수 이다.참고. Design Patterns : Elements of Reusable Object-Oriented Software - Erich Gamma" }, { "title": "Design Patterns - Prototype", "url": "/posts/design_patterns-prototype/", "categories": "Design Patterns", "tags": "Design Patterns, Creational Patterns, Prototype, C++", "date": "2020-04-12 00:04:00 +0900", "snippet": "Creational Patterns - PrototypeIntent원형이 되는 인스턴스를 사용하여 생성할 객체의 종류를 명시하고, 이렇게 만든 견본을 복사해서 새로운 객체를 생성한다.Utility 인트턴스화할 클래스를 런타임에 지정할(동적 로딩) 떄 제품 클래스 계통과 병렬적으로 만드는 Factory Class 피하고 싶을때 클래스의 인스턴스들이 서로 다른 상태 조합을 사용하고 있어, 그중 하나를 선택 할 떄StructureBasic StructureStructure ExampleElements Prototype Graphic에 해당 자신을 복제하는 데 필요한 인터페이스를 정의 ConcretePrototype Staff, WholeNote, HalfNote에 해당 자신을 복제하는 연산(인터페이스)을 구현 Client GraphicTool에 해당 Prototype에 자기 자신의 복제를 요청하여 새로운 객체를 생성 사용자는 Prototype 클래스에 스스로를 복제하도록 요청해야 한다.FeaturePrototype Pattern을 사용할 떄 가장 신경써야 하는 점은, Prototype의 서브클래스가 Clone() 연산을 구현해야 한다는 점이다. 예를들어, 패턴을 적용할 클래스가 이미 만들어진 경우 Clone() 연산을 추가하기가 어려워 진다. 또한 복사를 지원하지 않거나 환형 참조(Circular Reference) 가 없는 객체를 포함한다면 Clone() 연산의 구현은 매우 어려워 지기 때문에 Prototype Pattern 의 적용이 어려워 진다.런타임에 새로운 제품을 추가하고 삭제할수 있다Prototype Pattern을 이용하면 사용자에게 Prototype으로 생산되는 인스턴스를 등록하는 것만으로도 시스템에 새로운 제품 클래스를 추가할 수 있게 된다.런타임에 새로운 Prototype을 넣고 빼기가 쉽다는 점에서 다른 생성패턴에 비해 유연성을 지니고 있다.값들을 다양화 함으로써 새로운 객체를 명세한다Prototype Pattern은 사용자와 동작할 Prototype에 해당하는 기존 클래스의 인스턴스를 만들어서 그 인스턴스를 등록하면, 사용자는 이 Prototype에 정의된 행동이 수행되어 마치 새로운 행동이 정의된 듯한 결과를 얻게 된다.Prototype을 복제하는 것은 클래스의 인스턴스를 만드는 것과 동일하기 때문에 Prototype Pattern은 시스템에 필요한 객체를 생성하기 위해 정의할 클래스의 수를 대폭 줄여주는 효과가 있다.구조를 다양화 함으로써 새로운 객체를 명세할 수 있다세부 구성요소를 Prototype으로 만들어, 이것을 현재 사용 가능한 구성요소 관리자에 등록한다. 이후, 세부 구성요소를 가지는 복합객체에서 Clone() 연산을 구현함으로써 다른 구조를 가지는 객체의 기본 골격을 만든다.이렇게 함으로써 복잡한 사용자 정의 구조를 사용자가 인스턴스화 하여 그 상황에 맞는 세부 구성요소를 이용할 수 있도록 한다.서브클래스의 수를 줄인다Factory Method Pattern를 보면 Creator 클래스의 계통이 제품 관련 클래스의 계통과 병렬로 복합되어 진다.Prototype Pattern에서는 Factory Method에게 새로운 객체를 만들어 달라고 요청하는 것이 아니라 Prototype을 복제하는 것이므로, Creator 클래스에 따른 새로운 상속 계층이 필요없다.동적으로 클래스에 따라 응용프로그램을 설정할 수 있다몇몇 런타임 환경에서는 동적으로 클래스들을 응용프로그램으로 등록할 수 있도록 해준다.동적으로 로드된 클래스의 인스턴스를 생성하고 싶은 응용프로그램은 정적으로 그 클래스의 생성자를 참조할 수 없다. 그 대신 런타임 환경이 그 클래스의 인스턴스를 자동으로 생성하고 Prototype Manager 에게 등록한다. 이후 응용프로그램이 이 Prototype Manager에게서 필요한 클래스의 인스턴스를 얻게된다.ImplementationPrototype Manager를 사용한다사용자는 Prototype 자체를 다루지 않고, Prototype Manager에서 Prototype을 검색하고 그것을 복제하여 사용한다.Prototype Manager는 어떤 키에 부합되는 Prototype을 저장하고, 찾아서 반환하며, 삭제하는 기능을 담당하는 저장소이다.Clone() 연산을 구현한다구조가 복잡한 Prototype을 복제할 때는 대개 깊은 복사(Deep Copy) 가 필요하다. 사본과 원본이 독립적일 수 있어야 하기 때문이다. 그러므로 Clone() 연산을 구현 할 때는 무엇을 복사하고, 무엇을 공유하도록 할 것인지 결정해야 한다.Clone() 연산을 초기화 한다어떤 사용자는 내부 상태를 자신이 선택한 값으로 초기화하기를 바랄것이다. 일반적으로 이런 값은 Clone() 연산에 넘길 수 없다. 왜냐하면 Prototype 클래스마다 필요한 매개변수와 개수가 천차만별이기 때문이다.Prototype 클래스의 상태를 설정하기 위한 연산이나, 상태를 초기화 해주는 연산을 제공해 주어야 한다. 이러한 연산은 초기화 매개변수를 인자로받아 그 복제본의 내부 상태를 설정한다. 이때 깊은 복사를 수행하는 Clone() 연산이 있기떄문에, 사본을 재초기화 하기 전에 사본을 삭제해야 할 수도 있다.Implement Example/*** @brief Prototype - MousePointer*/class MousePointer {public: virtual ~MousePointer() {} // Prototype의 설정, 복제를 위한 인터페이스 선언 virtual void initailize(const Point&amp;amp; point) = 0; virtual MousePointer* clone() const = 0;private: Point m_point;};/*** @brief Prototype - Button*/class Button {public: virtual ~Button() {} // Prototype의 설정, 복제를 위한 인터페이스 선언 virtual void initailize(int id) = 0; virtual Button* clone() const = 0;private: int m_id;};/*** @brief ConcretePrototype - MousePointer*/class WINMousePointer : public MousePointer {public: // 깊은 복사를 위한 복사생성자 정의 WINMousePointer(const WINMousePointer&amp;amp; rhs){ m_point.x = rhs.m_point.x; m_point.y = rhs.m_point.y; } // Prototype의 설정 인터페이스 정의 void initailize(const Point&amp;amp; point) override { m_point.x = point.x; m_point.y = point.y; } // Prototype의 복제 인터페이스 정의 MousePointer* clone() const override { return new WINMousePointer(*this); } };/*** @brief ConcretePrototype - MousePointer*/class OSXMousePointer : public MousePointer {public: // 깊은 복사를 위한 복사생성자 정의 OSXMousePointer(const OSXMousePointer&amp;amp; rhs){ m_point.x = rhs.m_point.x; m_point.y = rhs.m_point.y; } // Prototype의 설정 인터페이스 정의 void initailize(const Point&amp;amp; point) override { m_point.x = point.x; m_point.y = point.y; } // Prototype의 복제 인터페이스 정의 MousePointer* clone() const override { return new OSXMousePointer(*this); }};/*** @brief ConcretePrototype - Button*/class WINButton : public Button {public: // 깊은 복사를 위한 복사생성자 정의 WINButton(const OSXButton&amp;amp; rhs){ m_id = rhs.m_id; } // Prototype의 설정, 복제 인터페이스 정의 void initailize(int id) override { m_id = id; } Button* clone() const override { return new WINButton(*this); }};/*** @brief ConcretePrototype - Button*/class OSXButton: public Button {public: // 깊은 복사를 위한 복사생성자 정의 OSXButton(const OSXButton&amp;amp; rhs){ m_id = rhs.m_id; } // Prototype의 설정, 복제 인터페이스 정의 void initailize(int id) override { m_id = id; } Button* clone() const override { return new OSXButton(*this); }};/*** @brief Prototype Factory for Client*/class UIPrototypeFactory {public: UIPrototypeFactory(OS_TYPE type){ switch(type){ case OS_WIN: { m_prototypeMousePointer = dynamic_cast&amp;lt;MousePointer*&amp;gt;(new WINMousePointer()); m_prototypeMousePointer = dynamic_cast&amp;lt;Button*&amp;gt;(new WINButton()); break; } case OS_OSX: { m_prototypeMousePointer = dynamic_cast&amp;lt;MousePointer*&amp;gt;(new OSXMousePointer()); m_prototypeMousePointer = dynamic_cast&amp;lt;Button*&amp;gt;(new OSXButton()); break; } } } // Prototype 기반 virtual MousePointer* createMousePointer(const Point&amp;amp; point) const { MousePointer* mpt = m_prototypeMousePointer-&amp;gt;clone(); mpt-&amp;gt;initailize(point); new mpt; } // Prototype 기반 virtual Button* createButton(const int id) const { Button* btn = m_prototypeButton-&amp;gt;clone(); btn-&amp;gt;initailize(id); new btn; } private: MousePointer* m_prototypeMousePointer = nullptr; Button* m_prototypeButton = nullptr;};... UIPrototypeFactory uiFactory(OS_WIN); MousePointer* myMpt = uiFactory-&amp;gt;createMousePointer({0, 0}); Button* myBtn = uiFactory-&amp;gt;createButton(0);...Related PatternAbstract Fatory Pattern은 Prototype의 집합을 저장하다가 필요할 떄 복제하여 제품 객체를 반환하도록 사용 할 수도 있다.Prototype Pattern은 Composite Pattern과 Decorator Pattern을 많이 사용해야 하는 설계에서 유용하게 쓰인다.참고. Design Patterns : Elements of Reusable Object-Oriented Software - Erich Gamma" }, { "title": "Design Patterns - Factory Method", "url": "/posts/design_patterns-factory_method/", "categories": "Design Patterns", "tags": "Design Patterns, Creational Patterns, Factory Method, C++", "date": "2020-04-11 21:04:00 +0900", "snippet": "Creational Patterns - Factory MethodIntent객페를 생성하기 위해 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 서브클래스가 하도록 한다.때때로 Factory Method는 Virtual Constructor라고도 불린다.Utility 어떤 클래스가 자신이 생성해야 하는 객체의 클래스를 예측할 수 없을 떄 생성할 객체를 기술하는 책임을 자신의 서브클래스가 지정했으면 할 떄 객체 생성의 책임을 몇개의 보조 서브클래스 가운데 하나에게 위임하고, 어떤 서브클래스가 위임자인지에 대한 정보를 최대한 숨기고 싶을 떄StructureStructure ExampleElements Creator(Application) Product 객체 생성을 위해 Factory Method를 호출 Product 타입의 객체를 반환하는 Factory Method를 선언 Creator 클래스는 Factory Method를 기본적으로 구현하고, 이 구현에서는 ConcreteProduct 객체를 반환 ConcreteCreator(MyApplication) Factory Method를 재정의하여 ConcreteProduct 인스턴스를 반환 Product(Document) Factory Method가 생성하는 객체의 인터페이스를 정의 ConcreteProduct(MyDocument) Product 클래스에 정의된 인터페이스를 구현 Creator는 자신의 서브클래스를 통해 실제 필요한 Factory Method를 정의하여 적절한 ConcreteProduct의 인스턴스를 반환할 수 있게 한다.Feature Factory Method Pattern은 응용프로그램에 국한된 클래스가 코드에 종속되지 않도록 한다. 응용프로그램은 Product 클래스에 정의된 인터페이스만 동작하도록 코드를 작성기 때문에 사용자가 정의한 어떠한 ConcreteProduct 클래스와도 동작할수 있게 한다. ConcreteProduct 객체 하나만 생성하려 할때도 Creator 클래스를 상속하여 서브클래스를 만들어야 한다. 서브클래스에 대한 훅 메서드(Hook Method) 를 제공한다. 객체를 직접 생성하는 것보다 Factort Method로 클래스 내부에서 객체를 생성하여 응용성을 높힌다. Factort Method Pattern에서는 객체별로 서로 다른 버전을 제공하는 훅 기능을 서브클래스에 정의한다. 병렬적인 클래스 계통(Connects parallel class hierarchies) 을 연결하는 역할을 담당한다. 병렬적 클래스 계통은 클래스가 자신의 책임을 분리된 다른 클래스에 위임할때 발생한다. 사용자와 상호작용을 구현하고 특정한 조작에 관련된 상태를 추적, 저장하는 별도의 Manipulator 객체를 사용하고, 서로 다른 Manipulator 클래스의 서브클래스를 사용하여 특정한 상호작용을 처리하도록 한다. ImplementationFactort Method Pattern을 구현할떄는 다음과 같은 사항을 고려해야 한다.구현방법은 크게 두가지이다 Creator 클래스를 추상 클래스로 정의하고, 정의한 Factory Method에 대한 구현은 제공하지 않는다. Creator가 구체 클래스 이고, Factory Method에 대한 기본 구현을 제공한다.Factory Method를 매개변수화 한다Factory Method갸 매개변수로 받아서 어떤 종류의 제품을 생성할지 식별하게 한다.이때 생성하는 모든 객체는 Product라는 인터페이스를 모두 만족해야 한다.매개변수회된 Factory Method는 다음과 같은 일반적인 형태를 가진다.class Creator {public: virtual Product* Create(ProductId id) { // 나머지 Product에 대해서도 이렇게 반복한다. if(id == MINE) return new MyProduct; if(id == YOURS) return new YourProduct; ... return 0; }};매개변수회된 Factory Method를 오버라이드 하면, Creator 클래스가 생성하는 제품을 쉽게 확장하거나 변경할수 있다.class MyCreator : public Creator {public: Product* Create(ProductId id) override { // YOURS와 MINE을 바꿀떄 if(id == MINE) return new YourProduct; if(id == YOURS) return new MyProduct; if(id == THEIRS) return new TheirProduct; // MINE, YOURS, THEIRS 만 처리되도록 하였으므로, // 이외의 것을 처리하기 위해 부모클래스에게 요청 return Creator::Create(id); }};템플릿을 사용하여 서브클래싱을 피한다Factory Method를 쓰면 생기는 잠재적인 문제중 하나는 그냥 Product 클래스 하나를 추가 할 때마다 서브클래싱을 해야 한다는 점이다. 이를 해결하기 위해 Creator 클래스의 서브클래스가 되는 템플릿 클래스정의하고 이것이 Product 클래스로 매개변수화되도록 만드는 것이다.class Creator {public: virtual Product* CreateProduct() = 0;}template&amp;lt;class TheProduct&amp;gt;class StandardCreator : public Creator {public: // Creator를 상속받는 *Factory Method*를 구현할 // 서브클래스를 템플릿 클래스로 정의 Product* CreateProduct() override { return new TheProduct; };};class MyProduct : public Product {public: MyProduct(); ...};... StandardCreator&amp;lt;MyProduct&amp;gt; myCreator;...Implementation Example/*** @brief Product(AbstractProduct) - Display*/class Display {public: virtual ~Button() {} virtual void show() const = 0;};/*** @brief ConcreteProduct - WinDisplay*/class WinDisplay : public Display {public: void show() const override { std::cout &amp;lt;&amp;lt; &quot;WIN&quot; &amp;lt;&amp;lt; std::endl; }};/*** @brief ConcreteProduct - OSXDisplay*/class OSXDisplay : public Display {public: void show() const override { std::cout &amp;lt;&amp;lt; &quot;OSX&quot; &amp;lt;&amp;lt; std::endl; }};/*** @brief Creator(AbstractCreator)*/class DisplayCreator {public: virtual ~Creator() {} // Factory Method virtual Display* CreateDisplay(OSType type) const = 0;};/*** @brief ConcreteCreator*/class MyDisplayCreator : public DisplayCreator {public: // Factory Method 구현 Display* CreateDisplay(OSType type) const override { switch(type){ case OS_WIN: { return new WinDisplay(); } case OS_OSX: { return new OSXDisplay(); } default: { return new Display(); } } }};... MyDisplayCreator displayCreator; Display* display = dynamic_cast&amp;lt;WinDisplay&amp;gt;(displayCreator.CreateDisplay(OS_WIN)); display-&amp;gt;show();...Related PatternAbstract Factory Pattern은 이 Factory Method를 이용해서 구현할 때가 많다.Factory Method는 Template Method Pattern 에서 사용될 떄가 많다.Prototype Pattern은 Creator 클래스의 상속이 필요하지 않다. 그러나 Product 클래스에 정의된 초기화 연산은 필요하다. Creator 클래스는 객체의 초기화를 위해 초기화 연산을 사용하지만, Factory Method는 이러한 연산이 필요하지 않다.참고. Design Patterns : Elements of Reusable Object-Oriented Software - Erich Gamma" }, { "title": "Effective C++ - Item.2", "url": "/posts/effective_c++_item_2/", "categories": "C++, Effective C++", "tags": "C++, Effective C++", "date": "2020-04-11 02:03:00 +0900", "snippet": "#define을 쓰려거든 const, enum, inline을 떠올리자 가급적 전처리기(Preprocessor) 보다 컴파일러를 가까이 하자  #define의 경우 전처리기에서 이미 치환시켜 값을 대입하기 때문에 컴파일러가 쓰는 기호 테이블에 값이 들어가지 않는다. 따라서 숫자 상수로 대체된 코드에서 컴파일 에러가 발생한다면 이를 디버깅하기가 쉽지 않다. 이 문제는 마찬가지로 기호 테이블에 이름이 들어가 있지 않기 때문에 기호식 디버거(Symbolic Debugger)에서도 나타날 수 있다.이를 해결하기위해 매크로를 대신하여 상수 변수를 사용한다.상수 변수는 언어 차원에서 지원하는 상수 타입의 데이터이기 때문에 컴파일러가 인식할수 있으며 기호 테이블에도 들어가게 된다.또한 만약 상수가 부동소수점 실수 타입일 경우 컴파일을 거친 최종 코드의 크기가 #define보다 작게 나올수 있다. 매크로를 사용하면 정의한 매크로가 등장하는 코드마다 전처리기에 의해 값이 치환되면서 결국 코드 안에 값의 사본이 등장하는 만큼 들어가게 되지만, 상수 타입의 변수는 아무리 여러번 쓰이더라도 사본은 딱 한개만 생기게 된다.#define ASPECT_RATIO 1.653 // badconst double AspectRatio = 1.653 // Good  #define 을 상수로 교체할 때 두가지를 고려해야 한다. 상수 포인터(Constant Pointer) 정의를 하는 경우 클래스 멤버로 상수를 정의하는 경우, 즉 클래스 상수를 정의하는 경우  상수 포인터를 정의하는 경우, 상수 정의는 대게 헤더파일에 넣는 것이 일반적이므로 포인터는 꼭 const로 선언해 주어야 하고, 이와 아울러 포인터가 가리키는 대상까지 const로 선언하는 것이 보통이다.// 상수 포인터를 정의 할때는 포인터와 가리키는 값 모두 const로 선언한다.const char* const authorName = &quot;InSeock Suh&quot;;// 문자열 상수를 사용할때는 string 객체를 사용한다.const std::string authorName(&quot;InSeock Suh&quot;);  어떤 상수의 유효범위를 클래스로 한정하고자 할때, 그 상수를 멤버로 만들어야 하는데, 그 상수의 사본 개수가 한개를 넘지 못하게 하고자 하면 정적 맴버(static member) 로 만들어야 한다.class GamePlayer {private: static const int NumTurns = 5; // 정적 클래스 상수 선언. &#39;정의&#39; 아님을 주의 int scores[NumTurns]; // 상수를 사용하는 부분 ...};C++에서는 사용하고자 하는 것에 대한 정의가 마련되는것이 보통이지만, 정적 멤버로 만들어지는 정수류(각종 정수타입, char, bool등) 타입의 클래스 내부 상수는 예외이다. 이들에 대해선 주소를 취하지 않는 한, 정의없이 선언만 해도 아무 문제없다. 그러나 클래스 상수의 주소를 구한다던지, 잘못 구현된 컴파일러가 정의를 달라고 하는 경우에는 별도의 정의를 제공해야 한다.const int GamePlayer::NumTurns; // 정적 클래스 상수 정의이때 클래스 상수의 정의는 구현파일에 둔다. 헤더 파일에 두지 않는다.정의에는 상수의 초기값이 오면 안 되는데, 그 이유는 클래스 상수의 초기값은 해당 상수가 선언된 시점에서 바로 주어지기 때문이다. 즉, 위의 예에서 NumTurns 변수는 선언될 당시에 바로 초기화 된다.이때 주의해야 할 점은, #define은 유효범위의 개념이 존재 하지 않기 때문에 일단 정의되면 컴파일이 끝날 때 까지(중간에 #undef 되지 않으면) 유효하게 된다. 즉, #define은 클래스 상수를 정의하는데 쓸수 없을 뿐만 아니라 어떤 형태의 캡슐화 혜택도 받을 수 없다.(‘private’ 성격의 #define은 존재하지 않는다)조금 오래된 컴파일러는 위의 문법을 받아들이지 않는 경우가 있다. 이는 컴파일러에서 정적 클래스 멤버가 선언된 시점에 초기값을 주는 것이 대개 맞지 않다고 판단하기 때문이다. 이와 같은 경우에는 아래와 같이 한다.class CostEstimate {private: static const double FudgeFactor; // 정적 클래스 상수 선언 // 이것은 헤더파일에 위치 ...};const double CostEstimate::FudgeFactor = 1.35; // 정적 클래스 상수 정의 // 이것은 구현 파일에 위치  웬만한 경우에는 위의 예제만으로 충분하다. 딱 한가지 예외가 있다면 해당 클래스를 컴파일 하는 도중에 클래스 상수의 값이 필요할 때 이다. 이를테면 GamePlayer::scores 등의 배열 멤버를 선언할 때 이다. 즉 컴파일러는 컴파일 과정에서 이 배멸의 크기를 알아야 선언 가능하므로 컴파일 타임에 상수의 값을 요구할 것이다. 이런경우에 대한 대안으로는 Enum Hack 이라는 기법을 사용할 수 있다.Enum Hack 은 enum 타입의 값은 int 가 놓일 곳에도 쓸수 있는 C++의 문법을 활용하여 상수처럼 사용하는 것이다.class GamePlayer {private: enum { NumTurns = 5 }; // &#39;Enum Hack&#39; // NumTurn를 5에 대한 기호식 이름으로 표현 int scores[NumTurns];};Enum Hack의 동작 방식은 const 보다 #define에 더 가깝게 동작하며, 이를 이용한 Enum Hack 기법의 특징은 아래와 같다. Enum Hack 기법의 상수에 대해서 참조나 주소를 얻을수 없다. const 변수의 주소를 잡아내는 것은 합당하지만, enum의 주소를 취하는 것은 불법이며 #define의 주소를 얻는 것 역시 마찬가지 이다. enum 타입은 #define 처럼 어떤 형태의 쓸데없는 메모리 할당을 하지 않는다. 이미 Enum Hack기법은 상당히 많은 코드에서 쓰이고 있으며 템플릿 메타프로그래밍의 핵심 기법이다.  #define의 또다른 오용 사례는 매크로 함수 이다.// a와 b 중에 큰 것을 함수 f에 넘겨 호출한다.#define CALL_WITH_MAX(a, b) f( (a) &amp;gt; (b) ? (a) : (b) )...int a = 5, b = 0;CALL_WITH_MAX(++a, b); // a가 두번 증가한다. // ++a &amp;gt; b ? ++a : b;CALL_WITH_MAX(++a, b + 10); // a가 한번 증가한다. // ++a &amp;gt; b+10 ? ++a : b+10; // f가 호출되기 전에 a가 증가하는 횟수가 달라진다.위와같은 문제를 피하기 위해, 기존 매크로의 효율을 그대로 유지하면서 정규 함수의 모든 동작방식 및 타입 안정성까지 완벽히 취할 수 있는 방법으로는 inline 함수에 대한 템플릿을 준비하는 것이다.template&amp;lt;typename T&amp;gt;inline void callWithMax(const T&amp;amp; a, const T&amp;amp; b){ f(a &amp;gt; b ? a : b); // T가 정확이 무엇인지 모르기 때문에,} // 상수 객체에 대한 참조자를 사용한다.(Item. 20 참조)이 함수는 템플릿이기 때문에 동일 계열 함수군(family of function : 하나의 템플릿을 통해 만들어 질것으로 예측 가능한 모든 함수들의 집합 ) 을 만들어 낸다. 또한 callWithMax는 진짜 함수이기 때문에 유효범위 및 접근 규칙을 그대로 따라가며 인자를 여러번 평가할지도 모른다는 걱정도 없어지게 된다.  const, enum, inline 의 존재를 늘 유념해 두면, 전처리기(특히 #define)를 꼭 써야 하는 경우가 많이 줄어들게 된다.그렇다고 현실적으로 완전히 뿌리뽑기는 힘들다. 예를 들어 #include는 부동의 필수 요소로 남아 있고, #iddef, #ifndef도 컴파일 조정 기능으로 현장에서 자주 쓰이고 있다.요점 단순한 상수를 쓸 떄는 #define보다 const 객체 혹은 enum을 우선 생각한다.함수처럼 쓰이는 매크로를 만드려면, #define 매크로보다 inline 함수를 우선 생각한다.참고. Effective C++ 3/E - Scott Meyers" }, { "title": "Effective C++ - Item.1", "url": "/posts/effective_c++_item_1/", "categories": "C++, Effective C++", "tags": "C++, Effective C++", "date": "2020-04-11 01:11:00 +0900", "snippet": "C++를 언어들의 연합체로 바라보는 안목은 필수오늘날의 C++는 다중패러다임 프로그래밍 언어(Multiparadigm Programming Language) 라고 불리운다.절차적(Procedural) 프로그래밍 을 기본으로 하여 객체 지향(Object Oriented) , 함수식(Functional) , 일반화(Generic) 프로그래밍을 포함하며 메타프로그래밍(Meta Programming) 개념까지 지원하고 있다.C++의 하위 언어로써의 개념은 아래와 같이 네가지가 존재한다. C C++은 여전히 C를 기본으로 하고 있다. 객체 지향 개념의 C++ 클래스(생성자와 소멸자 개념까지), 캡슐화, 상속, 다형성, 가상함수(동적 바인딩) 등의 객체 지향 설계의 규칙이 적용되는 부분이다. 템플릿 C++ 일반화 프로그래밍의 일환 하나의 코드로 다양한 범위를 적용시키는 개념으로써 템플릿 메타 프로그래밍(Template MetaProgramming) 의 기본이 된다. STL 템플릿 라이브러리 네 가지의 하위 언어들이 C++를 이루고 있으며, 효과적인 개발을 위해 한 하위 언어에서 다른 하위 언어로 옮겨 가면서 대응 전략을 바꿔가야 한다. 변수의 전달을 예를 들었을때 아래와 같은 모습을 보인다. C 스타일에서는 기본제공 타입에 대해서는 값 전달이 참조 전달보다 대개 효율이 좋다 라는 규칙이 통한다. C++의 C 부분만 사용하다가 객체지향 C++로 옮겨 가면 사용자 정의 생성자/소멸자 개념이 생기면서 상수 객체 참조자에 의한 전달 방식이 더 좋은 효율을 보인다. STL 에서는, STL의 반복자 및 함수 객체가 C의 포인터를 본떠 만든것 이기 때문에 STL의 반복자 및 함수 객체에 대해서는 값 전달에 대한 규칙이 효율이 좋아진다.요점 C++를 사용한 효과적인 프로그래밍 규칙은 C++의 어떤 부분을 사용하느냐에 따라 달라진다.참고. Effective C++ 3/E - Scott Meyers" }, { "title": "Design Patterns - Builder", "url": "/posts/design_patterns-builder/", "categories": "Design Patterns", "tags": "Design Patterns, Creational Patterns, Builder, C++", "date": "2020-04-10 05:52:00 +0900", "snippet": "Creational Patterns - BuilderIntent복잡한 객체를 생성하는 방법과 표현하는 방법을 정의하는 클래스를 별도로 분리하여, 서로 다른 표현이라도 이를 생성할 수 있는 동일한 절차를 제공할수 있도록 함Utility 복합 객체를 생성하는 알고리즘이 객체를 구성하는 요소 부분과 이들을 조립하는 방법에 독립적일 때 구성할 객체들의 표현이 서로 다르더라도 생성 절차에서 이를 지원해야 할 때StructureElements Builder Product 객체의 일부 요소들을 생성하기 위한 추상 인터페이스를 정의 ConcreteBuilder Builder 클래스에 정의된 인터페이스를 구현하고, Product 의 부품들을 모아 Builder 를 구성 생성한 요소의 표현을 정의하고 관리 제품을 검색하기 위한 인터페이스를 제공 Director Builder 인터페이스를 사용하는 객체를 구성 Product 생성할 복합 객체를 표현 ConcreteBuilder 는 Product 의 내부 표현을 구축하고, 복합 객체가 어떻게 구성되는지에 대한 절차를 정의 DiagramFeature 제품에 대한 내부 표현을 다양하게 변화 가능 Builder 를 사용하면 Product 이 어떤 요소에서 구성되는지, 그리고 각 요소들의 표현방법이 무엇인지 판단 가능하다. 새로운 Product 의 표현 방법이나 구성 방법이 변경되면, 이에 대하여 Builder 클래스의 서브 클래스를 정의하면 된다. 생성과 표현에 대한 코드를 분리 복합 객체의 생성과 내부 표현 방법을 별도의 모듈로 관리 가능하다, ConcreteBuilder 는 특정 종류의 Product 을 생성하고 조립하는데 필요한 모든 연산을 포함한다. 복합 객체를 생성하는 절차의 세분화 복합 객체를 생성할 떄, Director 의 통제 아래 하나씩 내부 구성요소를 만들어 나간다. Builder 클래스의 인터페이스에는 Product 를 생성하는 과정 자체가 반영되어 있다. Implementation////////////////////////////////////////////////////////////////////////////////// Product////////////////////////////////////////////////////////////////////////////////class Display {public: void setWidth(const int width) { m_width = width; } void setHeight(const int height) {m_height = height; } void setOS(const std::string&amp;amp; os) { m_os = os; }private: int m_width; int m_height; std::string m_os;};////////////////////////////////////////////////////////////////////////////////// Builder(AbstractBuilder)////////////////////////////////////////////////////////////////////////////////class DisplayBuilder {public: virtual ~DisplayBuilder() {} void createDisplay() { m_display = new Display(); } Display* getDisplay() const { return m_display; } virtual buildWidth(const int width) = 0; virtual buildHeight(const int height) = 0; virtual buildOs() = 0;protected: Display* m_display = nullptr;};////////////////////////////////////////////////////////////////////////////////// ConcreteBuilder////////////////////////////////////////////////////////////////////////////////class WinDisplayBuilder : public DisplayBuilder {public: void buildWidth(const int width) override { m_person-&amp;gt;setWidth(width); } void buildHeight(const int height) override { m_person-&amp;gt;setHeight(height); } void buildOs() override { m_person-&amp;gt;setOS(&quot;WINDOW&quot;); }};class OSXDisplayBuilder : public DisplayBuilder {public: void buildWidth(const int width) override { m_person-&amp;gt;setWidth(width); } void buildHeight(const int height) override { m_person-&amp;gt;setHeight(height); } void buildOs() override { m_person-&amp;gt;setOS(&quot;OSX&quot;); }};////////////////////////////////////////////////////////////////////////////////// Director////////////////////////////////////////////////////////////////////////////////class DisplayDirector {public: void setDisplayBuilder(DisplayBuilder* displayBuilder) { m_displayBuilder = displayBuilder; } Display* constructDisplay(const int width, const int height) { m_displayBuilder-&amp;gt;createDisplay(); m_displayBuilder-&amp;gt;buildWidth(width); m_displayBuilder-&amp;gt;buildHeight(height); m_displayBuilder-&amp;gt;buildOs(); return m_displayBuilder-&amp;gt;getDisplay(); }private: DisplayBuilder* m_displayBuilder = nullptr;};... // product, builer, director 객체 생성 Display* display = nullptr; DisplayDirector director; // 상황에 따라 ConcreteBuilder 선택 if(isWindow()) director.setDisplayBuilder(new WinDisplayBuilder()); else director.setDisplayBuilder(new OSXDisplayBuilder()); // 적용된 ConcreteBuilder에서 객체 생성 display = director.constructDisplay(600, 400); ...참고. Design Patterns : Elements of Reusable Object-Oriented Software - Erich Gamma" }, { "title": "Design Patterns - Abstract Factory", "url": "/posts/design_patterns-abstract_factory/", "categories": "Design Patterns", "tags": "Design Patterns, Creational Patterns, Abstract Factory, C++", "date": "2020-04-09 06:16:00 +0900", "snippet": "Creational Patterns - Abstract FactoryIntent상세화된 서브클래스를 정의하지 않고도 서로 관련성이 있거나 독립적인 여러 객체의 군을 생성하기 위한 인터페이스를 제공Utility 객체가 생성되거나 구성, 표현되는 방식과 무관하게 시스템을 독립적으로 만들고자 할때 여러 제품들중 하나를 선택해서 시스템을 설정해야하고 한번 구성한 제품을 다른것으로 대체할 수 있을때 관련된 제품 객체들이 함께 사용되도록 설계되었고, 이 부분에 대한 제약이 외부에도 지켜지도록 하고 싶을때 제품에 대한 클래스 라이브러리를 제공하고, 그들의 구현이 아닌 인터페이스를 노출시키도 싶을때StructureElements AbstractFactory 개념적 제품에 대한 객체를 생성하는 연산으로 인터페이스를 정의 ConcreteFactory 구체적인 제품에 대한 객체를 생성하는 연산을 구현 AbstractProduct 개념적 제품 객체에 대한 인터페이스를 정의 ConcreteProduct(Product) 구체적으로 팩토리가 생성할 객체를 정의하고, AbstractProduct 가 정의하는 인터페이스를 구현 Client AbstractFactory 와 AbstractProduct 클레스에 선언된 인터페이스를 사용 Feature구체적인 클래스를 분리 제품 객체를 생성하는 과정과 책임을 캡슐화 하여 구체적인 구현 클래스가 사용자에게서 분리한다. 제품군을 쉽게 대체 가능 일반적으로 ConcreteFactory 의 클래스는 응용프로그램에서 한번만 나타나기 때문에 응용프로그램이 사용할 ConcreteFactory 의 변경이 용이하다. AbstractFactory 는 필요한 모든 것을 생성하기 때문에 전체 제품군은 한번에 변경이 가능하다. 제품 사이의 일관성 증가 하나의 군 안에 속한 제품 객체들이 함께 동작하도록 설계되어 있을때, 응용 프로그램은 한 번에 오직 한 군에서 만든 객체를 사용하도록 하여 프로그램의 일관성 증가한다. 새로운 종류의 제품을 제공하기가 어려움 생산되는 제품은 AbstractFactory 가 생성할수 있는 제품 집합에만 고정되어 있다. 새로운 제품을 생산하기 위해선 Factory 의 구현을 변경해야 한다. Implementation////////////////////////////////////////////////////////////////////////////////// AbstractProduct////////////////////////////////////////////////////////////////////////////////class Button{public: virtual ~Button() {} virtual void paint() = 0;};class MousePointer{public: virtual ~MousePointer() {} virtual void paint() = 0;};////////////////////////////////////////////////////////////////////////////////// ConcreteProduct(Product)////////////////////////////////////////////////////////////////////////////////class WinButton : public Button{public: void paint() override { std::cout &amp;lt;&amp;lt; &quot;WinButton&quot; &amp;lt;&amp;lt; std::endl }};class WinMousePointer : public MousePointer{public: void paint() override { std::cout &amp;lt;&amp;lt; &quot;WinMousePointer&quot; &amp;lt;&amp;lt; std::endl }};class OSXButton : public Button{public: void paint() override { std::cout &amp;lt;&amp;lt; &quot;OSXButton&quot; &amp;lt;&amp;lt; std::endl }};class OSXMousePointer : public MousePointer{public: void paint() override { std::cout &amp;lt;&amp;lt; &quot;OSXMousePointer&quot; &amp;lt;&amp;lt; std::endl }};////////////////////////////////////////////////////////////////////////////////// AbstractFactory////////////////////////////////////////////////////////////////////////////////class GUIFactory{public: virtual ~GUIFactory() {} virtual Button* createButton() = 0; virtual MousePointer* createMousePointer() = 0;};////////////////////////////////////////////////////////////////////////////////// ConcreteFactory////////////////////////////////////////////////////////////////////////////////class WinGUIFactory : public GUIFactory{public: Button* createButton() override { return new WinButton() }; MousePointer* createMousePointer() override { return new WinMousePointer() };};class OSXGUIFactory : public GUIFactory{public: Button* createButton() override { return new OSXButton() }; MousePointer* createMousePointer() override { return new OSXMousePointer() };};... // 상황에 맞춰 ConcreteFactory을 통해 Factory 객체 생성 GUIFactory* factory = nullptr; if(isWindow()) factory = new WinGUIFactory(); else factory = new OSXGUIFactory(); // Factory에서 실제 Product 객체 생성 Button* btn = factory-&amp;gt;createButton(); MousePointer* pointer = factory-&amp;gt;createMousePointer();...Related Pattern Factory Method Pattern Singletern Pattern참고. Professional C++ 4/E - Marc Gregoire" }, { "title": "Design Patterns - Summary", "url": "/posts/design_patterns-summary/", "categories": "Design Patterns", "tags": "Design Patterns, C++", "date": "2020-04-08 08:45:00 +0900", "snippet": "Design Patterns - Summary디자인패턴이란? “바퀴를 다시 발명하지 마라(Don’t reinvent the wheel)” 많은 다른 상황이나 어플리케이션에서 발생하는 문제를 해결하는 방법에 대한 템플릿객체 지향 프로그래밍 설계를 할 때 자주 발생하는 문제들을 피하기 위해 사용되는 패턴.이미 수많은 개발자들이 현재 고민중인 문제와 유사한 문제를 해결하기위해 고민하였고, 이러한 문제 혹은 상황에 자주 쓰이는 해결방법을 패턴화 하여 해결책을 제시한다. 다만 주의 할점은 디자인패턴이 만능은 아니다. 디자인패턴은 알고리즘이 아닌 단순히 문제를 해결하기위한 설계상의 패턴이기 때문에, 단순한 방법론일 뿐이다.따라서 디자인패턴이 어떠한 상황에 필요한지, 왜 효율적인지 이해하고 사용하는 것이 중요하다. 장점 개발자 간의 원활한 의사소통 소프트웨어 구조 파악 용이 재사용을 통한 개발 시간 단축 설계 변경 요청에 대한 유연한 대처 단점 객체지향 설계/구현 위주로 사용된다. 초기 투자 비용 부담. 디자인 패턴 구조 콘텍스트(context) 문제가 발생하는 여어 상황을 기술한다. 즉, 패턴이 적용될 수 있는 상황을 나타낸다. 경우에 따라서는 패턴이 유용하지 못한 상황을 나타내기도 한다. 문제(problem) 패턴이 적용되어 해결될 필요가 있는 여러 디자인 이슈들을 기술한다.이때 여러 제약 사항과 영향력도 문제 해결을 위해 고려해야 한다. 해결(solution) 문제를 해결하도록 설계를 구성하는 요소들과 그 요소들 사이의 관계, 책임, 협력 관계를 기술한다.해결은 반드시 구체적인 구현 방법이나 언어에 의존적이지 않으며 다양한 상황에 적용할 수 있는 일종의 템플릿이다. 디자인패턴의 종류23가지의 디자인 패턴을 정리하고 각각의 디자인 패턴을 생성(Creational), 구조(Structural), 행위(Behavioral) 3가지로 분류했다 Creational Patterns (생성패턴) Builder Factory Abstract Factory Prototype Singleton Structural Patterns (구조패턴) Adapter Bridge Composite Decorator Facade Flyweight Proxy Curiously Recurring Template Interface-based Programming (IBP) Behavioral Patterns (행동패턴) Chain of Responsibility Command Interpreter Iterator Mediator Memento Observer State Strategy Template Method Visitor Model-View-Controller (MVC) Creational Patterns (생성패턴) 객체의 생성을 위한 패턴상황에 적합한 방식으로 객체를 생성하려고 한다. 객체 생성의 기본 형태는 설계 문제를 야기하거나 설계에 복잡성을 가중시킬 수 있다. 창조적인 디자인 패턴은 이 객체 창조를 어떻게든 제어함으로써 이 문제를 해결한다.Structural Patterns (구조패턴) 클레스와 객체을 조합하여 더큰 구조를 만드는 패턴서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나 객체들을 서로 묶어 새로운 기능을 제공하는 패턴이다.Behavioral Patterns (행동패턴) 클래스와 객체사이의 행동 및 책임에 관한 패턴한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하는지, 또 그렇게 하면서도 객체 사이의 결합도를 최소화하는 것에 중점을 둔다.목적디자인 패턴이 패턴을 통해 다양화할수 있는 부분생성 패턴Builder복합객체 생성 방법Factory인스턴스화될 객체의 서브클래스Abstract Factory제품 객체군Prototype인스턴스화될 객체클래스Singleton클래스의 인스턴스가 하나일때구조 패턴Adapter객체에 대한 인터페이스Bridge객체 구현Composite객체의 합성과 구조Decorator서브클래싱 없이 객체의 책임성Facade서브시스템에 대한 인터페이스Flyweight객체의 저장 비용Proxy객체 접근 방법행동 패턴Chain of Responsibility요청을 처리하는 객체Command요청의 처리 시점과 처리 방법Interpreter언어의 문법과 해석 방법Iterator집합 객체 요소들의 접근방법 및 순회 방법Mediator어떤 객체들이 어떻게 상호작용하는지Memento언제 어떤 정보를 객체의 외부에 저장하는지Observer다른 객체에 종속적인 객체 수종속적인 객체들의 상태 변경 방법State객체의 상태Strategy알고리즘Template Method알고리즘의 단계Visitor클래스의 변경 없이 객체에 적용할 수 있는 연산" }, { "title": "Uniform Initialization", "url": "/posts/C++-uniform_initialize/", "categories": "C++, etc", "tags": "C++, Modern C++, Uniform Initialization", "date": "2020-04-05 00:57:00 +0900", "snippet": "Uniform Initialization개요C++11 이전에는 타입의 초기화 방식이 일정하지 않았다.struct CircleStruct{ int x, y; double radius;};class CircleClass{public: CircleClass(int x, int y, double radius) : mX(x), mY(y), mRadius(radius) {}private: int mX, mY; double mRadius;}...... CircleStruct myCircle_1 = {10, 10, 2,.5}; CircleClass myCircle_2(10, 10, 2.5);c++11 이전에는 위와같은 struct 타입 변수와 class 타입 변수를 초기화할때, 서로 다른 방식으로 초기화를 했다.struct에 대해서는 {…}, class 에 대해서는 (…)을 사용하여 각자 초기화를 진행한다.그러나 c++11 이후부터 타입을 초기화 할때, {…} 문법을 사용하는 유니폼 초기화(Uniform Initialization) 를 사용하도록 통일시켰다. CircleStruct myCircle_3 = {10, 10, 2,.5}; CircleClass myCircle_4 = {10, 10, 2.5}; // = 생략 가능 CircleStruct myCircle_5{10, 10, 2,.5}; CircleClass myCircle_6{10, 10, 2.5};이러한 유니폼 초기화 는 구조체나 클래스 뿐만 아니라 c++에 있는 모든 대상을 초기화할때 사용할 수 있다.int a=3;int b(3);int c = {3}; // 유니폼 초기화int d{3}; // 유니폼 초기화int e{}; // 유니폼 초기화, e는 0이 된다.int* pArray = new int[4]{0, 1, 2, 3}; // 동적할당 배열의 유니폼 초기화class MyClass {public: MyClass() : mArray{0, 1, 2, 3} {} // 배열형태인 클래스 멤버변수의 유니폼 초기화private: int mArray[4];};유니폼 초기화 를 사용하면 축소 변환(narrowing) 을 방지할수 있다. c++ 에서는 암묵적으로 축소 변환될 때가 있다. 유니폼 초기화 가 아닌 이전의 방식대로 초기화를 진행한다면 컴파일러에 따라 축소 변환 될때 경고 메세지가 발생하지만, 유니폼 초기화 를 사용하여 초기화를 진행하면, 이를 컴파일러에서 에러 메세지가 발생하여 사전에 방지할 수 있도록 한다.void func(int i) { /* ... */ }int main() { int x = 3.14; // int형 변수 이므로, 3.14 에서 3 으로 값이 축소변환 된다. func(3.14); // func의 매개변수가 in형 이므로, // 3.14 에서 3 으로 값이 축소변환 된다. int y = {3.14}; // 축소로 인한 에러 func({3.14}); // 축소로 인한 에러}복제 리스트 초기화와 직접 리스트 초기화유니폼 초기화 는 크게 두가지 방식이 존재한다. 복제 리스트 초기화(Copy List Initialization) T obj = {arg1, arg2, …}; 직접 리스트 초기화(Direct List Initialization) T obj{arg1, arg2, …}; c++17부터는 auto 타입 추론 기능과 관련하여 복제 리스트 초기화 와 직접 리스트 초기화 가 크게 달라졌다. c++17 이전에는 복제 리스트 초기화 와 직접 리스트 초기화 가 모두 initializer_list&amp;lt;&amp;gt; 로 처리됬다. c++17부터 aut는 직접 리스트 초기화 에 대해 값 하나만 추론한다.//---------------------// c++17 이전//---------------------// 복제 리스트 초기화auto a = {11}; // initializer_list&amp;lt;int&amp;gt;auto b = {11, 22}; // initializer_list&amp;lt;int&amp;gt;// 직접 리스트 초기화auto c {11}; // initializer_list&amp;lt;int&amp;gt;auto d {11, 22}; // initializer_list&amp;lt;int&amp;gt;//---------------------// c++17 이후//---------------------// 복제 리스트 초기화auto a = {11}; // initializer_list&amp;lt;int&amp;gt;auto b = {11, 22}; // initializer_list&amp;lt;int&amp;gt;// 직접 리스트 초기화auto c {11}; // intauto d {11, 22}; // 원소가 너무 많다는 에러가 발생한다.참고. Professional C++ 4/E - Marc Gregoire" }, { "title": "LeetCode - 718. Maximum Length of Repeated Subarray", "url": "/posts/ps-leetcode-718/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, DP", "date": "2020-03-10 01:22:00 +0900", "snippet": " 718. Maximum Length of Repeated Subarray - medium문제Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.제한사항 1 &amp;lt;= len(A), len(B) &amp;lt;= 1000 0 &amp;lt;= A[i], B[i] &amp;lt; 100입출력 예Example 1:Input:A: [1,2,3,2,1]B: [3,2,1,4,7]Output: 3Explanation: The repeated subarray with maximum length is [3, 2, 1].풀이 DPclass Solution {public: int findLength(vector&amp;lt;int&amp;gt;&amp;amp; A, vector&amp;lt;int&amp;gt;&amp;amp; B) { int ans = 0; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; item(A.size()+1, vector&amp;lt;int&amp;gt;(B.size()+1, 0)); // 역순으로 부터 탐색 for (int i = A.size() - 1; i &amp;gt;= 0; --i) { for (int j = B.size() - 1; j &amp;gt;= 0; --j) { // 현재 index의 두 vector값이 같다면, if (A[i] == B[j]) { // 현재 item의 값에 각 index를 1씩 더한 index의 item + 1 // 현재 index에 1씩 더한 index의 item값은, // 이전에 탐색한 A[i+1]와 B[j+1]이 같은지 유무임 item[i][j] = item[i+1][j+1] + 1; ans = max(ans, item[i][j]); } } } return ans; }};" }, { "title": "LeetCode - 1007. Minimum Domino Rotations For Equal Row", "url": "/posts/ps-leetcode-1007/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Array, Hash", "date": "2020-03-06 23:37:00 +0900", "snippet": " 1007. Minimum Domino Rotations For Equal Row - medium문제In a row of dominoes, A[i] and B[i] represent the top and bottom halves of the i-th domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)We may rotate the i-th domino, so that A[i] and B[i] swap values.Return the minimum number of rotations so that all the values in A are the same, or all the values in B are the same.If it cannot be done, return -1.제한사항 1 &amp;lt;= A[i], B[i] &amp;lt;= 6 2 &amp;lt;= A.length == B.length &amp;lt;= 20000입출력 예Example 1:Input: A = [2,1,2,4,2,2], B = [5,2,6,2,3,2]Output: 2Explanation: The first figure represents the dominoes as given by A and B: before we do any rotations.If we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.Example 2:Input: A = [3,5,1,2,3], B = [3,6,3,3,4]Output: -1Explanation: In this case, it is not possible to rotate the dominoes to make one row of values equal.풀이 Arrary, Hashclass Solution {public: int minDominoRotations(vector&amp;lt;int&amp;gt;&amp;amp; A, vector&amp;lt;int&amp;gt;&amp;amp; B) { int ans = INT_MAX; int n = A.size(); // map의 key를 주사위눈으로 하고, // value를 해당 주사위눈을 값으로 가지는 A,B의 index와, // 해당 index가 A,B중 어느 vector의 index인지 혹은 둘다 가지고 있는지 표기하는 값으로로 함. // 즉, A,B vector 끼리 바꿀시 해당 주사위눈으로 모두 만들때, // 결국 0 ~ n 까지 모든 index가 map의 key에 해당하는 주사위눈의 value에 모두 존재해야함 map&amp;lt;int, vector&amp;lt;pair&amp;lt;int,char&amp;gt;&amp;gt;&amp;gt; m; // vector를 한번 조회하여 map을 구성 for(auto i = 0 ; i &amp;lt; n ; ++i){ // 만약 해당 주사위눈에 대한 값이 서로 같은 index에 있으면 &#39;S&#39; 로 표기 if(A[i] == B[i]) m[A[i]].push_back({i, &#39;S&#39;}); // 서로의 각 i index에 해당하는 주사위눈에 대한 index와 &#39;A&#39;, &#39;B&#39;를 각각 표기 else { m[A[i]].push_back({i, &#39;A&#39;}); m[B[i]].push_back({i, &#39;B&#39;}); } } // 완성된 map을 조회 for(auto i : m){ // 현재 key의 주사위눈이 가지는 값이 A,B vector의 크기와 같다면, // A,B vector의 서로 원소 스왑으로 해당 주사위눈만 가지는 vector를 만들수 있다는 뜻 if(i.second.size() == n){ map&amp;lt;char, int&amp;gt; counting; // 기록된 표기별 카운팅 for(auto j = i.second.begin() ; j != i.second.end() ; ++j) ++counting[j-&amp;gt;second]; // A 기반으로 스왑하는게 더 적은수인지, 혹은 B 기반으로 스왑하는게 더 적은수인지 계산 // 이때 서로 겹치게 되는 &#39;S&#39;의 수를 별도로 빼줌 auto swapCount = (n - max(counting[&#39;A&#39;], counting[&#39;B&#39;])) - counting[&#39;S&#39;]; // 최소값 비교 ans = min(ans, swapCount); } } return ans != INT_MAX ? ans : -1; }};" }, { "title": "OS - 가상메모리", "url": "/posts/os-ch9/", "categories": "Operating System", "tags": "OS", "date": "2020-03-06 20:12:00 +0900", "snippet": "가상메모리 베경 요구 페이징 쓰기 시 복사 페이지 교체 프레임의 할당 스레싱 메모리 사상 파일 커널 메모리의 할당 배경가상 메모리(Virtaul Memory) 라는 것은 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 것이다. 이 기법의 가장 주요 장점중 하나는 사용자 프로그램이 물리 메모리(Pysical Memoey)보다 커져도 된다는 점이다. 물리 메모리보다 큰 가상 메모리를 보여주는 다이어그램 가상 메모리 는 실제 물리 메모리 개념과 사용자의 논리 메모리 개념을 분리한 것이다. 이렇게 함으로써 작은 메모리를 가지고도 얼마든지 큰 가상 공간을 프로그래머에게 제공할 수 있다는 점이다.한 프로세스의 가상 주소 공간 은 그 프로세스가 메모리에 저장되는 논리적인 모습을 말한다. 가상 주소 공간 논리 메모리를 물리 메모리로부터 분리시캬주는 것 외에 가상 메모리는 페이지 공유를 통해 파일이나 메모리가 둘 또는 그 이상의 프로세스들에 의해 공유되는 것을 가능하게 한다. 시스템 라이브러리가 여러 프로세스들에게 공유될 수 있다. 프로세스들이 메모리를 공유할 수 있다. 페이지는 fork() 시스템콜을 통한 프로세스 생성 과정중에 공유될수 있기 때문에 프로세스 생성 속도를 높일수 있다. 가상 메모리를 사용한 공유 라이브러리 요구 페이징실행 프로그램을 디스크에서 메모리로 적재 할때, 초기에 필요한 것들만을 적재 하는 전략이 있을수 있다. 이 기법을 요구 페이징(Demand Paging) 이라고 하며 가상 메모리 시스템에서 많이 사용되고 있다.요구 페이징을 사용하는 가상메모리에서는 페이지들이 실행과정에서 실제로 필요해 질 때 적재(Dynamic Load)된다.요구 페이징 기법은 어떤점에서 스와핑(swarpping) 기법과 유사하다. 디스크 내 인접한 공간과 페이지화 된 메모리의 이동 프로세스는 보조 메모리에 존재한다. 프로세스를 실행하고 싶으면 메모리로 읽어 들인다(Swap in). 이때 전체 프로세스를 읽어오지 않고 게으른 스왑퍼(lazy swapper) 또는 페이저(pager) 를 사용하여 그 페이지가 필요로 하는 부분만 메모리에 적재 시킨다.기본 개념요구 페이징을 수행하기 위해선 어느 페이지가 디스크에만 있고, 어느 페이지가 메모리에 올라와 있는지 구별할 수 있어야 한다. 따라서 하드웨어의 지원이며 페이지 테이블 에서 사용되었던 기법인 유효 무효 비트(valid/invalid bit) 기법이 사용된다. 그러나 이전의 페이지 테이블 과는 달리 이 비트가 유효(valid)하다고 설정되면 해당 페이지가 메모리에 있다는 의미이고, 무효(invalid)하다고 설정되면 해당 페이지가 유효하지 않거나(즉, 가상 주소 공간상에 정의되지 않거나) 유효하지만 디스크에 존재한다는 것을 의미한다.어떤 페이지를 무효로 설정하는 것은 그 페이지를 접근하기 전까지는 어떠한 영향도 끼치지 않는다는 점을 주의한다. 즉, 제대로 추측하여 실제로 접근될 페이지들만을 적재한 경우 프로세스는 모든 페이지가 메모리에 존재할 때와 동일하게 수행된다.프로세스가 메모리에 존재하는(Memory Resident) 페이지들만을 접근하는 한 실행은 정상적으로 진행된다. 일부 페이지가 주 메모리에 없을때의 페이지 테이블 프로세스가 메모리에 올라와 있지 않는 페이지를 접근하려고 하면, 이때는 페이지 테이블 항목이 무효로 되어 있으므로 페이지 부재 트랩(Page Fault Trap) 이 발생시킨다. 페이징 하드웨어는 페이지 테이블을 이용한 주소 변환 과정에서 무효 비트를 발견하고 OS에게 트랩을 건다. 이 트랩은 OS가 필요한 페이지를 적재하는데 실패했기 때문이다.페이지 부재를 처리하는 과정은 다음과 같다. 프로세스에 대한 내부 테이블(internal table : 일반적으로 PCB와 함께 유지) 을 검사하여 그 메모리 참조가 유효인지 무효인지 검사. 만약 프로세스가 무효한 페이지에 대한 참조라면 그 프로세스는 중단된다. 만약 유효한 참조인데 페이지가 아직 메모리에 올라오지 않았다면, 그것을 디스크로부터 가져와야 한다. 빈 공간, 즉 자유 프레임(Free Frame) 을 찾는다. 디스크에 새로이 할당된 프레임으로 해당 페이지를 읽어 들이도록 요청한다. 디스크 읽기가 끝나면, 이 페이지가 이제는 메모리에 있다는 것을 알리기 위해 페이지 테이블 을 갱신하며, 프로세스가 유지하고 있는 내부 테이블 을 수정한다. 트랩에 의해 중단되었던 명령어를 다시 수행한다. 이제 프로세스는 마치 그 페이지가 항상 메모리에 있었던 것 처럼 해당 페이지에 접근 할 수 있다. 페이지 부재를 처리하는 과정 필요한 모든 페이지가 적재되고 나면 더이상 부재 오류가 발생하지 않는다. 이것이 순수 요구 페이징(Pure Demand Paging) 이다. 즉, 어떤 페이지가 필요해지기 전까지는 결코 그 페이지를 메모리로 적재하지 않는 방법이다.요구 페이징 을 지원하기 위해 필요한 하드웨어는 페이징 과 스와핑 을 위한 하드웨어와 동일하다. 페이지 테이블(Page Table) 보호 비트(Protection Bit) 를 특별한 값 또는 유효/무효 비트(valid/invalid Bit) 를 통해 특정 항목을 무효로 설정할 수 있어야 한다. 보조 기억 장치(Secondary Memory) 주 메모리에 없는 모든 페이지들을 가지고 있다. 이를 스왑 장치 라고 하며, 이 목적을 위해 사용되는 디스크 영역를 스왑 공간(Swap Space) 라고 한다. 요구 페이징을 위한 필수적인 요구사항은 페이지 부재 오류 처리 후에 명령어 처리를 다시 시작할 수 있어야 한다는 것이다.쓰기 시 복사fork()는 부모 프로세스와 똑같은 자식 프로세슷 만들어 준다. 과거에는 fork()를 하면 부모 프로세스의 페이지들을 실제로 자식 프로세스에 복사해 줌으로써 자식 프로세스의 주소 공간을 구성해 주었다. 그렇지만 대부분의 자식들은 이렇게 만들어 지자마자 exec() 시스템콜을 한다. 그러면 부모로부터 복사해온 페이지들은 모두 쓸모없게 되게 된다. 그래서 부모의 페이지들을 복사해오는 대신 쓰기 시 복사(Copy on Write) 방식을 사용 할 수 있다.이 방식에서는 자식 프로세스가 시작할 때 부모의 페이지를 당분간 함께 사용하도록 한다. 이때 공유되는 페이지를 쓰기 시 복사 페이지 라고 표시한다. 프로세스 1이 페이지 C를 수정하기 전 프로세스 1이 페이지 C를 수정한 후 페이지 교체논리 주소의 page의 수가 프레임의 수보다 많이 지게 되면, 프레임들중 하나을 선택하여 이를 새로운 프레임과 교체해야 한다. 페이지 교체의 필요성 기본적인 페이지 교체만약 빈 프레임이 없다면 현재 사용되고 있지 않는 프레임을 찾아서 그것을 비워버린다. 그 프레임의 내용을 스왑 공간에 쓰고 그 페이지가 메모리에 더 이상 존재하지 않는다는 것을 나타내기 위해, 페이지 테이블을 변화 시킴으로서 프레임을 비어 있게 한다. 그리고 이제 비워진 프레임을 페이지 부재를 발생시킨 프로세스에서 사용할 수 있게 한다. 페이지 교체 페이지 부재 서비스 루틴이 페이지 교체를 포함하여 다음과 같이 과정이 진행 되어야 한다. 디스크에서 필요한 페이지의 위치를 알아낸다. 빈 페이지의 프레임을 찾는다. 2.1. 빈 프레임이 있다면 그것을 사용한다. 2.2. 없다면 희생될 프레임(victim frame) 을 선정하기 위해 페이지 교체 알고리즘 을 실행한다. 2.3. 희생될 페이지 를 디스크에 기록하고, 관련 테이블을 수정한다. 빼앗은 프레임에 새 페이지를 읽어오고 테이블을 수정한다. 페이지부재가 발생한 지점에서 부터 사용자 프로세스를 계속한다.요구 페이징 시스템은 두가지 중요한 문제를 해결하야 하는데, 프레임 할당 알고리즘(Frame Allocation Algorithm) 과 페이지 교체 알고리즘(Page Replacement Algorithm) 이다. 즉 여러 프로세스가 존재하는 경우 각 프로세스에 얼마나 많은 프레임을 할당해야 하는지, 페이지 교체가 필요할 때마다 어떤 페이지를 교체해야 할지 결정해야 한다.FIFO 페이지 교체(FIFO Page Replacement) FIFO 페이지 교체 알고리즘은, 어떤 페이지를 교체할 때 메모리에 올라온지 가장 오래된 페이지를 교체한다. FIFO 페이지 교체 알고리즘 FIFO 페이지 교체 알고리즘 은 이해하기도 쉽고 구현하기도 쉽지만, 성능이 항상 좋지만은 않다. 교체된 페이지가 오래 전 사용된 뒤 더이상 사용되지 않았던 초기화 모듈일수도 있고, 반대로 계속해서 자주 사용되는 변수를 포함하고 있을수도 있다.[ 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5 ] 와 같은 참조열이 있을떄, 아래 그림과 같은 페이지 부재율 대 할당된 프레임 수 의 그래프를 보여진다. FIFO 페이지 교체 알고리즘의 페이지 부재 그래프 위 그래프를 보면, 4개의 프레임을 할당했을시 페이지부재 10번이 일어났는데, 3개의 프레임을 할당하면 페이지 부재가 9번 일어남을 알 수 있다. 이러한 현상을 Belady의 모순(Belady’s Anomaly) 라고 부른다.Belady의 모순 은 프로세스에게 프레임을 더 주었는데 오히려 페이지 부재율은 더 증가 하는 현상을 말한다.최적 페이지 교체(Optimal Page Replacement) 최적 페이지 교체 알고리즘은, 어떤 페이지를 교체할 때 앞으로 가장 오랜 동안 사용되지 않을 페이지를 찾아 교체한다.이 알고리즘은 할당된 프레임수가 고정된 경우 가장 낮은 페이지 부재율 을 보장한다. 최적 페이지 교체 알고리즘 이 최적 페이지 교체 알고리즘 은 프로세스가 앞으로 메모리를 어떻게 참조할 것인지 미리 알아야 하기 때문에 실제 구현이 어렵다.LRU 페이지 교체(LRU Page Replacement) LRU 페이지 교체 알고리즘은, 어떤 페이지를 교체할 때 가장 오랜 기간 동안 사용되지 않은 페이지를 교체한다.LRU 페이지 교체 알고리즘 은 각 페이지 마다 마지막 사용 시간을 유지한다. 페이지 교체 시, LRU는 가장 오랫동안 사용되지 않은 페이지를 선택한다. LRU 페이지 교체 알고리즘 LRU 페이지 교체 알고리즘 은 구현하기 위해 하드웨어의 지원이 필요하다. 프레임들을 최근 사용된 시간 순서로 파악할 수 있어야 하는 것이다. 이를 구현하기 위해 크게 두가지의 구현 방법이 존재한다. 계수기(Counters) 가장 간단한 방법으로, 각 페이지 항목마다 사용 시간 필드를 넣고 CPU에 논리적인 시계나 계수기를 추가한다. 그리고 매번 메모리 접근마다 시간은 증가한다. 시간값이 가장 작은 페이지가 교체된다. LRU 페이지를 찾기 위해 페이지 테이블 을 탐색해야 한다. 스택(Stack) 페이지 번호의 스택을 유지하는 방법이다. 페이지가 참조될 때마다 페이지 번호는 스택중간에서 제거 되어 스택의 top에 놓이게 된다. 이런 방법으로 진행하다 보면 스택의 top은 항상 가장 최근에 사용된 페이지이고, bottom은 가장 오랫동안 이용되지 않은 페이지 이다. 매 갱신시에 약간 더 오버헤드가 크지만 교체가 일어날 경우 페이지 테이블 을 탐색할 필요가 없다. 가장 최근의 페이지 참조를 기록하기 위한 스택의 사용 최적 페이지 교체 알고리즘 과 마찬가지로 LRU 페이지 교체 알고리즘 은 Belady의 모순 을 일으키지 않는다. 이렇게 페이지 교체 알고리즘들 중에서 Belady의 모순 을 일으키지 않는 알고리즘들을 스택 알고리즘(Stack Alorithm) 이라고 부른다.LRU근사 페이지 교체(LRU Approximation Page Replacement)LRU 페이지 교체 알고리즘을 충분히 지원하는 하드웨어는 거의 없다. 그러나 많은 시스템은 참조비트(Reference Bit)의 형태로 어느정도 지원은 하괴있다.처음에 모든 참조비트는 OS에 의해 0으로 채워진다. 프로세스가 실행되면서 참조되는 페이지의 비트는 하드웨어가 1로 설정한다. 2차 기회(clock) 페이지 교체 알고리즘 계수 기반 페이지 교체(Counting Based Page Replacement)각 페이지를 참조할 때 마다 계수를 하여 페이지 교체에 사용하되는 두 알고리즘이 있다. LFU 알고리즘(Least Frequently Used Algorithm) LFU 알고리즘 은 참조 횟수가 가장 작은 페이지를 교체하는 방법이다. MFU 알고리즘(Most Freeuently Used Algorithm) MFU 알고리즘 은 가장 작은 참조 횟수를 가진 페이지가 가장 최근 참조됫 것이고 앞으로 사용될 것이라는 판단에 근거한 방법이다. 프레임의 할당여러개의 프로세스들에게 제한된 가용 메모리를 어떻게 할당할 것인가?최소로 할당해야할 프레임의 수(Minimum Number of Frames)최소한의 프레임을 할당해야만 하는 한가지 이유는 성능과 관계된다.각 프로세스에 할당되는 프레임 수가 줄어들면 페이지 부재율은 증가하고 프로세스의 실행은 늦어지게 된다. 또한 명령어 수행을 완료되기 전에 페이지 부재가 발생하면 그 명령어가 재실행되어야 한다. 즉, 하나의 명령어가 참조하는 모든 페이지는 동시에 메모리에 올라와 있어야 그 명령어의 수행이 끝날수가 있게 된다.프로세스의 최소 프레임 수는 아키텍처에 의해 결정되고 최대 할당 수는 가용 물리 메모리에 의해 결정된다.할당 알고리즘(Allocation Algorithm) 균등 할당 방식(Equal Allocation) 모든 프로세스에게 똑같이 할당한다. 비례 할당 방식(Proportional Allocation) 가용 메모리를 각 프로세스의 크기 비율에 맞추어 할당한다. 우선순위 할당 방식(Priority Allocation) 비례 할당 방식기반이지만, 프레임 비율을 프로세스의 크기가 아닌 우선순위를 사용하여 할당한다. 전역 대 지역 할당(Global / Local Allocation) 전역 교체(Global Replacement) 전역 교체 는 프로세스가 교체할 프레임을 다른 프로세스에 속한 프레임을 포함한 모든 프레임을 대상으로 찾는 경우이다. 지역 교체(Local Replacement) 각 프로세스가 자기에게 할당된 프레임등 중에서만 교체될 희생자를 선택할 수 있는 경우이다. 지역 교체 방법에서는 프로세스에 할당된 프레임의 수는 변하지 않는다. 전역 교체 하에서는 한 프로세스에 할당된 프레임의 수는 바뀔수 있다.일반적으로 전역교체가 지역교체 알고리즘보다 더 좋은 성능을 보이며, 더 많이 사용된다.비균등 메모리 접근(Non Uniform Memory Access)특정 보드 상의 CPU는 같은 보드의 메모리를 다른 보드의 메모리보다 더 빠르게 접근할 수 있다. 메모리 접근 시간이 현저하게 차이가 나는 시스템을 모두 비균등 메모리 접근(NUMA) 시스템 이라고 한다.어느 페이지를 어느 프레임에 할당하느냐 하는 정책이 NUMA의 성능에 커다란 영향을 미친다.스레싱어떤 프로세스가 충분한 프레임을 할당받지 못했다고 가정한다. 활발하게 사용되는 페이지 집합을 지원해 줄 만큼 프레임을 충분히 할당받지 못한 프로세스는 페이지 부재가 바로 발생할 것이다. 이떄 페이지 교체가 필요하지만 이미 활발하게 사용되는 페이지들 만으로 이루어져 있으므로 어떤 페이지가 교체되는 바로 다시 필요해 질 것이다. 결과적으로 바로 바로 반복해서 페이지 부재가 발생하며 교체된 페이지는 얼마 지나지 않아 다시 읽어올 필요가 생긴다. 이러한 과도한 페이징 작업을 스레싱(Thrashing) 이라고 부르며, 이는 어떤 프로세스가 실제 실행보다 더 많은 시간을 페이징에 사용되고 있을 경우를 뜻한다.스레싱의 원인일반적으로 스레싱은 전역 교환 알고리즘(Global Replacement) 상에서 발생한다.즉, 전역 교환 알고리즘 상에서 어떤 프로세스의 페이지인지에 대한 고려 없이 페이지 교체를 수행하려 하다보니, 페이지가 교체된 프로세스에게 필요한 페이지를 교체했을시 교체된 프로세스는 페이지 부재를 발생 시키고, 다시 다른 프로세스의 프레임을 가져올 것이다.스레일은 심각한 성능 저하를 초래한다.처음에는 다중 프로그래밍 정도가 높아지에 따라 CPU의 이용율도 높아진다. 증가속도가 감소하기는 하지만 최대값에 도달하기 까지 증가한다. 그러나 다중 프로그래밍 정도가 그 이상으로 더 커지면 스레싱이 일어나게 되고 CPU의 이용율은 급격히 떨어진다. 따라서 이 지점에서는 CPU의 이용룰을 높이고 스레싱을 중지시키기 위해 다중 프로그래밍 정도를 낮춰야 한다. 스레싱 스레싱은 지역 교환 알고리즘(Local Replacement) 이나 우선순위 교환 알고리즘(Priority Replacement) 을 사용하면 제한할 수 있다.작업 집합 모델(Working Set Model)스레싱 현상을 방지하기 위해서는 각 프로세스가 필요로 하는 최소한의 프레임 개수를 보장해야 한다.각 프로세스가 필요로하는 최소한의 프레임 수를 알기 위해 사용되는 한가지 방법은 작업 집합 방법(Working Set Method) 이다.작업 집합 방법 은 먼저 프로세스가 실제로 사용하고 있는 프레임의 수가 몇개인지를 알아보는 것에서 시작한다. 이 방법은 프로세스 실행의 지역성 모델(Locality Model) 을 기반으로 한다.지역성 모델 이란 프로세스가 실행될 때에는 항상 어떤 특정한 지역에서만 메모리를 집중적으로 참조함을 의미한다. 여기서 지역(Locality) 란, 집중적으로 함꼐 참조되는 페이지들의 집합을 뜻한다.한 프로그램은 여러개의 지역으로 구성되어 있고, 이 지역들은 서로 겹쳐질 수고 있다. 메모리 참조 패턴의 지역성(Locality) 작업 집합 모델 모든 프로세스 전체의 프레임 요구량이 시스템이 보유한 총 메모리의 크기보다 커지면 어떤 프로세스는 지역을 위한 충분한 프레임을 메모리에 가질 수 없기 때문에 스레싱을 유발한다.페이지 부재 빈도(PFF, Page Fault Frequency)페이지 부재 빈도 는 페이지 부재율의 상한과 하한을 정해놓고, 만약 페이지 부재율이 상한을 넘으면 그 프로세스에게 프레임을 더 할당해주고, 하한 보다 낮으면 그 프로세스의 프레임 수를 줄인다. 이렇게 함으로써 작업 집합 모델 보다 더 직접적으로 부재율을 관찰하고 조절함으로써 스레싱을 방지 할 수 있다. 페이지 부재 빈도 작업 집합과 페이지 부재율 메모리 사상 파일open(), read(), write() 시스템 호출을 사용하여 디스크에 있는 파일을 순차적으로 읽을떄, 이러한 방식을 사용하면 파일이 매번 액세스될 떄마다 시스템 호출을 해야하고 디스크에 접근해야 한다. 아와 같이 하는 대신 디스크 입출력을 가상 메모리 기법을 적용하여 메모리 참조 방식 으로 대신 할 수 있다. 이러한 접근 방식을 메모리 사상 방식(Memory Mapping Method) 라고 하며, 프로세스의 가상 주소 공간중 일부를 관련된 파일인 메모리 사상 파일(Memory Mapped File) 에 할애하는 것을 말한다. 메모리 사상 파일 메모리 사상 입출력을 사용한 공유 메모리 커널 메모리의 할당사용자 모드에서 수행중인 프로세스가 추가적인 메모리를 요구하면 커넣이 관리하는 가용 페이지 프레임에서 페이지들이 할당된다. 가용 리스트는 페이지 교체 정책들에 의해 물리 공간상에 여기 저기 흩어져 있는 페이지들로 채워진다.사용자 프로세스가 단 한 바이트만 필요로하는 경우라면 프로세스가 한 페이지 프레임을 할당 받았으므로 내부 단편회가 발생한다. 그러나 커널 메모리는 보통 사용자 모드 프로세스에게 할당해 주기 위한 페이지 리스트와는 별도의 메모리 풀에서 할당 받는다. 이렇게 하는 이유는 다음과 같다. 커널은 다양한 크기의 자료구조를 위해 메모리를 할당받는다. 가상 메모리 인터페이스를 통하지 않고 물리 메모리에 직접 접근하는 특정 하드웨어 장치는 물리적으로 연속적인 메모리를 필요로 하는 경우가 있다.커널 프로세스에 할당되는 메모리 관리 기법 버디 시스템(Buddy System) 물리적으로 연속된 페이지들로 이루어진 고정된 크기의 세그먼트로 부터 메모리를 할당한다. 메모리는 이 세그먼트로부터 2의 거듭제곱 할당기에 의해 2의 거듭제곱 단위로 할당 된다. 버디 시스템 의 장점중 하나는 합병(Coalescing) 이라고 부르는 과정을 통해 서로 인접한 버디들이 손쉽게 하나의 큰 세그먼트로 합쳐질 수 있다는 점이다. 버디 시스템에서의 할당 슬랩 할당(Slab Allocation) 슬랩(slab) 이라 불리는 하나 또는 그 이상의 연속된 페이지들로 구성된다. 캐시(cache) 는 하나 혹은 그 이상의 슬랩 들로 구성되어 있다. 각 커널 자료구조마다 하나의 캐시가 존재한다. 단편화에 의해 낭비되는 메모리가 없다. 메모리 요청이 빠르게 처리된다. 슬랩 할당 참고. operating system concepts(9E) - Abraham Silberschatz" }, { "title": "LeetCode - 130. Surrounded Regions", "url": "/posts/ps-leetcode-130/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, DFS, BFS", "date": "2020-03-05 03:02:00 +0900", "snippet": " 130. Surrounded Regions - medium문제Given a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’.A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region.제한사항입출력 예Example:X X X XX O O XX X O XX O X XAfter running your function, the board should be:X X X XX X X XX X X XX O X XExplanation:Surrounded regions shouldn’t be on the border, which means that any &#39;O&#39; on the border of the board are not flipped to &#39;X&#39;. Any &#39;O&#39; that is not on the border and it is not connected to an &#39;O&#39; on the border will be flipped to &#39;X&#39;. Two cells are connected if they are adjacent cells connected horizontally or vertically.풀이 DFS, BFSclass Solution {public: void BFS(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board, pair&amp;lt;int, int&amp;gt;&amp;amp;&amp;amp; index){ int n = board.size(); int m = board[0].size(); queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; q.push(index); while(!q.empty()){ auto i = q.front(); q.pop(); // &#39;*&#39;이면 이미 조회했으므로 건너뜀 if(board[i.first][i.second] == &#39;*&#39;) continue; // 현재 위치를 조회하지 않았다면, 현재값에서 주변을 탐색 else if(board[i.first][i.second] == &#39;O // 현재 값을 &#39;&#39;*&#39;로 바꿈으로써 조회했다는 것을 표시 board[i.first][i.second] = &#39;*&#39;; // 현재 위치에서 상하좌우를 탐색 하는데, // 값이 &#39;O&#39;인 것만 탐색 if(0 &amp;lt;= i.first - 1 &amp;amp;&amp;amp; board[i.first-1][i.second] == &#39;O&#39;) q.push({i.first - 1, i.second}); if(i.first + 1 &amp;lt; n &amp;amp;&amp;amp; board[i.first+1][i.second] == &#39;O&#39;) q.push({i.first + 1, i.second}); if(0 &amp;lt;= i.second - 1 &amp;amp;&amp;amp; board[i.first][i.second-1] == &#39;O&#39;) q.push({i.first, i.second - 1}); if(i.second + 1 &amp;lt; m &amp;amp;&amp;amp; board[i.first][i.second+1] == &#39;O&#39;) q.push({i.first, i.second + 1}); } } } void solve(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board) { if(board.empty()) return; int n = board.size(); int m = board[0].size(); // 첫번쨰 행의 BFS for(auto i = 0 ; i &amp;lt; m ; ++i) BFS(board, {0, i}); // 마지막 행의 BFS for(auto i = 0 ; i &amp;lt; m ; ++i) BFS(board, {n-1, i}); // 첫번쨰 열의 BFS for(auto i = 1 ; i &amp;lt; n - 1 ; ++i) BFS(board, {i, 0}); // 마지막 열의 BFS for(auto i = 1 ; i &amp;lt; n - 1 ; ++i) BFS(board, {i, m-1}); // 탐색한것을 기반으로 값을 변환 for(auto&amp;amp; row : board){ for(auto&amp;amp; val : row){ if(val == &#39;*&#39;) val = &#39;O&#39;; else if(val == &#39;O&#39;) val = &#39;X&#39;; } } }};type Index struct { first, second int}// 재귀로 구현한 BFSfunc BFS(board [][]byte, i Index){ n := len(board) m := len(board[0]) if board[i.first][i.second] == &#39;*&#39; { return } else if board[i.first][i.second] == &#39;O&#39; { // 현재 값을 &#39;&#39;*&#39;로 바꿈으로써 조회했다는 것을 표시 board[i.first][i.second] = &#39;*&#39;; // 현재 위치에서 상하좌우를 탐색 하는데, // 값이 &#39;O&#39;인 것만 탐색 if 0 &amp;lt;= i.first - 1 &amp;amp;&amp;amp; board[i.first-1][i.second] == &#39;O&#39; { index := Index{i.first - 1, i.second} BFS(board, index); } if i.first + 1 &amp;lt; n &amp;amp;&amp;amp; board[i.first+1][i.second] == &#39;O&#39; { index := Index{i.first + 1, i.second} BFS(board, index); } if 0 &amp;lt;= i.second - 1 &amp;amp;&amp;amp; board[i.first][i.second-1] == &#39;O&#39; { index := Index{i.first, i.second - 1} BFS(board, index); } if i.second + 1 &amp;lt; m &amp;amp;&amp;amp; board[i.first][i.second+1] == &#39;O&#39; { index := Index{i.first, i.second + 1} BFS(board, index); } }}func solve(board [][]byte) { if len(board) == 0 { return } n := len(board) m := len(board[0]) // 첫번쨰 행의 BFS for i := 0 ; i &amp;lt; m ; i += 1{ index := Index{0, i} BFS(board, index); } // 마지막 행의 BFS for i := 0 ; i &amp;lt; m ; i += 1{ index := Index{n-1, i} BFS(board, index); } // 첫번쨰 열의 BFS for i := 1 ; i &amp;lt; n - 1 ; i += 1{ index := Index{i, 0} BFS(board, index); } // 마지막 열의 BFS for i := 1 ; i &amp;lt; n - 1 ; i += 1{ index := Index{i, m-1} BFS(board, index); } // 탐색한것을 기반으로 값을 변환 for i, row := range board { for j := range row { if board[i][j] == &#39;*&#39; { board[i][j] = &#39;O&#39;; } else if board[i][j] == &#39;O&#39; { board[i][j] = &#39;X&#39;; } } }}" }, { "title": "virtual 함수의 내부 작동 방식", "url": "/posts/C++-vitual_operation_method/", "categories": "C++, etc", "tags": "C++, virtual function", "date": "2020-03-05 00:22:00 +0900", "snippet": "virtual 함수의 내부 작동 방식정적 바인딩(Static Binding)C++에서 클레스를 컴파일하면 그 클래스의 모든 함수를 담은 바이너리 객체가 생성된다. 그런데 컴파일러는 virtual 로 선언되지 않은 함수를 호출하는 부분을 컴파일 시간에 결정된 타입의 코드로 교체한다. 이러한 과정을 정적 바인딩(Static Binding) 또는 이른 바인딩(Early Binding) 이라 부른다.가상 테이블(vtable)함수를 virtual 로 선언하면 vtable(가상 테이블) 이라는 메모리 영역을 활용하여 가장 적합한 구현 코드를 호출한다.virtual 함수가 하나 이상 정의된 클래스마다 vtable 이 하나씩 존재하며, 이 클래스로 생성한 객체마다 이 vtable 에 대한 포인터를 가지게 된다. 따라서 객체에 대한 멤버함수를 호출하면 vtable 을 보고 그 시점에서 적합한 버전의 함수를 실행하게 된다.이러한 과정을 동적 바인딩(Dynamic Binding) 또는 늦은 바인딩(Late Binding) 이라 부른다.class Base { public: virtual void func1() {} virtual void func2() {} void nonVirtualFunc() {}}; class Derived : public Base { public: virtual void func2() override {} void nonVirtualFunc() {}};Base myBase;Derived myDerived;위와 같은 클레스를 정의한 상태에서의 vtable 의 구조는 아래 그림과 같다.virtual 키워드가 필요한 이유몇몇 사함들은 모든 멤버함수를 모두 virtual 로 선언하거나 컴파일러 차원에서 모든 멤버함수를 virtual 로 선언하여 동작해야 한다고 주장한다. 실제로 자바의 경우 모든 메서드를 virtual 메서드 취급하여 동작한다. C++에서는 왜 굳이 따로 virtual 키워드를 만들어서 사용할까?현 시대의 CPU성능으로 보면 크 차이는 굉장히 미비하지만 분명히 오버헤드 가 발생하기에, 모든 멤버함수를 virtual 로 취급하는 대신 virtual 키워드를 두어서 개발자에게 맡기는 방향으로 진행되었다.virtual 함수를 호출하려면 가장 적합한 코드를 선택하는 과정에서 포인터를 역참조해야 한다. 예를 들어 virtual 함수를 가진 Point 클래스로 수백만 또는 수십억개의 Point 객체를 만들어서 저장한다면 Point 객체마다 virtual 함수를 호출하여 엄청난 오버헤드 가 발생하게 된다. 또한 객체마다 메모리 오버헤드 도 발생한다. 함수 구현 코드 뿐만 아니라 객체마다 vtable 에 대한 포인터를 가져야 하기 때문에 작게나마 메모리 공간을 더 차지하게 된다.virtual 소멸자의 필요성소멸자를 virtual 로 선언하지 않으면 객체가 소멸할 때 메모리가 해제되지 않을 수 있기 때문에 항상 소멸자 만큼은 클래스를 final 로 선언할 때를 제외하고, 항상 virtual로 선언을 해야한다.예를 들어 파생 클래스의 생성자에서 동적으로 할당된 메모리를 사용하다가 소멸자에서 삭제하도록 작성했을 때, 소멸자가 호출되지 않으면 메모리가 해제되지 않는다. 마찬가지로 std::unique_ptr 처럼 파생 클래스에 자동적으로 삭제되는 멤버가 있을때 그 클래스의 인스턴스가 삭제될 때 소멸자가 호출되지 않으면 이런 멤버가 삭제되지 않고 남아 있게 된다.다음과 같은 예제를 확인해보면 쉽게 이해할 수 있다.class Base {public: Base() {} ~Base() {}};class Derived : public Base{public: Derived() { mString = new char[30]; cout &amp;lt;&amp;lt; &quot;mString allocated&quot; &amp;lt;&amp;lt; endl; } ~Derived() { delete[] mString; cout &amp;lt;&amp;lt; &quot;mString deallocated&quot; &amp;lt;&amp;lt; endl; }private: char* mString;};int main() { // mString이 여기서 할당된다. Base* ptr = new Derived(); // ~Base는 호출되지만 ~Derived는 호출되지 않는다. // 소멸자를 virtual로 선언하지 않았기 때문이다. delete ptr;}이 코드를 실행하면 Derived 객체의 소멸자가 호출되지 않는다.이러한 업캐스팅 시, 파생 클래스의 객체가 업 캐스팅 되기 때문에 기본 클래스로 인식이 되어 파생 클래스의 소멸자가 호출되지 않는 것이다.이와 같은 문제를 해결하기 위해 기본 클래스의 소멸자를 virtual 로 선언하고, 파생 클래스에서 소멸자를 구현한다면 정상적으로 파생 클래스의 소멸자가 호출된다.class Base {public: Base() {} virtual ~Base() {}};class Derived : public Base{public: Derived() { mString = new char[30]; cout &amp;lt;&amp;lt; &quot;mString allocated&quot; &amp;lt;&amp;lt; endl; } virtual ~Derived() override { delete[] mString; cout &amp;lt;&amp;lt; &quot;mString deallocated&quot; &amp;lt;&amp;lt; endl; }private: char* mString;};int main() { Base* ptr = new Derived(); delete ptr;} NOTE : 소멸자에서 따로 처리할 일은 없고 virtual로만 지정하고 싶다면 다음과 같이 디폴트로 지정한다.class Base {public: virtual ~Base() = default;};참고. Professional C++ 4/E - Marc Gregoire" }, { "title": "LeetCode - 70. Climbing Stairs", "url": "/posts/ps-leetcode-70/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, DP", "date": "2020-03-04 22:55:00 +0900", "snippet": " 70. Climbing Stairs - easy문제You are climbing a stair case. It takes n steps to reach to the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?Note: Given n will be a positive integer.제한사항입출력 예Example 1:Input: 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 stepsExample 2:Input: 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 step풀이 DPfunc climbStairs(n int) int { item := make([]int, n + 1) item[0] = 1 item[1] = 1 for i := 2 ; i &amp;lt;= n ; i += 1 { item[i] = item[i-1] + item[i-2] } return item[n]}" }, { "title": "LeetCode - 198. House Robber", "url": "/posts/ps-leetcode-198/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, DP", "date": "2020-03-04 21:15:00 +0900", "snippet": " 198. House Robber - easy문제You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.제한사항입출력 예Example 1:Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4.Example 2:Input: [2,7,9,3,1]Output: 12Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12.풀이 DPfunc MaxInt(x, y int) int { if x &amp;lt; y { return y } return x}func MaxElement(x []int) int { m := 0 for i, e := range x { if i == 0 || m &amp;lt; e { m = e } } return m}func rob(nums []int) int { if len(nums) == 0 { return 0 } else if len(nums) == 1 { return nums[0] } else if len(nums) == 2 { return MaxInt(nums[0], nums[1]) } else if len(nums) == 3 { return MaxInt(nums[1], nums[2] + nums[0]) } item := make([]int, len(nums)) item[0] = nums[0] item[1] = nums[1] item[2] = nums[0] + nums[2] for i := 3 ; i &amp;lt; len(nums) ; i += 1 { item[i] = MaxInt(item[i-2] + nums[i], item[i-3] + nums[i]); } return MaxElement(item)}" }, { "title": "OS - 메모리 관리 전략", "url": "/posts/os-ch8/", "categories": "Operating System", "tags": "OS", "date": "2020-03-04 20:12:00 +0900", "snippet": "메모리 관리 전략 베경 스와핑 연속 메모리 할당 세그먼테이션 페이징 페이지 테이블 구조 배경기본 하드웨어시스템이 올바르게 동작하기 위해서는 사용자 프로그램으로 부터 OS 영역을 보호해야한다. 다중 사용자 시스템인 경우 추가적으로 다른 사용자 프로그램이 특장 사용자 프로그램을 접근하는 것을 막는 것도 함께 이우어 져야 한다.OS가 CPU와 메모리 간의 접근중에 개입하게 되면 성능이 떨어지기 떄문에 이러한 보호기법은 반드시 하드웨어 차원에서 지원되어야 한다.각각의 프로세스가 독립된 메모리 공간을 가지도록 보장해야 한다. 개별적인 메모리 공간을 분리하기 위해서 특정 프로세스만 접근할 수 있는 합법저인 메모리 주소 영역을 설정하고, 프로세스가 합법적인 영역만을 접근 가능하도록 하는것이 필요하다.기준(base)와 상한(limit)라고 불리는 두개의 레지스터들을 사용하여 이러한 보호 기법을 제공한다. 기준 레지스터는 가장 작은 합법저긴 물리 메모리 주소의 값을 저장하고, 상한 레지스터는 주어진 영역의 크기를 저장한다. 기준과 상한 레지스터가 논리 주소공간을 정의 메모리 공간의 보혼는 CPU 하드웨어가 사용자 모드에서 만들어진 모든 주소와 레지스터를 비교함으로써 이루어 진다.사용자 모드에서 수행되는 프로그램에 의해 OS의 메모리 공간이나 다른 사용자 프로그램의 메모리 공간의 접근이 일어나면, OS는 치명쩍인 오류로 간주하고 트랩(Trap)을 발생시킨다. 이러한 기법은 사용짜 프로그램이 OS나 다른 사용자 프로그램의 코드나 데이터 구조를 수정하는 것을 막는다. 기준과 상한 레지스터 하드웨어를 통한 주소 보호 커넣모드에서 수행되는 OS는 OS 메모리 역역과 사용자 메모리 영역의 접근에 어떠한 제한을 받지 않는다. 이러한 원칙 때문에 OS는 사용자 프로그램을 사용자 메모리 영역에 적재, 오류가 발생한 경우에 그 프로그램을 덤프(dump), 시스템호출의 매개변수를 변경, 사용자 메모리로부터 입출력과 다른 많은 서비스들을 제공할 수 있다.주소의 할당(Address Binding)프로그램은 원래 이진 실행 파일 형태로 디스크에 저장됭어 있고, 이를 주 메모리로 올라와서 ‘프로세스’ 가 되야 한다.디스크에서 주 메모리로 들어오기를 기다리고 있는 프로세스들을의 집합을 입력 큐(Input Queue) 를 이룬다. 보통의 단일 태스킹의 작업절차는 이 입력 큐의 프로세스 중 하나를 선택하여, 메모리로 적재한다. 이 프로세스는 실행 중에 메모리에서 명령어와 데이터를 액세스한다. 언젠가 이 프로세스가 종료되면 이 프로세스가 사용했던 기억공간이 가용공간이 되어 다른 프로세스를 위해 사용된다.원시 프로그램에서 주소는 숫자가 아닌 변수 count와 같이 심볼 형태로 표현된다. 컴파일러는 이 심볼주소를 재배치 가능 주수로 바인딩(Binding) 시키고, 추후에 링커나 로더가 이 재배치 가능 주소를 절대 주소로 바인팅 시킨다. 각각의 바인딩 과정은 한 주소 공간에서 다른 주소공간으로 맵핑하는 것이다.전통적으로 메모리 주소공간에서 명령어와 데이터의 바인딩은 그 바인딩이 이루어지는 시점에 따라 다음과 같이 구분된다. 컴파일 시간 바인딩(Compile Time Binding) 프로세스가 메모리 내에 듫어갈 위치를 컴하일 시간에 미리 알 수 있으면 컴파일러는 절대코드 를 생성할 수 있다. 적재 시간 바인딩(Load Time Binding) 프로세스가 메모리 내 어디로 올라오게 될자를 컴파일 시점에 알지 못하면 컴파일러는 일단 이진코드를 재배치 가능 코드 로 만들어야 한다. 심볼과 진짜 번지수와의 바인딩은 프로그램이 주 메모리로 실쩨로 적재되는 시간에 이루어 진다. 재배치 가능 코드는 시작주소가 변경되면 아무때나 사용자 코드를 다시 적재하기만 하면 된다. 실행 시간 바인딩(Execution Time Binding) 프롯세스가 실행하는 중간에 메모리 내의 한 세그먼트로부터 다른 세그먼트로 옮겨 질 수 있다면 우리는 “바인딩이 실행 시간까지 허용되었다” 고 이야기 한다. 사용자 프로그램의 단계별 처리 과정 논리 대 물리 주소 공간(Logical Versus Physical Address Space)CPU가 생성하는 주소를 일반적으로 논리주소(Logical Address) 라 하며, 메모리가 취급하게 되는 주소(즉, 메모리주소 레지스터(MAR) 에 주어지는 주소)는 일반적으로 물리주소(Physical AAddresss) 라 한다.컴파일시 바인딩과 적재시의 바인딩 기법의 경우에는 논리주소와 물리주소가 같다.실행시간 바인딩 기법에서는 논리주소와 물리주소가 다르다. 이러한 경우, 논리주소를 가상주소(Virtual Address ) 라 한다.프로그램에 의해 생성된 모든 논리 주소의 집합을 논리 주소 공간(Logical Address Space) 라 하며, 이 논리주소와 일치하는 모든 물리 주소 집합을 물리 주소 공간(Physical Address Space) 라 한다.프로그램의 실행 중에는 이와 같은 가상주소를 물리 주소로 바꾸어 줘야 한는데 이 맵핑 작업은 하드웨어 장치인 메모리 관리기(MMU, Memory Managment Unit) 에서 실행된다.MMU에선 기준 레지스터를 재배치 레지스터(Relocation Register) 라고 부른다. 기준 레지스터 속에 들어있는 값은 주소가 메모리로 보내질 떄마다 그 모든 주소에 더해진다. 예를 들면 재배치 레지스터의 값이 14000일때, 프로세스가 346번지를 액세스 할때, 실은 주 메모리의 14346번지를 액세스 하게된다. 재배치 레지스터를 이용한 동적 재배치 사용자 프로그램은 실제적인 물리 주소를 알 수 없다는 것을 주의해야 한다 . 위의 그림에서 사용자 프로그램은 346번지에 대한 포인터를 생성해서 그것에 대해 저장, 연산, 다른주소들과 비교하는등 여러가지 일을 수행 할 수 있다. 그러나 일단 그것이 주소(간접 적재 및 저장)로 갈때는 기준 레지스터에 대해 다시 바인딩 된다. 사용자 프로그램은 논리 주소를 사용한 것이고, 메모리 하드웨어는 논리 주소를 실제 주소로 바꾼것이다 . 따라서 참조된 메모리 주소의 실제 위치는 이 참조가 실제 실행시간에 결정(실행시간 바인딩)된다.동적 적재(Dynamic Loading)지금까지의 내용에는 프로세스가 실행되기 위해 그 프로세스 전체가 미리 메모리에 올라와 있어야 했다. 이 경우 프로세스의 크기는 메모리의 크기보다 컷서는 안된다.메모리 공간을 보다 효율적으로 이용하기 위해선 동적 적재(Dynamic Loading) 을 해야한다.동적 적재에서 각 루팅은 실제 호출이 되기 전까지는 메모리에 올라오지 않고 재배치 가능한 상태로 디스크에서 대기 하고 있다.동적 적재는 루틴이 필요한 경우에만 적재하기 때문에 오류처리 루틴과 같이 아주 간혹 발생하면서도 많은 양의 코드를 필요로 하는 경우에 유용하다.동적 연결 및 공유 라이브러리(Dynamic Linking &amp;amp; Shared Libraries)동적 연결 라이브러리(Dynamic Linking Libraries) 는 사용자 프로그램이 실행 될때, 사용자 프로그램에 연결된는 시스템 라이브러리 이다.동적 적재에서는 로딩(loading)이 실행시까지 미루어졌겠지만, 동적 연결에서는 연결(linking)이 실행 시기까지 미루어지는 것이다. 동적 연결은 주로 시스템 라이브러리에 사용된다. 만일 이 방식이 없었다면 모든 시스템 라이브러리를 부른는 프로그램들은 그들의 이진 프로그램 이미지내에 시스템 라이브러비 루틴들을 한부씩 가지고 있어야 할 것이다.이러한 동적 연결은 라이브러리 루틴을 바꿀때 특히 유용하다. 여러 버전의 라이브러리 들이 시스템에 존재 할 수도 있기 때문에, 각 프로그램은 라이브러리의 어느 버전을 사용해야 할 것인지 판별하기 위해 이러한 버전 정보를 이용한다. 이러한 시스템을 공유 라이브러리(Shared Libraries)동적 연결과 공유 라이브러리는 동적 적재와 달리 OS의 도움이 필요하다.스와핑프로세스가 실행되기 위해선 메모리에 있어야 하지만, 프로세스는 실행중에 임시로 예비 저장장치(Backup Store) 로 내보내어졌다가(Swap Out) 실행을 계속하기 위해 다시 메모리로 되돌아올(Swap In) 수 있다.모든 프로세스의 물리주소 공간 크기의 총합이 시스템의 실제 메모리 크기보다 큰 경우에도 스와핑을 사용하면 동시에 실행 하는것이 가능하여 다중 프로그래밍의 정도를 증가시킨다. 디스크를 예비 저장장치로 사용하는 경우의 두 프로세스 스와핑 기본 스와핑(Standard Swapping)기본 스와핑은 메인 메모리와 예비 저장장치 사이에서 프로세스를 이동시킨다.이러한 스와핑의 경우 문맥교환 시간(Context Switch Time)이 상당히 오래 걸린다.연속 메모리 할당주 메모리는 OS뿐만 아니라 여러 사용자 프로세스도 수용해야 한다.메모리는 일반적으로 두개의 부분으로 나누어지는데, 하나는 메모리에 상주하는 OS를 위한 영역과 다른 하나는 사용자 프로세스를 위한 영역이다.보통 여러 프로세스가 동시에 메모리에 올라와 있는것이 바람직 하기 때문에, 메모리에 올라오고자 하는 Input Queue에서 대기중인 프로세스들에게 메모리를 얼마만큼씩 어떻게 할당할 것인가 라는 문제가 있다. 이러한 연속 메모리 할당(Contiguous Memory Allocation) 시스템에서는 각 프로세스는 다음 프로세스를 포함하는 영역과 연속된 하나의 메모리 영역을 차지하게 된다.메모리 보호(Memory Protection)프로세스가 자신이 소유하지 않은 메모리를 접근 할 수 없게 강제해야한다. 이는 시스템이 상한 레지스터 와 재배치 레지스터 를 가지고 있다면 해결할 수 있다.재배치 레지스터 는 가장 작은 물리 주소의 값을 저장하고, 상한 레지스터 는 논리 주소의 범위 값을 저장한다. MMU는 동적으로 논리 주소에 재배치 레지스터 의 값을 더함으로써 주소를 변환하는 역할을 한다. 이렇게 변환된 주소는 메모리로 보내어 진다. 재배치와 상한 레지스터를 지원하는 하드웨어 CPU 스케쥴러가 다음으로 수행할 프로세스를 선택할때, 디스패처(dispatcher)는 문맥교환의 일환으로 재배치 레지스터와 상한 레지스터에 정확한 값을 적재한다. CPU에 의해 생성되는 모든 주소들은 이 레지스터들의 값을 참조해서 확인 작업을 거치기 때문에, OS와 다른 사용자 프로그램을 현재 수행중인 사용자 프로그램의 접근으로부터 보호 할 수 있다.메모리 할당(Memory Allocation)가장 간단한 공간 할당 방법은 메모리를 똑같은 고정된 크기로 분할(Partition) 하는 것이다. 각 분할마다 한 프로세스를 가지고, 이때 분할의 개수를 다중 프로그래밍 정도(MultiProgramming Degree)이라고 부른다.가변분할 기법에서의 OS는 메모리의 어떤 부분이 사용되고 있고, 어떤 부분이 사용되지 않는지 파악할 수 있는 테이블을 유지한다. 초기에 모든 메모리 공간은 한개의 큰 사용 가능한 블록으로 간주한다.프로세스가 시스템에 들어오면, 일단 Input Queue에 넣는다. OS는 각 프로세스가 메모리를 얼마나 요구하며, 또한 사용 가능한 메모리 공간이 어디에 얼마나 있는지를 고려하여 공간을 할당한다. 프로새스가 공간을 할당받게 되면, 이후로는 CPU를 할당받기 위해 경쟁한다. 프로세스가 끝내면 메모리를 반납하고, OS는 Input Queue에 있는 다른 프로세스로 이 공간을 채운다.OS는 항상 놀고있는 공간들의 크기와 Input Queue를 유지해야 한다.일반적으로 메모리에는 다양한 크기의 자유 공간이 여기저기에 산재 하게 된다. 프로세스가 공간을 필요로 할때 OS는 이 자유 공간들의 집합에서 적절한 것을 찾아 내야 한다.일련의 자유 공간들의 리스트로부터 크기 n 바이트 블록을 요구하는 것을 어떻게 만족시켜 줄 것이냐를 결정한는 문제를 동적 메모리 할당 문제(Dynamic Memory Allocation Problem) 이라고 한다. 이 문제를 해결하기 위한 일반적인 방법은 아래와 같이 세가지가 있다. 최초 적합(Firtst Fit) 첫번째 사용간능한 가용공간을 할당 한다. 검섹은 집합의 시작에서부터 하거나 이전 검색이 끝난곳부터 시작될 수 있다. 충분히 큰 가용 공간을 찾았을때 검색이 끝난다. 최적 적합(Best Fit) 사용가능한 공간들 중에서 가장 작은것을 선택한다.(Hole은 n보다 크면서 가장 작은 Hole을 선택) 리스트가 크기순으로 되어있지 않다면 모든 리스트를 검색해야 한다. 아주 작은 가용공간을 만들어 낸다. 최악 적합(Worst Fit) 가장 큰 가용공간을 선택한다.(Hole은 n보다 크면서 가장 큰 Hole을 선택) 할당해주고 남게 된는 자유공간은 충분히 커서 다른 프로세스들을 위하여 유용하게 사용될 수 있다. 모의실험을 통해 연구한 결과, 최초적합과 최적적합이 시간과 메모리 이용 효율 측면에서 최악적합보다 좋단는 것이 입증되었다. 일반적으로 최초적합이 최적적합보다 속도가 더 빠르다.단편화(Fragmentation)동적 메모리 할당 문제에서의 최초적합, 최적적합, 최악적합 알고리즘은 외부 단편화(External Fragmentation, ‘fragment’는 공간중 일부가 사용 못하게 되는 부분) 을 발생한다.프로세스들이 메모리에 적재되고 제거되는 일이 반복되다보면, 어떤 자유공간은 너무 작은 조각이 되어 버린다. 외부 단편화 는 이처럼 유휴 공간들을 모두 합치면 충분한 공간이 되지만 그것들이 너무 작은 조각들로 여러 곳에 분산되어있을때 발생한다. 즉, 메모리는 너무 많은 수의 매우 작은 조각들로 단편화되어 있는것이다.외부 단편화를 해결하는 방법으로는 아래와 같은 방법이 있다. 압축(Compaction) 메모리의 모든 내용들을 한곳으로 몰고 모든 자유공간들을 다른 한곳으로 몰아서 큰 블록을 만든다. 압축은 프로세스들의 재배치가 실행 시간에 동쩍으로 이루어지는 경우에만 가능 재배치가 어셈블 또는 적재시에 정적으로 행해진다면 압축 실행 불가 메모리내의 전체 블록의 재배치가 필요하므로 비용이 많이듬 페이징과 세그먼테이션(Paging &amp;amp; Segmentation) 한 프로세스의 논리 주소 공간을 여러개의 비연속적인 공간으로 나누어 필요한 크기의 공간이 가용해지는 경우 물리 메모리를 프로세스에게 할당 메모리 공간을 낭비하는 현상인 단편화는 내부적으로도 발생 할 수 있다. 이를 내부 단편화(Internal Fragmentation) 이라고 하며, 이 내부 단편화 역시 사용이 못되는 부분이다.내부 단편화의 예로, 18,464B 크기의 자유로운 크기의 자유공간을 생각해본다. 어느 한 프로세스가 18,462B를 요구한다고 가정했을때, 요구된 블록을 정확히 할당하면 2B의 가용공간(hole)이 남는다. 이 경우 2B짜리의 가용공간을 놓치지 않기 위해 오히려 2B보다 더 큰 부담을 시스템이 가지게 될 것이다. 따라서 일반적으로는 메모리를 먼저 아주 작은 공간들로 분할하고 프로세스가 요청하면 할당을 항상 이 분할된 크기의 정수 배로만 해주는것이 보통이다. 이들 두 크기 사이의 남는 부분이 바 로 내부 단편화 이다.세그먼테이션사용자가 인지하는 메모리의 모습은 실제 물리 메모리의 모양과 같지 않다. 이러한 불편함을 해소하기위해, 프로그래머가 인지하는 메모리의 모습을 실제 물리 메모리의 모습을로 변환해주는 메모리 기법인 세그먼테이션 이 등장하게 된다.기본 방법일반적으로 프로그래머들은 메모리의 모습을 가변적인 길이를 갖지는 세그먼트의 집합 그리고 세그먼트 사이에는 어떠한 순서도 존재하지 않는 모습으로 생각하고 있다. 개발자가 생각하는 프로그램의 모습 세그먼테이션(Segmentation) 은 위와같이 프로그래머가 생가하는 모양을 그대로 지원하는 메모리 관리 기법이다.프로그래머가 생각하는 논리주소 공간은 세그먼트들의 집합으로 이루어진다. 각 세그먼트는 이름과 길이를 가진다.프로그램에서 사용되는 주소는 세그먼트의 이름과 세그먼트 안에서의 오프셋을 모두 명시한다. 따라서 프로그래머는 모든 주소를 세그먼트 이름과 오프셋의 두 부분 으로 나누어 명기 한다.구분을 쉽게 하기 위해 세그먼트 이름 대신에 세그먼트 번호가 시스템에 의해 정해진다. 즉, 시스템 내부에서 세그먼트는 번호로 불려진다.프로그램이 컴파일 될때 입력 프로그램을 반영하여 컴파일러가 자동으로 세그먼트를 생성한다. 예로 C 컴파일러는 다음과 같은 세그먼트들을 만들어 낸다. 코드 전역 변수 메모리 할당을 위한 힙(Heap) 각각의 스레드를 위한 스택(Stack) 표준 C 라이브러리하드웨어세그먼트 테이블(Segment Table) 의 각 항목은 세그먼트의 기준(base)과 세그먼트의 한계(limit)를 가지고 있다. 세그먼트 기준(Segment Base) 은 세그먼트의 시작주소를 나탄내며, 세그먼트 한계(Segment Limit) 는 세그먼트의 길이를 명시한다.논리주소는 두 부분으로 구성된다. 세그먼트 번호 s 와 그 세그먼트 내에서의 변위(offset) d 로 구선성된다. 세그먼트 번호 s 는 세그먼트 테이블에 대한 색인으로 사용된다. 변위 d 는 0과 세그먼트 크기 사이의 값이어야 한다. 그렇지 않을 경우엔는 트랩(trap)을 발생시킨다. 이 변위가 범위 안에 있으면 세그먼트 기준과 변위가 더해져 원하는 바이트의 실제 주소가 얻어진다 . 즉, 세그먼트 테이블은 기본적으로 기준/한계 레지스터들의 쌍으로 이루어진 배열이다 . 세그먼테이션 하드웨어 세그먼테이션의 예 페이징세그먼테이션은 프로세스가 적재되는 물리주소 공간이 연속적이지 않아도 적재를 허용한다. 페이징(Paging) 은 이러한 이점을 제공한는 또하나의 메모리 관리 기법이다.페이징은 외부단편화를 방지하고 단편화에 따른 압축작업이 필요없지만 세그먼테이션은 그렇지 않다. 또한 페이징은 스왑 아웃되는 다양한 크기의 세그먼트를 예비 저장장치에 저장해야하는 심각한 문제도 해결한다.기본방법물리 메모리는 프레임(Frame) 이라 불리는 같은 크기의 블록으로 나누어 진다. 논리 메모리는 페이지(Page) 라 불리는 같은 크기의 블록으로 나누어 진다.CPU에서 나오는 모든 주소는 페이지 번호(p) 와 페이지 변위(d: offset) 두개의 부분으로 나누어진다. 페이지 번호는 페이지 테이블(Page Table) 을 액세스 할 때 사용되며 페이지 테이블은 주 메모리에서 각 페이지가 점유하는 주소를 가지고 있다. 페이징 하드웨어 이러한 메모리의 페이징 모델애서, 페이지의 주소에 페이지 변위를 더하면 원하는 물리 주소가 된다. 논리 및 물리 메모리로 이루어진 페이징 모델 프레임의 크기와 같이 페이지의 크기도 하드웨어에 의해 정의된다. 페이지의 크기는 대개 컴퓨터 구조에 따라 페이지당 512B에서 16MB 사이이며 2의 제곱으로 증가한다. 만약 논리 주소 공간의 크기가 2^m 이고, 페이지가 2^n 크기라면 논리주소의 상위 m-n 비트는 페이지 번호를 나탄내고, 하위 n 비트는 페이지 변위를 나타낸다. 즉, 논리 주소는 다음과 같다. 예시 4B 페이지를 가진 32B 메모리의 페이징 예 페이징 그 자체는 동적 재배치의 한 형태이다. 모든 논리주소는 페이징 하드웨어에 의해 물리주소로 변환된다.페이징 기법을 사용하게 되면 외부 단편화 문제는 발생하지 않지만, 내부 단편화 문제가 발생한다. 할당은 항상 프레임의 정수 배로 할당되기 때문이다. 만약 프로세스가 페이지 경계와 일치하지 않는 크기의 메모리를 요구 한다면, 마지막 페이지 프레임은 전부 할당되지 않는다.이러한 내부 단편화를 어느정도 해결하기 위해 페이지의 크기를 줄이는 것이 바람직 해보이지만, 페이지의 크기가 작아진다면 그에 반비례하여 페이지 테이블의 크기가 커지게 되고 이 페이지 테이블이 차지하는 공간은 낭비된다.일반적으로 페이지 테이블의 각 엔트리는 4B이다. 그러나 이 크기도 바뀔수 있다. 32bit 엔트리는 2^32개의 물리 페이지 프레임을 가리킬수 있다. 프레임 크기가 4KB이면 4B크기의 엔트리는 2^44개의 물리 주소를 저장할 수 있다. 기용 프레임 (a) 할당 전, (b) 할당 후 OS는 메모리를 관리하기 때문에 물리 메모리의 자세한 할당에 대해 파악하고 있어야 한다. 즉, 어느 프레임이 할당되어 있고, 어느 프레임이 사용 가능한지, 총 프레임은 몇개나 되는지 등을 알아야 한다. 이러한 정보는 일반적으로 프레임 테이블(Frame Table) 이라는 자료구조에 있다.OS는 사용자가 시스템콜을 하여 매개변수로 어떤 주소를 주면, 해당 주소를 정확히 찾아가야 한다. 이를 위해 OS는 각 사용자에 대해 페이지 테이블의 복사본을 유지해야 한다.하드웨어 지원몇몇 OS는 각 프로세스마다 하나의 페이지 테이블을 할당한다. 페이지 테이블을 가리키는 포인터는 프로세스의 다른 레지스터 값과 함께 프로세스 제어 블록(PCB)에 저장된다.페이지 테이블에 레지슽터를 사용하는 것은 페이지 테이블의 크기가 작을 경우에는 적합하지만, 대부분의 시스템에서 페이지 테이블이 1백만 항목에 이를만큼 크기가 매우 크다. 즉, 레지스터를 사용하기엔 부적절하다. 이를 해결하기 위해 대부분의 시스템은 페이지 테이블을 주 메모리에 저장하고 페이지 테이블 기준 레지스터(PTBR, Page Table Base Register) 로 하여금 페이지 테이블을 가리키도록 한다.그런나 PTBR 방식의 문제점은 메모리 접근 시간이다. i번지에 있는 정보를 액세스하기 위해서 두번의 메모리 접근이 필요하다(페이지 테이블을 위해서 한번, 그 메모리 자체를 위해서 한번). 그래서 메모리 접근은 두 배 로 느려지게 된다.이러한 문젱에 대한 해결에는 TLB(Translation Lock-aside Buffers) 라고 불리는 특수한 소형 하드웨어 캐시가 사용된다. TLB는 매우 빠른 연관 메모리(associative memory)로 구성된다.TLB는 페이지 테이블의 일부분만 저장하며 TLB내의 각 항목은 키(key)와 값(value)의 두부분으로 구성된다. TLB에 페이지를 찾아달라고 요청이 들어오면, 이 찾고자 하는 페이지를 동시에 여러 개의 내부 키(페이지 번호)와 비교하여 페이지 번호가 같은 것이 발견되면 그에 대응하는 프레임 번호를 전달한다.만약 페이지 번호가 TLB내에서 찾아지지 않을때, 이러한 경우를 TLB miss 라고 한다. TLB miss가 일어나게 되면, 페이지 테이블에 접근하기 위한 메모리 참조가 일어난다. 이 참조는 CPU의 종류에 따라 하드웨어서 자동적으로 이루어 지거나 OS에게 인터럽트를 걸어 수행된다. 프레임 번호가 얻어지면, 메모리 접근을 위해 사용된다. 또한 새로운 페이지 번호와 프레임 번호를 TLB에 추가하여 다음 참조시 사용되도록 한다. 만약 TLB가 가득 차게되면, 기존 항목중에서 교체할 항목을 선택하여야 한다. 교체 정책은 LRU부터 라운드로빈, 무작위등 다양한 정책이 사용된다. 몇몇 TLB는 특정 항목들을 TLB에 고정시키는데, 이러한 항목들은 TLB에서 제거될 수 없다. 보통 주요 커넣코드를 TLB에 고정시킨다. TLB가 장착된 페이징 하드웨어 접근하는 메모리의 페이지 번호가 TLB에서 발견되는 비율을 적중률(Hit Ratio) 라고 한다.보호페이지화된 환경에서 메모리 보호는 각 페이지에 붙어있는 보호 비트(Protection Bit) 에 의해 구현되다. 이 비트들은 보통 페이지 테이블에 속해 있다.각 비트는 이 페이지가 읽고-쓰기 또는 읽기전용임을 각각 정의할 수 있다.페이지 테이블의 각 엔트리에는 유효/무효(valid/invalid) 라는 하나의 비트가 더 있다. 이 비트가 유효(valid) 로 성정되면 관련된 페이직가 프로세스의 합법적인 페이지임을 나타내며, 무효(invalid) 로 설정되면 그 페이진는 프로세스의 논리 주소 공간에 속하지 않는다는 것을 나타낸다. 페이지 테이블에서 유효(v)/뮤효(i) 비트 몇몇 시스템은 페이지 테이블의 크기를 나타내기 위해 페이지 테이블 길이 레지스터(Page Tabe Length Register)) 라는 레지스터를 제공한다.공유 페이지(Shared Pages)페이징의 또 다른 장점은 코드를 쉽게 공유 할 수 있다는 것이다. 페이징 환경에서의 코드 공유 페이지 테이블 구조계층적 페이징(Hierarchical Paging)페이지 테이블의 구성으로써 한가지 방법은 2단계 페이징 기법(two level paging scheme) 으로서 페이지 테이블 자체가 다시 페이지화 되는 것이다. 2단계 페이지 테이블 기법 2단계 32비트 페이징 구조에서의 주소 변환 예 위 그림에서 P1은 바깥 페이지 테이블의 인덱스이고, P2는 안쪽 페이지 테이블의 페이지 내의 변위이다.해시 페이지 테이블(Hashed Page Tables)주소공간이 32비트보다 커지면 가상주소를 해시로 사용하는 해시 페이지 테이블 을 많이 사용한다. 해시 페이지 테이블 64비트 시스템에서 유용하도록 변형된 해시 테이블 기법이 제안되었다. 이 변형 기법은 해시 테이블과 비슷한 클러스터 페이지 테이블 을 사용한다. 해시 테이블의 각 항목들이 한 개의 페이지만 가리키는 것에 반해 클러스터 페이지 테이블의 각 항목들은 여러 페이지를 가리킨다.역 페이지 테이블(Inverted Page Tables)보통 프로세스는 각자 하나씩 페이지 테이블을 가지고 또 페이지 테이블은 프로세스가 사용하는 각 페이지마다 하나의 항목을 가진다. 이러한 기법의 단점중 하나는 페이지 테이블의 크기이다.이 문제를 해결하는 한 방법은 역 페이지 테이블(Inverted Page Table) 이다. 역 페이지 테이블에서는 메모리 프레임마다 한 항목씩을 할당하다. 각 항목은 그 프레임에 올라와 있는 페이지 주소, 그리고 그 페이지를 소유하고 있는 프로세스의 ID를 표시하고 있다. 이렇게 되면 시스템에서는 단 하나의 페이지 테이블만 존재하게 되고, 테이블 내 각 항목은 메모리 한 프레임씩을 가맄키게 된다.그러나 역 페이지 테이블의 단점으로는 일치하는 값을 찾을때 때까지 찾으므로 오랜 탐색시간을 가질수 있다. 역 페이지 테이블 " }, { "title": "LeetCode - 897. Increasing Order Search Tree", "url": "/posts/ps-leetcode-897/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Tree", "date": "2020-03-03 02:34:00 +0900", "snippet": " 897. Increasing Order Search Tree - easy문제Given a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child.제한사항 The number of nodes in the given tree will be between 1 and 100. Each node will have a unique integer value from 0 to 1000.입출력 예Example 1:Input: [5,3,6,2,4,null,8,1,null,null,null,7,9] 5 / \\ 3 6 / \\ \\ 2 4 8 / / \\ 1 7 9Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 \\ 7 \\ 8 \\ 9 풀이 Tree/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* increasingBST(TreeNode* root) { vector&amp;lt;int&amp;gt; item; // inorder로 값 검색 inorder(root, item); // 새로운 트리 생성후 저장한 값 지정 TreeNode* node = new TreeNode(0); TreeNode* head = node; for(const auto&amp;amp; i : item){ head-&amp;gt;right = new TreeNode(i); head = head-&amp;gt;right; } return node-&amp;gt;right; } // 트리 inorder 탐색 void inorder(TreeNode* root, vector&amp;lt;int&amp;gt;&amp;amp; item){ if(root == nullptr) return; inorder(root-&amp;gt;left, item); item.push_back(root-&amp;gt;val); inorder(root-&amp;gt;right, item); }};" }, { "title": "LeetCode - 551. Student Attendance Record I", "url": "/posts/ps-leetcode-551/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Arrary", "date": "2020-03-03 01:53:00 +0900", "snippet": " 551. Student Attendance Record I - easy문제You are given a string representing an attendance record for a student. The record only contains the following three characters: ‘A’ : Absent. ‘L’ : Late. ‘P’ : Present.A student could be rewarded if his attendance record doesn’t contain more than one ‘A’ (absent) or more than two continuous ‘L’ (late).You need to return whether the student could be rewarded according to his attendance record.제한사항입출력 예Example 1:Input: &quot;PPALLP&quot;Output: TrueExample 2:Input: &quot;PPALLL&quot;Output: False풀이 Arraryclass Solution {public: bool checkRecord(string s) { int a_count = 0; int l_count = 0; for(const auto&amp;amp; i : s){ if(i == &#39;A&#39;){ ++a_count; l_count = 0; } else if(i == &#39;L&#39;) ++l_count; else l_count = 0; if(a_count &amp;gt; 1 || l_count &amp;gt; 2) return false; } return true; }};" }, { "title": "Casting", "url": "/posts/C++-casting/", "categories": "C++, etc", "tags": "C++, Modern C++, Casting", "date": "2020-03-03 00:22:00 +0900", "snippet": "CastingC++는 const_cast() , static_cast() , dynamic_cast() , reinterpret_cast라는() 라는 네가지 캐스팅 방법을 제공한다.const_cast()const_cast()는 변수에 const속성을 추가하거나 제거할 때 사용한다.정석대로 처리하려면 프로그램 전체에서 const로 정의한 부분에 대하여 일관성을 유지해야 하지만 서드파티 라이브러리와 같이 마음대로 수정할 수 없는 경우 어쩔수 없이 const속성을 일시적으로 제거할 수 밖에 없다.extern void ThirdPartyLibraryMethod(char* str); void f(const char* str){ ThirdPartyLibraryMethod(const_cast&amp;lt; char*&amp;gt; (str));}static_cast()명시적 타입 캐스팅static_cast()는 언어에서 제공하는 명시적 변환 기능을 수행한다.int i = 3;int j = 4;double res = static_cast&amp;lt;double&amp;gt;(i) / j;사용자 정의 생성자에서의 캐스팅사용자 정의 생성자나 변환 과정에서 허용하는 명시적 변환을 수행할 떄도 사용할 수 있다.예를 들어 A 클래스의 생성자 중에 B 클래스 객체를 인수로 받는 경우, B 객체를 A 객체로 변환하는데 static_cast()를 이용할 수 있다. 다만 이러한 변환은 대부분 컴파일러가 알아서 처리해준다.상속관계에서의 캐스팅상속 계츨에서 하위 타입으로 다운캐스팅 할때도 static_cast()를 사용한다.class Base {public: virtual ~Base() = default;};class Derived : public Base {public: virtual ~Derived() = default;}; int main() { Base* b; Derived* d = new Derived(); // 상속계층의 상위 타입으로 업캐스팅할 필요없다. b=d; // 상속계층의 하위 타입으로 다운캐스팅해야 한다. d = static_cast&amp;lt;Derived*&amp;gt;(b); Base base; Derived derived; Base&amp;amp; br = derived; Derived&amp;amp; dr = static_cast&amp;lt;Derived&amp;amp;&amp;gt;(br); return 0;}이러한 캐스팅은 포인터나 레퍼런스에도 적용할 수 있지만, 객체 자체에는 적용할 수 없다.이렇게 static_cast() 을 사용할 때는 실행 시간에 타입 검사를 수행하지 않는다.실행시간에 캐스팅 할 때는 Base와 Derived가 실제로 관련이 없어도 Base 포인터나 레퍼런스를 모두 Derived 포인터나 레퍼런스로 변환한다.예를 들어 아래와 같은 경우, 컴파일 과정과 실행 과정에 아무 문제가 발생하지 않지만, 포인터 d를 사용하다가 객체의 범위를 벗어난 영역의 메모리를 덮어쓰는 심각한 문제가 발생할 수 있다.Base* b = new Base();Derived* d = static_cast&amp;lt;Derived*&amp;gt;(b);불가능한 부분포인터 타입이 서로 관련 없을 때는 static_cast()를 적용할 수 없다. 또한 변환 생성자가 제공되지 않는 타입의 객체도 static_cast()를 적용 할 수 없다.const 타입을 non-const 타입으로 변환 할 수 없고, int에 대한 포인터에도 적용할 수 없다.기본적으로 C++의 타입규칙에 위배된는 것은 모두 할 수 없다.dynamic_cast()dynamic_cast()는 같은 상속 계층에 속한 타입끼리 캐스팅 할 떄 실행 시간에 타입을 검사한다. 포인터나 레퍼런스를 캐스팅할 떄 이를 이용할 수 있다.dynamic_cast()는 내부 객체의 타입 정보를 실행 시간에 검사한다. 그래서 캐스팅하는 것이 적합하지 않다고 판단되면 포인터에 대해선는 널 포인터를 반환하고, 레퍼런스에 대해서는 std::bad_cast 익셉션을 반환한다.예를 들어 다름과 같이 클래스 계층이 구성되어 있는경우를 살펴본다.class Base {public: virtual ~Base() = default;};class Derived : public Base{public: virtual ~Derived() = default;};이떄 올바른 dynamic_cast()에 대한 사용은 다음과 같다. 부모클래스가 자식클래스의 생성자로부터 생성된 후, 자식클래스로 다운캐스팅Base* b = new Derived();Derived* d = dynamic_cast&amp;lt;Derived*&amp;gt;(b); 자식클래스가 자식클래스의 생성자로부터 생성된 후, 부모클래스로 업캐스팅Derived* d = new Derived();Base* b = dynamic_cast&amp;lt;Base*&amp;gt;(d);반면 올바르지 못한 dynamic_cast()에 대한 사용은 다음과 같다. 부모클래스가 부모클래스의 생성자로부터 생성된 후, 자식클래스로 다운캐스팅Base* b = new Base();Derived* d = dynamic_cast&amp;lt;Derived*&amp;gt;(b);if(d == nullptr){ cout &amp;lt;&amp;lt; &quot;Bad cast!&quot; &amp;lt;&amp;lt; endl;}부모클래스가 자신의 생성자로부터 객체가 생성되므로, 자식클래스의 정보를 가지고 있지 않는다. 따라서 캐스팅할때 자식클래스의 생성자 정보를 모르므로 정상적인 캐스팅이 되지 않는다. 레퍼런스의 경우, 다음과 같이 적용하면 익셉션이 발생한다.Base base;Derived derived;Base&amp;amp; br = base;try { Derived&amp;amp; dr = dynamic_cast&amp;lt;Derived&amp;amp;&amp;gt;(br);}catch (const bad_cast&amp;amp;) { cout &amp;lt;&amp;lt; &quot;Bad cast!&quot; &amp;lt;&amp;lt; endl;}static_cast()나 reinterpret_cast()로도 같은 상속 계층의 하위 타입으로 캐스팅을 할 수 있다.차이점으로는 dynamic_cast()는 실행 시간에 타입 검사를 수행한는 반면, static_cast()나 reinterpret_cast()의 경우는 문제가 되는 타입도 그냥 캐스팅 해버린다는 것이다.실행시간의 타입정보는 객체의 vtable 에 저장된다. 따라서 dynamic_cast()를 적용하려면 클래스에 virtual 메소드가 적어도 한 개 이상 있어야 한다. 그렇지 않은 객체에 대해 dynamic_cast()를 적용하면 컴파일 에러가 발생한다.reinterpret_cast()reinterpret_cast()는 static_cast()보다 강력하지만 안전성은 좀 떨어진다.C++ 타입규칙에서 허용하지 않더라도 상황에 따라 캐스팅하는 것이 적합할 때 적용할 수 있다.예를 들어 서로 관련이 없는 레퍼런스끼리 변환할 수도 있다. 마찬가지로 상속계층에서 아무런 관련이 없는 포인터 타입끼리도 변환할 수 있다.이런 포인터는 흔히 void* 타입으로 캐스팅한다. 이 작 업은 내부적으로 처리되기 때문에 명시적으로 캐스팅하지 않아도 된다. 하지만 이렇게 void* 로 변환한 것을 다시 원래 타입으로 캐스팅할 때는 reinterpret_cast()를 사용해야 한다.class X {};class Y {};int main() { X x; Y y; X* xp = &amp;amp;x; Y* yp = &amp;amp;y; // 서로 관련 없는 클래스 타입의 포인터를 변환할 때는 reinterpret_cast()를 써야 한다. // static_cast()는 작동하지 않는다. xp = reinterpret_cast&amp;lt;X*&amp;gt;(yp); // 포인터를 void*로 변환할 때는 캐스팅하지 않아도 된다. void* p = xp; // 변환된 void*를 다시 원래 포인터로 복원할 때는 reinterpret_cast()를 써야 한다. xp = reinterpret_cast&amp;lt;X*&amp;gt;(p); // 서로 관련 없는 클래스 타입의 레퍼런스를 변환할 때는 reinterpret_cast()를 써야 한다. // static_cast()는 작동하지 않는다. X&amp;amp; xr=x; Y&amp;amp; yr = reinterpret_cast&amp;lt;Y&amp;amp;&amp;gt;(x); return 0;}reinterpret_cast ( )를 사용할 때는 주의해야 한다. 타입 검사를 하지 않고 변환할 수 있기 때문이다. CAUTION : 포인터를 int 타입으로 변환하거나 그 반대로 변환할 때도 reinterpret_cast()를 사용할 수있다.단,이때int의크기가포인터를담을정도로충분히커야한다.예를들어64비트포인터를32비트 int로 변환하는 작업을 reinterpret_cast ( )로 처리하면 컴파일 에러가 발생한다.캐스팅 정리 상황 캐스팅 방법 const 속성 제거 const_cast() 안에서 허용되는 명시적 변환(int -&amp;gt; double, int -&amp;gt; bool) static_cast() 사용자 정의 생성자나 변환 연산자에서 지원하는 명시적 변환 static_cast() 서로 관련없는 타입의 객체끼리 변환 불가능 같은 상속 계층에 있는 클래스 타입의 객체 포인터 사이의 변환 dynamic_cast() - 권장 static_cast() - 가능 같은 상속 계층에 있는 클래스 타입의 객체 레퍼런스 사이의 변환 dynamic_cast() - 권장 static_cast() - 가능 서로 관련 없는 타입의 포인서 사이의 변환 reinterpret_cast() 서로 관련 없는 타압의 레퍼런스 사이의 변환 reinterpret_cast() 함수 포인터 사이의 변환 reinterpret_cast() 참고. Professional C++ 4/E - Marc Gregoire" }, { "title": "OS - 교착상태", "url": "/posts/os-ch7/", "categories": "Operating System", "tags": "OS", "date": "2020-03-02 20:36:00 +0900", "snippet": "교착상태 개요 시스템 모델 교착상태의 특정 교착상태 처리 방법 교착상태 예방 교착상태 회피 교착상태 탐지 교착상태로부터 회복 개요다중프로그래밍 환경에서는 여러 프로세스들이 한정된 자원을 사용하려고 서로 경쟁할 수 있다. 한 프로세스가 자원을 요청했을때, 짱원ㄴ을 사용할 수 없는 상활이 발생 할 수 있고, 그 경우 프로세슨는 대기 상태로 들어간다. 이처럼 대기 상태인 프로세스들이 결코 다시는 그 상태를 변경시킬수 없으면, 이런 상황을 교착상태(DeadLock) 라고 한다.시스템 모델프로세스가 OS에게 자원을 요청하면, OS는 이를 확인하고 해당 프로세스에게 자원을 할당한다.정상적인 작동모드에서, 프로세스는 다음의 순서로만 자원을 사용할수 있다. 요청 프로세스는 자원을 요청한다. 자원이 다른프로세스에 의해 사용중인 상황과 같이 요청이 즉시 허용되지 않으면, 요창 프로세스는 자원을 얻을때까지 대기한다. 사용 프로세스는 자원에 대해 작업을 수행할 수 있다. 예를 들어 프린터가 자원이라면, 프로세스는 프린터로 인쇄를 할 수 있다. 방출 프로세스가 자원을 방출한다. 한 프로세스 집합 내의 모든 프로세스가 그 집합 내의 다른 프로세스에 의해서만 발생될 수 있는 사건을 기다린다면, 그 프로세스 집합은 교착상태에 있다. Mutex 락 사용시의 교착상태 교착상태의 특정필요조건교착상태는 한 시스템이 다음과 같이 네가지 쪼건이 동시에 성립될 떄 발생한다. 상호 배제(Mutual Exclusion) 최소한 하나의 자원이 비공유 모드로 점유되어야 한다. 비공유 모드에서는 한번에 한 프로세스만이 그 자원을 사용할 수 았다. 점유하며 대기(Hold and Wait)) 프로세스는 최소한 하나의 자원을 점유한 채, 현재 다른 프로세스에 의해 점유된 자원을 추가로 얻기 위해 반드시 대기 해야 한다. 비선점(No Preemption) 자원이 강쩨적으로 방출될 수 없고, 점유하고 있는 프로세스가 태스크를 종료한 후, 그 프로세스에 의해 자발적으로만 방출 될 수 있다. 순환 대기(Circular Wait)) 대기하고 있는 프로세스의 집합에서, 서로 다른 프로세스가 서로 필요한 자원을 점유하여 순환구조로 대기한다. 자원할당 그래프(Resource Allocation Grapth)교착상태는 시스템 자원 할닽 그래프 라고 하는 방향그래프로 보다 정확하게 기술할 수 있다. 이 그래프는 정점 V 의 집합과 간선 E 의 집합으로 구별된다. 프로세스 P와 자원 R 일때, 방향간선 P -&amp;gt; R 은 요청간선(Request Ddge) 라 하며, R -&amp;gt; P 는 할당간선(Assignment Edge) 라 한다. 자원 할당 그래프 자원 할당 그래프의 정의로부터, 우리는 만일 그래프가 사이클을 포함하지 않으면 시스템 내 어느 프로세스도 교착상태가 아님을 보일수 있다. 교착상태를 가진 자원 할당 그래프 사이클이 있으면서 교착상태가 아닌 자원 할당 그래프 위의 예에서, 프로세스 P2,P4가 끝나고 자원이 반납되면 남은 프로세스가 자원을 할당받게 되고, 고착상태 상황이 풀린다. Only one instance type -&amp;gt; deadlock multi instance type -&amp;gt; deadlock or not교착상태 처리 방법원칙적으로 교착상태 문제를 해결하기위해 세가지 다른방법이 있다. 시스템이 결코 교착상태가 되지 않도록 보장하기 위해 교착상태를 예방 하거나 회피 하는 프로토콜을 쩍용시킨다. 시스템이 교착상태가 되도록 허용한다면, 이를 회복 시킨다. 문제를 무시 하고, 교착상태가 시스템에서 결코 방생하지 않는 척 한다.세번째 해결안이 Linux와 Winodws를 포함해 대부분의 OS가 사용하는 방법이다. 쯕, 교착상태를 해결하는것은 프로그램을 작성하는 개발자의 몫이다.교착상태 예방교착상태 예방(Deadlock Prevention) 이란, 교착상태가 발생하기 위한 필요조컨들 중 적어도 하나가 성립되지 않도록 보장하는 방법이다.상호 배제(Mutual Exclusion)공유 가능한 자원들을 배타적인 접근을 요구하지 않도록하여 교착상태에 관련될 수 없도록 한다.점유하며 대기(Hold and Wait)프로세스가 자원을 요청할 때는, 다른 자원들을 점유하지 않을 것을 반드시 보짱한다.프로세스가 실행되기 전에 자신의 모든 자원을 요청하고 할당받을것을 요구하거나, 프로세스가 자원을 전혀 가지고 있지 않을때만 자원을 요청할수 있도록 허용하는 방안이 있다.이러한 방법에는 두가지 단점이 있다. 많은 자원들이 할당된 후, 오랜동안 사용되지 않기 때문에 자원의 이용도가 낮다. 기아상태를 유발시킬수 있다.비선점(No Preemption)만일 어떤 자원을 점유하고 있는 프로세스가 즉시 할당할 수 없는 다른 자원을 요청하면, 현재 점유하고 있는 모든 자원들이 선점된다. 즉 이들 자원들은 묵시적으로 방출된다.대안으로, 한 프로세스가 어떤 자원들을 요청하면, 우리는 이들이 사용 가능한지를 검사한다. 사용가능하다면 할당하고, 사용이 불가능 하다면, 그 자원들이 추가의 자원을 위해 대기하고 있는 어떤 다른 프로세스에 할당되어 있는지를 검사한다.순환 대기(Circular Wait)순환대기 조건이 성립되지 않도록하는 한가지 방법은 모든 자원 타입들에게 전체적인 순서를 부여하여, 각 프로세스가 열거된 순서대로 오름차순으로 자원을 요청하도록 요구하는 것이다.교착상태 회피교착상태 회피(Deadlock Avoidence) 이란, 프로세스가 일생동안 요구하고 사용할 자원에 대한 부갖적인 정보를 미리 제공할 것을 요구한다.교착상태 예방을 통해 해결할떄, 가능한 부수적인 문제는 장치의 이용률이 저하되고, 시스템 처리율(Throughput)이 감소된다는 것이다.교착상태 회피에 대한 가장 단순한 모델은, 각 프로세스가 자신이 필요로하는 각 타입의 자원마다 최대 수를 선언하도록 요구하는 것이다. 각 프로세스가 요청할 각 타입의 자원의 최대 수 정보를 미리 알 수 있다면, 시스템이 교착상태에 들어가지 않을것을 보장하는 알고리즘을 만들 수 있다.안전 상태(Safe Sate)시스템 상태가 안전 하단는 말은 시스템이 어떤 순서로든 프로세스들이 요청하는 모든 자원을 교착상태를 발생시키지 않고 차례로 모두 할당해 줄 수 있다는 것을 뜻한다.시스템의 상태가 안전하다면 교착상태가 아니다. 반면에 교착상태에 있는 시스템은 불안전한 상태에 있다. 하지만 불한전한 상태의 시스템이 반드시 교착상태를 발생시키지는 않는다. 안전, 불안전, 그리고 교착상태 공간 자원할당 그래프 알고리즘(Resource Allocation Grapth Algorithm)자원 할당 그래프의 변형을 사용하여 교착상태를 회피한다. 예약 간선(Claim Edge) 라는 새로운 간선을 추가한다. 예약 간선 P -&amp;gt; R는 P가 미래에 짜원 R을 요청할 것이라는 의미이다. 교착상태 회피를 위한 자원 할당 그래프 불안전 상태의 자원 할당 그래프 은행원 알고리즘(Banker’s Algorithm)자원 할당 그래프 알고리즘은 종류마다 짜원이 여러개씩 있게되면 사용할 수 없다.은행원 알고리즘을 도입한 시스템에서는 프로세스가 시작할 때 프로세스가 가지고 있어야할 자원의 최대 갯수를 자원 종류마다 미리 신고해야 한다.은행원 알고리즘을 구현하기 위해 몇가지 자료구조가 필요하다. n이 프로세스의 수이고, m은 자원의 종류수 라고 하자. Available[ m ] indicates how many resources are currently available of each type. Max[ n ][ m ] indicates the maximum demand of each process of each resource. Allocation[ n ][ m ] indicates the number of each resource category allocated to each process. Need[ n ][ m ] indicates the remaining resources needed of each type for each process. ( Note that Need[ i ][ j ] = Max[ i ][ j ] - Allocation[ i ][ j ] for all i, j. )안정성 알고리즘(Safery Algorithm)시스템이 안전한지 아닌지 알아내는 알고리즘은 다음과 같다. Let Work and Finish be vectors of length m and n respectively. 1.1. Work is a working copy of the available resources, which will be modified during the analysis. 1.2. Finish is a vector of booleans indicating whether a particular process can finish. ( or has finished so far in the analysis. ) 1.3. Initialize Work to Available, and Finish to false for all elements. Find an i such that both (A) Finish[ i ] == false, and (B) Need[ i ] &amp;lt; Work. This process has not finished, but could with the given available working set. If no such i exists, go to step 4. Set Work = Work + Allocation[ i ], and set Finish[ i ] to true. This corresponds to process i finishing up and releasing its resources back into the work pool. Then loop back to step 2. If finish[ i ] == true for all i, then the state is a safe state, because a safe sequence has been found.자원요청 알고리즘(Resource Request Algorithm)자원 요청이 안전하게 들엊줄 수 있는지를 검사하는 알고리즘이다. Let Request[ n ][ m ] indicate the number of resources of each type currently requested by processes. If Request[ i ] &amp;gt; Need[ i ] for any process i, raise an error condition. If Request[ i ] &amp;gt; Available for any process i, then that process must wait for resources to become available. Otherwise the process can continue to step 3. Check to see if the request can be granted safely, by pretending it has been granted and then seeing if the resulting state is safe. If so, grant the request, and if not, then the process must wait until its request can be granted safely.The procedure for granting a request ( or pretending to for testing purposes ) is: Available = Available - Request Allocation = Allocation + Request Need = Need - Reques 교착상태 탐지만일 시스템이 교착상태 예방이나 교착상태 방지 알고리즘을 사용하지 않는다면 교착상태가 발생 할 수 있다. 이러한 시스템은 다음과 같은 알고리즘을 반드시 지원해야 한다. 교착상태가 발생했는지 결정하기 위해 시스템의 상태를 검사하는 알고리즘 교착상태로부터 회복하는 알고리즘각 자원타입이 한개씩 있는 경우(Single Instance of Each Resource Type)모든 자원들이 한개의 인스턴스만 있다면, 대기 그래프(Wait for graph) 라고 한는, 자원 할당 그래프의 변형을 사용하여 교착상태 탐지 알고리즘을 정의할 수 있다. (a) 자원 할당 그래프, (b) 대응되는 대기 그래프 각 자원타입을 여러개 가진 경우(Several Instance of a Resource Type)대기 그래프의 경우, 각 쫑류마다 자원이 여러개씩 존재하는 상황일때는 사용항 수 없다.은행원 알고리즘과 마찬가지로 시시각각 내용이 달라지는 자료구조를 사용하며, 알고리즘은 아래와 같다. In step 1, the Banker’s Algorithm sets Finish[ i ] to false for all i. The algorithm presented here sets Finish[ i ] to false only if Allocation[ i ] is not zero. If the currently allocated resources for this process are zero, the algorithm sets Finish[ i ] to true. This is essentially assuming that IF all of the other processes can finish, then this process can finish also. Furthermore, this algorithm is specifically looking for which processes are involved in a deadlock situation, and a process that does not have any resources allocated cannot be involved in a deadlock, and so can be removed from any further consideration. Steps 2 and 3 are unchanged In step 4, the basic Banker’s Algorithm says that if Finish[ i ] == true for all i, that there is no deadlock. This algorithm is more specific, by stating that if Finish[ i ] == false for any process Pi, then that process is specifically involved in the deadlock which has been detected.교착상태로부터 회복프로세스 종료(Process Termination)프로세스를 중지시킴으로써 교착상태를 제거하기 위해 두 방법중 하나를 사용할 수 있다. 교착상태 프로세스를 모두 중지 이 방식의 경우 확실하게 교착상태의 사이클을 깰수 있지만, 비용이 크다. 교착상태가 쩨거될 때까지 한 프로세스씩 중지 각 프로세스가 중지될때 마다 교착생태 탐지 알고리즘을 호출하여 프로세스들이 아직도 교착상태에 있는지 확인하기 때문에 상당한 오버헤드가 유발한다. 만일 부분 종료방식을 사용한다면 교착상태인 프로세스들의 집합 중에서 교착상태를 깨트리기 위해 어느 프로세스를 중지해야 하는지 반드시 결졍 해야한다.어느 프로세스를 중지시킬 것인지 결정하는데 다음과 같은 요인이 있다. 프로세스의 우선순위가 무엇인지 지금까지 프로세스가 수행된 시간과 지정된 일을 종료하는데 까지 더 필요한 시간 프로세스가 사용한 자원 타입과 수 프로세스가 종료하기 위해 더 필요한 자원의 수 얼마나 많은 수의 프로세스가 종료되어야 하는지 프로세스가 대화형인지 일괄처리형 인지 여부자원 선점(Resource Preemption)자원 선점을 이용해 교착상태를 제거하기 위해선, 교착상테기 께어질 때까지 프로세스로부터 자원을 계속 선점해 이들을 다른 프로세스에게 준다.교착상태를 제거하기 위해 선점이 필요하다면 다음의 세가지 사항들을 고려해야 한다. 희생자 선탱(Selection of Victim) 어느 자원과 어느 프로세스들이 선점될 것인지 후퇴(Rollback) 프로세스로 부터 자원을 선점할떄, 해당 프로세슨는 어떻게 해야하는지(중지, 안전한 상태로 후퇴) 기아 상태(Starvation)) 자원들이 동일한 프로세스로부터 항상 선점되지 않도록 어떻게 보장할 것인지 " }, { "title": "LeetCode - 617. Merge Two Binary Trees", "url": "/posts/ps-leetcode-617/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Tree, Recursive", "date": "2020-03-02 00:36:00 +0900", "snippet": " 617. Merge Two Binary Trees - easy문제Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node.Otherwise, the NOT null node will be used as the node of new tree.제한사항 The merging process must start from the root nodes of both trees.입출력 예Example :Input: Tree 1 Tree 2 1 2 / \\ / \\ 3 2 1 3 / \\ \\ 5 4 7 Output: Merged tree: 3 / \\ 4 5 / \\ \\ 5 4 7풀이 Tree, Recursive/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) { if(t1 == nullptr &amp;amp;&amp;amp; t2 == nullptr) return nullptr; else if(t1 != nullptr &amp;amp;&amp;amp; t2 == nullptr) return t1; else if(t1 == nullptr &amp;amp;&amp;amp; t2 != nullptr) return t2; TreeNode* root = new TreeNode(t1-&amp;gt;val + t2-&amp;gt;val); root-&amp;gt;left = mergeTrees(t1-&amp;gt;left, t2-&amp;gt;left); root-&amp;gt;right = mergeTrees(t1-&amp;gt;right, t2-&amp;gt;right); return root; }};" }, { "title": "LeetCode - 429. N-ary Tree Level Order Traversal", "url": "/posts/ps-leetcode-429/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, DFS, BFS", "date": "2020-03-02 00:18:00 +0900", "snippet": " 429. N-ary Tree Level Order Traversal - medium문제Given an n-ary tree, return the level order traversal of its nodes’ values.Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).제한사항 The height of the n-ary tree is less than or equal to 1000 The total number of nodes is between [0, 10^4]입출력 예Input: root = [1,null,3,2,4,null,5,6]Output: [[1],[3,2,4],[5,6]]Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]Output: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]풀이 DFS, BFS/*// Definition for a Node.class Node {public: int val; vector&amp;lt;Node*&amp;gt; children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector&amp;lt;Node*&amp;gt; _children) { val = _val; children = _children; }};*/class Solution {public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(Node* root) { if(!root) return {}; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; // 트리의 depth를 key로 가지며 해당 deptp의 원소들을 가진 vector를 value로 가진 map map&amp;lt;int, vector&amp;lt;int&amp;gt;&amp;gt; m; queue&amp;lt;pair&amp;lt;Node*, int&amp;gt;&amp;gt; q; // BFS q.push({root, 1}); while(!q.empty()){ auto node = q.front(); q.pop(); // 현재 deptp에 원소의 값을 추가 m[node.second].push_back(node.first-&amp;gt;val); for(const auto&amp;amp; i : node.first-&amp;gt;children){ q.push({i, node.second + 1}); } } for(const auto&amp;amp; i : m) ans.push_back(i.second); return ans; }};" }, { "title": "LeetCode - 515. Find Largest Value in Each Tree Row", "url": "/posts/ps-leetcode-515/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, DFS, BFS", "date": "2020-03-02 00:00:00 +0900", "snippet": " 515. Find Largest Value in Each Tree Row - medium문제You need to find the largest value in each row of a binary tree.제한사항입출력 예Example :Input: 1 / \\ 3 2 / \\ \\ 5 3 9 Output: [1, 3, 9]풀이 DFS, BFS/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&amp;lt;int&amp;gt; largestValues(TreeNode* root) { if(!root) return {}; vector&amp;lt;int&amp;gt; ans; // 트리의 각 depth를 key값 으로 가지고, 최대값을 value로 가지는 map map&amp;lt;int, int&amp;gt; m; queue&amp;lt;pair&amp;lt;TreeNode*, int&amp;gt;&amp;gt; q; // BFS q.push({root, 0}); while(!q.empty()){ auto node = q.front(); q.pop(); // map의 key중에 현재 depth가 있으면 최대값 비교 // map의 key중에 현재 depth가 없으면 현재 노드의 값을 저장 if(m.find(node.second) != m.end()) m[node.second] = max(m[node.second], node.first-&amp;gt;val); else m[node.second] = node.first-&amp;gt;val; if(node.first-&amp;gt;left) q.push({node.first-&amp;gt;left, node.second + 1}); if(node.first-&amp;gt;right) q.push({node.first-&amp;gt;right, node.second + 1}); } for(const auto&amp;amp; i : m) ans.push_back(i.second); return ans; }};" }, { "title": "LeetCode - 1319. Number of Operations to Make Network Connected", "url": "/posts/ps-leetcode-1319/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, DFS, BFS", "date": "2020-03-01 02:53:00 +0900", "snippet": " 1319. Number of Operations to Make Network Connected - medium문제There are n computers numbered from 0 to n-1 connected by ethernet cables connections forming a network where connections[i] = [a, b] represents a connection between computers a and b. Any computer can reach any other computer directly or indirectly through the network.Given an initial computer network connections.You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected. Return the minimum number of times you need to do this in order to make all the computers connected.If it’s not possible, return -1.제한사항 1 &amp;lt;= n &amp;lt;= 10^5 1 &amp;lt;= connections.length &amp;lt;= min(n*(n-1)/2, 10^5) connections[i].length == 2 0 &amp;lt;= connections[i][0], connections[i][1] &amp;lt; n connections[i][0] != connections[i][1] There are no repeated connections. No two computers are connected by more than one cable.입출력 예Example 1:Input: n = 4, connections = [[0,1],[0,2],[1,2]]Output: 1Explanation: Remove cable between computer 1 and 2 and place between computers 1 and 3.Example 2:Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]Output: 2Example 3:Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]Output: -1Explanation: There are not enough cables.Example 4:Input: n = 5, connections = [[0,1],[0,2],[3,4],[2,3]]Output: 0풀이 DFS, BFSclass Solution {public: int makeConnected(int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; connections) { if(n - 1 &amp;gt; connections.size()) return -1; int countUnion = 0; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; connectionsMap(n, vector&amp;lt;int&amp;gt;()); vector&amp;lt;bool&amp;gt; visited(n, true); // connections기반으로 connectionsMap을 구성 for(const auto connection : connections){ connectionsMap[connection[0]].push_back(connection[1]); connectionsMap[connection[1]].push_back(connection[0]); } // index하나씩 검사하여 구성된 집함의 갯수를 조사 for(auto index = 0 ; index &amp;lt; n ; ++index){ // 현재 index에 대하여 이미 조회했다면 패스 if(!visited[index]) continue; stack&amp;lt;int&amp;gt; s; // DFS s.push(index); while(!s.empty()){ auto nodeIndex = s.top(); s.pop(); // 현재 index를 조회했으니 체크 visited[nodeIndex] = false; // 현재 index와 연결된 모든 노드들을 탐색 for(auto i : connectionsMap[nodeIndex]){ if(visited[i]){ s.push(i); } } } ++countUnion; } return countUnion - 1; }};" }, { "title": "LeetCode - 1306. Jump Game III", "url": "/posts/ps-leetcode-1306/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, DFS, BFS", "date": "2020-03-01 00:03:00 +0900", "snippet": " 1306. Jump Game III - medium문제Given an array of non-negative integers arr, you are initially positioned at start index of the array.When you are at index i, you can jump to i + arr[i] or i - arr[i], check if you can reach to any index with value 0.Notice that you can not jump outside of the array at any time.제한사항입출력 예Example 1:Input: arr = [4,2,3,0,3,1,2], start = 5Output: trueExplanation: All possible ways to reach at index 3 with value 0 are: index 5 -&amp;gt; index 4 -&amp;gt; index 1 -&amp;gt; index 3 index 5 -&amp;gt; index 6 -&amp;gt; index 4 -&amp;gt; index 1 -&amp;gt; index 3 Example 2:Input: arr = [4,2,3,0,3,1,2], start = 0Output: true Explanation: One possible way to reach at index 3 with value 0 is: index 0 -&amp;gt; index 4 -&amp;gt; index 1 -&amp;gt; index 3Example 3:Input: arr = [3,0,2,1,2], start = 2Output: falseExplanation: There is no way to reach at index 1 with value 0.풀이 DFS, BFSclass Solution {public: bool canReach(vector&amp;lt;int&amp;gt;&amp;amp; arr, int start) { stack&amp;lt;int&amp;gt; s; // checker for avoid visited twice vector&amp;lt;bool&amp;gt; visited(arr.size(), true); // DFS s.push(start); while(!s.empty()){ auto index = s.top(); s.pop(); // set &#39;true&#39; on now index; visited[index] = false; // found if(arr[index] == 0) return true; // jump left from now index as much as now index&#39;s value int leftIndex = index - arr[index]; if(leftIndex &amp;gt;= 0 &amp;amp;&amp;amp; visited[leftIndex]) s.push(leftIndex); // jump right from now index as much as now index&#39;s value int rightIndex = index + arr[index]; if(rightIndex &amp;lt; arr.size() &amp;amp;&amp;amp; visited[rightIndex]) s.push(rightIndex); } return false; }};" }, { "title": "OS - 프로세스 동기화", "url": "/posts/os-ch6/", "categories": "Operating System", "tags": "OS", "date": "2020-02-26 05:36:00 +0900", "snippet": "프로세스 동기화 배경 임계영역 문제 피터슨의 해결안 동기화 하드웨어 Mutex Locks 세마포 모니터 배경이번 챕터에선 프로세스가 병행 또는 병렬로 실행될 때 여러 프로세스가 공유하는 데이터의 무결성 에 대하여 설명한다. 생산자와 소비자 코드 예시 위 예시의 코드를 병행 실행하였을때, 문제가 발생한다. counter의 현재 값은 5이고 생산자와 소비자는 counter++와 couter–를 병행실행한다고 가정한다면, 이 두 명령을 수행하고나면 counter의 값은 4나 5나 6이 된다. 생산자와 소비자 프로세스의 명령 수행 동시에 여러 프로세스가 동일한 자료를 접근하여 조작하고, 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황을 경쟁 상황(Race Condition) 이라고 한다. 이를 해결하기 위해, 한 순간에 하나의 프로세스만이 서로 공유하고 있는 자료를 조작하도록 보장하여야 한다. 즉, 코드가 원자성(Atomic) 하게 실행되도록 보장하여야 한다.임계영역 문제n개의 프로세스가 있는 시스템을 고려했을때, 각 프로세스는 임계구역(Critical Section) 이라고 불리는 코드부분을 포함하고있고, 그 안에서는 다른 프로세스와 공유하는 변수를 변경하거나, 테이블을 갱신하거나 파일을 쓰거나 하는등의 작업을 수행한다. 이 시스템의 중요한 특징은 “한 프로세스가 자신의 임계구역에서 작업을 수행하는 동안에는 다른 프로세스는 그들의 임계구역에 접근할수 없다” 라는 점이다. 즉, 동시에 두 프로세스는 그들의 임계구역 안에서 실행할 수 없다.임계구역 문제(Critical Section Problem) 는 프로세스들이 협력할 때 사용할 수 있는 프로토콜을 설계하는 것이다.각 프로세스는 자신의 임계구역으로 접근하려 할때, 진입 허가를 요청한다. 이러한 요청을 구현하는 코드 부분을 진입구역(Entry Section) 이라 하며, 이후 임계구역을 빠져나오는 코드 부분을 퇴장구역(Exit Section) 이라 한다. 나머지 코드 부분은 나머지구역(Remainder Section) 이라고 불린다. 전형적인 프로세스 P_i의 일반적인 구조 임계구역 문제에 대한 해결안은 아래 세가지 요구조건을 충족해야 한다. 상호 배제(Mutual Exclusion) 프로세스 P_i 가 자기의 임계구역에서 실행된다면, 다른 프로세스들은 그들 자신의 임계구역에서 실행될수 없다. 진행(Progress) 자시의 임계구역에서 실행되는 프로세스가 없고, 그들 자신의 임계구역으로 진입하려고 하는 프로세스들이 있다면, 나머지 구역에서 실행 중이지 않은 프로세스들만 다음에 누가 그 임계구역으로 진입할 수 있는지를 결정하는데 참여할 수 있으며, 이 선택은 무기한 연장될수 있다. deadlock-free-condition 한정된 대기(Bounded Waiting) 프로세스가 자기의 임계구역에 진입하려는 요청을 한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 그들 자신의 임계구역에 진입하도록 허용되는 횟수에 한계가 있어야 한다. starvation-free-condition 피터슨의 해결안임계구역 문제를 해결하기 위해 상호배제, 진행, 한정된 대기의 요구조건을 충족하는 SW를 설계하는데 필요한 복잡성을 잘 설명하기 때문에 이 해결책을 제시한다.Peterson’s solution 에서는 두 프로세스가 두개의 데이터 항목을 공유하도록 하여 해결한다. int turn 임계구역으로 진입할 순번 bool flag[2] 프로세스가 임계구역으로 진입할 준비가 되어있다는것을 나타내는 배열 한 프로세스 P_i가 임계구역으로 진입하기 위해서, 먼저 flag[i]를 참으로 만들고, turn을 j로 지정한다. 이렇게 함으로써 프로세스 j가 임계구역으로 진입하기를 원한다면 진입 가능하다는 것을 보장한다. Peterson’s solution에서의 프로세스 P_i의 구조 동기화 하드웨어이번 챕터에서 설명하는 해결책들은 락킹(Locking) 에 대한 가정, 즉 임계구역을 보호하기 위한 방법에 대해 분석한다.임계구역 문제는 단일 처리기 환경에서는 공유 변수가 변경되는 동안 인터럽트 발생을 허용하지 않음으로써 간단히 해결할 수 있다.많은 현대의 기계들은 한 워드(word)의 내용을 검사하고 변경하거나, 두 워드의 내용을 원자적 으로 교환(swap)할 수 있는, 즉 인터럽트 되지 않는 하나의 단위로서, 특별한 하드웨어 명령어들을 제공한다.Mutex Locks임계구역을 보호하고, 경쟁조건을 방지하기 위해 mutex 락을 사용한다.프로세스는 임계구역에 들어가기 전에 반드시 락을 획득해야 하고, 임계구역을 빠져나올때 락을 반환해야 한다. acquire(), release() 함수 예시 Mutex 락을 사용한 임계영역 문제 해결방안 락을 획득하고 반환하는 acquire(), release() 함수 호출은 반드시 원자적으로 수행되어야 한다.mutex의 단점으로는 바쁜 대기(Busy Waiting) 혹은 Spinlock 을 해야 한다는 점이다. 프로세스가 임계구역에 들어가 있는동안 임계구역에 접근하고자 하는 다른 프로세스들은 acquire() 함수를 호출하는 반복문을 계속 실행하여야 한다. 즉 CPU 사이클을 낭비하게 된다. 하지만 락을 기다리는 동안 상당한 시간을 소모하는 문맥교환을 전혀 필요로 하질 않는다는 점이 있기 때문에, 프로세스들이 짧은 시간동안만 락을 소유할 것이라고 예상되면 유용하게 쓸수 있다.세마포세마포 S는 정수 변수로써, 초기화를 제외하고는, 단지 두개의 표준 원자적 연산 wait(), signal() 로만 접근이 가능하다. wait()와 signal() 정의 wait()과 signal() 연산 시 세마포의 정수 값을 변경하는 연산은 반드시 분리되지 않고 수행되어야 한다. 즉, 한 스레드가 세마포 값을 변경하면, 다른 어떤 스레드도 동시에 동일한 세마포 값을 변경할 수 없다.세마포 사용법OS는 종종 카운팅(counting) 과 이진(binary) 세마포를 구분한다. 카운팅 세마포(Counting Semaphore) 의 값은 제한 없는 영역을 가지며, 이진 세마포(Binary Semaphore) 의 값은 0과 1사이의 값만 가능하다.이진 세마포는 mutex 락과 유사하게 동작한다. 세마포를 이용한 상호 배제 구현 세마포는 가용한 자원의 개수로 초기화된다. 각 자원을 사용하려는 프로세스는 세모포의 wait() 연산을 수행하며, 이 때 세마포의 값은 감소된다. 세마포의 값이 0이 되면 모든 자원이 사용중임을 나타낸다. 이후 자원을 사용하려는 프로세스는 세마포의 값이 0보다 커질때 까지 block되어 대기한다.구현 세마포, wait(), signal() 구현 block() 연산은 자기를 호출한 프로세스를 중지 시킨다. wakeup(P) 연산은 중지된 프로세스 P의 실행을 재개시킨다. 일련의 과정은 아래와 같다. P1이 block() 호출 P1은 Waiting 상태가 되며 Waiting Queue에 넣어짐 다른 프로세스 P2에서 wakeup(P1) 호출 P1은 Ready 상태가 되며 Ready Queue에 넣어짐세마포가 원자적으로 실행되어야 한다는 것은 매우 중요하다. 같은 세마포에 대하여 두 프로세스가 동시에 wait()와 signal() 연산을 실행 할 수 없도록 반드시 보장하여야 한다. 이를 보장하기위해 다중 처리기 환경에서는 모든 처리기에서 인터럽트를 금지하여야만 한다.교착 상태와 기아대기 큐를 가진 세마포를 구현하는 두 개 이상의 프로세스들이 대기 중인 프로세스들 중 하나에 의해서만 야기될 수 있는 사건을 무한정 기다리는 상황이 발생할 수 있다. 이러한 상황을 교착상태(Deadlock) 이라고 한다. P0, P1간 세마포 동작 P0이 wait(S)를 실행하고, P1이 wait(Q)를 실행한다고 가정할때, P0이 wait(Q)를 실행 할때, P0는 P1이 signal(Q)를 실행할 때까지 기다려야 한다. 마찬가지로 P1이 wait(S)를 실행 할때, P1는 P0이 signal(S)를 실행할 때까지 기다려야 한다. 이들 signal() 연산들은 실행될 수 없기 때문에 P0와 P1은 교착상태가 된다.한 집합내의 모든 프로세스들이 그 집합 내의 다른 프로세스만이 유발할 수 있는 사건을 기다릴때, 이 프로세스들의 집합이 교착상태에 있다고 한다.교착상태와 연관된 다른 문제는 무한봉쇄(Indefinite Blocking) 와 기아상태(Starvation) 로서, 이들으 세마포에서 무한정 대기하는 것이다. 무한봉쇄는 우리가 세마포와 연관된 큐에서 프로세스들은 후입선출(LIFO) 순으로 제거할 경우 발생할 수 있다.모니터세마포의 경우, 세마포를 이용하여 임계구역 문제를 해결하고자 할떄, 프로그래머가 세마포를 잘못하용하면 다얀한 유형의 오류가 쉽게 발생될수 있다. 이러한 문제를 해결하기 위해 고급 언어 구조물들이 등장하게 되는데, 이러한 고급 언어 구조물중 하나가 모니터(Monitor) 이다. monitor의 구문 모니터 사용법모니터 구조물은 모니터 안에 항상 하나의 프로세스만이 활성화 되도록 보장한다. 이러한 동기화 기법은 condition 이라는 구조물로 제공된다.condition 형 변수에 호출될 수 있는 연산은 오직 wait()과 signal() 연산 이다. 연산 x.wait()는, 이 연산을 호출한 프로세스가 다른 프로세스의 x.signal() 연산을 호출할 때까지 일시중단 되어야 한다는 것을 의미한다. monitor의 구조 x.signal() 연산은 정확히 하나의 일시중단 프로세스를 재개한다. 만약 일지중단된 프로세스가 없다면 signal() 연산은 아무 소용이 없다.x.signal() 연산이 프로세스 P에 의하여 호출될때, 조건 x와 연관되어 있는 일시중단된 프로세스 Q가 있다고 가정할때, 만일 일시중단된 스레드 Q가 실행을 재개하도록 허용된다면, signal을 보낸 스레드 P는 반드시 대기하여야 한다. 그렇지 않으면, P와 Q는 모니터 안에서 동시에 활성화 된다.두 프로세스들은 개념적으로 그들의 실행을 계속할 수 있는데, 아래 두가지 가능성이 존재한다. Signal and wait P는 Q가 모니터를 떠날 때까지 기다리거나 다른조건을 기다린다. Signal and continue Q는 P가 모니터를 떠날 때까지 기다리거나 다른 조건을 기다린다. 조건변수를 가지는 monitor 세마포를 이용한 모니터의 구현각 모니터마다 mutex라는 세마포가 정의되고 그 초기 값은 1이다. 프로세스는 모니터로 들어가기 전에 wait(mutex)를 호출하고 모니터를 나온 후에 signal(mutex)를 호출해야 한다.signaling 프로세스는 자신을 중단시키기 위해 next라는 또다른 세마포를 사용할 수 있다. ㅅ 세마포를 이용한 모니터에서의 상호배제 조건변수를 가지는 세마포의 Wait(), Signal() 모니터 내에서 프로세스 수행재개 하나의 자원을 할당해주는 모니터 프로세스들이 올바른 순서로 동작하도록 순서를 보장하기 위해 두가지 조건을 검사하여야 한다. 프로세스들이 모니터를 정확한 순서에 맞추어 호출하는지 검사 비협조적인 프로세스가 액세스 제어 프로토콜을 사용하지 않아서 모니터가 정한 상호 배제 규칙 경로를 무시하여 공유 자원을 직접 액세스 하지 않는다는 것을 보장" }, { "title": "LeetCode - 300. Longest Increasing Subsequence", "url": "/posts/ps-leetcode-300/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, DP", "date": "2020-02-26 02:40:00 +0900", "snippet": " 300. Longest Increasing Subsequence - medium문제Given an unsorted array of integers, find the length of longest increasing subsequence.제한사항 There may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity. Could you improve it to O(n log n) time complexity?입출력 예Example 1:Input: [10,9,2,5,3,7,101,18]Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. 풀이 DPclass Solution {public: int lengthOfLIS(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if(nums.empty()) return 0; vector&amp;lt;int&amp;gt; item(nums.size(), 1); for(auto i = 1 ; i &amp;lt; nums.size() ; ++i){ // 현재 index 이전의 값을 조사 for(auto j = 0 ; j &amp;lt; i ; ++j){ // 현재 index값보다 작은 값일때, // (현재 index의 값)과 (이전 index의 값 + 1)을 비교하여 큰값을 저장 // 가장긴 increasing subsequence이므로, // 이전값에 현재 자기를 포함한 subsequence 이므로 +1 힘 if(nums[j] &amp;lt; nums[i]){ item[i] = max(item[i], item[j] + 1); } } } return *max_element(item.begin(), item.end()); }};class Solution {public: int lengthOfLIS(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; res; for(auto i = 0; i &amp;lt; nums.size(); ++i) { // low_bound를 통해 현재 index의 값과 // res의 값을 비교하여 위치할 곳을 찾음 auto it = std::lower_bound(res.begin(), res.end(), nums[i]); // 현재 index의 값이 res내의 값들보다 크다면 // res에 현재 index의 값 추가 if(it == res.end()) res.push_back(nums[i]); // 현재 index의 값이 res에 위치할 곳이 잇다면, // 위치할곳의 값과 현재 index의 값과 바꿈 else *it = nums[i]; } // input이 [0, 4, 1, 5, 12, 2] 일때, // 반복 횟수에 따른 res의 값들은 아래와 같음 // 0 // 0 4 // 0 1 // 0 1 5 // 0 1 5 12 // 0 1 2 12 return res.size(); }};" }, { "title": "LeetCode - 322. Coin Change", "url": "/posts/ps-leetcode-322/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, DP", "date": "2020-02-26 01:55:00 +0900", "snippet": " 322. Coin Change - medium문제You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.제한사항 You may assume that you have an infinite number of each kind of coin.입출력 예Example 1:Input: coins = [1, 2, 5], amount = 11Output: 3 Explanation: 11 = 5 + 5 + 1Example 2:Input: coins = [2], amount = 3Output: -1풀이 DPclass Solution {public: int coinChange(vector&amp;lt;int&amp;gt;&amp;amp; coins, int amount) { if(amount &amp;lt; 1) return 0; // amount까지의 길이를 가지는 임시 vector 생성 // 비교를 위해 적당히 큰수를 기본으로 가짐 vector&amp;lt;int&amp;gt; item(amount+1, (INT_MAX &amp;gt;&amp;gt; 2)); // coins 벡터에 포함된 coin == amount 일때, // 최소 coin의 수는 자기 자신인 1임 for(const auto&amp;amp; coin : coins){ if(coin &amp;lt;= amount) item[coin] = 1; } // 값이 1부터 최종 목적인 amount까지 반복 for(auto val = 1 ; val &amp;lt;= amount ; ++val){ // 조합할 각 단위의 coin별로 만들수 있는 최소값을 계산 // coin이 [1,2,5] 일때, val = 10 이라면, // item[10] = min(item[10], item[10 - 1] + 1) // item[10] = min(item[10], item[10 - 2] + 1) // item[10] = min(item[10], item[10 - 5] + 1) // 즉, 해당 코인으로 만들수 있는 최소값을 각각 계산하여 // 최후의 최소값을 저장 int minVal = INT_MAX; for(const auto&amp;amp; coin : coins){ if(val - coin &amp;gt;= 0 &amp;amp;&amp;amp; item[val - coin] &amp;gt; 0){ item[val] = min(item[val], item[val - coin] + 1); } } } // 구하고자 하는 amout가 현재 코인으로 만들수 있는 조합이 아니라면, // 초기에 설정한 적당한 크기의 값이 저장되어 있으므로 이를 -1로 리턴 return item[amount] != (INT_MAX &amp;gt;&amp;gt; 2) ? item[amount] : -1; }};" }, { "title": "LeetCode - 55. Jump Game", "url": "/posts/ps-leetcode-55/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, DP, Greedy", "date": "2020-02-26 00:03:00 +0900", "snippet": " 55. Jump Game - medium문제Given an array of non-negative integers, you are initially positioned at the first index of the array.Each element in the array represents your maximum jump length at that position.Determine if you are able to reach the last index.제한사항입출력 예Example 1:Input: [2,3,1,1,4]Output: trueExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.Example 2:Input: [3,2,1,0,4]Output: falseExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.풀이 DP, Greedyclass Solution {public: bool canJump(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int dis = 0; // index 0 부터 현재 index에서 점프할수 있는 최대 점프한 뒤의 index까지 반복 // 반복을 수행하며 index i는 하나씩 증가하며, // 점프할수 있는 최대 거리의 index 또한 증가하는 index i의 값을 통해 변함 for (int i = 0; i &amp;lt;= dis; ++i) { // 현재까지의 구한 최대 거리 index 와 index에서 갈수 있는 최대 점프후 도착하는 위치의 index를 비교 // input = [2,3,1,1,4] 이며, i = 0, dis = 0 일때, // dis = max(0, 2+0) = 2 // dis가 2가 되면서 반복문을 최대 2까지 반복할수 있음 // 즉 점프할수 있는거리가 2까지 늘어나게됨 dis = max(dis, nums[i] + i); // 저장한 현재 거리가 vector의 인덱스보다 크면 참 if(dis &amp;gt;= nums.size() - 1) return true; } return false; }};" }, { "title": "LeetCode - 17. Letter Combinations of a Phone Number", "url": "/posts/ps-leetcode-17/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, String, BackTracking", "date": "2020-02-25 06:48:00 +0900", "snippet": " 17. Letter Combinations of a Phone Number - medium문제Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.제한사항 Although the above answer is in lexicographical order, your answer could be in any order you want.입출력 예Input: &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].풀이 String,BackTrackingclass Solution {public: void backTracking(const string&amp;amp; digits, const int&amp;amp; index, const string&amp;amp; now, vector&amp;lt;string&amp;gt;&amp;amp; ans){ // 현재 digits의 index가 digits.size()보다 커지면, // 현재까지 구성한 문자열을 정답 vector에 저장 if(index &amp;gt; digits.size() - 1){ ans.push_back(now); return; } // 미리 구성한 keypad의 index 계산 // 현재까지 구성한 문자열에 지금 숫자의 keypad에 할당된 모든 새로운 문자 추가 int digitIndex = digits[index] - &#39;0&#39;; for(const auto&amp;amp; i : keypad[digitIndex]){ string nowStr = now; nowStr.push_back(i); backTracking(digits, index + 1, nowStr, ans); } }; vector&amp;lt;string&amp;gt; letterCombinations(string digits) { if(digits.size() &amp;lt; 1) return {}; vector&amp;lt;string&amp;gt; ans; backTracking(digits, 0, &quot;&quot;, ans); return ans; } private: vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; keypad = { {}, {}, {&#39;a&#39; , &#39;b&#39;, &#39;c&#39;}, {&#39;d&#39; , &#39;e&#39;, &#39;f&#39;}, {&#39;g&#39; , &#39;h&#39;, &#39;i&#39;}, {&#39;j&#39; , &#39;k&#39;, &#39;l&#39;}, {&#39;m&#39; , &#39;n&#39;, &#39;o&#39;}, {&#39;p&#39; , &#39;q&#39;, &#39;r&#39;, &#39;s&#39;}, {&#39;t&#39; , &#39;u&#39;, &#39;v&#39;}, {&#39;w&#39; , &#39;x&#39;, &#39;y&#39;, &#39;z&#39;} };};" }, { "title": "LeetCode - 559. Maximum Depth of N-ary Tree", "url": "/posts/ps-leetcode-559/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Tree", "date": "2020-02-23 06:20:00 +0900", "snippet": " 559. Maximum Depth of N-ary Tree - easy문제Given a n-ary tree, find its maximum depth.The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).제한사항 The depth of the n-ary tree is less than or equal to 1000. The total number of nodes is between [0, 10^4].입출력 예Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]Output: 5Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]Output: 5풀이 Tree/*// Definition for a Node.class Node {public: int val; vector&amp;lt;Node*&amp;gt; children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector&amp;lt;Node*&amp;gt; _children) { val = _val; children = _children; }};*/class Solution {public: // 재귀를 통해 leaf 노드부터 1씩 더해가면서 최대 depth를 탐색 int maxDepth(Node* root) { if(root == nullptr) return 0; // 현재 노드가 leaf 노드라면 1을 리턴 if(root-&amp;gt;children.empty()) return 1; // 여러 자식노드들의 depth를 탐색 및 저장 // 현재 노드는 자식 노드의 depth의 + 1 이므로 // 자식노드의 depth + 1 하여 현재노드의 최대 depth를 저장 vector&amp;lt;int&amp;gt; depth; for(const auto&amp;amp; childNode : root-&amp;gt;children){ depth.push_back(maxDepth(childNode) + 1); } // 자식노드들 중 최대 depth를 리턴 return *max_element(depth.begin(), depth.end()); }};" }, { "title": "LeetCode - 841. Keys and Rooms", "url": "/posts/ps-leetcode-841/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, DFS", "date": "2020-02-23 05:52:00 +0900", "snippet": " 841. Keys and Rooms - medium문제There are N rooms and you start in room 0. Each room has a distinct number in 0, 1, 2, …, N-1, and each room may have some keys to access the next room.Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, …, N-1] where N = rooms.length. A key rooms[i][j] = v opens the room with number v.Initially, all the rooms start locked (except for room 0).You can walk back and forth between rooms freely.Return true if and only if you can enter every room.제한사항 1 &amp;lt;= rooms.length &amp;lt;= 1000 0 &amp;lt;= rooms[i].length &amp;lt;= 1000 The number of keys in all rooms combined is at most 3000.입출력 예Example 1:Input: [[1],[2],[3],[]]Output: trueExplanation: We start in room 0, and pick up key 1.We then go to room 1, and pick up key 2.We then go to room 2, and pick up key 3.We then go to room 3. Since we were able to go to every room, we return true.Example 2:Input: [[1,3],[3,0,1],[2],[0]]Output: falseExplanation: We can&#39;t enter the room with number 2.풀이 DFSclass Solution {public: bool canVisitAllRooms(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; rooms) { // 방을 방문 했다면 false, 방문하지 않았다면 true vector&amp;lt;bool&amp;gt; visited(rooms.size(), true); stack&amp;lt;int&amp;gt; s; // DFS s.push(0); while(!s.empty()){ auto index = s.top(); s.pop(); // 현재 index의 방을 방문한 것으로 저장 visited[index] = false; // 현재 rooms안의 키를 각각 stack에 저장 for(const auto&amp;amp; sub : rooms[index]){ // 방문한적이 없는 키만 stack에 저장 if(visited[sub]){ s.push(sub); } } } // 방문한적 없는 방이 있다면 false for(const auto&amp;amp; checker : visited){ if(checker){ return false; } } return true; }};" }, { "title": "LeetCode - 108. Convert Sorted Array to Binary Search Tree", "url": "/posts/ps-leetcode-108/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Tree, BST, Recursive", "date": "2020-02-22 08:13:00 +0900", "snippet": " 108. Convert Sorted Array to Binary Search Tree - easy문제Given an array where elements are sorted in ascending order, convert it to a height balanced BST.For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.제한사항입출력 예Example:Given the sorted array: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \\ -3 9 / / -10 5풀이 Tree, BST, Recursive/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* sortedArrayToBST(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if(nums.size() &amp;lt; 1) return nullptr; // 현재 vector의 중간값을 기준으로 // 왼쪽과 오른쪽 sub vector를 구성 int mid = nums.size()/2; vector&amp;lt;int&amp;gt; left(nums.begin(), nums.begin()+mid); vector&amp;lt;int&amp;gt; right(nums.begin()+mid+1, nums.end()); // 왼쪽의 sub vector는 현재 중간값 보다 모두 값이 작으므로 // 왼쪽 자식노드에 저장 // 오른쪽의 sub vector는 현재 중간값 보다 모두 값이 크므로 // 오른쪽 자식노드에 저장 TreeNode* item = new TreeNode(nums[mid]); item-&amp;gt;left = sortedArrayToBST(left); item-&amp;gt;right = sortedArrayToBST(right); return item; }};" }, { "title": "LeetCode - 98. Validate Binary Search Tree", "url": "/posts/ps-leetcode-98/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Tree, DFS, BST", "date": "2020-02-22 08:04:00 +0900", "snippet": " 98. Validate Binary Search Tree - medium문제Given a binary tree, determine if it is a valid binary search tree (BST).Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees.제한사항입출력 예Example 1: 2 / \\ 1 3Input: [2,1,3]Output: trueExample 2: 5 / \\ 1 4 / \\ 3 6Input: [5,1,4,null,null,3,6]Output: falseExplanation: The root node&#39;s value is 5 but its right child&#39;s value is 4.풀이 Tree, DFS, BST/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool isValidBST(TreeNode* root) { if(root == NULL) return true; if(root-&amp;gt;left == NULL &amp;amp;&amp;amp; root-&amp;gt;right == NULL) return true; std::stack&amp;lt;TreeNode*&amp;gt; stack; long long value = LONG_MIN; // DFS 를 이용해 BST인지 탐색 // preOrder와 유사하게 탐색 while(!stack.empty() || root != NULL){ // 현재 노드의 모든 왼쪽 자식 노드를 채움 while(root != NULL){ stack.push(root); root = root-&amp;gt;left; } root = stack.top(); stack.pop(); // 현재 노드의 값보다 비교값이 크거나 같다면, // 왼쪽 자식노드의 값이 부모노드의 값보다 크다는 의미 이거나, // 부모노드의 값이 오른쪽 자식노드보다 크다는 의미 // 즉, BST가 아님 if(root-&amp;gt;val &amp;lt;= value) return false; // 현재 노드의 값과 다음에 탐색되는 노드의 값을 비교하기위해 저장 // 오른쪽 자식노드또한 탐색하기 위해 root에 오른쪽 자식노드를 저장 value = root-&amp;gt;val; root = root-&amp;gt;right; } return true; }};" }, { "title": "OS - CPU 스케쥴링", "url": "/posts/os-ch5/", "categories": "Operating System", "tags": "OS", "date": "2020-02-21 06:28:00 +0900", "snippet": "CPU 스케쥴링 기본 개념 스케쥴링 기준 스케쥴링 알고리즘 스레드 스케쥴링 다중 처리기 스케쥴링 실시간 CPU 스케쥴링 운영체제 사례들 기본 개념단일 처리기 시스템에서는 한 순간에 오직 하나의 프로세스만이 실행될 수 있다.다중 프로그래밍의 목적은 CPU 이용률을 최대화하기 위해 항상 실행 중인 프로세스를 가지게 하는데 있다.CPU 입출력 버스트 사이클(CPU-I/O Brust Cycle)프로세스 실행은 CPU 실행과 입출력 대기의 사이클 로 구성된다. 프로세스들은 이 두 상태 사이를 교대로 왔다 갔다 한다.프로세스 실행은 CPU 버스트(Burst) 로 시작되고, 뒤이어 입출력 버스트 가 발생하며, 그 뒤를 이어 또 다른 CPU 버스트가 발생하며 이어 또 다른 입출력 버스트 등등으로 진행된다.마지막 CPU 버스트는 또 다른 입출력 버스트가 뒤따르는 대신, 실행을 종료하기 위한 시스템 요청과 함께 끝난다. 단일코어 시스템에서의 병행 실행 CPU 버스트들의 지속 시간을 측정하면, 일반적으로 곡선이 지수형 또는 초지수형으로 특성화 된다.짧은 CPU 버스트가 많이 있으며, 긴 CPU 버스트는 적다. 입출력 중심의 프로그램은 전형적으로 짧은 CPU 버스트를 많이 가지게 될 것이며, CPU 중심의 프로그램은 다수의 긴 CPU 버스트를 가지게 될 것이다. CPU 버스트 시간의 도표 CPU 스케쥴러(CPU Scheduler)CPU가 유휴 상태가 될 때마다, OS는 Ready Queue에 있는 프로세스들 중에서 하나를 선택하여 실행한다. 실행 절차는 단기 스케쥴러에 의해 수행된다. 스케쥴러는 실행 준비가 되어있는 메모내의 프로세스들 중에서 선택하여 이들 중 하나에게 CPU를 할당한다.선점 스케쥴링(Preemptive Scheduling)CPU 스케쥴링은 아래와 같은 다섯가지 상황에서 발생할 수 있다. 한 프로세스가 실행 상태에서 대기 상태로 전환될 때 프로세스의 상태가 running -&amp;gt; wait 로 전환 non preemtive scheduling 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때 프로세스의 상태가 running -&amp;gt; ready 로 전환 preemtive scheduling 프로세스가 대기 상태에서 준비 완료 상태로 전환될 때 프로세스의 상태가 wait -&amp;gt; ready 로 전환 preemtive scheduling 프로세스가 생성 되고 준비 완료 상태로 전환 될 때 프로세스의 상태가 new -&amp;gt; ready 로 전환 preemtive scheduling 프로세스가 종료할 때 프로세스의 상태가 running -&amp;gt; terminate 로 전환 non preemtive scheduling 비선점 스케쥴링(Non Preemtive Scheduling) 에선, CPU가 한 프로세스에 할당 되면, 프로세스가 종료하든지 또는 대기 상태로 전환하여 CPU를 방출할 때 까지 CPU를 점유한다.디스패처(Dispatcher)디스패처는 CPU의 제어를 단기 스케쥴러가 선택한 프로세스에게 주는 모듈이며 아래과 같은 작업을 수행한다. 문맥 교환 사용자 모드로 전환 프로그램을 다시 시작하기 위해 사용자 프로그램의 적정한 위치로 이동디스패처가 하나의 프로세스를 정지하고 다른 프로세스의 수행을 시작하는데 까지 소요되는 시간을 디스패치 지연(Dispather Latency) 이라고 한다.스케쥴링 기준여러 CPU 스케쥴링 알고리즘들 중 하나를 선택하기 위해 아래와 같은 기준을 참고한다. CPU 이용률(Utilization) 처리량(Throughput) 단위 시간당 완료된 프로세스의 갯수 총처리 시간(Turnaround Time) 프로세스를 실행하는데 소요된 시간 대기 시간(Waiting Time) 스케쥴링 알고리즘은 단지 프로세스가 Ready Queue에서 대기하는 시간의 양에만 영향을 준다. 대기 시간은 Ready Queue에서 대기하면서 보내는 시간의 합니다. 응답 시간(Response Time) 요구를 제출한 후 첫번째 응답이 나올때 까지의 시간 CPU 이용률과 처리량을 최대화 하고, 총처리 시간, 대기 시간, 응답 시간을 최소화 하는것이 바람직 하다.스케쥴링 알고리즘선입 선처리 스케쥴링(First-Come, First-Served Schduling) - Non Preemtive Scheduling CPU를 먼저 요청한 프로세스가 CPU를 먼저 할당 받는다.평균 대기 시간이 종종 대단히 길 수 잇다. Process Burst Time P1 24 P2 3 P3 3 P1, P2, P3 순으로 도착할때의 FCFS 알고리즘 위와 같은 순서로 프로세스가 도착할 때, FCFS 알고리즘에서 프로세스의 평균 대기시간은 (0 + 24 + 27) / 3 = 17 이다. P2, P3, P1 순으로 도착할때의 FCFS 알고리즘 위와 같은 순서로 프로세스가 도착할 때, FCFS 알고리즘에서 프로세스의 평균 대기시간은 (6 + 0 + 3) / 3 = 3 이다.즉, FCFS 알고리즘 상에서 평균 대기 시간은 일반적으로 최소가 아니며, 프로세스 CPU 버스트 시간이 크게 변할 경우에는 평균 대기 시간도 상당히 변할 수 있다.모든 다른 프로세스들이 하나의 긴 프로세스가 CPU를 양도하기를 기다리는 것을 호위 효과(Convoy Effect) 라고 한다. 이 효과는 짧은 프로세스들이 먼저 처리되도록 허용될 때보다 CPU와 장치 이용률이 저하되는 결과를 낳는다.최단 작업 우선 스케쥴링(Shortest Job First Schduling) - Non Preemtive Scheduling or Preemtive Scheduling 가장 작은 다음 CPU 버스트를 가진 프로세스에게 CPU를 할당한다.각 프로세스에 다음 CPU 버스트 길이를 연관시켜, 가장 작은 CPU 버스트를 가진 프로세스에게 CPU를 할당한다. 즉, 프로세스의 전체 길이가 아니라 다음 CPU 버스트의 길이에 의해 스케쥴링된다. Process Burst Time P1 6 P2 8 P3 7 P4 3 SJF 알고리즘에서의 P1, P2, P3, P4의 스케쥴링 위와 같은 상황에서 평균 대기시간은 (3 + 16 + 9 + 0) / 4 = 7 이다.SJF 스케쥴링 알고리즘은 주어진 프로세스 집합에 대해 최소의 평균 대기 시간을 가진다는 점에서 최적임이 증명 가능하다.장기 스케줄링에 많이 이용되는 알고리즘이지만, 단기 스케쥴링에서는 다음 CPU 버스트의 길이를 알 수 있는 방법이 없다.SJF 알고리즘은 선점형 이거나 비선점형 일 수 있다. 앞의 프로세스가 실행되는 동안 새로운 프로세스가 Ready Queue에 도착하면 선택이 발생 된다. 새로운 프로세스가 현재 실행되고 있는 프로세스의 남은 시간보다도 더 짧은 CPU 버스트를 가질 수 있다. 이때, 선점형 SJF 알고리즘은 현재 실행하고 있는 프로세스를 선점 할 것이고, 비선점형 SJF 알고리즘은 현재 실행하고 있는 프로세스가 자신의 CPU 버스트를 끝내도록 허용한다. Process Arrival Time Burst Time P1 0 8 P2 1 4 P3 2 9 P4 3 5 선점형 SJF 알고리즘에서의 P1, P2, P3, P4의 스케쥴링 이 예에서 평균 대기시간은 ((10 - 1) + (1 - 1) + (17 - 2) + (5 - 3)) / 4 = 26 / 4 = 6.5 이다.우선순위 스케쥴링(Priority Scheduling) - Non Preemtive Scheduling or Preemtive Scheduling 우선순위가 각 프로세스들에게 연관되어 있으며, CPU는 가장 높은 우선순위를 가진 프로세스에게 할당된다.SJF 알고리즘은 우선순위(p)가 다음 CPU 버스트의 역인 단순한 우선순위 알고리즘이다 Process Burst Time Priority P1 10 3 P2 1 1 P3 2 4 P4 1 5 P5 5 2 우선순위 알고리즘에서의 P1, P2, P3, P4, P5의 스케쥴링 우선 순위 스케쥴링의 주요 문제는 무한 봉쇄(Indefinite Blocking) 또는 기아 상태(Starvation) 이다. 무한 봉쇄(Indefinite Blocking) 우선순위가 낮은 프로세스의 경우, 무한히 CPU의 할당을 기다릴 수 있다. 기아 상태(Starvation) 높은 우선순위를 가진 프로세스들이 꾸준히 들어와서 낮은 우선순위의 프로세스들이 CPU를 얻지 못할수 있다. 낮은 우선순위의 프로세스들이 무한히 봉쇄되는 문제에 대한 한가지 해결책으로는 노화(Aging) 이다. 노화는 오랫동안 시스템에서 대기하는 프로세스들의 우선순위를 점진적으로 증가시키는 것이다.라운드 로빈 스케쥴링(Roud Robin Scheduling) - Preemtive Scheduling CPU 스케쥴러는 Ready Queue를 돌면서 한 번에 한 프로세스에게 한번의 시간 할당량 동안 CPU를 할당한다.라운드 로빈 스케쥴링 알고리즘은 특별히 시분할 시스템을 위해 설계되었다.시간 할당량(Time Quantum) 또는 시간 조각(Time Slice) 라고 불리는 작은단위의 시간을 정의하여 해당 시간동안 프로세스에게 순차적으로 CPU 할당한다. 일반적으로 시간 할당량은 10 ~ 100밀리초 이다.일반적으로 아래 두 경우 중 하나가 발생한다. 프로세스의 CPU 버스트가 한번의 시간할당량보다 작을경우 프로세스 자신이 CPU를 자발적으로 방출한다. 스케쥴러는 그 후 Ready Queue에 있는 다음 프로세스로 진행한다. 현재 실행 중인 프로세스의 CPU 버스트가 한 번의 시간 할당량보다 긴경우 타이머가 끝나고 OS에서 인터럽트를 발생시킨다. 문맥교환이 일어나고, 실행하던 프로세스는 Ready Queue의 꼬리에 넣어진다. 그 후 CPU 스케쥴러는 Ready Queue의 다음 프로세스로 진행한다. 만일 시간 할당량을 4밀리초라고 할 떄, 그 예는 아래와 같다. Process Burst Time P1 24 P2 3 P3 3 RR 알고리즘에서의 P1, P2, P3의 스케쥴링 RR 스케쥴링 알고리즘의 성능은 시간 할당량의 크기에 매우 많은 영향을 받는다. 극단적인 경우, 시간 할당량이 매우 크다면, RR 스케쥴링 알고리즘은 FCFS 스케쥴링 알고리즘과 같다. 이와 반대로 시간 할당량이 매우 작다면 RR 스케쥴링 알고리즘은 매우 많은 문맥교환을 발생시킨다. 시간 할당량이 작을수록 문맥교환 획수가 늘어나는 예시 총처리 시간이 시간 할당량에 따라 변하는 모습 문맥교환을 하는데 걸리는 시간은 보통 10마이크로초 이다.시간 할당량이 문맥교환 시간에 비해 커야 하지만 너무 커져서는 안된다.다단계 큐 스케쥴링(Multilevel Queue Scheduling) - Preemtive Scheduling Ready Queue를 다수의 별도의 큐로 분리하여, 각각 별도의 스케쥴링 알고리즘을 가지게 한다.일반적으로 포그라운드(Foreground)(대화형) 백그라운드(Background)(일괄처리) 프로세스는 응답시간에 대한 요구사항이 다르기 때문에, 프로세스의 유형을 구분하여 각 특성에 맞춰 다른 스케쥴링 알고리즘을 사용한다.프로세스들은 메모리 크기, 프로세스의 우선순위 혹은 프로세스 유형과 같은 프로세스의 특성에 따라 한개의 큐에 영구적으로 할당된다. 각 큐는 자신만의 스케쥴링 알고리즘을 가지고 있다.큐와 큐 사이에 스케쥴링도 반드시 있어야 하며, 일반적으로 고정 우선순위 의 선점형 스케쥴링으로 구현된다. 다단계 큐 스케쥴링 각 큐는 낮은 우선순위의 큐보다 절대적인 우선순위를 가진다.다단계 피드백 큐 스케쥴링(Multilevel Feedback Queue Scheduling) - Preemtive Scheduling 다단계 큐 스케쥴링과 유사하지만 다른점은 프로세스가 큐들 사이를 이동하는것을 허용한다.다단계 큐 스케쥴링 알고리즘에서는 일반적으로 프로세스들이 시스템 진입 시에 영구적으로 하나의 큐에 할당된다. 대조적으로 다단계 피드백 큐 스케쥴링 알고리즘은 프로세스가 큐들 사이를 이동하게 한다.먼저 프로세스들을 CPU 버스트 성격에 따라 구분한다. 어떤 프로세스가 CPU 시간을 저무 많이 사용하면, 낮은 우선운위의 큐로 이동된다. 이러한 방법에서는 입출력 중심의 프로세스와 대화형 프로세스들은 높은 우선순위의 큐에 넣는다. 마찬가지로 낮은 우선순위의 큐에서 너무 오래 대기하는 프로세스는 높은 우선순위의 큐에 넣는다. 이러한 노화(Aging) 형태는 기아상태를 예방한다. 다단계 큐 스케쥴링 일반적으로 다단계 피드백 큐 스케쥴러는 다음의 매개변수에 의해 정의된다.. 큐의 개수 각 큐를 위한 스케쥴링 알고리즘 한 프로세스를 높은 우선순위 큐로 올려주는 시기를 결정하는 방법 한 프로세스를 낮은 우선순위 큐로 강등시키는 시기를 결정하는 방법 프로세스가 서비스를 필요로 할 때 프로세스가 들어갈 큐를 결정하는 방법스레드 스케쥴링사용자 수준 과 커널 수준 스레드를 구별하는 OS에서 스케쥴되는 대상은 프로세스가 아니라 커널 수준의 스레드이다. 사용자 수준 스레드는 스레드 라이브러리에 의해 관리되고 커넣은 그들의 존재를 알지 못한다.경쟁 볌위(Contention Scope)사용자 수준과 커널 수준 스레드의 차이 중 하나는 그들이 어떻게 스케쥴 되는지 이다.다대일, 다대다 모델을 구현하는 시스템에서 스레드 라이브러리는 사용자 수준 스레드를 가용한 LWP 상에서 스케쥴한다. 이러한 기법은 동일한 프로세스에 속한 스레드들 사이에서 CPU를 경쟁하기 때문에 프로세스 경쟁 범위(Process Contention Scope, PCS) 로 알려저 있다.전형적으로 PCS는 우선순위에 따라 행해진다.CPU상에서 어느 커널 스레드를 스케쥴 할 것인지 경정하기 위해서 커널은 시스템 경쟁 범위(System Contention Scope, SCS) 를 사용한다. SCS 스케쥴링에서의 CPU에 대한 경쟁은 시스템 상의 모든 스레드 사이에서 일어난다.Windows, Linux와 같은 일대일 스레드 모델을 사용하는 시스템은 오직 SCS만을 사용하여 스케쥴한다.다중 처리기 스케쥴링여러개의 CPU 코어가 사용가능해 지면서, 부하 공유(Load Sharing) 가 가능해 진다.다중 처리기 스케쥴링에 대한 접근 방법다중 처리기 시스템의 CPU 스케쥴링에 관한 해결방법은 크게 두가지가 있다. 비대칭 다중처리(Asymmetric Multiprocessing) 주 서버라는 하나의 처리기가 모든 스케쥴링 결정과 입출력 처리 그리고 다른 시스템의 활동을 취급하게 한다. 다른 처리기들은 다만 사용자 코드만 수행한다. 단지 한 처리기만 시스템 자료구조를 접근하여 자료공유의 필요성을 배게하기 때문에 간단하다. 대칭 다중처리(Symmetric Multiprocessing, SMP) 각 처리기가 독자적으로 스케쥴링 한다. 모든 프로세스는 공동의 Ready Queue에 있거나 각 처리기 마다 가지고 있는 사유의 Ready Queue에 있게 된다. Windows, Linux, MacOS를 포함한 거의 모든 현대의 OS들은 SMP를 지원한다. 처리기 진화성부하 균등화(Load Balancing)다중코어 프로세서실시간 CPU 스케쥴링지연 시간 최소화(Minimizing Latency)우선순위 기반의 스케쥴링(Priority Based Scheduling)Rate-Monotonic 스케쥴링운영체제 사례들Linux 스케쥴링Windows 스케쥴링" }, { "title": "LeetCode - 1104. Path In Zigzag Labelled Binary Tree", "url": "/posts/ps-leetcode-1104/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Tree, Math", "date": "2020-02-18 08:52:00 +0900", "snippet": " 1104. Path In Zigzag Labelled Binary Tree - medium문제In an infinite binary tree where every node has two children, the nodes are labelled in row order.In the odd numbered rows (ie., the first, third, fifth,…), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,…), the labelling is right to left.Given the label of a node in this tree, return the labels in the path from the root of the tree to the node with that label.제한사항 1 &amp;lt;= label &amp;lt;= 10^6입출력 예Example 1:Input: label = 14Output: [1,3,4,14]Example 2:Input: label = 26Output: [1,2,6,10,26]풀이 Tree, Mathclass Solution {public: vector&amp;lt;int&amp;gt; pathInZigZagTree(int label) { if(label == 1) return {1}; // Tree의 깊이탐색 auto findLevel = label; int level = 0; while(findLevel){ findLevel &amp;gt;&amp;gt;= 1; ++level; } // 가장 마지막원소의 값은 label이며, // 마지막의 앞 원소의 값은 // label이 속한 트리의 깊이가 뒤집혀있든 뒤집혀있지 않든, 모두 같은 방향으로 만들어 줌 // ((2의 현재 level의 제곱) - label + (2의 현재 level-1 의 제곱) - 1) / 2 vector&amp;lt;int&amp;gt; ans(2); ans[0] = label; ans[1] = (pow(2, level) - label + pow(2, level - 1) - 1) / 2; // 현재 노드의 할아버지 노드는, 손자 노드의 / 4 임 // 즉, ans[i] = ans[i - 2] / 4 --level; int index = 0; while(--level){ label /= 4; ans.push_back(ans[index] / 4); ++index; } // Tree의 leaf노드부터 구하기 시작했으므로 역전시켜야 함 std::reverse(ans.begin(), ans.end()); return ans; }};" }, { "title": "OS - 스레드", "url": "/posts/os-ch4/", "categories": "Operating System", "tags": "OS", "date": "2020-02-18 05:57:00 +0900", "snippet": "스레드 개요 다중코어 프로그래밍 다중 스레드 모델 암묵적 스레딩 스레드 이슈 운영체제 사례 개요스레드는 CPU 이용의 기본단위이다.스레드는 스레드 ID, 프로그램 카운터, 레지스터 집합, 스택 으로 구성된다.스레드는 같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션 그리고 열린 파일이나 신호와 같은 OS 자원을 공유한다. 단일 및 다중 스레드 프로세스 어떤 프로세스가 다수의 제어 스레드를 가진다면, 해당 프로세스는 동시에 하나 이상의 작업들을 수행할 수 있다.동기(Motivation)다수의 OS 커널은 다중화 되어 있다. 커널 안에서 다수의 스레드가 동작하고 각 스레드는 장치 또는 인터럽트 처리 등의 특정 작업을 수행한다. 다중 스레드 서버 구조 장점다중 스레드 프로그래밍이 가지는 이점은 아래와 같다. 응답성(Responsiveness) 대화형 응용 프로그램을 다중 스레딩하면 응용 프로그램의 일부분이 봉쇄되거나, 응용 프로그램이 장시간 작업을 수행하더라도 프로그램의 수행이 계속 되는 것을 허용하여 사용자에 대한 응답성을 증가시킨다. 자원 공유(Resource Sharing) 스레드는 자동적으로 그들이 속한 프로세스의 자원들과 메모리를 공유한다. 즉 코드와 데이터 공유를 통해 같은 주소 공산내에 여러개의 다른 작업을 하는 스레드를 가진수 있다. 경제성(Economy) 프로세스 생성을 위해 메모리와 자원을 할당하는 것은 비용이 많이 든다. 스레드는 자신이 속한 프로세스의 자원들을 공유하기 때문에, 스레드를 생성하고 문맥 교환하는 것이 보다 더 경제적이다. 규모 적응성(Scalability) 다중 처리기 구조에서는 각각의 스레드가 다른 처리기에서 병렬로 수행될 수 있으므로 더욱 성능이 좋아진다. 다중코어 프로그래밍병렬 실행(Parallel Excution) 과 병행 실행(Concurrent Excution) 병렬 실행 하나 이상의 태스크를 동시에 수행할 수 있는 시스템에 대하여 병렬적 이라고 한다. 병행 실행 모든 태스크가 진행하도록 하여, 하나 이상의 태스크를 지원한다. 따라서 병렬 실행 없이 병행실행이 가능하게끔 한다. 단일코어 시스템에서의 병행 실행 다중코어 시스템에서의 병렬 실행 프로그래밍 챌린지다중코어 시스템을 위해 프로그래밍하기 위해, 아래와 같은 5개의 극복해야할 도전이 있다. 태스크 인식(Identifying Tasks) 개발하고자 하는 응용 프로그램을 분석하여 독립된 병행가능 태스크로 나눌수 있는 영역을 찾아야 한다. 균형(Balance) 찾아진 병렬실행 가능 부분들이 전체 작업에 균등한 기여도를 가지도록 태스크를 나누어야 한다. 데이터 분리(Data Spliting) 태스크가 접근하고 조작하는 데이터 또한 개별 작업에서 사용될수 있도록 나누어져야 한다. 데이터 의존성(Data Dependency) 태스크가 접근하는 데이터는 둘 이상의 태스크 사이에 종속성 및 의존성이 없는지 확인하여야 한다. 한 태스크가 다른 태스크로부터 오는 데이터에 종속적이거나 의존성이 있을때, 이를 수용할 수 있도록 태스트의 수행을 동기화하여 데이터 종속에 오는 문제를 회피한다. 테스트 및 디버깅(Testing and Debugging) 단일 스레드 프로그램의 테스트와 디버깅보다 난이도 있기때문에, 주의하여야 한다. 병렬 실행의 유형일반적으로 데이터 병렬 실행 과 태스크 병렬 실행 두가지가 있다. 데이터 병렬 실행 동일한 데이터의 부분집합을 다수의 계산 코어에 분배한 뒤, 각 코어에서 동일한 연산을 실행하는데 초첨을 맞춘다. 태스크 병렬 실행 각 스테드는 고유의 연산을 수행한다. 각기 다른 스레드는 동일한 데이터에 대해연산을 실행할 수 있고, 또는 서로 다른 데이터에 연산을 실행할 수 있다. 다중 스레드 모델스레드를 위한 자원은, 사용자 스레드(User Thread) 를 위해서는 사용자 수준에서, 또는 커널 스레드(Kernel Thread) 를 위해서는 커널 수준에서 제공된다.사용자 스레드는 커널 위에서 지원되며 커널의 지원 없이 관리된다. 반면 커널 스레드는 OS에 의해 직접 지원되고 관리된다.다대일 모델(Many-to-One Model) 많은 사용자 스레드를 하나의 커널 스레드로 매칭한 모델스레드 관리는 사용자 공간의 스레드 라이브러리에 의해 행해진다.한 스레드가 블럭형 시스템콜을 호출 할 경우, 전체 프로세스가 블럭된다.한번에 하나의 스레드만이 커널에 접근할 수 있기 때문에, 다중 스레드가 다중코어 시스템에서 병렬로 실행될 수 없다.현대의 시스템에서는 거의 사용되지 않는다. 다대일 스레드 모델 일대일 모델(One-to-One Model) 하나 사용자 스레드를 각각 하나의 커널 스레드로 매칭한 모델하나의 스레드가 블럭형 시스템콜을 호출 할 경우에도 다른 스레드가 실행될 수 있기 때문에 다대일 모델보다 더 많은 병렬성을 제공한다.사용자 스레드를 생성할때, 그에 따른 커널 스레드를 생성해야 하므로, 오버헤드가 발생하여 성능저하가 일어날수 있다.이 모델의 대부분의 구현은 시스템에 의해 지원되는 스레드의 수를 제한한다.Windows 계열과, Linux가 일대일 모델을 구현하고 있다. 일대일 스레드 모델 다대다 모델(Many-to-Many Model) 여러개의 사용자 스레드를 그보다 작은 수, 혹은 같은 수의 커널 스레드로 매칭한 모델한번에 하나의 스레드만이 커널에의해 스케쥴링 되기 때문에 진정한 병렬 실행을 이룰수 없다.개발자는 일대일 모델과 달리 다대다 모델의 시스템에서는 필요한 만큼 사용자 스레드를 생성할 수 있다.어떤 스레드가 블럭형 시스템콜을 호출했을때, 커널이 다른 스레드의 수행을 스케쥴링할 수 있다. 다대다 스레드 모델 두 수준 모델(Two-level Model) 다대다 모델의 변형으로써, 많은 사용자 스레스를 적거나 같은수의 커널 스레드와 매칭하지만, 또한 한 사용자 스레드가 하나의 커널 스레드에서만 매칭되는것을 허용 두 수준 모델 암묵적 스레딩암묵적 스레딩(Implicit Threading) 이란, 스레딩 생성과 관리 책임을 컴파일러와 실행시간 라이브러리에게 넘겨주는 방식이다.스레드 이슈Fork() 및 Exec() 시스템 호출다중 스레드 프로그램에서는 fork()와 exec()의 의미가 달라질 수 있다.만일 하나의 프로그램의 스레드가 fork()를 호출하면, 해당 자식 프로세스는 부모 프로세스의 모든 스레드를 복제하여 가질 수 있고, fork()를 호출한 스레드만 복제하여 가질 수 있다.신호 처리(Signal Handling)신호 는 UNIX에서 프로세스에게 어떤 사건이 일어났음을 알려주기 위해 사용된다.신호는 알려줄 사건의 근원지나 이유에 따라 동기식 과 비동기식 으로 전달될 수 있다.모든 신호는 다음과 같은 형태로 전달된다. 신호는 특정 사건이 일어나야 생성된다. 생성된 신호가 프로세스에게 전달된다. 신호가 전달되면 반드시 처리되어야 한다.동기식 신호의 예로는 불법적인 메모리 접근, 0으로 나누기 등이 있다. 동기식 신호는 신호를 발생시킨 프로세스에게 전달된다.신호가 발생중인 프로세스 외부로부터 발생되면, 그 프로세스는 신호를 비동기식으로 전달 받는다. 비동기식 신호의 예로는 “CRTL + C”와 같은 특수한 키를 눌러 프로세스를 강제 종료 하거나 타이머가 만료되는 경우 이다.모든 신호는 둘 중 하나의 처리기에 의해 처리된다. 디폴트 신호 처리기(Default Signal Handler) 사용자 정의 신호 처리기(User Design Signal Handler)모든 신호마다 커널이 실행시키는 디폴트 신호 처리기가 있다. 이 디폴트 신호 처리기는 신호를 처리하기 위해 사용자 정의 신호 처리기로 대체될 수 있다.다중 스레드 프로그램에서 신호를 전달한 스레드를 선택할 때, 다음과 같은 방법이 존재한다. 신호가 적용될 스레드에게 전달 모든 스레드에게 전달 몇몇 스레드에게만 선택적으로 전달 특정 스레드가 모든 신호를 전달 받도록 지정취소(Cancellations)스레드 취소는 스레드가 끝나기 전에 그것을 강제 종료 시키는 작업이다.스레드의 취소는 두가지 방법으로 발생할 수 있다. 비동기식 취소(Asynchronous Cancellation) 한 스레드가 즉시 취소 시킬 스레드를 강제 종료 시킨다. 지연 취소(Deferred Cancellation) 취소할 스레드가 주기적으로 자신이 강제 종료 되어야 할지 점검한다. 스레드 취소를 어렵게 만드는 것은 취소 스레드들에게 할당된 자원 문제이다. 또한 스레드가 다른 스레드와 공유하는 자료구조를 갱신하는 도중에 취소 요청이 와도 문제가 된다.스레드 로컬 저장소(Thread Local Storage)한 프로세스에 속한 스레드들은 그 프로세스의 데이터를 모두 공유한다. 그러나 스레드는 때로 자신만 액세스 할 수 있는 데이터를 가져야 할 필요가 있다. 이러한 데이터를 스레드 로컬 저장소(Thread Local Storage) 이라고 한다.TLS를 지역변수와 혼동하기 쉬운데, 지역변수는 하나의 함수가 호출되는 동한에만 보이는 반면, TLS는 전체 함수 호출에 걸쳐 보인다.스케쥴러 액티베이션(Scheduler Activation)다대다 또는 두 수준 모델을 가진 많은 시스템들은 사용자와 커널 스레드 사이에 중간 자료구조를 둔다. 해당 자료구조를 경량 프로세스(LWP) 라고 한다. 경량 프로세스(LWP) 사용자 스레드 라이브러리와 커널 스레드 간의 통신 방법중 하나는 스케쥴러 액티베이션(Scheduler Activation) 이다.운영체제 사례Windows 스레드Windows에서는 일대일 스레드 모델을 사용한다.스레드와 일반적인 구성요소는 다음과 같다. 스레드 ID 처리기의 상태를 나타내는 레지스터 집합 사용자 모드에서 실행될 때 필요한 사용자 스택, 커널 모드에서 실행될 때 필요한 커널 스택 실행 시간 라이브러리와 동적 링크 라이브러리(DLL) 등이 사용하는 개별 데이터 저장 영역레지스터 집합, 스택, 개별 데이터 저장 영역들은 그 스레드의 문맥으로 불린다. 스레드를 위해서는 아래와 같은 자료구조를 가진다. ETHERAD - 실행 스레드 블록(Executive Thread Block) 스레드가 속한 프로세스를 가리키는 포인터와 그 스레드가 실행해야할 루틴의 주소를 가짐 KTHREAD에 대한 포인터를 가짐 KTHREAD - 커널 스레드 블록(Kernel Thread Block) 스레드의 스케쥴링 및 동기화 정보를 가짐 해당 스레드가 커널코드에서 실행될 때 사용되는 커널 스택과 TEBdp에 대한 포인터를 가짐 TEB - 스레드 환경 블록(Thread Environment Block) 사용자 모드에서 실행될 때 접근되는 사용자 공간 자료구조 스레드 ID, 사용자 모드 스택, 스레드 로컬 저장소를 저장하기 위한 배열을 가짐 Windows 스레드의 자료구조 ETHREAD와 KTHREAD는 모두 커널안에 존재한다.Linux 스레드Linux는 프로세스를 복제하는 기능을 가진 fork() 시스템콜과 clone() 시스템콜을 이용하여 스레드를 생성할 수 있다.Linux는 프로세스와 스레드를 구별하지 않는다. 사실 Linux는 프로그램 내의 제어 흐을을 나타내기 위해 프로세스 나 스레드 보다 태스크 라는 용어를 사용한다.clone()이 호출될 때, 부모와 자식 태스크가 자료구조를 얼마나 공유 할 것인지 결정하는 플레그의 집합이 전달된다. flag Meaning CLONE_FS 파일 시스템 정보가 공유 CLONE_VM 같은 메모리 공간이 공유 CLONE_SIGHAND 신호 처리기가 공유 CLONE_FILES 열린 파일의 집합이 공유 " }, { "title": "LeetCode - 998. Maximum Binary Tree II", "url": "/posts/ps-leetcode-998/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Tree", "date": "2020-02-17 06:02:00 +0900", "snippet": " 998. Maximum Binary Tree II - medium문제We are given the root node of a maximum tree: a tree where every node has a value greater than any other value in its subtree.Just as in the previous problem, the given tree was constructed from an list A (root = Construct(A)) recursively with the following Construct(A) routine: If A is empty, return null. Otherwise, let A[i] be the largest element of A. Create a root node with value A[i]. The left child of root will be Construct([A[0], A[1], …, A[i-1]]) The right child of root will be Construct([A[i+1], A[i+2], …, A[A.length - 1]]) Return root.Note that we were not given A directly, only a root node root = Construct(A).Suppose B is a copy of A with the value val appended to it. It is guaranteed that B has unique values.Return Construct(B).제한사항 1 &amp;lt;= B.length &amp;lt;= 100입출력 예Example 1:Input: root = [4,1,3,null,null,2], val = 5Output: [5,4,null,1,3,null,null,2]Explanation: A = [1,4,2,3], B = [1,4,2,3,5]Example 2:Input: root = [5,2,4,null,1], val = 3Output: [5,2,4,null,1,null,3]Explanation: A = [2,1,5,4], B = [2,1,5,4,3]Example 3:Input: root = [5,2,3,null,1], val = 4Output: [5,2,4,null,1,3]Explanation: A = [2,1,5,3], B = [2,1,5,3,4]풀이 Tree/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* insertIntoMaxTree(TreeNode* root, int val) { // 현재 노드의 값보다 val의 값이 크거나, // 현재 노드의 값이 val값보다 작자는 뜻이 되므로 노드를 생성하여 교체 // 또는 현재 노드가 마지막 리프 노드이라면, // 마지막 리프노드를 새로 생성하여 기존 root에 붙임 if(root == nullptr || val &amp;gt; root-&amp;gt;val){ auto node = new TreeNode(val); node-&amp;gt;left = root; return node; } // 다음 right 노드를 탐색 root-&amp;gt;right = insertIntoMaxTree(root-&amp;gt;right, val); return root; };};" }, { "title": "LeetCode - 1114. Print in Order", "url": "/posts/ps-leetcode-1114/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Thread Synchronize, Mutex, Condition Variable", "date": "2020-02-15 04:03:00 +0900", "snippet": " 1114. Print in Order - easy문제Suppose we have a class:public class Foo { public void first() { print(&quot;first&quot;); } public void second() { print(&quot;second&quot;); } public void third() { print(&quot;third&quot;); }}The same instance of Foo will be passed to three different threads. Thread A will call first(), thread B will call second(), and thread C will call third(). Design a mechanism and modify the program to ensure that second() is executed after first(), and third() is executed after second().제한사항 We do not know how the threads will be scheduled in the operating system, even though the numbers in the input seems to imply the ordering. The input format you see is mainly to ensure our tests’ comprehensiveness.입출력 예Example 1:Input: [1,2,3]Output: &quot;firstsecondthird&quot;Explanation: There are three threads being fired asynchronously. The input [1,2,3] means thread A calls first(), thread B calls second(), and thread C calls third(). &quot;firstsecondthird&quot; is the correct output.Example 2:Input: [1,3,2]Output: &quot;firstsecondthird&quot;Explanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). &quot;firstsecondthird&quot; is the correct output.풀이 Mutex, Condition Variableclass Foo {public: Foo() {} void first(function&amp;lt;void()&amp;gt; printFirst) { // printFirst() outputs &quot;first&quot;. Do not change or remove this line. printFirst(); m_runId = 2; m_cv.notify_all(); } void second(function&amp;lt;void()&amp;gt; printSecond) { std::unique_lock&amp;lt;std::mutex&amp;gt; lock(m_mutex); while(m_runId != 2) m_cv.wait(lock); // printSecond() outputs &quot;second&quot;. Do not change or remove this line. printSecond(); m_runId = 3; m_cv.notify_all(); } void third(function&amp;lt;void()&amp;gt; printThird) { std::unique_lock&amp;lt;std::mutex&amp;gt; lock(m_mutex); while(m_runId != 3) m_cv.wait(lock); // printThird() outputs &quot;third&quot;. Do not change or remove this line. printThird(); }private: int m_runId = 0; condition_variable m_cv; std::mutex m_mutex;};" }, { "title": "OS - 프로세스", "url": "/posts/os-ch3/", "categories": "Operating System", "tags": "OS", "date": "2020-02-14 07:58:00 +0900", "snippet": "프로세스 프로세스 개념 프로세스 스케쥴링 프로세스에 대한 연산 프로세스간 통신프로세스 개념일괄저리 시스템은 잡(Job) 들을 실행하는 반면세, 시분할 시스템은 사용자 프로그램 또는 태스크(Task) 를 가진다. 이와같은 것들을 프로세스(Process) 라고 한다.프로세스(Process)프로세스란 실행중인 프로그램이다.프로세스는 텍스트 세션 으로 알려진 프로그램 코드 영역과, 프로그램 카운터 의 값과 처리지 레지스터의 내용으로 대표되는 현재 활동을 포함한다. 프로세스는 일반적으로 함수의 매개변수, 복귀주소, 로컬 변수와 같은 임시적인 자료를 가지는 프로세스 스택(Stack) 영역과 전역변수들을 수록하는 데이터 섹션 을 포함한다. 또한 프로세스 실행중 동적으로 할당되는 메모리인 힙(Heap) 을 포함한다. 메모리상의 프로세스 스택영역은 높은 주소로 부터 낮은 주소로 데이터가 기록한다. 힙역역은 낮은 주소로 부터 높은 주소로 데이터를 기록한다. 스택영역과 힙영역은 같은 영역을 공유하고 있으며 이는 가변적이다. 텍스트영역과 데이터역역은 크기가 고정적이다.프로세스 상태(Process State)프로세스는 실행되면서 그 상태가 변경된다. 프로세스 상태도 New 프로세스가 생성 중이다. Ready 프로세스가 처리기에 할당되기를 기다리는 중이다. Running 프로세스가 실행되고 있는 중이다. Waiting 프로세스가 어떠한 이벤트를 기다리는 중이다. Terminated 프로세스의 실행이 종료된다. 어느 한 순간에 한 처리기상에서는 오직 하나의 프로세스만이 실행 된다. 즉 많은 프로세스가 Waiting 및 Ready 상태에 있다.프로세스 제어블록(Process Control Block) 프로세스 제어 블록(PCB) 프로세스 상태(Process State) 상태는 New, Ready, Running, Waiting, Terminated 가 있다. 프로그램 카운터(Program Counter) 이 프로세스가 다음에 실행할 명령어의 주소를 가리킨다. 나중에 프로세스가 계속해서 정상적으로 실행될 수 있도록 인터럽트 발생 시, 저장되어야 한다. 추후 이 프로세스가 다시 실행 될때, 백업을 받은 후, 프로그램 카운터가 가리키는 부분부터 실행 CPU 레지스터들(CPU Registers) 누산기, 인덱스 레지스터, 스택 레지스터, 범용 레지스터등 다양한 타입의 CPU 레지스터의 상태 코드를 포함한다. 프로그램 카운터와 함께 이 상태 정보는 나중에 프로세스가 계속해서 정상적으로 실행될 수 있도록 인터럽트 발생시, 저장되어야 한다. 추후 이 프로세스가 다시 실행 될때, 백업을 받은 후, 중지한 부분부터 실행 CPU 스케쥴링 정보(CPU Scheduling Infomation) 프로세스 우선순위, 스케쥴 큐에 대한 포인터와 다른 스케쥴 매개변수들을 포함한다. 메모리 관리 정보(Memory Management Infomation) OS에 의해 사용되는 메모리 관리 시스템에 따라 기준 레지스터와 한계 레지스터의 값과 같은 정보를 포함한다. OS에 의해 사용되는 메모리 관리 시스템에 따라 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함한다. 회계 정보(Accounting Infomation) CPU 사용 시간과 경과된 실시간, 시간 제한, 제정 정보, 프로세스 번호 등을 포함한다. 입출력 상태 정보(I/O State Infomation) 프로세스에 의해 할당된 입출력 장치들과 열린 파일의 목록 등을 포함한다. 프로세스에서 다른 프로세스로 CPU가 전환되는 흐름도 스레드(Thread)현대의 대부분의 OS는 프로세스의 개념을 확장하여 한 프로세스가 다수의 실행 스레드를 가질 수 있도록 허용한다. 즉, 하나의 프로세스가 다수의 스레드를 가짐으로서 하나 이상의 일을 수행 할 수 있도록 한다.스레드를 지원하는 시스템에서의 PCB 는 각 스레드에 관한 정보를 포함하도록 확장된다.프로세스 스케쥴링다중 프로그래밍의 목적은 CPU 이용을 최대화 하기 위해 항상 어떤 프로세스가 실행되도록 하는데 있다. 시분할의 목적은 각 프로그램이 실행되는 동안 사용자가 상호 작용할 수 있도록 프로세스들 사이에서 CPU를 빈번하게 교체하는 것이다. 이러한 목적을 달성하기 위해 프로세스 스케쥴러(Process Scheduler) 는 CPU에서 실행 가능한 여러 프로세스등 중에서 하나의 프로세스를 선택하여 실행한다. Linux에서의 프로세스 표현 스케쥴링 큐(Scheduling Queue)프로세스가 시스템에 들어오면, 이들은 잡 큐(Job Queue) 에 놓여진다. 이 큐는 시스템 안의 모든 프로세스로 구성되어 있다. 주 메모리에 존재하며, 준비 완료 상태(Ready State)에서 실행을 대기하는 프로세스들은 준비 완료 큐(Ready Queue) 라 불리는 리스트 상에 유지된다.Ready Queue는 일반적으로 Linked List로 저장되어 지며, Ready Queue의 헤더는 리스트의 첫번째와 마지막 PCB를 가리키는 포인터를 포함한다. 각 PCB는 Ready Queue에 있는 다음 프로세스를 가리키는 포인터 필드를 가진다.특정 입출력 장치를 대기하는 프로세스들의 리스트를 장치 큐(Device Queue) 라고 한다. Ready Queue와 다양한 Device Queue 프로세스 프케쥴링의 공통적인 표현 방신은 아래와 같은 큐잉 도표(Queueing Diagram) 이다. 프로세스 스케쥴링을 표현하는 Queueing 도표 새로운 프로세스는 처름에 Ready Queue에 놓인다. 프로세스는 실행을 위해 선택될 때, 즉 CPU를 할당받을(Dispatch) 때 까지 Ready Queue에서 대기한다. 일단 프로세스에 CPU가 할당되어 실행되며느 여러가지 일중 하나가 발생할 수 잇다. 프로세스가 입출력 요청을 하여 입출력 큐에 넣어질수 있다. 프로세스가 새로운 자식 프로세스를 생성하고 자식 프로세스의 종료를 기다릴 수 있다. 프로세스가 인터럽트의 결과에 의해 강제로 CPU로부터 제거되고, Ready Queue에 다시 놓여질 수 있다.프로세스는 종료될 때까지 이 주기를 반복하며, 종료되면 모든 큐에서 삭제되고 그 자신의 PCB와 자원을 반납한다.스케쥴러(Schedulers)프로세스는 일생동안에 다양한 스케쥴링 큐들 사이를 여행한다. OS는 어떤 방식으로든지 스케쥴링 목적을 위해 프로세스들을 큐에서 반드시 선택해야 한다. 선택절차는 적절한 스케쥴러(Schedulers) 에 의해 선택된다.프로세스들은 대용량 메모리(전형적으로 디스크)에 저장되어 나중에 실행될 때 까지 유지된다.장기 스케쥴러(Long-term Scheduler) 또는 잡 스케쥴러 는 이 디스크에서 프로세스들을 선택하여 실행 하기 위해 메모리로 적재한다. 단기 스케쥴러(Short-term Scheduler) 또는 CPU 스케쥴러 는 실행 준비가 완료되어 있는 프로세스들 중에서 선택하여, 이들 중 하나에게 CPU를 할당한다.장기 스케쥴러는 다중 프로그래밍 정도(메모리에 있는 프로세스들의 수) 를 제어한다. 즉 몇개의 프로세스를 메모리에 적재 시킬 것인지 제어한다.입출력 중심의 프로세스 는 연산보다 입출력 실행에 더 많은 시간을 소요하는 프로세스 이다. 반면에 CPU 중싱 프로세스 는 입출력 중심 프로세스보다 연산에 시간을 더 소요하여, 입출력 요청을 드물게 발생시키는 프로세스 이다.장기 스케쥴러는 입출력 중심과 CPU 중심 프로세스들의 적절한 프로세스 혼합(mix) 을 선택하는 것이 중요하다.UNIX와 Windows와 같은 시분할 시스템들은 장기 스케쥴러가 없으며, 모든 새로운 프로세스를 단기 스케쥴러를 위해 단순히 메모리에 넣는다.시분할 시스템과 같은 일부 OS들은 추가로 중간수준의 스케쥴링, 즉 중기 스케쥴러(Medium-term Scheduler) 를 가진다. Queueing 도표에 중기 스케쥴링을 포함 중기 스케쥴어의 핵심 아이디어는 메모리에서 프로세스들을 제거함으로써 다중 프로그래밍의 정도를 완화하는 것이 가끔 바람직할 수 있다는 것이다. 즉 차후에 다시 프로세스를 메모리로 불러와서 중단되었던 지점에서 실행을 재개한다. 이러한 기법을 스와핑(Swapping) 이라 한다. 프로세스는 중기 스케쥴러에 의해 스왑되어 다가고 다시 스왑되어 들어온다.문맥교환(Context Switch)인터럽트가 발생하면 시스템은 인터럽트 처리가 끝난 후에 문맥(Context) 을 복구할 수 있도록 현재 실행 중인 프로세스의 현재 문맥을 저장할 필요가 있다.문맥은 프로세스의 PCB에 표현된다.문맥은 CPU의 레지스터 값, 프로세스 상태, 메모리 관리 정보 등을 포함한다.일반적으로 커널 모드이건, 사용자 모드이건 CPU의 현재 상태를 저장하는 작업을 수행하고(State Save), 나중에 연산을 재개하기 위해 상태 복구 작업을 수행한다(State Restore).CPU를 다른 프로세스로 교환하려면 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 보관된 상태를 복구하는 작업이 필요하다. 이 작업을 문맥 교환(Context Switch) 라고 한다.문맥 교환이 일어나면 커널은 과거 프로세스의 문맥을 PCB에 저장하고, 선택된 새로운 프로세스의 저장된 문맥을 복구한다.문맥 교환이 진행될 동안 시스템이 아무런 유용한 일을 하지 못하기 때문에 문맥 교환 시간은 순수한 오버헤드 이다.프로세스에 대한 연산대부분 시스템 내의 프로세스들은 병행 실행될 수 있으며, 반드시 동적으로 생성되고 제거 되어야 한다.기본적으로 부모 자식간의 프로세스라도 하더라도 프로세스는 서로 독립적이다.프로세스 생성(Process Creation)생성하는 프로세스를 부모 프로세스(Parent Process)라고 하고, 생성되는 프로세스를 자식 프로세스(Child Process) 라고 한다. 즉 프로세스는 다른 프로세스를 생성할 수 있으며 그 결과, 프로세스의 트리를 형성한다.대부분의 현대의 OS들은 유일한 프로세스 식별자(PID) 를 사용해 프로세스를 구분하는데, 일반적으로 특정 정수를 각 프로세스에 할달하여 프로세스에게 고유한 값을 가지도록 한다. 일반적은 Linux 시스템의 프로세스 트리 일반적으로 프로세스가 자식 프로세스를 생성할 때, 그 자식 프로세스는 자신의 일을 달성하기 위해 어떤 자원(CPU 시간, 메모리, 파일, 입출력 장치 등)이 필요하다. 자식 프로세스는 이 자원을 OS로 부터 직접 얻거나, 부모 프로세스가 가진 자원의 부분 집합만을 사용하도록 제한될 수 있다. 부모 프로세스는 자원을 분할하여 자식 프로세스들에게 나우어 주거나 메모리나 파일과 같은 몇몇 자원들은 자식 프로세스들이 같이 사용하게 할 수도 있다.프로세스가 새로운 프로세스를 생성할 때, 두 프로세스를 실행시키는 데 두 가지 가능한 방법이 존재한다. 부모는 자식과 병행하게 실행을 계속한다. 부모는 일부 또는 모든 자식이 실행을 종료할 때까지 기다린다.새로운 프로세스들의 주소 공간 측면에서 볼대 아래와 같이 두가지 가능성이 있다. 자식 프로세스는 부모 프로세스의 복사본이다.(자식 프로세스는 부모와 똑같은 프로그램과 데이터를 가진다.) 자식 프로세스가 자신에게 적재될 새로운 프로그램을 가지고 있다. Linux의 fork() 시스템 콜을 통한 프로세스 생성 프로세스 종료(Process Termination)프로세스 종료에는 크게 두가지가 있다. 프로세스가 마지막 문장의 실행을 끝내고, exit 시스템 호출을 사용하여 OS에게 자신의 삭제를 요청한다. 한 프로세스는 적당한 시스템 호출을 통해, 다른 프로세스의 종료를 유발할 수 있다. 일반적으로, 그런 시스템 호출은 단지 종료될 프로세스의 부모만이 호출할 수 있다.프로세스간 통신OS내에서 실행되는 병행 프로세스들은 독립적 이거나 협력적 인 프로세스들 일수 있다.프로세스 협렵을 허용하는 환경을 제공하는 데는 아래와 같은 이유가 있다. 정보 공유(Information Sharing) 여러 사용자가 동일한 정보(ex 공유 파일)에 접근할 경우가 있을수 있으므로, 그러한 정보를 병행적으로 접근할 수 있는 환경을 제공해야 한다. 계산 가속화(Computation Accelation) 특정한 태스크를 여러 서브 태스크로 나누어, 각각이 다른 서브 태스크들과 병렬로 실행되도록 한다. 다수의 처리 코어를 가져야만 가능하다. 모듈성(Modularity)-시스템의 기능을 별도의 프로세스들 또는 스레들로 나누어, 모듈식 형태로 시스템을 구성하도록 한다. 편의성(Convenience) 개별 사용자들이 한 순간에 작업할 많은 태스크를 가질 수도 있다. 위와 같은 협렵적 프로세스들은 데이터와 정보를 교환할 수 있는 프로세스간 통신(InterProcess Communication) 기법을 필요로 한다.프로세스간 통신에는 기본적으로 공유 메모리(Shared Memory) 와 메시지 전달(Message Passing), 두가지 방식이 있다. Shared Memory model 협력 프로세스들에 의해 공유되는 메모리 영역이 구축된다. 공유 메모리 영역을 구축할 때만 시스템 콜이 필요하다. 공유 메모리 영역이 구축되면, 모든 접근은 일반적인 메모리 접근으로 취급되어 커널의 도움이 필요없다. 메시지 전달 방식보다 빠르다. 멀티코어 시스템에서 공유 메모리는 공유 데이터가 여러 캐시 사이에서 이주하기 때문에 발생하는 캐시 일관성 문제로 인해 성능 저하가 발생한다. Message Passing model 협력 프로세스들 사이에 통신을 통해 메시지를 교환하여 이루어 진다. 충돌을 회피할 필요가 없기 때문에 적은 양의 데이터를 교환하는데 유용하다. 공유 메모리 방식보다 구현이 용이하다. 메시지를 전달할때, 통상적으로 시스템 콜을 사용하여 구현되므로, 커널 간섭 등의 부가적인 시간 소비 작업이 필요하다. 통신 모델. (a) 메시지 전달. (b) 공유 메모리 다중프로세스 구조 - Chrome 브라우저 공유 메모리 시스템(Shared Memory System)통상 공유 메모리 영역은 공유 메모리 세그먼트를 생성하는 프로세스의 주소 공간에 위치한다. 이 공유 메모리 세그먼트를 이용하여 통신하고자 하는 다른 프로세스들은 이 세그먼트를 자신의 주소 공간에 추가하여야 한다.프로세스들은 동시에 동일한 위치에 쓰지 않도록 책임져야 한다.생산자와 소비자가 반드시 동기화(Synchronize) 되어야 생산되지도 않은 항목들을 소비자가 소비하려도 시도하지 않을 것이다.일반적으로 두 가지 유형의 버퍼가 사용된다. 무한 버퍼(Unbounded Buffer) 생산자 소비자 문제 에서는 버퍼의 크기에 실질적인 한계가 없다. 유한 버퍼(Bounded Buffer) 버퍼의 크기가 고정되어 있으므로, 버퍼가 비어있다면 소비자는 반드시 대기하여야 하며, 버퍼가 가득 찼으면 생산자가 대기하여야 한다. // 공유 메모리 사이의 유한 버퍼 #define BUFFER_SIZE 10 typedef struct { . . . } item; item buffer[ BUFFER_SIZE ]; int in = 0; int out = 0; // 공유 메모리를 사용한 생산자 프로세스 item nextProduced; while( true ) { /* Produce an item and store it in nextProduced */ nextProduced = makeNewItem( . . . ); /* Wait for space to become available */ while( ( ( in + 1 ) % BUFFER_SIZE ) == out ) ; /* Do nothing */ /* And then store the item and repeat the loop. */ buffer[ in ] = nextProduced; in = ( in + 1 ) % BUFFER_SIZE; } // 공유 메모리를 사용한 소비자 프로세스 item nextConsumed; while( true ) { /* Wait for an item to become available */ while( in == out ) ; /* Do nothing */ /* Get the next available item */ nextConsumed = buffer[ out ]; out = ( out + 1 ) % BUFFER_SIZE; /* Consume the item in nextConsumed ( Do something with it ) */ }메시지 전달 시스템(Message Passing System)메시지 전달 시스템은 최소한 두가지 연산을 제공한다. Send Receive하나의 링크과 send()/receive() 연산을 논리적으로 구현하는 다수의 방법은 아래와 같다. 직접 또는 간접 통신 동기식(Sync) 도는 비동기식(Async) 통신 자동 도는 명시적 버퍼링명명(Naming)통신을 원하는 프로세스들은 서로를 가리킬 수 있는 방법이 있어야 한다. 이들은 간접통신 또는 직접통신을 할 수 있다.직접 통신직접통신 하에서, 통신을 원하는 각 프로세스는 통신의 수신자 또는 송신자의 이름을 명시해야 한다. send(P, message) 프로세스 P에게 메시지를 전송한다. receive(Q, message) 프로세스 Q에게 메시지를 수신한다. 이 기법에서 통신 연결은 다음과 같은 특성을 가진다. 통신을 원하는 각 프로세스의 쌍들 사이에 연결이 자동적으로 구축된다. 프로세스들은 통신하기 위해 서로 상대방의 신원만 알면 된다. 연결은 정확히 두 프로세스들 사이에만 연관된다. 통신하는 프로세스들의 각 쌍 사이에는 정확하게 하나의 연결이 존재해야 한다.이 기법은 주소 방식에서 대칭성 을 보인다. 즉, 송신자와 수신자 프로세스가 모두 통신 하려면 상대방의 이름을 제시하여야 한다.이 기법의 변형으로서 주소 지정 시에 비대칭 을 사용할 수 있다. 송신자만 수신자 이름을 지명하며, 수신자는 송신자의 이름을 제시할 필요가 없다. send(P, message) 메시지를 프로세스 P에 전송한다. receive(id, message) 임의의 프로세스로 부터 메시지를 수신한다. 변수 id는 통신을 발생시킨 프로세스의 이름으로 설정된다. 간접 통신메시지들은 메일 박스(Mailbox) 또는 포트(Port)로 송신되고, 그곳으로부터 수신된다.메일박스는 추상적으로, 프로세스들에 의해 메시지들이 넣어지고, 메시지들이 제거될 수 있는 객체하라고도 볼 수 있다. send(A, message) 메시지를 메일박스 A로 송신한다. receive(A, message) 메시지를 메일박스 A로 부터 수신한다. 동기화(Synchronization)프로세스간 통신은 send와 receive 프리미티브에 대한 호출에 의해 발생한다.메시지 전달은 봉쇄형(Blocking) 이거나 비봉쇄형(Non Blocking) 방식으로 전달된다. Blocking Send 송신하는 프로세스는 메시지가 수신 프로세스 또는 메일박스에 의해 수신될 때까지 block 된다. Non Blocking Send 송신하는 프로세스가 메시지를 보내고 이후 작업을 재개 한다. Blocking Receive 메시지가 이용 가능할 때까지 수신 프로세스가 block 된다. Non Blocking Receive 송신하는 프로세스가 유효한 메시지 도는 null을 받는다. 메시지 전달을 사용한 소비자 프로세스 버퍼링(Buffering)통신하는 프로세스들에 의해 교환되는 메시지는 임시 큐에 들어 있다. 무용량(Zero Capacity) 링크는 자체 안에 대기하는 메시지들을 가질수 없다. 송신자는 수신자가 메시지를 수신할 때 까지 기다린다. 유한 용량(Bounded Capacity) 큐는 유한한 길이 n을 가진다. 큐가 가득 차게되면 송신자는 큐 안이 이용 가능할 때까지 봉쇄되어야 한다. 무한 용량(Unbounded Capacity) 큐는 잠재적으로 무한한 길이를 가진다. 송신자는 결코 봉쇄되지 않는다. " }, { "title": "OS - 시스템 구조", "url": "/posts/os-ch2/", "categories": "Operating System", "tags": "OS", "date": "2020-02-13 06:09:00 +0900", "snippet": "시스템 구조 운영체제 서비스 시스템 호출 시스템 호출의 유형 시스템 프로그램 운영체제 설계 및 구현 운영체제 구조 운영체제 서비스운영체제는 프로그램의 실행 환경을 제공한다.운영체제가 사용자에게 제공하는 서비스의 종류 사용자 인터페이스(User Interface) Command Line Interface(CLI) Graphical User Interface(GUI) Batch Interface(BI) 명령어와 명령어를 제어하는 디렉티브가 파일형태로 입력되어 그 파일이 실행되는 구조 프로그램 수행(Program Execution) OS는 프로그램을 메모리에 적재하여 실행할 수 있어야 함 OS는 프로그램을 정상적이든 비정상적이든 실행을 끝낼수 있어야 함 입출력 연산(I/O Operations) OS는 수행중인 프로그램에게 파일, 다양한 입출력 장치등과 연관된 입출력을 요구할 수 있음 파일 시스템 조작(File System Manipulation) OS는 프로그램에게 파일을 생성하고 삭제할 수 있고 지정된 파일을 찾을수 있어야 하며 파일의 정보를 얻을 수 있어야 함 OS는 프로그램에게 파일 소유권에 기반을 둔 권한 관리를 이용하여 파일이나 디렉토리의 접근을 허가하거나 거부할 수 있어야 함 통신(Communication) OS는 한 프로세스가 다른 프로세스와 정보를 교환할 수 있도록 환경을 제공하여야 함 공유메모리(Shared Memory) 통해 프로세스간 통신 메시지 전달(Message Passing) 은 정보의 패킷들이 OS에 의해 프로세스 사이를 이동 EX) pipe, queue, socket 오류 탐지(Error Detection) OS는 모든 가능한 오류를 항상 의식하고 있어야 함 오류는 CPU, 메모리 하드웨어, 입출력 장치 또는 사용자 프로그램에서 일어날 수 있음 운영체제 서비스의 관점 컴퓨터 시스템의 동작을 위한 운영체제의 기능 자원 할당(Resource Allocation) 다수의 사용자나 다수의 작업들이 동시에 실행될 때, 그들 각각에게 자원을 할당해 주어야 함 회계(Accounting) OS는 사용자가 어떤 종류의 컴퓨터 자원을 얼마나 사용하고 있는지 추적할 수 있어야 함 보호와 보안(Protection and Security) OS는 시스템 자원에 대하여 모든 접근이 통제 될수 있도록 보장하여야 함 OS는 외부로부터 시스템이 보호디고 보안이 유지되도록 하여야 함 시스템 콜 (System Call)시스템 콜(System Call) 은 OS에 의해 사용 가능하게 된 서비스에 대한 인터페이스를 제공한다. 또한 일반 프로세스와 OS가 통신하기 위한 유일한 방법이다. 시스템콜의 사용예 각 시스템 콜에는 번호가 할당되고 시스템 콜 인터페이스는 이 번호에 따라 색인되는 테이블을 유지한다. 시스템 콜 인터페이스는 의도하는 시스템 콜을 부르고 시스템 콜의 상태와 반환 값을 리턴한다. open() 시스템콜을 호출한 사용자 프로그램의 처리 테이블로 매개변수 전달 OS에 매개변수를 전달하기 위해 세가지 일반적인 방법을 사용한다. 매개변수를 레지스터에 전달 매개변수는 메모리 내의 블록이나 테이블에 저장하고, 블록의 주소가 레지스터 내에 매개변수로 전달 Block Method 매개변수는 프로그램에 의해 스택(Stack) 에 넣어질(Push) 수 있고, OS에 의해 꺼내진다(Pop). Stack Method 시스템 콜의 유형시스템 콜은 크게 다섯가지로 분류 될 수 있다. 프로세스 제어 (Process Control) 끝내기(end), 중지(abort) 적재(load), 수행(execute) 생성(create), 종료(terminate) 프로세스 속성(attributes) 획득, 프로세스 속성(attributes) 설정 시간을 기다림 사건을 기다림(wait event), 사건을 알림(signal event) 메모리 할당 및 자유화 파일 조작 (File Manipulate) 생성(create), 삭제(delete) 열기(open), 닫기(close) 읽기(read), 쓰기(write), 위치 변경(reposition) 파일 속성 획득 및 설정 장치 관리 (Device Management) 장치 요구(request), 장치 방출(release) 읽기(read), 쓰기(write), 위치 변경(reposition) 장치 속성 획득 및 설정 장치의 논리적 부착(attach) 및 분리(detach) 정보 유지 (Information Maintenance) 시간과 날짜의 설정과 획득 시스템 데이터의 설정과 획득 프로세스, 파일, 장치 속성의 획득 및 설정 통신 (Communication) 통신 연결의 생성, 제거 메시지의 송신, 수신 상태 정보 전달 원격 장치의 부착(attach) 및 분리(detach) Windows와 UNIX 시스템 콜의 예 표준 C 라이브러리의 예 멀티 프로그램을 수행하는 FreeBSD 운영체제 설계 및 구현설계 목표OS를 설계하기 이전에, 시스템의 목표, 명세, 요구사항들을 근본적으로 사용자의 목적과 시스템 목적 두가지로 기본 그룹으로 나눈다.사용자들이 시스템에 대하여 기대하는 특징은 대게 사용하기 쉽고, 배우기 쉽고, 믿을 수 있고, 안전하고, 신속해야 한다는 점이다. 이에 유사하게 시스템을 설계, 생성, 유지, 조작해야 하는 사람들에게도 비슷하게 정의될 수 있는데, OS는 설계, 구현, 유지 보수가 쉬워야 하며 또한 적응성, 신뢰성, 무오류, 효율성을 가져야 한다는 점이다.기법과 정책한가지 중요한 원칙은 기법(Mechanism) 으로부터 정책 을 분리하는 것이다. 기법은 어떤 일을 어떻게 할 것인가를 결정하는 것이고, 정책은 무엇 을 할 것인가를 결정하는 것이다.운영체제 구조일반적인 접근 방법은 한 개의 일관된 시스템 보다는 태스크를 작은 구성요소로 분할하는 것이다.간단한 구조(Simple Structure) MS-DOS의 계층 구조 전통적인 UNIX 시스템의 구조 계층적 접근(Layered Approach)시스템은 다양한 방식으로 모듈화 될 수 있다. OS를 여러개의 계층으로 나누어 구별하는 방식. 계층구조의 운영체제 각 층은 자신보다 하위 수준의 층에 의해 제공된 연산만 사용해 구현한다.계층적 접근 방법의 가장 어려운 점은 여러 층을 적절히 정의하는 것이다.마이크로커널(Microkernels)모든 중요하지 않은 구성 요소를 커널로부터 제거하고, 그들을 시스템 및 사용자 수준의 프로그램으로 구현하여 OS를 구성하는 방법 일반적인 마이크로 커널의 구조 마이크로커널의 단점중 하나는 가중된 시스템 기능 오버헤드 때문에 성능이 나빠진다는 점이다.모듈(Modules)OS 설계하는데 이용되는 최근 기술에는 적재가능한 커널 모듈(Loadable Kernel Modules) 기법이다. 커널은 핵심적인 구성요소의 집합을 가지고 있고 부팅 때 또는 실행 중에 부가적인 서비스들을 모듈을 통래 링크한다.커널의 각 부분이 정의되고 보호된 인터페이스를 가진다는 점에서 계층구조와 닮았지만, 모듈에서 임의의 다른 모듈을 호출할 수 있다는 점에서 보다 유연하다. Solaris 적재가능 모듈 " }, { "title": "LeetCode - 1008. Construct Binary Search Tree from Preorder Traversal", "url": "/posts/ps-leetcode-1008/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Tree", "date": "2020-02-12 08:23:00 +0900", "snippet": " 1008. Construct Binary Search Tree from Preorder Traversal - medium문제Return the root node of a binary search tree that matches the given preorder traversal.(Recall that a binary search tree is a binary tree where for every node, any descendant of node.left has a value &amp;lt; node.val, and any descendant of node.right has a value &amp;gt; node.val. Also recall that a preorder traversal displays the value of the node first, then traverses node.left, then traverses node.right.)제한사항 1 &amp;lt;= preorder.length &amp;lt;= 100 The values of preorder are distinct.입출력 예Example 1:Input: [8,5,1,7,10,12]Output: [8,5,10,1,7,null,12]풀이 Tree/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: // start index의 값보다 큰 값의 index 리턴 int getMaxIndex(vector&amp;lt;int&amp;gt;&amp;amp; preorder, int start, int last){ for(auto i = start + 1 ; i &amp;lt; last ; ++i){ if(preorder[i] &amp;gt; preorder[start]){ return i; } } // start index보다 큰 값이 없으면 last 리턴 return last; } TreeNode* createNode(vector&amp;lt;int&amp;gt;&amp;amp; preorder, int start, int last){ // start와 last가 같다는것은 이후 노드가 없다는 뜻 if(start == last) return nullptr; TreeNode* node = new TreeNode(preorder[start]); auto maxIndex = getMaxIndex(preorder, start, last); // start가 maxIndex보다 작다는 것은, // start와 last사이에 start의 값보다 작은 수가 있다는 뜻이므로, // 이는 left child 노드의 후보가 됨 if(start &amp;lt; maxIndex) node-&amp;gt;left = createNode(preorder, start + 1, maxIndex); // maxIndex가 last보다 작다는 것은, // maxIndex가 last사이에 maxIndex의 값보다 큰 수가 있다는 뜻이므로, // 이는 right child 노드의 후보가 됨 if(maxIndex &amp;lt; last) node-&amp;gt;right = createNode(preorder, maxIndex, last); return node; } TreeNode* bstFromPreorder(vector&amp;lt;int&amp;gt;&amp;amp; preorder) { TreeNode* head = createNode(preorder, 0, preorder.size()); return head; }};" }, { "title": "LeetCode - 1347. Minimum Number of Steps to Make Two Strings Anagram", "url": "/posts/ps-leetcode-1347/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Hash, String", "date": "2020-02-12 07:03:00 +0900", "snippet": " 1347. Minimum Number of Steps to Make Two Strings Anagram - medium문제Given two equal-size strings s and t. In one step you can choose any character of t and replace it with another character.Return the minimum number of steps to make t an anagram of s.An Anagram of a string is a string that contains the same characters with a different (or the same) ordering.제한사항 1 &amp;lt;= s.length &amp;lt;= 50000 s.length == t.length s and t contain lower-case English letters only.입출력 예Example 1:Input: s = &quot;bab&quot;, t = &quot;aba&quot;Output: 1Explanation: Replace the first &#39;a&#39; in t with b, t = &quot;bba&quot; which is anagram of s.Example 2:Input: s = &quot;leetcode&quot;, t = &quot;practice&quot;Output: 5Explanation: Replace &#39;p&#39;, &#39;r&#39;, &#39;a&#39;, &#39;i&#39; and &#39;c&#39; from t with proper characters to make t anagram of s.Example 3:Input: s = &quot;anagram&quot;, t = &quot;mangaar&quot;Output: 0Explanation: &quot;anagram&quot; and &quot;mangaar&quot; are anagrams. Example 4:Input: s = &quot;xxyyzz&quot;, t = &quot;xxyyzz&quot;Output: 0Example 5:Input: s = &quot;friend&quot;, t = &quot;family&quot;Output: 4풀이 Hash, Stringclass Solution {public: int minSteps(string s, string t) { int ans = 0; map&amp;lt;char, int&amp;gt; m; // 각각 문자 및 반복횟수를 map으로 구성 for(auto&amp;amp; i : s) ++m[i]; for(auto&amp;amp; i : t){ // 현재 문자가 map에 저장되어 있다면 -1 하여 문자의 수를 맞춤 if(m[i] &amp;gt; 0){ --m[i]; } // 현재 문자가 map에 없다면 바꿔야할 문자 else{ ++ans; } } return ans; }};" }, { "title": "LeetCode - 1329. Sort the Matrix Diagonally", "url": "/posts/ps-leetcode-1329/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Array, Sort", "date": "2020-02-12 06:41:00 +0900", "snippet": " 1329. Sort the Matrix Diagonally - medium문제Given a m * n matrix mat of integers, sort it diagonally in ascending order from the top-left to the bottom-right then return the sorted array.제한사항 m == mat.length n == mat[i].length 1 &amp;lt;= m, n &amp;lt;= 100 1 &amp;lt;= mat[i][j] &amp;lt;= 100입출력 예Input: mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]Output: [[1,1,1,1],[1,2,2,2],[1,2,3,3]]풀이 Array, Sortclass Solution {public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; diagonalSort(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; mat) { int m = mat.size(); int n = mat[0].size(); // 첫번째 행의 대각선을 조사하여 정렬 for(int i = 0 ; i &amp;lt; n ; ++i){ vector&amp;lt;int&amp;gt; temp; int colm = i, row = 0; // 현재 요소의 대각선 값을 임시 vector에 저장 for(row = 0 ; row &amp;lt; m &amp;amp;&amp;amp; colm &amp;lt; n ; ++row, ++colm){ temp.push_back(mat[row][colm]); } sort(temp.begin(), temp.end()); // 정렬한 값을 저장 row = 0; colm = i; for(auto&amp;amp; j : temp){ if(row &amp;lt; m &amp;amp;&amp;amp; colm &amp;lt; n){ mat[row][colm] = j; } ++row; ++colm; } } // 첫번째 열의 대각선을 조사하여 정렬 for(int i = 1 ; i &amp;lt; m ; ++i){ vector&amp;lt;int&amp;gt; temp; int row = i, colm = 0; // 현재 요소의 대각선 값을 임시 vector에 저장 for(int colm = 0 ; row &amp;lt; m &amp;amp;&amp;amp; colm &amp;lt; n ; ++row, ++colm){ temp.push_back(mat[row][colm]); } sort(temp.begin(), temp.end()); // 정렬한 값을 저장 row = i; colm = 0; for(auto&amp;amp; j : temp){ if(row &amp;lt; m &amp;amp;&amp;amp; colm &amp;lt; n){ mat[row][colm] = j; } ++row; ++colm; } } return mat; }};" }, { "title": "LeetCode - 451. Sort Characters By Frequency", "url": "/posts/ps-leetcode-451/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Hash", "date": "2020-02-11 08:14:00 +0900", "snippet": " 451. Sort Characters By Frequency - medium문제Given a string, sort it in decreasing order based on the frequency of characters.제한사항 1 &amp;lt;= A.length = A[0].length &amp;lt;= 20 0 &amp;lt;= A[i][j] &amp;lt;= 1입출력 예Example 1:Input:&quot;tree&quot;Output:&quot;eert&quot;Explanation:&#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once.So &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &quot;eetr&quot; is also a valid answer.Example 2:Input:&quot;cccaaa&quot;Output:&quot;cccaaa&quot;Explanation:Both &#39;c&#39; and &#39;a&#39; appear three times, so &quot;aaaccc&quot; is also a valid answer.Note that &quot;cacaca&quot; is incorrect, as the same characters must be together.Example 3:Input:&quot;Aabb&quot;Output:&quot;bbAa&quot;Explanation:&quot;bbaA&quot; is also a valid answer, but &quot;Aabb&quot; is incorrect.Note that &#39;A&#39; and &#39;a&#39; are treated as two different characters.풀이 Hashclass Solution {public: string frequencySort(string s) { string ans = &quot;&quot;; unordered_map&amp;lt;char, int&amp;gt;m; vector&amp;lt;pair&amp;lt;int, char&amp;gt;&amp;gt; item; // map을 통해 문자열내의 반복 문자의 횟수를 계산 for(auto&amp;amp; i : s) ++m[i]; // 정렬을 위해 vector에 저장 for(auto&amp;amp; i : m) item.push_back({i.second, i.first}); // 내림차순으로 정렬 sort(item.begin(), item.end(), [](pair&amp;lt;int, char&amp;gt; &amp;amp;a, pair&amp;lt;int, char&amp;gt; &amp;amp;b){ return a.first &amp;gt; b.first; }); // 많은 반복문자 순으로 문자열 구성 for(auto&amp;amp; i : item){ for(auto j = 0 ; j &amp;lt; i.first ; ++j) ans.push_back(i.second); } return ans; }};" }, { "title": "OS - 개요", "url": "/posts/os-ch1/", "categories": "Operating System", "tags": "OS", "date": "2020-02-11 06:34:00 +0900", "snippet": "개요 운영체제가 하는 일 컴퓨터 시스템의 구성 컴퓨터 시스템의 구조 운영체제의 구조 운영체제의 연산 프로세스 관리 메모리 관리 저장장치 관리 운영체제가 하는 일컴퓨터 시스템은 대게 네 가지 구성 요소인 하드웨어, 운영체제, 응용 프로그램, 사용자 로 구분할 수 있다.하드웨어 는 중앙 처리 장치(CPU), 메모리, 입출력장치(I/O) 로 구성되어 기본 자원을 제공한다.응용 프로그램 은 컴파일러, 웹 브라우저, 워드 프로세서등 사용자의 문제를 해결하기 위해 이들 자원이 어떻게 사용될지 정의한다.운영체제 는 다른 프로그램이 유용한 작업을 할 수 있도록 기본 환경을 제공한다. 기본적으로 운영체제는 응용 프로그램에게 자원을 할당하고, 실행하고 있는 프로그램을 관리하는 역할을 수행한다.시스템관점에서의 운영체제 Resource Allocator 컴퓨터 시스템은 사용자의 문제를 해결하기 위해 요구되는 CPU, 메모리, 저장공간, 입출력장치등의 하드웨어 및 소프트웨어 자원을 관리하는 관리자로써의 역할을 수행하며, 작업을 위해 특정 프로그램과 사용자에게 필요한 자원을 할당한다. Control Program 운영체제는 다양한 입출력 장치와 사용자 프로그램을 제어한다. 따라서 운영체제는 컴퓨터 시스템의 가장 기본적인 제어 프로그램이라고 할수 있으며, 컴퓨터 시스템의 부적절한 사용을 방지하기 위해 사용자 프로그램의 수행을 제어한다. 컴퓨터 시스템의 구성컴퓨터 시스템의 연산현대의 범용 컴퓨터 시스템은 공유 메모리에 대한 접근을 제공하는 공통 버스에 의해 연결된 여러개의 장치 제어기와 하나 이상의 CPU로 구성되어 있다.컴퓨터가 구동을 시작하기 위해, 가장 먼저 실행할 부트스트랩 프로그램(Bootstrap Program) 이 필요하다.이 부트스트랩 프로그램 은 일반적으로 컴퓨터 내의 ROM(Read Only Memory) 이나 EEPROM에 저장되어 지며, 이를 펌웨어 라도로 한다. 이것은 CPI 레지스터로부터, 장치제어기, 메모리 내용등을 포함한 시스템의 모든 면을 초기화한다. 그리고 운영체제의 커널을 찾아 메모리에 적재한다.운영체제의 커널이 적재 되고 수행이 시작되면 시스템과 사용자에게 서비스를 제공할 수 있게 된다.일부 서비스는 커널이 아닌 시스템 프로그램에 의해 제공되며 이는 부팅시 커널이 적재된후 같이 메모리에 적재되어 진다.이 단계가 끝나면 시스템은 완전이 부트된 상태이며 시스템은 이벤트(event)가 발생하기를 기다린다.사건이 발생하면 하드웨어나 또는 소프트웨어로부터 발생한 인터럽트(Interrupt) 에 의해 신호가 보내어진다. 하드웨어는 어느 순간이든 시스템 버스를 통해 CPU에 신호는 보내 인터럽트를 발생시킬수 있다. 소프트웨어는 시스템 호출(System Call) 을 통해 인터럽트를 발생 시킬 수 있다.CPU가 인터럽트 되면, CPU는 하던 일을 중단하고, 즉시 고정된 위치로 실행을 옮긴다. 이러한 고정된 위치는 일반적으로 인터럽트를 위한 서비스 루틴이 위치한 시작주소를 자기고 있다. 그리고 인터럽트 서비스 루틴 이 실행된다. 인터럽트 서비스 루틴의 실행이 완료 되면, CPU는 인터럽트 되었던 연산을 재개한다.인터럽트는 매우 빠르게 처리되어야 하고, 사용가능한 인터럽트의 수가 미리 정의 되어 있으므로, 인터럽트 루틴에 대한 포인들의 테이블을 이용할수 있다. 이 경우 중간 루틴을 둘 필요 없이, 테이블을 통하여 간접적으로 인터럽트 루틴이 호출되어 질 수 있다. 이렇게 인터럽트 서비스 루틴의 주소를 제공하기 위해, 제공되는 배열을 인터럽트 벡터 라고 한다.저장 장치 구조CPU는 명령어를 단지 메모리로부터 가져올 수 있으므로 프로그램을 수행하려면 프로그램이 반드시 메모리에 있어야 한다. 일반적인 컴퓨터 시스템은 대부분의 프로그램을 주 메모리(RAM) 이라 불리는 메모리에서 가져온다.모든 형태의 메모리는 바이트의 배열을 제공한다. 각 바이트는 자신의 주소를 자지고 있으며, 상호작용은 특정 메모리 주소들에 대한 일련의 적재(load), 저장(store) 명령을 통하여 이루어 진다.현대의 컴퓨터 시스템의 기본 아키텍쳐인 폰 노이만 구조 시스템에서 실행되는 전형적인 명령-실행 사이클은 먼저 메모리로부터 명령을 인출해, 그 명령은 명령 레지스터(Instruction Register) 에 저장한다. 이어서 명령을 해독하고, 이는 메모리로부터 피연산자를 인출하여 내부 레지스터에 저장할수 있도록 한다. 피 연산자에 대한 명령을 수행 한 후에 결과가 다시 메모리에 저장된다.명령어 사이클의 종류는 아래와 같다. Fetch Cycle(인출 사이클) 제어장치가 앞의 명령 실행을 완료한 후 다음에 실행할 명령을 기억 장치로부터 CPU로 가져오는 동작 을 완료할 때까지의 사이클 Indirect Cycle(간접 사이클) 간접 주소 지정이 허용되는 경우 실행 사이클에 앞서 간접 사이클이 진행되는데, 오퍼랜드가 지정하는 곳으로부터 유효주소를 읽어들이기 위해 메모리에 접근하는 사이클 Execute Cycle(실행 사이클) 인출된 명령어를 이용하여 직접 명령어를 실행하는 사이클 Interrupt Cycle(인터럽트 사이클) 현재 수행중인 명령이 예기치 않은 일의 발생으로 중단되는 상태 저장창치의 종류는 아래와 같다.입출력 구조장치 제어기는 약간의 로컬 버퍼 저장 장치와 특수 목적용 레지스터 집합을 유지한다.통상적으로 윤용체제는 각 장치 제어기마다 디바이스 드라이버를 가지고 있다. 이 디바이스 드라이버는 장치 제어기의 동작을 이해하도 운영체제의 다른 부분들에게 장치에 대한 일관된 인터페이스를 제공한다.입출력 연산을 시작하기 위해, 디바이스 드라이버는 장치 제어기의 적절한 레지스터에 필요한 값을 적재한다. 장치 제어기는, 취할 동작을 결정하기 위해 이들 레지스터의 내용을 조사한다. 제어기는 장치로부터 자신의 로컬버퍼로 데이터 전송을 시작한다. 일단 데이터의 전송이 완료되면, 장치 제어기는 자신이 연산을 완료 했음을 인터럽트를 이용하여 디바이스 드라이버에게 통보한다. 그렇게 되면 디바이스 드라이버는 제어를 운영체제에게 반환하고 이때 입력 완료인 경우에는 데이터 또는 데이터에 대한 포인터를 같이 반환할 수도 있다.이 인터럽트 구동 방식의 입출력은 적은 데이터를 전송하는 데에는 문제가 없으나 대량의 데이터를 전송하는 데에는 성능에 저하가 일어난다. 이러한 문제를 해결하기 위해 직접 메모리 접근(Direct Memory Access) 장치가 사용된다.컴퓨터 시스템의 구조요즘날에 사용되는 다중처리 시스템(MultiProcessor System) 은 크게 두가지 형태를 가진다. 비대칭적 다중 처리(Asymmetric Multiprocessing) 하나의 주 처리기가 시스템을 제어한다. 다른 처리기들은 주 처리기의 명령을 수행하거나 미리 정의된 작업을 수행한다. 주종관계에 있으며, 주 처리기는 작업을 스케쥴링하고, 종속처리기에 작업을 할당한다. 대칭적 다중 처리(Symmetric Multiprocessing) 대칭적 다중 처리(SMP)는 모든 처리기가 대등하다. Window, Linux, MAC OS등 거의 모든 현대의 OS는 SMP를 지원한다. 대칭적 다중 처리 구조 현대의 CPU 설계 근황은 하나의 칩에 여러개의 코어를 포함시킨다. 이러한 구조의 다중처리 시스템을 멀티코어 시스템이라 한다. 멑티 코어 시스템 운영체제의 구조운영체제의 핵심중 하나는 여러개의 프로그램을 실행할 수 있는 능력이다. 이를 다중 프로그램(Multi Program) 이라 한다.다중 프로그래밍(MultiProgramming) 은 CPU가 수행할 작업(코드와 데이터)을 항상 하나 가지도록 작업을 구상하여 CPU의 이용률을 증가시킨다. 다중프로그래밍 시스템의 메모리 배치 멀티태스킹(Multi Tasking) 은 다중 프로그래밍의 논리적 확장이다. 멑티태스킹 시스템에서는 CPU가 다수의 작업들을 교대로 수행하지만, 매우 빈번하게 교대가 일어나기 때문에 프로그램이 실행되는 동안에 사용자는 각자 자기의 프로그램와 상호작용 할 수 있다. Multi Programming Throughput을 극대화 작업도중에 User의 간섭 불가능 Multi Tasking User 친화적 운영체제의 연산현대의 OS는 인터럽트 구동식(Interrupt Driven) 이다.컴퓨터 시스템에서 사건은 거의 항상 인터럽트나 트랩을 발생시켜 신호를 보낸다.트랩(예외)은 오류(0으로 나누기, 유요하지 않은 메모리 접근) 혹은 사용자 프로그램의 OS 서비스 수행 요청에 의해 유발되는 SW에 의해 생성된 인터럽트 이다.이중 연산모드(Duel Operate)OS의 적절한 동작을 보장하기 위해, OS 코드의 실행과 사용자 정의 코드의 실행을 구분할 수 있어야 한다.이를 보장하기 위해 두개의 독립된 연산보드, 즉 사용자 모드와 커널 모드를 필요로 한다.두 모드를 구분하기 위해서 모드 비트(Mode Bit) 라 불리는 하나의 비트가 현재의 모드를 나타내기 위해 컴퓨터의 하드웨어에 추가된다. 커널 모드 : 0 사용자 모드 : 1시스템 부트 시, 하드웨어는 커넣모드에서 부터 시작된다. OS가 적재되고, 사용자 모드에서 사용자 프로세스가 실행된다.트랩이나 인터럽트가 발생할 때 마다, 하드웨어는 사용자 모드에서 커널 모드로 전환한다. 사용자 모드에서 커널 모드로 변환 타이머사용자 프로그램이 무한루프에 빠지거나 시스템 서비스 호출에 실패하여, 제어가 OS로 복귀하지 않는 경우가 없도록 반드시 방지 해야한다. 이를 위해 타이머(Timer) 를 사용한다. 타이머는 지정된 시간 후 컴퓨터를 인터럽트 하도록 설정한다.프로세스 관리하나의 프로그램은 디스크에 저장된 파일의 내용과 같이 수동적 개체인 반면, 프로세스는 다음 수행할 명령을 지정하는 프로그램 카운터(Program Counter) 를 가진 능동적 인 개체이다.한 프로세스의 수행은 반드시 순차적이여야 한다.OS는 프로세스 관리와 연관하여 아래와 같은 활동에 책임을 진다. CPU에 프로세스와 스레드를 스케쥴링 사용자 프로세스와 시스템 프로세스 생성 및 제거 프로세스의 일시 중지와 재수행 프로세스 동기화 제공 프로세스 통신 제공메모리 관리주 메모리는 CPU와 I/O 장치에 의해 공유되는 데이터의 저장소이다.프로그램이 수행되기 위해선, 반드시 절대 주소로 매핑되어야 하고 메모리에 적재되어야 한다.OS는 메모리 관리와 연관하여 아래와 같은 활동에 책임을 진다. 현재 메모리의 사용현황 추적 어떠한 프로세스들을 메모리에 적재하고 제거할 것인지 선정 메모리 공간 할당 및 회수저장장치 관리파일은 파일 생성자에 의해 정의된 관련 정보의 집합체이다.OS는 파일 관리와 연관하여 아래와 같은 활동에 책임을 진다. 파일의 생성 및 제거 디렉토리 생성 및 제거 파일과 디렉토리를 조작하기 위한 프리미티브 제공 파일을 보조 저장 장치로 매핑 안정적인 저장 매체에 파일 백업캐싱(Caching)정보가 사용됨에 따라 보다 빠른 장치인 캐시에 일시적으로 복사된다. 저장장치의 각 단계별 성능 정수 A를 디스크에서 레지스터로 이동하는 과정 CPU가 내부 레지스터를 유지할 뿐만 아니라 로컬 캐시도 가지고 있는 다중 처리기 환경에서 나타날 수 있는 문제는, A의 복사본이 동시에 여러 캐시에 존재 할 수 있다는 것 이다. 여러개의 CPU가 모두 동시에 실행될 수 있으므로, 한 캐시에 있는 A값이 갱신될 경우, A가 존재하는 모든 캐시에 즉각적으로 반영 되어야 한다. 이러한 문제를 캐시 일관성 문제라 한다.입출력 시스템(I/O System)OS의 목적중 하나는 사용자에게 특정 하드에어 장치의 특성을 숨기는 것이다.일반적으로 입출력 시스템은 아래와 같이 구성된다. 버퍼링, 캐싱, 스풀링을 포함한 메모리 관리 구성요소 일반적인 장치 드라이버 인터페이스 특정 하드웨어 장치들을 위한 드라이버" }, { "title": "LeetCode - 832. Flipping an Image", "url": "/posts/ps-leetcode-832/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Array", "date": "2020-02-10 04:25:00 +0900", "snippet": " 832. Flipping an Image - easy문제Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image.To flip an image horizontally means that each row of the image is reversed. For example, flipping [1, 1, 0] horizontally results in [0, 1, 1].To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0].제한사항 1 &amp;lt;= A.length = A[0].length &amp;lt;= 20 0 &amp;lt;= A[i][j] &amp;lt;= 1입출력 예Example 1:Input: [[1,1,0],[1,0,1],[0,0,0]]Output: [[1,0,0],[0,1,0],[1,1,1]]Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]Example 2:Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]풀이 Arrayclass Solution {public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; flipAndInvertImage(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; A) { for(auto&amp;amp; i : A){ // 행을 뒤집음 std::reverse(i.begin(), i.end()); // 값을 뒤집음 for(auto&amp;amp; j : i){ j ^= 1; } } return A; }};" }, { "title": "LeetCode - 907. Sum of Subarray Minimums", "url": "/posts/ps-leetcode-907/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Array, Stack", "date": "2020-02-09 02:59:00 +0900", "snippet": " 907. Sum of Subarray Minimums - medium문제Given an array of integers A, find the sum of min(B), where B ranges over every (contiguous) subarray of A.Since the answer may be large, return the answer modulo 10^9 + 7.제한사항 1 &amp;lt;= A.length &amp;lt;= 30000 1 &amp;lt;= A[i] &amp;lt;= 30000입출력 예Input: [3,1,2,4]Output: 17Explanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1. Sum is 17.풀이 Array, Stack// 분석 필요class RepInteger{public: RepInteger(int v, int c) : val(v), count(c) {} int val, count;};class Solution {public: int sumSubarrayMins(vector&amp;lt;int&amp;gt;&amp;amp; A) { int ans = 0, dot = 0; int n = A.size(), mod = 1e9 + 7; stack&amp;lt;RepInteger&amp;gt; s; for (int i = 0; i &amp;lt; n; ++i) { // Add all answers for subarrays [i, j], i &amp;lt;= j int count = 1; while (!s.empty() &amp;amp;&amp;amp; s.top().val &amp;gt;= A[i]) { RepInteger node = s.top(); s.pop(); count += node.count; dot -= node.val * node.count; } s.push(RepInteger(A[i], count)); dot += A[i] * count; ans += dot; ans %= mod; } return ans; }};" }, { "title": "LeetCode - 5. Longest Palindromic Substring", "url": "/posts/ps-leetcode-5/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, String, Array", "date": "2020-02-09 00:56:00 +0900", "snippet": " 5. Longest Palindromic Substring - medium문제Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.제한사항입출력 예Example 1:Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer.Example 2:Input: &quot;cbbd&quot;Output: &quot;bb&quot;풀이 String, Arrayclass Solution {public: string longestPalindrome(string s) { if(s.size() &amp;lt; 2) return s; string answer = &quot;&quot;; for(auto index = 1 ; index &amp;lt; s.size() ; ++index){ string oddRes = {s[index]}, evenRes = {s[index]}; int oddLeft = index - 1, oddRight = index + 1; int evenLeft = index - 1, evenRight = index; bool oddFlag = false, evenFlag = false; while(1){ // 문자열의 길이가 홀수인 sub palindrome 검색 // 문자열의 길이가 홀수 이므로 현재 index를 기준으로 잡고, // 양쪽의 index를 --left, ++right 하여 각 문자르 비교해 sub palindrome 탐색 if((oddLeft &amp;gt;= 0 &amp;amp;&amp;amp; oddRight &amp;lt; s.size()) &amp;amp;&amp;amp; (s[oddLeft] == s[oddRight])){ oddRes = s.substr(oddLeft, oddRight - oddLeft + 1); --oddLeft; ++oddRight; } // 비교시 같지 않다면 트리거를 true로 변환 else{ oddFlag = true; } // 문자열의 길이가 짝수인 sub palindrome 검색 // 문자열의 길이가 짝수 이므로 초기 right의 index를 중앙 index로 기준을 잡고, // 양쪽의 index를 --left, ++right 하여 각 문자르 비교해 sub palindrome 탐색 if((evenLeft &amp;gt;= 0 &amp;amp;&amp;amp; evenRight &amp;lt; s.size()) &amp;amp;&amp;amp; (s[evenLeft] == s[evenRight])){ evenRes = s.substr(evenLeft, evenRight - evenLeft + 1); --evenLeft; ++evenRight; } // 비교시 같지 않다면 트리거를 true로 변환 else{ evenFlag = true; } // 짝수, 홀수 모두 트리거가 true면, // 현재 index기준으 sub palindrome 탐색완료 if(oddFlag &amp;amp;&amp;amp; evenFlag) break; } // 문자열의 길이가 긴 palindrome을 선택 auto sub = oddRes.size() &amp;gt; evenRes.size() ? oddRes : evenRes; answer = answer.size() &amp;gt; sub.size() ? answer : sub; } return answer; }};" }, { "title": "LeetCode - 179. Largest Number", "url": "/posts/ps-leetcode-179/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Sort", "date": "2020-02-08 22:52:00 +0900", "snippet": " 179. Largest Number - medium문제Given a list of non negative integers, arrange them such that they form the largest number.제한사항 The result may be very large, so you need to return a string instead of an integer.입출력 예Example 1:Input: [10,2]Output: &quot;210&quot;Example 2:Input: [3,30,34,5,9]Output: &quot;9534330&quot;풀이 Sortbool comp(const string&amp;amp; a, const string&amp;amp; b){ // string인 a+b, b+a 중 큰것으로 정렬 // 예를 들어 a = &quot;10&quot;, b = &quot;2&quot; 일때, // a + b =&amp;gt; &quot;102&quot; // b + a =&amp;gt; &quot;210&quot; // 연산후, 이 둘을 비교하여 큰 값인 &quot;210&quot; 선택 auto str1 = a + b; auto str2 = b + a; return str1 &amp;gt; str2;}class Solution {public: string largestNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { string answer = &quot;&quot;; vector&amp;lt;string&amp;gt; numStr; // 연산이 쉽도록 nums의 숫자를 모두 string으로 변환 for(auto&amp;amp; i : nums) numStr.push_back(to_string(i)); // 사용자 비교함수대로 정렬 sort(numStr.begin(), numStr.end(), comp); for(auto&amp;amp; i : numStr) answer += i; // &quot;000&quot;과 같은 경우를 체크하기 위해 문자열의 최대값을 구함 auto check = *max_element(answer.begin(), answer.end()); return check == &#39;0&#39; ? &quot;0&quot; : answer; }};" }, { "title": "LeetCode - 654. Maximum Binary Tree", "url": "/posts/ps-leetcode-654/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Tree, Divide and Conquer", "date": "2020-02-08 21:20:00 +0900", "snippet": " 654. Maximum Binary Tree - medium문제Given an integer array with no duplicates. A maximum tree building on this array is defined as follow: The root is the maximum number in the array. The left subtree is the maximum tree constructed from left part subarray divided by the maximum number. The right subtree is the maximum tree constructed from right part subarray divided by the maximum number.Construct the maximum tree by the given array and output the root node of this tree.제한사항 The size of the given array will be in the range [1,1000].입출력 예Example:Input: [3,2,1,6,0,5]Output: return the tree root node representing the following tree: 6 / \\ 3 5 \\ / 2 0 \\ 1풀이 Tree, Divide and Conquer/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* constructMaximumBinaryTree(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if(nums.empty()) return nullptr; // 현재 vector의 최대값 index를 검색 // 찾은 index를 기반으로 최대값을 tree의 root으로 새로 node를 생성 auto maxValIndex = max_element(nums.begin(), nums.end()) - nums.begin(); TreeNode* node = new TreeNode(nums[maxValIndex]); // 최대값 index의 왼쪽의 sub vector를 재귀를 통해 // 하위 left child node를 찾아 tree를 구성 vector&amp;lt;int&amp;gt; leftNums(nums.begin(), nums.begin() + maxValIndex); node-&amp;gt;left = constructMaximumBinaryTree(leftNums); // 최대값 index의 오른쪽의 sub vector를 재귀를 통해 // 하위 right child node를 찾아 tree를 구성 vector&amp;lt;int&amp;gt; rightNums(nums.begin() + maxValIndex + 1, nums.end()); node-&amp;gt;right = constructMaximumBinaryTree(rightNums); return node; }};" }, { "title": "LeetCode - 701. Insert into a Binary Search Tree", "url": "/posts/ps-leetcode-701/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, BST", "date": "2020-02-08 07:20:00 +0900", "snippet": " 701. Insert into a Binary Search Tree - medium문제Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.제한사항입출력 예Example:Given the tree: 4 / \\ 2 7 / \\ 1 3And the value to insert: 5You can return this binary search tree: 4 / \\ 2 7 / \\ / 1 3 5This tree is also valid: 5 / \\ 2 7 / \\ 1 3 \\ 4풀이 BST/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* insertIntoBST(TreeNode* root, int val) { // 현재 노드가 마지막 leaf 까지 왔다면 새 노드 생성 if (root == NULL) return new TreeNode(val); // 재귀로 트리를 검색하면서 위치를 찾아감 // 현재 val이 현재 노드의 크기보다 작으면 left 노드 탐색 if (val &amp;lt; root-&amp;gt;val) root-&amp;gt;left = insertIntoBST(root-&amp;gt;left, val); // 현재 val이 현재 노드의 크기보다 작으면 right 노드 탐색 else if (val &amp;gt; root-&amp;gt;val) root-&amp;gt;right = insertIntoBST(root-&amp;gt;right, val); return root; }};" }, { "title": "LeetCode - 1038. Binary Search Tree to Greater Sum Tree", "url": "/posts/ps-leetcode-1038/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Tree", "date": "2020-02-07 08:11:00 +0900", "snippet": " 1038. Binary Search Tree to Greater Sum Tree - medium문제Given the root of a binary search tree with distinct values, modify it so that every node has a new value equal to the sum of the values of the original tree that are greater than or equal to node.val.As a reminder, a binary search tree is a tree that satisfies these constraints: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees.제한사항 The number of nodes in the tree is between 1 and 100. Each node will have value between 0 and 100. The given tree is a binary search tree.입출력 예Input: [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]풀이 Tree/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int sum = 0; // PreOrder, InOreder, PostOrder를 응용하여, // right -&amp;gt; root -&amp;gt; left 순으로 탐방하는 Ordering void order(TreeNode* root){ if(!root) return; order(root-&amp;gt;right); sum += root-&amp;gt;val; root-&amp;gt;val = sum; order(root-&amp;gt;left); } TreeNode* bstToGst(TreeNode* root) { order(root); return root; }};" }, { "title": "LeetCode - 807. Max Increase to Keep City Skyline", "url": "/posts/ps-leetcode-807/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Array", "date": "2020-02-07 06:43:00 +0900", "snippet": " 807. Max Increase to Keep City Skyline - medium문제In a 2 dimensional array grid, each value grid[i][j] represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amounts can be different for different buildings). Height 0 is considered to be a building as well.At the end, the “skyline” when viewed from all four directions of the grid, i.e. top, bottom, left, and right, must be the same as the skyline of the original grid. A city’s skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. See the following example.What is the maximum total sum that the height of the buildings can be increased?제한사항 1 &amp;lt; grid.length = grid[0].length &amp;lt;= 50. All heights grid[i][j] are in the range [0, 100]. All buildings in grid[i][j] occupy the entire grid cell: that is, they are a 1 x 1 x grid[i][j] rectangular prism.입출력 예Example:Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]Output: 35Explanation: The grid is:[ [3, 0, 8, 4], [2, 4, 5, 7], [9, 2, 6, 3], [0, 3, 1, 0] ]The skyline viewed from top or bottom is: [9, 4, 8, 7]The skyline viewed from left or right is: [8, 7, 9, 3]The grid after increasing the height of buildings without affecting skylines is:gridNew = [ [8, 4, 8, 7], [7, 4, 7, 7], [9, 4, 8, 7], [3, 3, 3, 3] ]풀이 Arrayclass Solution {public: int maxIncreaseKeepingSkyline(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { int answer = 0; int n = grid.size(); vector&amp;lt;int&amp;gt; top_bottom(n, 0); vector&amp;lt;int&amp;gt; left_right(n, 0); // 각 행, 열의 최대값 검색하여 저장 for(auto i = 0 ; i &amp;lt; n ; ++i){ for(auto j = 0 ; j &amp;lt; n ; ++j){ top_bottom[i] = max(top_bottom[i], grid[j][i]); left_right[i] = max(left_right[i], grid[i][j]); } } // 최대 건물 높이는 grid[i][j]중 i,j 인덱스 있때, // 저장한 행, 열의 최대값중 최소값까지 올릴수 있음 // skyeLine = min(top_bottom[i], left_right[j]) // 따라서 저장한 각 행,열의 같은 index중 작은 값을 골라 // 현재 grid의 값을 뺌 for(auto i = 0 ; i &amp;lt; n ; ++i){ for(auto j = 0 ; j &amp;lt; n ; ++j){ int skyeLine = min(top_bottom[i], left_right[j]); answer += skyeLine - grid[i][j]; } } return answer; }};" }, { "title": "LeetCode - 122. Best Time to Buy and Sell Stock II", "url": "/posts/ps-leetcode-122/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Array, Greedy", "date": "2020-02-06 07:29:00 +0900", "snippet": " 122. Best Time to Buy and Sell Stock II - easy문제Say you have an array for which the ith element is the price of a given stock on day i.Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).제한사항입출력 예Example 1:Input: [7,1,5,3,6,4]Output: 7Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.Example 2:Input: [1,2,3,4,5]Output: 4Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.Example 3:Input: [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit = 0.풀이 Array, Greedyclass Solution {public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) { int answer = 0; // 가격이 증가하고있을때, // 현재 가격이 전날의 가격보다 큰 현재 가격을 기준으로 // 현재 가격 - 전날 가격 // 을 계속해서 더해줌 for(auto i = 1 ; i &amp;lt; prices.size() ; ++i){ if(prices[i-1] &amp;lt; prices[i]) answer += prices[i] - prices[i-1]; } return answer; }};풀이참고" }, { "title": "Thread Safe Queue", "url": "/posts/C++-thread_safe_queue/", "categories": "C++, etc", "tags": "C++, Thead, Thread Safe, Queue, Mutex, Condition Variable", "date": "2020-02-06 06:25:00 +0900", "snippet": "Thread Safe Queuemutex와 condition_variable을 통한 Thread Safe Queue Class 예제#include &amp;lt;queue&amp;gt;#include &amp;lt;mutex&amp;gt;#include &amp;lt;condition_variable&amp;gt;template&amp;lt;typename DataType&amp;gt;class Buffer{public: /** * Create thread safe queue. * \\param[in] Max queue size. **/ Buffer(int maxSize = 0) : maxSize(m_maxSize) {}; /*! Destroy thread safe queue. */ ~Buffer(){ std::lock_guard&amp;lt;std::mutex&amp;gt; lock(m_mutex); } /** * Push a data into the queue. * \\param[in] Max queue size. * \\return true if a data was pushed into the queue. **/ bool push(const DataType&amp;amp; data){ std::lock_guard&amp;lt;std::mutex&amp;gt; lock(m_mutex); if (m_maxSize &amp;gt; 0 &amp;amp;&amp;amp; m_queue.size() &amp;gt; m_maxSize) return false; m_queue.push(data); m_cv.notify_one(); return true; }; /** * Pop data from the queue. * If queue is empty, this function blocks until item becomes available. * \\param[out] The data was poped in params variable. */ void pop(DataType&amp;amp; data){ std::unique_lock&amp;lt;std::mutex&amp;gt; lock(m_mutex); m_condition.wait (lock, [this]() { return !m_queue.empty(); }); data = m_queue.front(); m_queue.pop(); }; /** * Try pop data from the queue like aysn function. * \\param[out] The data was poped in params variable. * \\return False is returned if no item is available. */ bool try_pop(DataType&amp;amp; data){ std::unique_lock&amp;lt;std::mutex&amp;gt; lock(m_mutex); if (m_queue.empty()) return false; data = m_queue.front(); m_queue.pop(); return true; }; /** * Gets the number of items in the queue. * \\return Number of items in the queue. */ int size const(){ std::lock_guard&amp;lt;std::mutex&amp;gt; lock(m_mutex); return m_queue.size(); }; /** * Check if the queue is empty. * \\return true if queue is empty. */ bool empty const(){ std::lock_guard&amp;lt;std::mutex&amp;gt; lock(m_mutex); return m_queue.empty(); }; private: std::queue&amp;lt;DataType&amp;gt; m_queue; std::mutex m_mutex; std::condition_variable m_cv; int m_maxSize = 0;};" }, { "title": "LeetCode - 1078. Occurrences After Bigram", "url": "/posts/ps-leetcode-1078/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, String", "date": "2020-02-05 06:57:33 +0900", "snippet": " 1078. Occurrences After Bigram - easy문제Given words first and second, consider occurrences in some text of the form “first second third”, where second comes immediately after first, and third comes immediately after second.For each such occurrence, add “third” to the answer, and return the answer.제한사항 1 &amp;lt;= text.length &amp;lt;= 1000 text consists of space separated words, where each word consists of lowercase English letters. 1 &amp;lt;= first.length, second.length &amp;lt;= 10 first and second consist of lowercase English letters.입출력 예Example 1:Input: text = &quot;alice is a good girl she is a good student&quot;, first = &quot;a&quot;, second = &quot;good&quot;Output: [&quot;girl&quot;,&quot;student&quot;]Example 2:Input: text = &quot;we will we will rock you&quot;, first = &quot;we&quot;, second = &quot;will&quot;Output: [&quot;we&quot;,&quot;rock&quot;]풀이 Stringclass Solution {public: vector&amp;lt;string&amp;gt; findOcurrences(string text, string first, string second) { vector&amp;lt;string&amp;gt; answer; vector&amp;lt;string&amp;gt; splitText; string token; stringstream ss(text); // 공백을 기준으로 문자열을 tokenize while(getline(ss, token, &#39; &#39;)){ splitText.push_back(token); } // tokenize한 문자들을 검사 for(int i = 0; i &amp;lt; splitText.size() - 2; i++){ if(splitText[i] == first &amp;amp;&amp;amp; splitText[i + 1] == second){ answer.push_back(splitText[i+2]); } } return answer; }};" }, { "title": "Programmers - 네트워크", "url": "/posts/ps-programmers-039/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, DFS, BFS", "date": "2020-02-02 21:54:00 +0900", "snippet": " 네트워크 - lv.3문제네트워크란 컴퓨터 상호 간에 정보를 교환할 수 있도록 연결된 형태를 의미합니다. 예를 들어, 컴퓨터 A와 컴퓨터 B가 직접적으로 연결되어있고, 컴퓨터 B와 컴퓨터 C가 직접적으로 연결되어 있을 때 컴퓨터 A와 컴퓨터 C도 간접적으로 연결되어 정보를 교환할 수 있습니다. 따라서 컴퓨터 A, B, C는 모두 같은 네트워크 상에 있다고 할 수 있습니다.컴퓨터의 개수 n, 연결에 대한 정보가 담긴 2차원 배열 computers가 매개변수로 주어질 때, 네트워크의 개수를 return 하도록 solution 함수를 작성하시오.제한사항 컴퓨터의 개수 n은 1 이상 200 이하인 자연수입니다. 각 컴퓨터는 0부터 n-1인 정수로 표현합니다. i번 컴퓨터와 j번 컴퓨터가 연결되어 있으면 computers[i][j]를 1로 표현합니다. computer[i][i]는 항상 1입니다.입출력 예 n vector return 3 [[1, 1, 0], [1, 1, 0], [0, 0, 1]] 2 3 [[1, 1, 0], [1, 1, 1], [0, 1, 1]] 1 예제 #1 아래와 같이 2개의 네트워크가 있습니다.예제 #2 아래와 같이 1개의 네트워크가 있습니다.풀이 DFS, BFSint solution(int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; computers) { int answer = 0; stack&amp;lt;int&amp;gt; s; for(auto index = 0 ; index &amp;lt; n ; ++index){ if(!computers[index][index]) continue; s.push(index); while(!s.empty()){ int i = s.top(); s.pop(); for(auto j = 0 ; j &amp;lt; n ; ++j){ if(computers[i][j] &amp;amp;&amp;amp; computers[j][i]){ computers[i][j] = 0; s.push(j); } } } ++answer; } return answer;}" }, { "title": "Programmers - 멀쩡한 사각형", "url": "/posts/ps-programmers-038/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Math, GCD", "date": "2020-02-02 21:54:00 +0900", "snippet": " 멀쩡한 사각형 - lv.2문제가로 길이가 Wcm, 세로 길이가 Hcm인 직사각형 종이가 있습니다. 종이에는 가로, 세로 방향과 평행하게 격자 형태로 선이 그어져 있으며, 모든 격자칸은 1cm x 1cm 크기입니다. 이 종이를 격자 선을 따라 1cm × 1cm의 정사각형으로 잘라 사용할 예정이었는데, 누군가가 이 종이를 대각선 꼭지점 2개를 잇는 방향으로 잘라 놓았습니다. 그러므로 현재 직사각형 종이는 크기가 같은 직각삼각형 2개로 나누어진 상태입니다. 새로운 종이를 구할 수 없는 상태이기 때문에, 이 종이에서 원래 종이의 가로, 세로 방향과 평행하게 1cm × 1cm로 잘라 사용할 수 있는 만큼만 사용하기로 하였습니다.가로의 길이 W와 세로의 길이 H가 주어질 때, 사용할 수 있는 정사각형의 개수를 구하는 solution 함수를 완성해 주세요.제한사항 W, H : 1억 이하의 자연수입출력 예 W H result 8 12 80 가로가 8, 세로가 12인 직사각형을 대각선 방향으로 자르면 총 16개 정사각형을 사용할 수 없게 됩니다. 원래 직사각형에서는 96개의 정사각형을 만들 수 있었으므로, 96 - 16 = 80 을 반환합니다.풀이 Math, GCDlong long getGCD(int a, int b){ if(a == 0) return b; return getGCD(b % a, a);}long long solution(int w,int h){ long long gcd = getGCD(w, h); long long sum = (long long)w * (long long)h; return sum - (w + h - gcd);}" }, { "title": "Programmers - 스킬트리", "url": "/posts/ps-programmers-037/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Array", "date": "2020-02-02 21:54:00 +0900", "snippet": " 스킬트리 - lv.2문제선행 스킬이란 어떤 스킬을 배우기 전에 먼저 배워야 하는 스킬을 뜻합니다.예를 들어 선행 스킬 순서가 스파크 → 라이트닝 볼트 → 썬더일때, 썬더를 배우려면 먼저 라이트닝 볼트를 배워야 하고, 라이트닝 볼트를 배우려면 먼저 스파크를 배워야 합니다.위 순서에 없는 다른 스킬(힐링 등)은 순서에 상관없이 배울 수 있습니다. 따라서 스파크 → 힐링 → 라이트닝 볼트 → 썬더와 같은 스킬트리는 가능하지만, 썬더 → 스파크나 라이트닝 볼트 → 스파크 → 힐링 → 썬더와 같은 스킬트리는 불가능합니다.선행 스킬 순서 skill과 유저들이 만든 스킬트리1를 담은 배열 skill_trees가 매개변수로 주어질 때, 가능한 스킬트리 개수를 return 하는 solution 함수를 작성해주세요.제한사항 스킬은 알파벳 대문자로 표기하며, 모든 문자열은 알파벳 대문자로만 이루어져 있습니다. 스킬 순서와 스킬트리는 문자열로 표기합니다. 예를 들어, C → B → D 라면 “CBD”로 표기합니다 선행 스킬 순서 skill의 길이는 1 이상 26 이하이며, 스킬은 중복해 주어지지 않습니다. skill_trees는 길이 1 이상 20 이하인 배열입니다. skill_trees의 원소는 스킬을 나타내는 문자열입니다. skill_trees의 원소는 길이가 2 이상 26 이하인 문자열이며, 스킬이 중복해 주어지지 않습니다. 입출력 예 Skill skill_trees result “CBD” [“BACDE”, “CBADF”, “AECB”, “BDA”] 2 풀이 Arrayint solution(string skill, vector&amp;lt;string&amp;gt; skill_trees) { int answer = 0, flag = 1; for(auto &amp;amp;i : skill_trees){ int skillIndex = 0; for(auto &amp;amp;j : i){ if(skill.find(j) == std::string::npos) continue; if(skill[skillIndex] == j) ++skillIndex; else{ flag = 0; break; } } if(flag) answer++; flag = 1; } return answer;}" }, { "title": "Programmers - H-Index", "url": "/posts/ps-programmers-036/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Sort", "date": "2020-02-02 21:54:00 +0900", "snippet": " H-Index - lv.2문제H-Index는 과학자의 생산성과 영향력을 나타내는 지표입니다. 어느 과학자의 H-Index를 나타내는 값인 h를 구하려고 합니다. 위키백과1에 따르면, H-Index는 다음과 같이 구합니다.어떤 과학자가 발표한 논문 n편 중, h번 이상 인용된 논문이 h편 이상이고 나머지 논문이 h번 이하 인용되었다면 h가 이 과학자의 H-Index입니다.어떤 과학자가 발표한 논문의 인용 횟수를 담은 배열 citations가 매개변수로 주어질 때, 이 과학자의 H-Index를 return 하도록 solution 함수를 작성해주세요.제한사항 과학자가 발표한 논문의 수는 1편 이상 1,000편 이하입니다. 논문별 인용 횟수는 0회 이상 10,000회 이하입니다.입출력 예 citations result [3, 0, 6, 1, 5] 3 이 과학자가 발표한 논문의 수는 5편이고, 그중 3편의 논문은 3회 이상 인용되었습니다. 그리고 나머지 2편의 논문은 3회 이하 인용되었기 때문에 이 과학자의 H-Index는 3입니다.풀이 sortint solution(vector&amp;lt;int&amp;gt; citations) { int answer = 0; std::sort(citations.begin() , citations.end(), greater&amp;lt;int&amp;gt;()); for(auto i = 0 ; i &amp;lt; citations.size() ; ++i){ if(citations[i] &amp;lt; i+1) return i; } return citations.size();}" }, { "title": "Programmers - 가장 큰 정사각형 찾기", "url": "/posts/ps-programmers-035/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, DP", "date": "2020-02-02 21:54:00 +0900", "snippet": " 가장 큰 정사각형 찾기 - lv.2문제1와 0로 채워진 표(board)가 있습니다. 표 1칸은 1 x 1 의 정사각형으로 이루어져 있습니다. 표에서 1로 이루어진 가장 큰 정사각형을 찾아 넓이를 return 하는 solution 함수를 완성해 주세요. (단, 정사각형이란 축에 평행한 정사각형을 말합니다.)예를 들어 1 2 3 4 0 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0 가 있다면 가장 큰 정사각형은 1 2 3 4 0 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0 가 되며 넓이는 9가 되므로 9를 반환해 주면 됩니다.제한사항 표(board)는 2차원 배열로 주어집니다. 표(board)의 행(row)의 크기 : 1,000 이하의 자연수 표(board)의 열(column)의 크기 : 1,000 이하의 자연수 표(board)의 값은 1또는 0으로만 이루어져 있습니다.입출력 예 board result [[0,1,1,1],[1,1,1,1],[1,1,1,1],[0,0,1,0]] 9 [[0,0,1,1],[1,1,1,1]] 4 입출력 예 #1위의 예시와 같습니다.입출력 예 #2| 0 | 0 | 1 | 1 || 1 | 1 | 1 | 1 |로 가장 큰 정사각형의 넓이는 4가 되므로 4를 return합니다.`풀이 DPint solution(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; board){ if(board.size() &amp;lt; 2 || board[0].size() &amp;lt; 2) return 1; int answer = 0; for(auto i = 1; i &amp;lt; board.size() ; ++i){ for(auto j = 1; j &amp;lt; board[0].size() ; ++j){ if(board[i][j] == 0) continue; board[i][j] = min({board[i-1][j-1], board[i-1][j], board[i][j-1]}) + 1; } int max = *max_element(board[i].begin(), board[i].end()); if(answer &amp;lt; max) answer = max; } return answer * answer;}" }, { "title": "Programmers - 뉴스 클러스터링", "url": "/posts/ps-programmers-034/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Sort, Set", "date": "2020-02-02 20:15:00 +0900", "snippet": " 뉴스 클러스터링 - lv.2문제여러 언론사에서 쏟아지는 뉴스, 특히 속보성 뉴스를 보면 비슷비슷한 제목의 기사가 많아 정작 필요한 기사를 찾기가 어렵다. Daum 뉴스의 개발 업무를 맡게 된 신입사원 튜브는 사용자들이 편리하게 다양한 뉴스를 찾아볼 수 있도록 문제점을 개선하는 업무를 맡게 되었다.개발의 방향을 잡기 위해 튜브는 우선 최근 화제가 되고 있는 “카카오 신입 개발자 공채” 관련 기사를 검색해보았다.카카오 첫 공채..&#39;블라인드&#39; 방식 채용카카오, 합병 후 첫 공채.. 블라인드 전형으로 개발자 채용카카오, 블라인드 전형으로 신입 개발자 공채카카오 공채, 신입 개발자 코딩 능력만 본다카카오, 신입 공채.. &quot;코딩 실력만 본다&quot;카카오 &quot;코딩 능력만으로 2018 신입 개발자 뽑는다&quot;기사의 제목을 기준으로 “블라인드 전형”에 주목하는 기사와 “코딩 테스트”에 주목하는 기사로 나뉘는 걸 발견했다. 튜브는 이들을 각각 묶어서 보여주면 카카오 공채 관련 기사를 찾아보는 사용자에게 유용할 듯싶었다.유사한 기사를 묶는 기준을 정하기 위해서 논문과 자료를 조사하던 튜브는 “자카드 유사도”라는 방법을 찾아냈다.자카드 유사도는 집합 간의 유사도를 검사하는 여러 방법 중의 하나로 알려져 있다. 두 집합 A, B 사이의 자카드 유사도 J(A, B)는 두 집합의 교집합 크기를 두 집합의 합집합 크기로 나눈 값으로 정의된다.예를 들어 집합 A = {1, 2, 3}, 집합 B = {2, 3, 4}라고 할 때, 교집합 A ∩ B = {2, 3}, 합집합 A ∪ B = {1, 2, 3, 4}이 되므로, 집합 A, B 사이의 자카드 유사도 J(A, B) = 2/4 = 0.5가 된다. 집합 A와 집합 B가 모두 공집합일 경우에는 나눗셈이 정의되지 않으니 따로 J(A, B) = 1로 정의한다.자카드 유사도는 원소의 중복을 허용하는 다중집합에 대해서 확장할 수 있다. 다중집합 A는 원소 “1”을 3개 가지고 있고, 다중집합 B는 원소 “1”을 5개 가지고 있다고 하자. 이 다중집합의 교집합 A ∩ B는 원소 “1”을 min(3, 5)인 3개, 합집합 A ∪ B는 원소 “1”을 max(3, 5)인 5개 가지게 된다. 다중집합 A = {1, 1, 2, 2, 3}, 다중집합 B = {1, 2, 2, 4, 5}라고 하면, 교집합 A ∩ B = {1, 2, 2}, 합집합 A ∪ B = {1, 1, 2, 2, 3, 4, 5}가 되므로, 자카드 유사도 J(A, B) = 3/7, 약 0.42가 된다.이를 이용하여 문자열 사이의 유사도를 계산하는데 이용할 수 있다. 문자열 “FRANCE”와 “FRENCH”가 주어졌을 때, 이를 두 글자씩 끊어서 다중집합을 만들 수 있다. 각각 {FR, RA, AN, NC, CE}, {FR, RE, EN, NC, CH}가 되며, 교집합은 {FR, NC}, 합집합은 {FR, RA, AN, NC, CE, RE, EN, CH}가 되므로, 두 문자열 사이의 자카드 유사도 J(“FRANCE”, “FRENCH”) = 2/8 = 0.25가 된다.제한사항 입력으로는 str1과 str2의 두 문자열이 들어온다. 각 문자열의 길이는 2 이상, 1,000 이하이다. 입력으로 들어온 문자열은 두 글자씩 끊어서 다중집합의 원소로 만든다. 이때 영문자로 된 글자 쌍만 유효하고, 기타 공백이나 숫자, 특수 문자가 들어있는 경우는 그 글자 쌍을 버린다. 예를 들어 “ab+”가 입력으로 들어오면, “ab”만 다중집합의 원소로 삼고, “b+”는 버린다. 다중집합 원소 사이를 비교할 때, 대문자와 소문자의 차이는 무시한다. “AB”와 “Ab”, “ab”는 같은 원소로 취급한다.입출력 예 str1 str2 answer FRANCE french 16384 handshake shake hands 65536 aa1+aa2 AAAA12 43690 E=M*C^2 e=m*c^2 65536 풀이 sort, setint solution(string str1, string str2) { int answer = 0; vector&amp;lt;string&amp;gt; s1, s2; vector&amp;lt;string&amp;gt; unionStr, intersectionStr; std::transform(str1.begin(), str1.end(), str1.begin(), ::tolower); std::transform(str2.begin(), str2.end(), str2.begin(), ::tolower); for(auto i = 1 ; i &amp;lt; str1.size() ; ++i){ if((&#39;a&#39; &amp;lt;= str1[i-1] &amp;amp;&amp;amp; str1[i-1] &amp;lt;= &#39;z&#39;) &amp;amp;&amp;amp; (&#39;a&#39; &amp;lt;= str1[i] &amp;amp;&amp;amp; str1[i] &amp;lt;= &#39;z&#39;)) s1.push_back(str1.substr(i-1, 2)); } for(auto i = 1 ; i &amp;lt; str2.size() ; ++i){ if((&#39;a&#39; &amp;lt;= str2[i-1] &amp;amp;&amp;amp; str2[i-1] &amp;lt;= &#39;z&#39;) &amp;amp;&amp;amp; (&#39;a&#39; &amp;lt;= str2[i] &amp;amp;&amp;amp; str2[i] &amp;lt;= &#39;z&#39;)) s2.push_back(str2.substr(i-1, 2)); } sort(s1.begin(), s1.end()); sort(s2.begin(), s2.end()); set_union(s1.begin(), s1.end(), s2.begin(), s2.end(), back_inserter(unionStr)); set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(), back_inserter(intersectionStr)); if(unionStr.size() &amp;lt; 1) answer = 65536; else answer = (static_cast&amp;lt;float&amp;gt;(intersectionStr.size()) / static_cast&amp;lt;float&amp;gt;(unionStr.size())) * 65536; return answer;}" }, { "title": "Programmers - 캐시", "url": "/posts/ps-programmers-033/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, LRU, Cache", "date": "2020-02-02 20:15:00 +0900", "snippet": " 캐시 - lv.2문제지도개발팀에서 근무하는 제이지는 지도에서 도시 이름을 검색하면 해당 도시와 관련된 맛집 게시물들을 데이터베이스에서 읽어 보여주는 서비스를 개발하고 있다.이 프로그램의 테스팅 업무를 담당하고 있는 어피치는 서비스를 오픈하기 전 각 로직에 대한 성능 측정을 수행하였는데, 제이지가 작성한 부분 중 데이터베이스에서 게시물을 가져오는 부분의 실행시간이 너무 오래 걸린다는 것을 알게 되었다.어피치는 제이지에게 해당 로직을 개선하라고 닦달하기 시작하였고, 제이지는 DB 캐시를 적용하여 성능 개선을 시도하고 있지만 캐시 크기를 얼마로 해야 효율적인지 몰라 난감한 상황이다.어피치에게 시달리는 제이지를 도와, DB 캐시를 적용할 때 캐시 크기에 따른 실행시간 측정 프로그램을 작성하시오.제한사항 캐시 크기(cacheSize)와 도시이름 배열(cities)을 입력받는다. cacheSize는 정수이며, 범위는 0 ≦ cacheSize ≦ 30 이다. cities는 도시 이름으로 이뤄진 문자열 배열로, 최대 도시 수는 100,000개이다. 각 도시 이름은 공백, 숫자, 특수문자 등이 없는 영문자로 구성되며, 대소문자 구분을 하지 않는다. 도시 이름은 최대 20자로 이루어져 있다. 입력된 도시이름 배열을 순서대로 처리할 때, “총 실행시간”을 출력한다. 캐시 교체 알고리즘은 LRU(Least Recently Used)를 사용한다. cache hit일 경우 실행시간은 1이다. cache miss일 경우 실행시간은 5이다.입출력 예 캐시크기(cacheSize) 도시이름(cities) 실행시간 3 [“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”, “Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”] 50 3 [“Jeju”, “Pangyo”, “Seoul”, “Jeju”, “Pangyo”, “Seoul”, “Jeju”, “Pangyo”, “Seoul”] 21 2 [“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”, “SanFrancisco”, “Seoul”, “Rome”, “Paris”, “Jeju”, “NewYork”, “Rome”] 60 5 [“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”, “SanFrancisco”, “Seoul”, “Rome”, “Paris”, “Jeju”, “NewYork”, “Rome”] 52 2 [“Jeju”, “Pangyo”, “NewYork”, “newyork”] 16 0 [“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”] 25 풀이 LRU, Cacheint solution(int cacheSize, vector&amp;lt;string&amp;gt; cities) { if(cacheSize &amp;lt; 1) return cities.size() * 5; int answer = 0; map&amp;lt;string, int&amp;gt; m; queue&amp;lt;string&amp;gt; q; for(auto&amp;amp; i : cities){ std::transform(i.begin(), i.end(), i.begin(), ::toupper); if(m.find(i) != m.end()){ answer += 1; queue&amp;lt;string&amp;gt; temp; while(!q.empty()){ if(q.front() != i) temp.push(q.front()); q.pop(); } temp.push(i); q.swap(temp); } else{ if(m.size() &amp;gt;= cacheSize){ auto least = q.front(); q.pop(); m.erase(least); } m[i] = 1; q.push(i); answer += 5; } } return answer;}" }, { "title": "Programmers - 2 x n 타일링", "url": "/posts/ps-programmers-032/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, DP", "date": "2020-02-02 20:15:00 +0900", "snippet": " 2 x n 타일링 - lv.3문제가로 길이가 2이고 세로의 길이가 1인 직사각형모양의 타일이 있습니다. 이 직사각형 타일을 이용하여 세로의 길이가 2이고 가로의 길이가 n인 바닥을 가득 채우려고 합니다. 타일을 채울 때는 다음과 같이 2가지 방법이 있습니다.타일을 가로로 배치 하는 경우타일을 세로로 배치 하는 경우예를들어서 n이 7인 직사각형은 다음과 같이 채울 수 있습니다.직사각형의 가로의 길이 n이 매개변수로 주어질 때, 이 직사각형을 채우는 방법의 수를 return 하는 solution 함수를 완성해주세요.제한사항 가로의 길이 n은 60,000이하의 자연수 입니다. 경우의 수가 많아 질 수 있으므로, 경우의 수를 1,000,000,007으로 나눈 나머지를 return해주세요.입출력 예 n result 4 5 입출력 예 #1 다음과 같이 5가지 방법이 있다. 풀이 DP int solution(int n) { if(n == 0) return 0; int answer = 0; int n_1 = 1; int n_2 = 0; for(auto i = 1; i &amp;lt;= n ; ++i){ answer = (n_2 + n_1) % 1000000007; n_2 = n_1; n_1 = answer; } return answer;}" }, { "title": "Programmers - 종이접기", "url": "/posts/ps-programmers-031/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Array", "date": "2020-02-02 20:15:00 +0900", "snippet": " 종이접기 - lv.3문제직사각형 종이를 n번 접으려고 합니다. 이때, 항상 오른쪽 절반을 왼쪽으로 접어 나갑니다. 다음은 n = 2인 경우의 예시입니다.먼저 오른쪽 절반을 왼쪽으로 접습니다.다시 오른쪽 절반을 왼쪽으로 접습니다.종이를 모두 접은 후에는 종이를 전부 펼칩니다. 종이를 펼칠 때는 종이를 접은 방법의 역순으로 펼쳐서 처음 놓여있던 때와 같은 상태가 되도록 합니다. 위와 같이 두 번 접은 후 종이를 펼치면 아래 그림과 같이 종이에 접은 흔적이 생기게 됩니다.위 그림에서 ∨ 모양이 생긴 부분은 점선(0)으로, ∧ 모양이 생긴 부분은 실선(1)으로 표시했습니다.종이를 접은 횟수 n이 매개변수로 주어질 때, 종이를 절반씩 n번 접은 후 모두 펼쳤을 때 생기는 접힌 부분의 모양을 배열에 담아 return 하도록 solution 함수를 완성해주세요.제한사항 종이를 접는 횟수 n은 1 이상 20 이하의 자연수입니다. 종이를 접었다 편 후 생긴 굴곡이 ∨ 모양이면 0, ∧ 모양이면 1로 나타냅니다. 가장 왼쪽의 굴곡 모양부터 순서대로 배열에 담아 return 해주세요.입출력 예 n result 1 [0] 2 [0,0,1] 3 [0,0,1,0,0,1,1] 입출력 예 #1 종이의 오른쪽 절반을 왼쪽으로 한번 접었다 펴면 아래 그림과 같이 굴곡이 생깁니다. 입출력 예 #2 문제의 예시와 같습니다. 입출력 예 #3 종이를 절반씩 세 번 접은 후 다시 펼치면 아래 그림과 같이 굴곡이 생깁니다. 풀이 Arrayvector&amp;lt;int&amp;gt; solution(int n) { vector&amp;lt;int&amp;gt; answer; int N = 0; for(auto i = 0 ; i &amp;lt; n ; ++i){ // 한번 접을때 마다 N*2+1만큼 증가 N = N * 2 + 1; answer.resize(N); // 배열의 가운데는 무조건 0 int size = answer.size() / 2; answer[size] = 0; // 인덱스 i 와 size()-i-1 의 값은 반대 for(auto j = 0 ; j &amp;lt; size ; ++j){ answer[answer.size() - j - 1] = answer[j] == 0 ? 1 : 0; } } return answer;}" }, { "title": "Programmers - 단속카메라", "url": "/posts/ps-programmers-030/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Greedy", "date": "2020-02-02 20:15:00 +0900", "snippet": " 단속카메라 - lv.3문제고속도로를 이동하는 모든 차량이 고속도로를 이용하면서 단속용 카메라를 한 번은 만나도록 카메라를 설치하려고 합니다.고속도로를 이동하는 차량의 경로 routes가 매개변수로 주어질 때, 모든 차량이 한 번은 단속용 카메라를 만나도록 하려면 최소 몇 대의 카메라를 설치해야 하는지를 return 하도록 solution 함수를 완성하세요.제한사항 차량의 대수는 1대 이상 10,000대 이하입니다. routes에는 차량의 이동 경로가 포함되어 있으며 routes[i][0]에는 i번째 차량이 고속도로에 진입한 지점, routes[i][1]에는 i번째 차량이 고속도로에서 나간 지점이 적혀 있습니다. 차량의 진입/진출 지점에 카메라가 설치되어 있어도 카메라를 만난것으로 간주합니다. 차량의 진입 지점, 진출 지점은 -30,000 이상 30,000 이하입니다.입출력 예 routes return [[-20,15], [-14,-5], [-18,-13], [-5,-3]] 2 -5 지점에 카메라를 설치하면 두 번째, 네 번째 차량이 카메라를 만납니다. -15 지점에 카메라를 설치하면 첫 번째, 세 번째 차량이 카메라를 만납니다. 풀이 Greedybool comp(vector&amp;lt;int&amp;gt;&amp;amp; a, vector&amp;lt;int&amp;gt;&amp;amp; b){ return a[1] &amp;lt; b[1]; }int solution(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; routes) { int answer = 1; int preValue = 0; sort(routes.begin(), routes.end(), comp); preValue = routes[0][1]; for(auto&amp;amp; i : routes){ if(i[0] &amp;gt; preValue){ ++answer; preValue = i[1]; } } return answer;}" }, { "title": "Programmers - 단어 변환", "url": "/posts/ps-programmers-029/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, DFS", "date": "2020-02-02 20:15:00 +0900", "snippet": " 단어 변환 - lv.3문제두 개의 단어 begin, target과 단어의 집합 words가 있습니다. 아래와 같은 규칙을 이용하여 begin에서 target으로 변환하는 가장 짧은 변환 과정을 찾으려고 합니다.1. 한 번에 한 개의 알파벳만 바꿀 수 있습니다.2. words에 있는 단어로만 변환할 수 있습니다.예를 들어 begin이 “hit”, target가 “cog”, words가 [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]라면 “hit” -&amp;gt; “hot” -&amp;gt; “dot” -&amp;gt; “dog” -&amp;gt; “cog”와 같이 4단계를 거쳐 변환할 수 있습니다.두 개의 단어 begin, target과 단어의 집합 words가 매개변수로 주어질 때, 최소 몇 단계의 과정을 거쳐 begin을 target으로 변환할 수 있는지 return 하도록 solution 함수를 작성해주세요.제한사항 각 단어는 알파벳 소문자로만 이루어져 있습니다. 각 단어의 길이는 3 이상 10 이하이며 모든 단어의 길이는 같습니다. words에는 3개 이상 50개 이하의 단어가 있으며 중복되는 단어는 없습니다. begin과 target은 같지 않습니다. 변환할 수 없는 경우에는 0를 return 합니다.입출력 예 begin target words return “hit” “cog” [“hot”, “dot”, “dog”, “lot”, “log”, “cog”] 4 “hit” “cog” [“hot”, “dot”, “dog”, “lot”, “log”] 0 예제 #1 문제에 나온 예와 같습니다.예제 #2 target인 &quot;cog&quot;는 words 안에 없기 때문에 변환할 수 없습니다.풀이 DFSint solution(string begin, string target, vector&amp;lt;string&amp;gt; words) { int answer = INT_MAX; // begin과 하나만 다른words의 elements 찾아서 저장 vector&amp;lt;string&amp;gt; choice; for(auto&amp;amp; str : words){ int count = 0; for(auto i = 0 ; i &amp;lt; begin.size() ; ++i){ if(begin[i] != str[i]){ ++count; } } if(count == 1) choice.push_back(str); } for(auto i = 0 ; i &amp;lt; choice.size() ; ++i){ // 한번 조회한 element 체크 vector&amp;lt;bool&amp;gt; check(words.size(), false); stack&amp;lt;pair&amp;lt;string, int&amp;gt;&amp;gt; s; int val = INT_MAX; s.push({choice[i], 1}); while(!s.empty()){ auto temp = s.top(); s.pop(); // target과 같을때, 현재 저장된 값보다 count가 작으면 저장 if(temp.first == target){ if(temp.second &amp;lt; val) val = temp.second; } // 현재 단계에서 하나만 다른words의 elements 찾아서 저장 for(auto j = 0; j &amp;lt; words.size() ; ++j){ if(check[j]) continue; int count = 0; for(auto t = 0 ; t &amp;lt; words[j].size() ; ++t){ if(words[j][t] != temp.first[t]){ ++count; } } if(count == 1){ s.push({words[j], temp.second + 1}); check[j] = true; } } } if(val &amp;lt; answer) answer = val; } return answer == INT_MAX ? 0 : answer;}" }, { "title": "Programmers - 정수 삼각형", "url": "/posts/ps-programmers-028/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, DP", "date": "2020-02-02 20:15:00 +0900", "snippet": " 정수 삼각형 - lv.3문제위와 같은 삼각형의 꼭대기에서 바닥까지 이어지는 경로 중, 거쳐간 숫자의 합이 가장 큰 경우를 찾아보려고 합니다. 아래 칸으로 이동할 때는 대각선 방향으로 한 칸 오른쪽 또는 왼쪽으로만 이동 가능합니다. 예를 들어 3에서는 그 아래칸의 8 또는 1로만 이동이 가능합니다.삼각형의 정보가 담긴 배열 triangle이 매개변수로 주어질 때, 거쳐간 숫자의 최댓값을 return 하도록 solution 함수를 완성하세요.제한사항 삼각형의 높이는 1 이상 500 이하입니다. 삼각형을 이루고 있는 숫자는 0 이상 9,999 이하의 정수입니다.입출력 예 triangle target [[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [4, 5, 2, 6, 5]] 30 풀이 DPint solution(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; triangle) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; answer = triangle; for(auto i = 0 ; i &amp;lt; triangle.size() - 1 ; ++i ){ for(auto j = 0 ; j &amp;lt; triangle[i].size() ; ++j){ int left = answer[i][j] + triangle[i+1][j]; int right = answer[i][j] + triangle[i+1][j+1]; if(left &amp;gt; answer[i+1][j]){ answer[i+1][j] = left; } if(right &amp;gt; answer[i+1][j+1]){ answer[i+1][j+1] = right; } } } return *max_element(answer.rbegin()-&amp;gt;begin(), answer.rbegin()-&amp;gt;end());}" }, { "title": "Programmers - 여행경로", "url": "/posts/ps-programmers-027/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, DFS, BFS", "date": "2020-02-02 20:15:00 +0900", "snippet": " 여행경로 - lv.3문제주어진 항공권을 모두 이용하여 여행경로를 짜려고 합니다. 항상 “ICN” 공항에서 출발합니다.항공권 정보가 담긴 2차원 배열 tickets가 매개변수로 주어질 때, 방문하는 공항 경로를 배열에 담아 return 하도록 solution 함수를 작성해주세요.제한사항 모든 공항은 알파벳 대문자 3글자로 이루어집니다. 주어진 공항 수는 3개 이상 10,000개 이하입니다. tickets의 각 행 [a, b]는 a 공항에서 b 공항으로 가는 항공권이 있다는 의미입니다. 주어진 항공권은 모두 사용해야 합니다. 만일 가능한 경로가 2개 이상일 경우 알파벳 순서가 앞서는 경로를 return 합니다. 모든 도시를 방문할 수 없는 경우는 주어지지 않습니다.입출력 예 tickets return [[“ICN”, “JFK”], [“HND”, “IAD”], [“JFK”, “HND”]] [“ICN”, “JFK”, “HND”, “IAD”] [[“ICN”, “SFO”], [“ICN”, “ATL”], [“SFO”, “ATL”], [“ATL”, “ICN”], [“ATL”,”SFO”]] [“ICN”, “ATL”, “ICN”, “SFO”, “ATL”, “SFO”] `예제 #1 [“ICN”, “JFK”, “HND”, “IAD”] 순으로 방문할 수 있습니다.``예제 #2 [“ICN”, “SFO”, “ATL”, “ICN”, “ATL”, “SFO”] 순으로 방문할 수도 있지만 [“ICN”, “ATL”, “ICN”, “SFO”, “ATL”, “SFO”] 가 알파벳 순으로 앞섭니다.`풀이 DFS, BFSvector&amp;lt;string&amp;gt; solution(vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; tickets) { vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; answer; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; answerIndex; map&amp;lt;string, vector&amp;lt;pair&amp;lt;string, int&amp;gt;&amp;gt;&amp;gt; m; // tickets의 요소를 map으로 구성 for(auto i = 0 ; i &amp;lt; tickets.size() ; ++i){ m[tickets[i][0]].push_back({tickets[i][1], i}); } // ICN부터 시작하여 요소를 DFS로 검사 for(auto i = m[&quot;ICN&quot;].begin() ; i != m[&quot;ICN&quot;].end() ; ++i ){ stack&amp;lt;pair&amp;lt;string, vector&amp;lt;int&amp;gt;&amp;gt;&amp;gt; q; q.push({i-&amp;gt;first, {i-&amp;gt;second}}); while(!q.empty()){ auto tmp = q.top(); q.pop(); if(tmp.second.size() == tickets.size()){ answerIndex.push_back(tmp.second); } for(auto j = m[tmp.first].rbegin() ; j != m[tmp.first].rend() ; ++j){ // 현재까지 저장된 index vector에 현재 index가 없는지 검사 if(find(tmp.second.begin(), tmp.second.end(), j-&amp;gt;second) == tmp.second.end()){ // 현재 검사중인 운항출발지의 여러 목적지가 답이 될수 있으므로 // vector를 copy하여 이를 저장 auto ans = tmp.second; ans.push_back(j-&amp;gt;second); q.push({j-&amp;gt;first, ans}); } } } } // 얻은 경로의 index를 기반하여 문자열 생성 for(auto&amp;amp; i : answerIndex){ vector&amp;lt;string&amp;gt; temp; temp.push_back(tickets[i[0]][0]); for(auto&amp;amp; j : i){ temp.push_back(tickets[j][1]); } answer.push_back(temp); } // 알파벳 순으로 정렬 sort(answer.begin(), answer.end()); return answer[0];}" }, { "title": "Programmers - 디스크 컨트롤러", "url": "/posts/ps-programmers-026/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Heap", "date": "2020-02-02 20:15:00 +0900", "snippet": " 디스크 컨트롤러 - lv.3문제하드디스크는 한 번에 하나의 작업만 수행할 수 있습니다. 디스크 컨트롤러를 구현하는 방법은 여러 가지가 있습니다. 가장 일반적인 방법은 요청이 들어온 순서대로 처리하는 것입니다.예를들어- 0ms 시점에 3ms가 소요되는 A작업 요청- 1ms 시점에 9ms가 소요되는 B작업 요청- 2ms 시점에 6ms가 소요되는 C작업 요청와 같은 요청이 들어왔습니다. 이를 그림으로 표현하면 아래와 같습니다.한 번에 하나의 요청만을 수행할 수 있기 때문에 각각의 작업을 요청받은 순서대로 처리하면 다음과 같이 처리 됩니다.- A: 3ms 시점에 작업 완료 (요청에서 종료까지 : 3ms)- B: 1ms부터 대기하다가, 3ms 시점에 작업을 시작해서 12ms 시점에 작업 완료(요청에서 종료까지 : 11ms)- C: 2ms부터 대기하다가, 12ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 16ms)이 때 각 작업의 요청부터 종료까지 걸린 시간의 평균은 10ms(= (3 + 11 + 16) / 3)가 됩니다.하지만 A → C → B 순서대로 처리하면- A: 3ms 시점에 작업 완료(요청에서 종료까지 : 3ms)- C: 2ms부터 대기하다가, 3ms 시점에 작업을 시작해서 9ms 시점에 작업 완료(요청에서 종료까지 : 7ms)- B: 1ms부터 대기하다가, 9ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 17ms이렇게 A → C → B의 순서로 처리하면 각 작업의 요청부터 종료까지 걸린 시간의 평균은 9ms(= (3 + 7 + 17) / 3)가 됩니다.각 작업에 대해 [작업이 요청되는 시점, 작업의 소요시간]을 담은 2차원 배열 jobs가 매개변수로 주어질 때, 작업의 요청부터 종료까지 걸린 시간의 평균을 가장 줄이는 방법으로 처리하면 평균이 얼마가 되는지 return 하도록 solution 함수를 작성해주세요. (단, 소수점 이하의 수는 버립니다)제한사항 jobs의 길이는 1 이상 500 이하입니다. jobs의 각 행은 하나의 작업에 대한 [작업이 요청되는 시점, 작업의 소요시간] 입니다. 각 작업에 대해 작업이 요청되는 시간은 0 이상 1,000 이하입니다. 각 작업에 대해 작업의 소요시간은 1 이상 1,000 이하입니다. 하드디스크가 작업을 수행하고 있지 않을 때에는 먼저 요청이 들어온 작업부터 처리합니다.입출력 예 jobs return [[0, 3], [1, 9], [2, 6]] 9 예제 #1 문제에 주어진 예와 같습니다. 0ms 시점에 3ms 걸리는 작업 요청이 들어옵니다. 1ms 시점에 9ms 걸리는 작업 요청이 들어옵니다. 2ms 시점에 6ms 걸리는 작업 요청이 들어옵니다.풀이 Heapclass Comp{public: bool operator() (const vector&amp;lt;int&amp;gt;&amp;amp; lhs, const vector&amp;lt;int&amp;gt;&amp;amp; rhs) const{ return lhs[1] &amp;gt; rhs[1]; }};int solution(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; jobs) { int answer = 0, curTime = 0, index = 0, runTime = 0; priority_queue&amp;lt;vector&amp;lt;int&amp;gt;, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;, Comp&amp;gt; pq; sort(jobs.begin(), jobs.end()); while(index &amp;lt; jobs.size() || !pq.empty()){ // 현재 job의 끝나는 시간전 까지 요청이 시작되는 job들을 heap에 넣어, // 수행시간이 짧은 순으로(SJF) 정렬. while(index &amp;lt; jobs.size() &amp;amp;&amp;amp; jobs[index][0] &amp;lt;= curTime){ pq.push(jobs[index]); ++index; } // index는 아직 마지막이 아니지만 Heap이 비어있다면, // 다음 job의 요청시간은 현재 job이 작업을 끝낸 이후. // 따라서 현재 시간을 다음 job의 요청시간으로 변경 if(pq.empty()){ curTime = jobs[index][0]; continue; } // 현재 시간은 heap에 있는 최소 작업시간만큼 더한시간 curTime += pq.top()[1]; // 현재시간에 해당 job의 요청시간을 빼주어, // (요청시간 - 작업시간) 을 구함 answer += curTime - pq.top()[0]; pq.pop(); } return answer / jobs.size();}" }, { "title": "Programmers - 예산", "url": "/posts/ps-programmers-025/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Binary Search", "date": "2020-02-02 20:15:00 +0900", "snippet": " 예산 - lv.3문제국가의 역할 중 하나는 여러 지방의 예산요청을 심사하여 국가의 예산을 분배하는 것입니다. 국가예산의 총액은 미리 정해져 있어서 모든 예산요청을 배정해 주기는 어려울 수도 있습니다. 그래서 정해진 총액 이하에서 가능한 한 최대의 총 예산을 다음과 같은 방법으로 배정합니다.1. 모든 요청이 배정될 수 있는 경우에는 요청한 금액을 그대로 배정합니다.2. 모든 요청이 배정될 수 없는 경우에는 특정한 정수 상한액을 계산하여 그 이상인 예산요청에는 모두 상한액을 배정합니다. 상한액 이하의 예산요청에 대해서는 요청한 금액을 그대로 배정합니다. 예를 들어, 전체 국가예산이 485이고 4개 지방의 예산요청이 각각 120, 110, 140, 150일 때, 상한액을 127로 잡으면 위의 요청들에 대해서 각각 120, 110, 127, 127을 배정하고 그 합이 484로 가능한 최대가 됩니다.각 지방에서 요청하는 예산이 담긴 배열 budgets과 총 예산 M이 매개변수로 주어질 때, 위의 조건을 모두 만족하는 상한액을 return 하도록 solution 함수를 작성해주세요.제한사항 지방의 수는 3 이상 100,000 이하인 자연수입니다. 각 지방에서 요청하는 예산은 1 이상 100,000 이하인 자연수입니다. 총 예산은 지방의 수 이상 1,000,000,000 이하인 자연수입니다.입출력 예 budgets M return [120, 110, 140, 150] 485 127 풀이 Binary Searchint solution(vector&amp;lt;int&amp;gt; budgets, int M) { int answer = 0, maxSum = 0; int min = 0, middle = 0; int max = *max_element(budgets.begin(), budgets.end()); // Binary Search 기반 while(min &amp;lt;= max){ middle = (max + min) &amp;gt;&amp;gt; 1; int sum = 0; // 각 지방의 예산의 합 계산 for(auto &amp;amp;i : budgets){ // 지방의 요청예산보다 중간값이 클경우 지방의 요청예산을 반영 if(i &amp;lt;= middle){ sum += i; } // 지방의 요청예산보다 중간값이 작을시 중간값을 반영 else{ sum += middle; } } // 지방의 예산 합보다 국가예산이 작은 액수중 가장 큰값을 계산 if(sum &amp;lt; M &amp;amp;&amp;amp; maxSum &amp;lt; sum){ maxSum = sum; answer = middle; } // Binary Search 의 종료조건 if(min == middle &amp;amp;&amp;amp; middle == max){ break; } if(sum &amp;lt;= M){ min = middle + 1; } else{ max = middle - 1; } } return answer;}" }, { "title": "Programmers - 타일 장식물", "url": "/posts/ps-programmers-024/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, DP", "date": "2020-02-02 20:15:00 +0900", "snippet": " 타일 장식물 - lv.3문제대구 달성공원에 놀러 온 지수는 최근에 새로 만든 타일 장식물을 보게 되었다. 타일 장식물은 정사각형 타일을 붙여 만든 형태였는데, 한 변이 1인 정사각형 타일부터 시작하여 마치 앵무조개의 나선 모양처럼 점점 큰 타일을 붙인 형태였다. 타일 장식물의 일부를 그리면 다음과 같다.그림에서 타일에 적힌 수는 각 타일의 한 변의 길이를 나타낸다. 타일 장식물을 구성하는 정사각형 타일 한 변의 길이를 안쪽 타일부터 시작하여 차례로 적으면 다음과 같다.[1, 1, 2, 3, 5, 8, .]지수는 문득 이러한 타일들로 구성되는 큰 직사각형의 둘레가 궁금해졌다. 예를 들어, 처음 다섯 개의 타일이 구성하는 직사각형(위에서 빨간색으로 표시한 직사각형)의 둘레는 26이다.타일의 개수 N이 주어질 때, N개의 타일로 구성된 직사각형의 둘레를 return 하도록 solution 함수를 작성하시오.제한사항 N은 1 이상 80 이하인 자연수이다.입출력 예 N return 5 26 6 42 풀이 DPlong long solution(int N) { long long answer = 0; long long val = 1, preVal = 1; for(auto i = 2 ; i &amp;lt; N ; ++i){ long long temp = val + preVal; preVal = val; val = temp; } answer = (val * 2) + ((val + preVal) * 2); return answer;}" }, { "title": "Programmers - 등굣길", "url": "/posts/ps-programmers-023/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, DP", "date": "2020-02-02 20:15:00 +0900", "snippet": " 등굣길 - lv.3문제계속되는 폭우로 일부 지역이 물에 잠겼습니다. 물에 잠기지 않은 지역을 통해 학교를 가려고 합니다. 집에서 학교까지 가는 길은 m x n 크기의 격자모양으로 나타낼 수 있습니다.아래 그림은 m = 4, n = 3 인 경우입니다.가장 왼쪽 위, 즉 집이 있는 곳의 좌표는 (1, 1)로 나타내고 가장 오른쪽 아래, 즉 학교가 있는 곳의 좌표는 (m, n)으로 나타냅니다.격자의 크기 m, n과 물이 잠긴 지역의 좌표를 담은 2차원 배열 puddles이 매개변수로 주어집니다. 집에서 학교까지 갈 수 있는 최단경로의 개수를 1,000,000,007로 나눈 나머지를 return 하도록 solution 함수를 작성해주세요.제한사항 격자의 크기 m, n은 1 이상 100 이하인 자연수입니다. m과 n이 모두 1인 경우는 입력으로 주어지지 않습니다. 물에 잠긴 지역은 0개 이상 10개 이하입니다. 집과 학교가 물에 잠긴 경우는 입력으로 주어지지 않습니다.입출력 예 M N puddles return 4 3 [[2, 2]] 4 풀이 DPint solution(int m, int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; puddles) { int answer = 0; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; tile = vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;(n + 1, vector&amp;lt;int&amp;gt;(m + 1, 1)); for(auto&amp;amp; puddle : puddles){ // 가로축 첫번째 줄에서 웅덩이가 있을때, // 해당 웅덩이의 오른쪽을 모두 0으로 초기화 if(puddle[1] == 1){ for(auto i = puddle[0] ; i &amp;lt;= m ; ++i){ tile[1][i] = 0; } } // 세로축 첫번째 줄에서 웅덩이가 있을때, // 해당 웅덩이의 아래를 모두 0으로 초기화 else if(puddle[0] == 1){ for(auto i = puddle[1] ; i &amp;lt;= n ; ++i){ tile[i][1] = 0; } } else{ tile[puddle[1]][puddle[0]] = 0; } } // 물웅덩이를 제외하고, // 현재 경로 = 위 경로 + 왼쪽 경로 for(auto i = 2 ; i &amp;lt;= n ; ++i){ for(auto j = 2 ; j &amp;lt;= m ; ++j){ if(tile[i][j] != 0) tile[i][j] = (tile[i-1][j] + tile[i][j-1]) % 1000000007; } } return tile[n][m];}" }, { "title": "Programmers - 이중우선순위큐", "url": "/posts/ps-programmers-022/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Queue", "date": "2020-02-02 20:15:00 +0900", "snippet": " 이중우선순위큐 - lv.3문제이중 우선순위 큐는 다음 연산을 할 수 있는 자료구조를 말합니다. 명령어 수신 탑(높이) I 숫자 큐에 주어진 숫자를 삽입합니다. D 1 큐에서 최댓값을 삭제합니다. D -1 큐에서 최소값을 삭제합니다. 이중 우선순위 큐가 할 연산 operations가 매개변수로 주어질 때, 모든 연산을 처리한 후 큐가 비어있으면 [0,0] 비어있지 않으면 [최댓값, 최솟값]을 return 하도록 solution 함수를 구현해주세요.제한사항 operations는 길이가 1 이상 1,000,000 이하인 문자열 배열입니다. operations의 원소는 큐가 수행할 연산을 나타냅니다. - 원소는 “명령어 데이터” 형식으로 주어집니다.- 최댓값/최솟값을 삭제하는 연산에서 최댓값/최솟값이 둘 이상인 경우, 하나만 삭제합니다. 빈 큐에 데이터를 삭제하라는 연산이 주어질 경우, 해당 연산은 무시합니다.입출력 예 operations return [I 16,D 1] ] [0,0] [I 7,I 5,I -5,D -1] ] [7,5] 16을 삽입 후 최댓값을 삭제합니다. 비어있으므로 [0,0]을 반환합니다.7,5,-5를 삽입 후 최솟값을 삭제합니다. 최대값 7, 최소값 5를 반환합니다.풀이 Queue, Dequevector&amp;lt;int&amp;gt; solution(vector&amp;lt;string&amp;gt; operations) { deque&amp;lt;int&amp;gt; answer; for(auto&amp;amp; str : operations){ vector&amp;lt;string&amp;gt; operation; string token; stringstream ss(str); while (getline(ss, token, &#39; &#39;)) { operation.push_back(token); } if(operation[0] == &quot;I&quot;){ auto val = stoi(operation[1]); answer.push_back(val); sort(answer.begin(), answer.end()); } //최대값 삭제 else if(operation[0] == &quot;D&quot; &amp;amp;&amp;amp; operation[1] == &quot;1&quot;){ if(answer.empty()) continue; answer.pop_back(); } // 최소값 삭제 else{ if(answer.empty()) continue; answer.pop_front(); } } if(answer.size() == 0) return {0,0}; else return {answer.back(), answer.front()};}" }, { "title": "Programmers - 베스트앨범", "url": "/posts/ps-programmers-021/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Hash", "date": "2020-02-02 20:15:00 +0900", "snippet": " 베스트앨범 - lv.3문제스트리밍 사이트에서 장르 별로 가장 많이 재생된 노래를 두 개씩 모아 베스트 앨범을 출시하려 합니다. 노래는 고유 번호로 구분하며, 노래를 수록하는 기준은 다음과 같습니다.속한 노래가 많이 재생된 장르를 먼저 수록합니다.장르 내에서 많이 재생된 노래를 먼저 수록합니다.장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록합니다.노래의 장르를 나타내는 문자열 배열 genres와 노래별 재생 횟수를 나타내는 정수 배열 plays가 주어질 때, 베스트 앨범에 들어갈 노래의 고유 번호를 순서대로 return 하도록 solution 함수를 완성하세요.제한사항 genres[i]는 고유번호가 i인 노래의 장르입니다. plays[i]는 고유번호가 i인 노래가 재생된 횟수입니다. genres와 plays의 길이는 같으며, 이는 1 이상 10,000 이하입니다. 장르 종류는 100개 미만입니다. 장르에 속한 곡이 하나라면, 하나의 곡만 선택합니다. 모든 장르는 재생된 횟수가 다릅니다.입출력 예 genres plays return [classic, pop, classic, classic, pop] ] [500, 600, 150, 800, 2500] [4, 1, 3, 0] classic 장르는 1,450회 재생되었으며, classic 노래는 다음과 같습니다. - 고유 번호 3: 800회 재생 - 고유 번호 0: 500회 재생 - 고유 번호 2: 150회 재생pop 장르는 3,100회 재생되었으며, pop 노래는 다음과 같습니다. - 고유 번호 4: 2,500회 재생 - 고유 번호 1: 600회 재생따라서 pop 장르의 [4, 1]번 노래를 먼저, classic 장르의 [3, 0]번 노래를 그다음에 수록합니다.풀이 Hashbool comp(pair&amp;lt;int,int&amp;gt;&amp;amp; a, pair&amp;lt;int,int&amp;gt;&amp;amp; b){ if(a.first == b.first) return a.second &amp;lt; b.second; return a.first &amp;gt; b.first;}vector&amp;lt;int&amp;gt; solution(vector&amp;lt;string&amp;gt; genres, vector&amp;lt;int&amp;gt; plays) { vector&amp;lt;int&amp;gt; answer; int len = genres.size(); map&amp;lt;string, vector&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt;&amp;gt; m; map&amp;lt;int, string&amp;gt; sumPlays; // 장르별 플레이수 vector 구성 for(auto i = 0 ; i &amp;lt; len ; ++i){ m[genres[i]].push_back({plays[i], i}); } // 플레이수를 내림차순으로 정렬 // 많이 재생된순의 장르를 알기 위해, // 각 장르별 플레이수 합의 map을 구성 for(auto&amp;amp; i : m){ sort(i.second.begin(), i.second.end(), comp); int sum = 0; for(auto &amp;amp;j : i.second) sum += j.first; sumPlays[sum] = i.first; } for(auto i = sumPlays.rbegin() ; i != sumPlays.rend() ; ++i){ if(m[i-&amp;gt;second].size() &amp;gt; 1){ answer.push_back(m[i-&amp;gt;second][0].second); answer.push_back(m[i-&amp;gt;second][1].second); } else{ answer.push_back(m[i-&amp;gt;second][0].second); } } return answer;}" }, { "title": "Programmers - 최대공약수와 최소공배수", "url": "/posts/ps-programmers-020/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Math", "date": "2020-02-02 20:15:00 +0900", "snippet": " 최대공약수와 최소공배수 - lv.1문제두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환하는 함수, solution을 완성해 보세요. 배열의 맨 앞에 최대공약수, 그다음 최소공배수를 넣어 반환하면 됩니다. 예를 들어 두 수 3, 12의 최대공약수는 3, 최소공배수는 12이므로 solution(3, 12)는 [3, 12]를 반환해야 합니다.제한사항 두 수는 1이상 1000000이하의 자연수입니다.입출력 예 n m return 3 12 [3, 12] 2 5 [1, 10] 입출력 예 #1 - 위의 설명과 같습니다.입출력 예 #2 - 자연수 2와 5의 최대공약수는 1, 최소공배수는 10이므로 [1, 10]을 리턴해야 합니다.풀이 Mathint gcd(int a, int b){ if(a == 0) return b; return gcd((b%a), a); }int lcm(int a, int b){ return (a * b) / gcd(a, b);}vector&amp;lt;int&amp;gt; solution(int n, int m) { return {gcd(n,m), lcm(n,m)};}" }, { "title": "Programmers - [2020카카오공채] 문자열 압축", "url": "/posts/ps-programmers-019/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, String", "date": "2020-02-02 20:15:00 +0900", "snippet": " [2020카카오공채] 문자열 압축 - lv.1문제데이터 처리 전문가가 되고 싶은 어피치는 문자열을 압축하는 방법에 대해 공부를 하고 있습니다. 최근에 대량의 데이터 처리를 위한 간단한 비손실 압축 방법에 대해 공부를 하고 있는데, 문자열에서 같은 값이 연속해서 나타나는 것을 그 문자의 개수와 반복되는 값으로 표현하여 더 짧은 문자열로 줄여서 표현하는 알고리즘을 공부하고 있습니다.간단한 예로 aabbaccc의 경우 2a2ba3c(문자가 반복되지 않아 한번만 나타난 경우 1은 생략함)와 같이 표현할 수 있는데, 이러한 방식은 반복되는 문자가 적은 경우 압축률이 낮다는 단점이 있습니다. 예를 들면, abcabcdede와 같은 문자열은 전혀 압축되지 않습니다. 어피치는 이러한 단점을 해결하기 위해 문자열을 1개 이상의 단위로 잘라서 압축하여 더 짧은 문자열로 표현할 수 있는지 방법을 찾아보려고 합니다.예를 들어, ababcdcdababcdcd의 경우 문자를 1개 단위로 자르면 전혀 압축되지 않지만, 2개 단위로 잘라서 압축한다면 2ab2cd2ab2cd로 표현할 수 있습니다. 다른 방법으로 8개 단위로 잘라서 압축한다면 2ababcdcd로 표현할 수 있으며, 이때가 가장 짧게 압축하여 표현할 수 있는 방법입니다.다른 예로, abcabcdede와 같은 경우, 문자를 2개 단위로 잘라서 압축하면 abcabc2de가 되지만, 3개 단위로 자른다면 2abcdede가 되어 3개 단위가 가장 짧은 압축 방법이 됩니다. 이때 3개 단위로 자르고 마지막에 남는 문자열은 그대로 붙여주면 됩니다.압축할 문자열 s가 매개변수로 주어질 때, 위에 설명한 방법으로 1개 이상 단위로 문자열을 잘라 압축하여 표현한 문자열 중 가장 짧은 것의 길이를 return 하도록 solution 함수를 완성해주세요.제한사항 s의 길이는 1 이상 1,000 이하입니다. s는 알파벳 소문자로만 이루어져 있습니다.입출력 예 n return “aabbaccc” 7 “ababcdcdababcdcd” 9 “abcabcdede” 8 “abcabcabcabcdededededede” 14 “xababcdcdababcdcd” 17 입출력 예 #1 - 문자열을 1개 단위로 잘라 압축했을 때 가장 짧습니다.입출력 예 #2 - 문자열을 8개 단위로 잘라 압축했을 때 가장 짧습니다.입출력 예 #3 - 문자열을 3개 단위로 잘라 압축했을 때 가장 짧습니다.입출력 예 #4 - 문자열을 2개 단위로 자르면 abcabcabcabc6de 가 됩니다. - 문자열을 3개 단위로 자르면 4abcdededededede 가 됩니다. - 문자열을 4개 단위로 자르면 abcabcabcabc3dede 가 됩니다. - 문자열을 6개 단위로 자를 경우 2abcabc2dedede가 되며, 이때의 길이가 14로 가장 짧습니다.입출력 예 #5 - 문자열은 제일 앞부터 정해진 길이만큼 잘라야 합니다. 따라서 주어진 문자열을 x / ababcdcd / ababcdcd 로 자르는 것은 불가능 합니다. 이 경우 어떻게 문자열을 잘라도 압축되지 않으므로 가장 짧은 길이는 17이 됩니다.풀이 stringint solution(string s) { if(s.size() &amp;lt; 2) return 1; int answer = INT_MAX; // 반복문자를 쪼갤 수만큼 반복 // 1 ~ size / 2 만큼 쪼갤수 있음 for(auto i = 1 ; i &amp;lt;= s.size() / 2 ; ++i){ string res(&quot;&quot;); int count = 1 ; auto j = i; // s를 조회하며 i 만큼 문자를 쪼개며 // 반복되는 수를 조사함 for(; j &amp;lt; s.size() ; j = j+i){ if(s.substr(j, i) == s.substr(j-i, i)) ++count; else{ if(count &amp;gt; 1) res += to_string(count) + s.substr(j-i, i); else res += s.substr(j-i, i); count = 1; } } // 이전의 반복문에서 마지막 인덱스에 관한 값을 // 채우지 못하고 빠져나오므로 따로 // 마지막 인덱스에 관한 정보만 처리 if(count &amp;gt; 1) res += to_string(count) + s.substr(j-i, i); else res += s.substr(j-i, i); answer = answer &amp;lt; res.size() ? answer : res.size(); } return answer;}" }, { "title": "Programmers - 정수 제곱근 판별", "url": "/posts/ps-programmers-018/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Math", "date": "2020-02-02 20:15:00 +0900", "snippet": " 정수 제곱근 판별 - lv.1문제임의의 양의 정수 n에 대해, n이 어떤 양의 정수 x의 제곱인지 아닌지 판단하려 합니다.n이 양의 정수 x의 제곱이라면 x+1의 제곱을 리턴하고, n이 양의 정수 x의 제곱이 아니라면 -1을 리턴하는 함수를 완성하세요.제한사항 n은 1이상, 50000000000000 이하인 양의 정수입니다.입출력 예 n return 121 144 3 -1 입출력 예 #1 - 121은 양의 정수 11의 제곱이므로, (11+1)를 제곱한 144를 리턴합니다.입출력 예 #2 - 3은 양의 정수의 제곱이 아니므로, -1을 리턴합니다.풀이 mathlong long solution(long long n) { long long answer = 0; long long mul = 1; while(mul &amp;lt;= n){ ++answer; mul = answer * answer; if(n == mul){ return (answer+1) * (answer+1); } } return -1;}" }, { "title": "Programmers - 정수 내림차순으로 배치하기", "url": "/posts/ps-programmers-017/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Math", "date": "2020-02-02 20:15:00 +0900", "snippet": " 정수 내림차순으로 배치하기 - lv.1문제함수 solution은 정수 n을 매개변수로 입력받습니다. n의 각 자릿수를 큰것부터 작은 순으로 정렬한 새로운 정수를 리턴해주세요. 예를들어 n이 118372면 873211을 리턴하면 됩니다.제한사항 n은 1이상 8000000000 이하인 자연수입니다.입출력 예 n return 118372 873211 풀이 mathlong long solution(long long n) { long long answer = 0; long long temp = 10; vector&amp;lt;int&amp;gt; arr; while(temp &amp;lt; n * 10){ arr.push_back(((n % temp) - (n % (temp/10))) / (temp/10)); temp *= 10; } sort(arr.begin(), arr.end(), greater&amp;lt;int&amp;gt;()); auto len = arr.size(); temp = 1; for(auto i = 0 ; i &amp;lt; len ; ++i){ answer += (arr.back() * temp); arr.pop_back(); temp *= 10; } return answer;}" }, { "title": "Programmers - [1차] 비밀지도", "url": "/posts/ps-programmers-016/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Bit Manipulte", "date": "2020-02-02 20:15:00 +0900", "snippet": " [1차] 비밀지도 - lv.1문제네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 공백(“ ) 또는벽(#”) 두 종류로 이루어져 있다.전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 지도 1과 지도 2라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.지도 1과 지도 2는 각각 정수 배열로 암호화되어 있다.암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라.제한사항 1 ≦ n ≦ 16 arr1, arr2는 길이 n인 정수 배열로 주어진다. 정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2n - 1을 만족한다.입출력 예 매개변수 값 n 5 arr1 [9, 20, 28, 18, 11] arr2 [30, 1, 21, 17, 28] 출력 [”#####”,”# # #”, “### #”, “# ##”, “#####”] 매개변수 값 n 6 arr1 [46, 33, 33 ,22, 31, 50] arr2 [27 ,56, 19, 14, 14, 10] 출력 [”######”, “### #”, “## ##”, “ #### “, “ #####”, “### # “] 풀이 Bit Manipultevector&amp;lt;string&amp;gt; solution(int n, vector&amp;lt;int&amp;gt; arr1, vector&amp;lt;int&amp;gt; arr2) { vector&amp;lt;string&amp;gt; answer; vector&amp;lt;int&amp;gt; makeMap; // &amp;amp; 연산을 통해 두 지도 배열을 합침 for(auto i = 0 ; i &amp;lt; n ; ++i){ makeMap.push_back(arr1[i] | arr2[i]); } // 합친 지도에서 각 행마다 // 2진수를 조사하여 1의 위치를 알아냄 for(auto&amp;amp; i : makeMap){ string res; stack&amp;lt;int&amp;gt; s; // 2진수의 1의 위치를 조사할때, // 순서에 반대부터 조사하므로 stack을 이용하여 뒤집음 for(auto k = 0 ; k &amp;lt; n ; ++k){ auto temp = i &amp;amp; 1; s.push(temp); i &amp;gt;&amp;gt;= 1; } while(!s.empty()){ if(s.top() == 1) res.push_back(&#39;#&#39;); else res.push_back(&#39; &#39;); s.pop(); } answer.push_back(res); } return answer;}" }, { "title": "Programmers - N개의 최소공배수", "url": "/posts/ps-programmers-015/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Math", "date": "2020-02-02 20:15:00 +0900", "snippet": " N개의 최소공배수 - lv.2문제두 수의 최소공배수(Least Common Multiple)란 입력된 두 수의 배수 중 공통이 되는 가장 작은 숫자를 의미합니다. 예를 들어 2와 7의 최소공배수는 14가 됩니다. 정의를 확장해서, n개의 수의 최소공배수는 n 개의 수들의 배수 중 공통이 되는 가장 작은 숫자가 됩니다. n개의 숫자를 담은 배열 arr이 입력되었을 때 이 수들의 최소공배수를 반환하는 함수, solution을 완성해 주세요.제한사항 arr은 길이 1이상, 15이하인 배열입니다. arr의 원소는 100 이하인 자연수입니다.입출력 예 arr return [2,6,8,14] 168 [1,2,3] 6 풀이 mathint gcd(int a, int b){ if(a == 0) return b; return gcd((b % a), a);}int lcm(int a, int b){ return (a * b) / gcd(a,b);}int solution(vector&amp;lt;int&amp;gt; arr) { int answer = arr[0]; for(auto i = arr.begin() + 1 ; i != arr.end() ; ++i){ answer = lcm(answer, *i); } return answer;}" }, { "title": "Programmers - 큰 수 만들기", "url": "/posts/ps-programmers-014/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Greedy", "date": "2020-02-02 20:15:00 +0900", "snippet": " 큰 수 만들기 - lv.2문제어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다.문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요.제한사항 number는 1자리 이상, 1,000,000자리 이하인 숫자입니다. k는 1 이상 number의 자릿수 미만인 자연수입니다.입출력 예 number k return “1924” 2 “94” “1231234” 3 “3234” “4177252841” 4 “775841” 풀이 Greedystring solution(string number, int k) { int index = 1; while(k &amp;amp;&amp;amp; index &amp;lt; number.size()){ // index의 값과 index-1의 값을 비교하여 // index-1값이 작으면 index-1의 원소를 제거 // 제거후 전체 크기가 -1 만큼 줄어드므로, // 현재 index의 -1을 하여 재 비교가 될수 있도록 함 if(index &amp;gt; 0 &amp;amp;&amp;amp; number[index-1] &amp;lt; number[index]){ number.erase(number.begin()+(index-1)); --k; --index; } // 마지막 원소에서 까지 k만큼 제거가 안됬다면, // 마지막 원소부터 지우기 시작 // 이때 index값과 index-1의 값을 비교하여 // index값이 작으면 index의 원소를 제거 else if(index == number.size()-1 &amp;amp;&amp;amp; number[index] &amp;lt;= number[index-1]){ number.erase(number.begin()+index); --k; --index; } else{ ++index; } } return number;}" }, { "title": "Programmers - 카카오프렌즈 컬러링북", "url": "/posts/ps-programmers-013/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, DFS, BFS", "date": "2020-02-02 20:15:00 +0900", "snippet": " 카카오프렌즈 컬러링북 - lv.2문제출판사의 편집자인 어피치는 네오에게 컬러링북에 들어갈 원화를 그려달라고 부탁하여 여러 장의 그림을 받았다. 여러 장의 그림을 난이도 순으로 컬러링북에 넣고 싶었던 어피치는 영역이 많으면 색칠하기가 까다로워 어려워진다는 사실을 발견하고 그림의 난이도를 영역의 수로 정의하였다. (영역이란 상하좌우로 연결된 같은 색상의 공간을 의미한다.)그림에 몇 개의 영역이 있는지와 가장 큰 영역의 넓이는 얼마인지 계산하는 프로그램을 작성해보자.위의 그림은 총 12개 영역으로 이루어져 있으며, 가장 넓은 영역은 어피치의 얼굴면으로 넓이는 120이다.제한사항 입력은 그림의 크기를 나타내는 m과 n, 그리고 그림을 나타내는 m × n 크기의 2차원 배열 picture로 주어진다. 1 &amp;lt;= m, n &amp;lt;= 100 picture의 원소는 0 이상 2^31 - 1 이하의 임의의 값이다. picture의 원소 중 값이 0인 경우는 색칠하지 않는 영역을 뜻한다. 입출력 예 m n picture return 6 4 [[1, 1, 1, 0], [1, 2, 2, 0], [1, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 3], [0, 0, 0, 3]] [4,5] 풀이 BFS, DFSvector&amp;lt;int&amp;gt; solution(int m, int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; picture) { int number_of_area = 0; int max_size_of_one_area = 0; vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; checker(m, vector&amp;lt;bool&amp;gt;(n, false)); for(auto i = 0 ; i &amp;lt; m ; ++i){ for(auto j = 0 ; j &amp;lt; n ; ++j){ // 현재 인덱스의 체커가 true 거나 색이 0 이면 패스 if(checker[i][j] || !picture[i][j]) continue; // BFS // 저장할 pair의 정보는 {행 index, 열 index} int count = 0; queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; q.push({i,j}); while(!q.empty()){ auto curPic = q.front(); q.pop(); // 이미 체크되어있거나, 색이 다르면 패스 if(checker[curPic.first][curPic.second] || picture[curPic.first][curPic.second] != picture[i][j]) continue; // 현재 인덱스 체크 및 영역 수 증가 checker[curPic.first][curPic.second] = true; count++; // 위 검사 if(curPic.first + 1 &amp;lt; m) q.push({curPic.first+1, curPic.second}); // 아래 검사 if(curPic.first - 1 &amp;gt;= 0) q.push({curPic.first-1, curPic.second}); // 오른쪽 검사 if(curPic.second + 1 &amp;lt; n) q.push({curPic.first, curPic.second+1}); // 왼쪽 검사 if(curPic.second - 1 &amp;gt;= 0) q.push({curPic.first, curPic.second-1}); } ++number_of_area; max_size_of_one_area = max(count, max_size_of_one_area); } } return {number_of_area, max_size_of_one_area};}" }, { "title": "Programmers - 멀리 뛰기", "url": "/posts/ps-programmers-012/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, DP", "date": "2020-02-02 20:15:00 +0900", "snippet": " 멀리 뛰기 - lv.3문제효진이는 멀리 뛰기를 연습하고 있습니다. 효진이는 한번에 1칸, 또는 2칸을 뛸 수 있습니다. 칸이 총 4개 있을 때, 효진이는(1칸, 1칸, 1칸, 1칸)(1칸, 2칸, 1칸)(1칸, 1칸, 2칸)(2칸, 1칸, 1칸)(2칸, 2칸)의 5가지 방법으로 맨 끝 칸에 도달할 수 있습니다. 멀리뛰기에 사용될 칸의 수 n이 주어질 때, 효진이가 끝에 도달하는 방법이 몇 가지인지 알아내, 여기에 1234567를 나눈 나머지를 리턴하는 함수, solution을 완성하세요. 예를 들어 4가 입력된다면, 5를 return하면 됩니다.제한사항 n은 1 이상, 2000 이하인 정수입니다.입출력 예 m return 4 5 3 3 풀이 DPlong long solution(int n) { if(n &amp;lt;= 1) return 1; long long answer = 1; long long preVal = 0; // i = (i -1) + (i -2) for(auto i = 1 ; i &amp;lt;= n ; ++i){ auto nextVal = answer + preVal; preVal = answer; answer = nextVal % 1234567; } return answer;}" }, { "title": "Programmers - 야근 지수", "url": "/posts/ps-programmers-011/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Greedy", "date": "2020-02-02 20:15:00 +0900", "snippet": " 야근 지수 - lv.3문제회사원 Demi는 가끔은 야근을 하는데요, 야근을 하면 야근 피로도가 쌓입니다. 야근 피로도는 야근을 시작한 시점에서 남은 일의 작업량을 제곱하여 더한 값입니다. Demi는 N시간 동안 야근 피로도를 최소화하도록 일할 겁니다.Demi가 1시간 동안 작업량 1만큼을 처리할 수 있다고 할 때, 퇴근까지 남은 N 시간과 각 일에 대한 작업량 works에 대해 야근 피로도를 최소화한 값을 리턴하는 함수 solution을 완성해주세요.제한사항 works는 길이 1 이상, 20,000 이하인 배열입니다. works의 원소는 50000 이하인 자연수입니다. n은 1,000,000 이하인 자연수입니다.입출력 예 works n return [4, 3, 3] 4 12 [2, 1, 2] 1 6 [1,1] 3 0 풀이 Greedylong long solution(int n, vector&amp;lt;int&amp;gt; works) { long long answer = 0; priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, less&amp;lt;int&amp;gt;&amp;gt; pq; for(auto&amp;amp; i : works) pq.push(i); // n만큼 반복하며 현재 works중 가장 큰수를 골라 -1 함 // 가장 큰수가 0 일땐 모든수가 0이므로 빠져나옴 // priority queue를 이용하여 구성 while(n--){ auto max = pq.top(); pq.pop(); if(max == 0) break; pq.push(--max); } while(!pq.empty()){ auto val = pq.top(); pq.pop(); answer += val * val; } return answer;}" }, { "title": "Programmers - 섬 연결하기", "url": "/posts/ps-programmers-010/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, DFS, BFS, MST, Kruskal", "date": "2020-02-02 20:15:00 +0900", "snippet": " 섬 연결하기 - lv.3문제n개의 섬 사이에 다리를 건설하는 비용(costs)이 주어질 때, 최소의 비용으로 모든 섬이 서로 통행 가능하도록 만들 때 필요한 최소 비용을 return 하도록 solution을 완성하세요.다리를 여러 번 건너더라도, 도달할 수만 있으면 통행 가능하다고 봅니다. 예를 들어 A 섬과 B 섬 사이에 다리가 있고, B 섬과 C 섬 사이에 다리가 있으면 A 섬과 C 섬은 서로 통행 가능합니다.제한사항 섬의 개수 n은 1 이상 100 이하입니다. costs의 길이는 ((n-1) * n) / 2이하입니다. 임의의 i에 대해, costs[i][0] 와 costs[i] [1]에는 다리가 연결되는 두 섬의 번호가 들어있고, costs[i] [2]에는 이 두 섬을 연결하는 다리를 건설할 때 드는 비용입니다. 같은 연결은 두 번 주어지지 않습니다. 또한 순서가 바뀌더라도 같은 연결로 봅니다. 즉 0과 1 사이를 연결하는 비용이 주어졌을 때, 1과 0의 비용이 주어지지 않습니다. 모든 섬 사이의 다리 건설 비용이 주어지지 않습니다. 이 경우, 두 섬 사이의 건설이 불가능한 것으로 봅니다. 연결할 수 없는 섬은 주어지지 않습니다.입출력 예 n costs return 4 [[0,1,1],[0,2,2],[1,2,5],[1,3,1],[2,3,8]] 4 costs를 그림으로 표현하면 다음과 같으며, 이때 초록색 경로로 연결하는 것이 가장 적은 비용으로 모두를 통행할 수 있도록 만드는 방법입니다.풀이 DFS, BFS, MST, Kruskal// cost가 작은순으로 정렬bool comp(const vector&amp;lt;int&amp;gt;&amp;amp; a, const vector&amp;lt;int&amp;gt;&amp;amp; b){ return a[2] &amp;lt; b[2];}// 부모노드 찾기int getParent(vector&amp;lt;int&amp;gt;&amp;amp; parent, int node){ if(parent[node] == node) return node; return parent[node] = getParent(parent, parent[node]);}// 작은 부모노드의 번호로 합치기void unionParent(vector&amp;lt;int&amp;gt;&amp;amp; parent, int a, int b){ a = getParent(parent, a); b = getParent(parent, b); int max = a &amp;gt; b ? a : b; int min = a &amp;lt;= b ? a : b; parent[max] = min;}// 부모노드 검사를 통해 사이클이 이루어지는지 검사bool checkCycle(vector&amp;lt;int&amp;gt;&amp;amp; parent, int a, int b){ a = getParent(parent, a); b = getParent(parent, b); if(a == b) return true; else return false;}int solution(int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; costs) { int answer = 0; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; g(n, vector&amp;lt;int&amp;gt;(n, 0)); vector&amp;lt;int&amp;gt; parent(n, 0); for(auto i = 0 ; i &amp;lt; n ; ++i) parent[i] = i; sort(costs.begin(), costs.end(), comp); // kruskal 알고리즘을 통해 // minimum spanning tree(MST)를 구함 for(auto i = 0 ; i &amp;lt; costs.size() ; ++i){ if(!checkCycle(parent, costs[i][0], costs[i][1])){ answer += costs[i][2]; unionParent(parent, costs[i][0],costs[i][1]); } } return answer;}" }, { "title": "Programmers - 저울", "url": "/posts/ps-programmers-009/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Greedy", "date": "2020-02-02 20:15:00 +0900", "snippet": " 저울 - lv.3문제하나의 양팔 저울을 이용하여 물건의 무게를 측정하려고 합니다. 이 저울의 양팔의 끝에는 물건이나 추를 올려놓는 접시가 달려 있고, 양팔의 길이는 같습니다. 또한, 저울의 한쪽에는 저울추들만 놓을 수 있고, 다른 쪽에는 무게를 측정하려는 물건만 올려놓을 수 있습니다.저울추가 담긴 배열 weight가 매개변수로 주어질 때, 이 추들로 측정할 수 없는 양의 정수 무게 중 최솟값을 return 하도록 solution 함수를 작성해주세요.예를 들어, 무게가 각각 [3, 1, 6, 2, 7, 30, 1]인 7개의 저울추를 주어졌을 때, 이 추들로 측정할 수 없는 양의 정수 무게 중 최솟값은 21입니다.제한사항 저울추의 개수는 1개 이상 10,000개 이하입니다. 각 추의 무게는 1 이상 1,000,000 이하입니다.입출력 예 weight return [3, 1, 6, 2, 7, 30, 1] 21 풀이 Greedyint solution(vector&amp;lt;int&amp;gt; weight) { int answer = 0; sort(weight.begin(), weight.end()); answer = weight[0]; // 정렬후, 요소들의 순서대로 합했을때, 표현할 수 있는 무게는 // weight[0] ~ weight[i-1] 까지의 합 까지 표현 할수 있음 // 즉, // // ((weight[0] ~ weight[i-1] 까지의 합) + 1) &amp;gt;= weight[i] 이면, // 초기값 ~ (weight[0] ~ weight[i-1] 까지의 합)의 무게를 모두 표현가능함 // // ((weight[0] ~ weight[i-1] 까지의 합) + 1) &amp;lt; weight[i] 이면, // 초기값 ~ (weight[0] ~ weight[i-1] 까지의 합)과 weight[i]사이의 값은 // 표현할 수 없다. for(auto i = 0 ; i &amp;lt; weight.size() ; ++i){ if(answer+1 &amp;lt; weight[i]){ break; } answer += weight[i]; } return answer;}" }, { "title": "Programmers - 최고의 집합", "url": "/posts/ps-programmers-008/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Greedy", "date": "2020-02-02 20:15:00 +0900", "snippet": " 최고의 집합 - lv.3문제자연수 n 개로 이루어진 중복 집합(multi set, 편의상 이후에는 집합으로 통칭) 중에 다음 두 조건을 만족하는 집합을 최고의 집합이라고 합니다. 각 원소의 합이 S가 되는 수의 집합 위 조건을 만족하면서 각 원소의 곱 이 최대가 되는 집합예를 들어서 자연수 2개로 이루어진 집합 중 합이 9가 되는 집합은 다음과 같이 4개가 있습니다.{ 1, 8 }, { 2, 7 }, { 3, 6 }, { 4, 5 }그중 각 원소의 곱이 최대인 { 4, 5 }가 최고의 집합입니다.집합의 원소의 개수 n과 모든 원소들의 합 s가 매개변수로 주어질 때, 최고의 집합을 return 하는 solution 함수를 완성해주세요.제한사항 최고의 집합은 오름차순으로 정렬된 1차원 배열(list, vector) 로 return 해주세요. 만약 최고의 집합이 존재하지 않는 경우에 크기가 1인 1차원 배열(list, vector) 에 -1 을 채워서 return 해주세요. 자연수의 개수 n은 1 이상 10,000 이하의 자연수입니다. 모든 원소들의 합 s는 1 이상, 100,000,000 이하의 자연수입니다.입출력 예 n s return 2 9 [4, 5] 2 1 [-1] 2 8 [4, 4] 입출력 예#1 - 문제의 예시와 같습니다.입출력 예#2 - 자연수 2개를 가지고는 합이 1인 집합을 만들 수 없습니다. 따라서 -1이 들어있는 배열을 반환합니다.입출력 예#3 - 자연수 2개로 이루어진 집합 중 원소의 합이 8인 집합은 다음과 같습니다. { 1, 7 }, { 2, 6 }, { 3, 4 }, { 4, 4 } 그중 각 원소의 곱이 최대인 { 4, 4 }가 최고의 집합입니다.풀이 Greedyvector&amp;lt;int&amp;gt; solution(int n, int s) { // 각 원소의 합이 S가 되는 수의 집합중, 원소의 곱이 가장크게 되려면 // 각 원소의 값이 최대한 균등하게 분배되어 있어야 함 // 따라서 s를 n으로 나눈 몫을 전체 배열로 초기화 시킨다음, // s를 n으로 나눈 나머지를 균등하게 1씩 배열의 원소에 더해줌 int carry = s / n; int count = s % n; vector&amp;lt;int&amp;gt; answer(n, carry); for(auto i = 0 ; i &amp;lt; count ; ++i) ++answer[n - i - 1]; if(carry) return answer; return {-1};}" }, { "title": "Programmers - 가장 긴 팰린드롬", "url": "/posts/ps-programmers-007/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, String", "date": "2020-02-02 20:15:00 +0900", "snippet": " 가장 긴 팰린드롬 - lv.3문제앞뒤를 뒤집어도 똑같은 문자열을 팰린드롬(palindrome)이라고 합니다.문자열 s가 주어질 때, s의 부분문자열(Substring)중 가장 긴 팰린드롬의 길이를 return 하는 solution 함수를 완성해 주세요.예를들면, 문자열 s가 abcdcba이면 7을 return하고 abacde이면 3을 return합니다.제한사항 문자열 s의 길이 : 2,500 이하의 자연수 문자열 s는 알파벳 소문자로만 구성입출력 예 s return “abcdcba” 7 “abacde” 3 입출력 예 #1 - 4번째자리 &#39;d&#39;를 기준으로 문자열 s 전체가 팰린드롬이 되므로 7을 return합니다.입출력 예 #2 - 2번째자리 &#39;b&#39;를 기준으로 aba가 팰린드롬이 되므로 3을 return합니다.풀이 String// 문자열의 길이가 홀수인 펠린드롬 찾기int oddBasedPalindrome(const string&amp;amp; s){ int answer = 1; int len = s.size(); for(auto i = 1 ; i &amp;lt; len - 1 ; ++i){ // 인덱스 i를 기준으로 양옆의 문자가 같은지 판단 int left = i - 1; int right = i + 1; int count = 1; // 양옆이 같으면 각 왼쪽, 오른쪽의 인덱스를 // 1씩 증가시키면서 최대 펠린드롬 찾기 while(left &amp;gt;= 0 &amp;amp;&amp;amp; right &amp;lt; len){ if(s[left] == s[right]){ count += 2; --left; ++right; } else break; } answer = max(answer, count); } return answer;}// 문자열의 길이가 짝수인 펠린드롬 찾기int evenBasedPalindrome(const string&amp;amp; s){ int answer = 1; int len = s.size(); for(auto i = 0 ; i &amp;lt; len - 1 ; ++i){ // 인덱스 i를 기준으로 양옆의 문자가 같은지 판단 int left = i; int right = i + 1; int count = 0; // 양옆이 같으면 각 왼쪽, 오른쪽의 인덱스를 // 1씩 증가시키면서 최대 펠린드롬 찾기 while(left &amp;gt;= 0 &amp;amp;&amp;amp; right &amp;lt; len){ if(s[left] == s[right]){ count += 2; --left; ++right; } else break; } answer = max(answer, count); } return answer;}int solution(string s){ int answer = max(evenBasedPalindrome(s), oddBasedPalindrome(s)); return answer;}" }, { "title": "Programmers - 거스름돈", "url": "/posts/ps-programmers-006/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, DP", "date": "2020-02-02 20:15:00 +0900", "snippet": " 거스름돈 - lv.3문제Finn은 편의점에서 야간 아르바이트를 하고 있습니다. 야간에 손님이 너무 없어 심심한 Finn은 손님들께 거스름돈을 n 원을 줄 때 방법의 경우의 수를 구하기로 하였습니다.예를 들어서 손님께 5원을 거슬러 줘야 하고 1원, 2원, 5원이 있다면 다음과 같이 4가지 방법으로 5원을 거슬러 줄 수 있습니다.1원을 5개 사용해서 거슬러 준다.1원을 3개 사용하고, 2원을 1개 사용해서 거슬러 준다.1원을 1개 사용하고, 2원을 2개 사용해서 거슬러 준다.5원을 1개 사용해서 거슬러 준다.거슬러 줘야 하는 금액 n과 Finn이 현재 보유하고 있는 돈의 종류 money가 매개변수로 주어질 때, Finn이 n 원을 거슬러 줄 방법의 수를 return 하도록 solution 함수를 완성해 주세요.제한사항 n은 100,000 이하의 자연수입니다. 화폐 단위는 100종류 이하입니다. 모든 화폐는 무한하게 있다고 가정합니다. 정답이 커질 수 있으니, 1,000,000,007로 나눈 나머지를 return 해주세요.입출력 예 s money return 5 [1,2,5] 4 풀이 DPint solution(int n, vector&amp;lt;int&amp;gt; money) { vector&amp;lt;int&amp;gt; item(n+1, 0); item[0] = 1; // 현재 선택한 동전으로 만들수 있는 거스름돈 조사 for (int&amp;amp; i : money){ // 현재 선택된 동전으로 만들수 있는 거스름돈은 // (현재 선택된 동전의 금액) ~ n * (현재 선택된 동전의 금액) 이며, // 현재 선택된 동전으로 만들수 있는 현재 금액의 거스름돈은, // item[현재금액 - 현재선택된동전] 임. 예시로, // 현재 선택된 동전이 2일때, 최소 2부터 시작되며, // 만들수 있는 금액은 2,4,6,8,10,... 순으로, 현재 금액과 다음 금액의 차이는 2만큼 차이남 // 전체 동전으로 만들수 있는 수를 구해야 하므로 매번 이전 금액의 수와 더해나감 // 즉, item[현재금액] = item[현재금액 - 현재선택된 동전] + item[현재금액] for (int j = i; j &amp;lt;= n; j++){ item[j] += item[j - i]; } } return item[n];}" }, { "title": "Programmers - 줄 서는 방법", "url": "/posts/ps-programmers-005/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Greedy", "date": "2020-02-02 20:15:00 +0900", "snippet": " 줄 서는 방법 - lv.3문제n명의 사람이 일렬로 줄을 서고 있습니다. n명의 사람들에게는 각각 1번부터 n번까지 번호가 매겨져 있습니다. n명이 사람을 줄을 서는 방법은 여러가지 방법이 있습니다. 예를 들어서 3명의 사람이 있다면 다음과 같이 6개의 방법이 있습니다.[1, 2, 3][1, 3, 2][2, 1, 3][2, 3, 1][3, 1, 2][3, 2, 1]사람의 수 n과, 자연수 k가 주어질 때, 사람을 나열 하는 방법을 사전 순으로 나열 했을 때, k번째 방법을 return하는 solution 함수를 완성해주세요.제한사항 n은 20이하의 자연수 입니다. k는 n! 이하의 자연수 입니다.입출력 예 n k return 3 5 [3,1,2] 풀이 Greedyvector&amp;lt;int&amp;gt; solution(int n, long long k) { vector&amp;lt;int&amp;gt; answer; vector&amp;lt;int&amp;gt; item(n + 1, 1); vector&amp;lt;long long&amp;gt; mul(n + 1 ,1); // n 까지의 값과 n 까지의 factoral를 저장 for(auto i = 1 ; i &amp;lt;= n ; ++i){ item[i] = i; mul[i] = mul[i-1] * i; } // 구하고자하는 자리수의 값을 mul[i-1]으로 나눈 몫의 인덱스 값이 해당 자리의 값 // 다음자리의 자리수 값은 현재 자리수 % mul[i-1] 임 long long val = k - 1; for(auto i = n ; i &amp;gt; 1 ; --i){ auto share = val / mul[i-1]; val %= mul[i-1]; answer.push_back(*(item.begin() + 1 + share)); item.erase(item.begin() + 1 + share); } answer.push_back(item.back()); return answer;}" }, { "title": "Programmers - 방문 길이", "url": "/posts/ps-programmers-004/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Brute Force", "date": "2020-02-02 20:15:00 +0900", "snippet": " 방문 길이 - lv.3문제게임 캐릭터를 4가지 명령어를 통해 움직이려 합니다. 명령어는 다음과 같습니다.U: 위쪽으로 한 칸 가기D: 아래쪽으로 한 칸 가기R: 오른쪽으로 한 칸 가기L: 왼쪽으로 한 칸 가기캐릭터는 좌표평면의 (0, 0) 위치에서 시작합니다. 좌표평면의 경계는 왼쪽 위(-5, 5), 왼쪽 아래(-5, -5), 오른쪽 위(5, 5), 오른쪽 아래(5, -5)로 이루어져 있습니다.예를 들어, ULURRDLLU로 명령했다면 1번 명령어부터 7번 명령어까지 다음과 같이 움직입니다. 8번 명령어부터 9번 명령어까지 다음과 같이 움직입니다.이때, 우리는 게임 캐릭터가 지나간 길 중 캐릭터가 처음 걸어본 길의 길이를 구하려고 합니다. 예를 들어 위의 예시에서 게임 캐릭터가 움직인 길이는 9이지만, 캐릭터가 처음 걸어본 길의 길이는 7이 됩니다. (8, 9번 명령어에서 움직인 길은 2, 3번 명령어에서 이미 거쳐 간 길입니다)단, 좌표평면의 경계를 넘어가는 명령어는 무시합니다.예를 들어, LULLLLLLU로 명령했다면 1번 명령어부터 6번 명령어대로 움직인 후, 7, 8번 명령어는 무시합니다. 다시 9번 명령어대로 움직입니다.이때 캐릭터가 처음 걸어본 길의 길이는 7이 됩니다.명령어가 매개변수 dirs로 주어질 때, 게임 캐릭터가 처음 걸어본 길의 길이를 구하여 return 하는 solution 함수를 완성해 주세요.제한사항 dirs는 string형으로 주어지며, ‘U’, ‘D’, ‘R’, ‘L’ 이외에 문자는 주어지지 않습니다. dirs의 길이는 500 이하의 자연수입니다.입출력 예 dirs return “ULURRDLLU” 7 “LULLLLLLU” 7 입출력 예 #1문제의 예시와 같습니다.입출력 예 #2문제의 예시와 같습니다.풀이 Brute Forceint solution(string dirs) { int answer = 0; int len = dirs.size(); set&amp;lt;pair&amp;lt;pair&amp;lt;int,int&amp;gt;,pair&amp;lt;int,int&amp;gt;&amp;gt;&amp;gt; path; pair&amp;lt;int, int&amp;gt; now = {0, 0}; // 현재좌표 -&amp;gt; 다음좌표 / 다음좌표 -&amp;gt; 현재좌표 // 이 두가지 경로를 저장하여 지나온길인지, 새로운길인지 판단 for(auto i = 0 ; i &amp;lt; len ; ++i){ // 다음좌표값을 구함 auto next = now; if(dirs[i] == &#39;U&#39; &amp;amp;&amp;amp; now.second+1 &amp;lt;= 5){ next = {now.first, now.second+1}; } else if(dirs[i] == &#39;D&#39; &amp;amp;&amp;amp; -5 &amp;lt;= now.second-1){ next = {now.first, now.second-1}; } else if(dirs[i] == &#39;L&#39; &amp;amp;&amp;amp; -5 &amp;lt;= now.first-1){ next = {now.first-1, now.second}; } else if(dirs[i] == &#39;R&#39; &amp;amp;&amp;amp; now.first+1 &amp;lt;= 5){ next = {now.first+1, now.second}; } // 현재좌표와 다음좌표가 같으면 좌표를 전체좌표에 벗어난 것이므로 무시 if(now == next) continue; // 현재좌표 -&amp;gt; 다음좌표 / 다음좌표 -&amp;gt; 현재좌표 // 이 두가지 경우가 모두 없다면 새로 지나온길 if(path.find({now, next}) == path.end() &amp;amp;&amp;amp; path.find({next, now}) == path.end()){ ++answer; path.insert({now, next}); path.insert({next, now}); } // 다음좌표값을 현재좌표로 저장 now = next; } return answer;}" }, { "title": "Programmers - N-Queen", "url": "/posts/ps-programmers-003/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Back Tracking", "date": "2020-02-02 20:15:00 +0900", "snippet": " N-Queen - lv.3문제가로, 세로 길이가 n인 정사각형으로된 체스판이 있습니다. 체스판 위의 n개의 퀸이 서로를 공격할 수 없도록 배치하고 싶습니다.예를 들어서 n이 4인경우 다음과 같이 퀸을 배치하면 n개의 퀸은 서로를 한번에 공격 할 수 없습니다.체스판의 가로 세로의 세로의 길이 n이 매개변수로 주어질 때, n개의 퀸이 조건에 만족 하도록 배치할 수 있는 방법의 수를 return하는 solution함수를 완성해주세요.제한사항 퀸(Queen)은 가로, 세로, 대각선으로 이동할 수 있습니다. n은 12이하의 자연수 입니다.입출력 예 n return 4 2 입출력 예 #1문제의 예시와 같습니다.풀이 Back Trackingvoid BackTracking(int&amp;amp; res, int n, vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt;&amp;amp; board, pair&amp;lt;int,int&amp;gt; point){ // 열 index가 n과 같아지면 만족하는 경우를 찾았다는 뜻 if(point.first == n){ ++res; return; } // 현재 행에서 만족하는 좌표 검사 for(auto i = 0 ; i &amp;lt; n ; ++i){ // 이전의 퀸에의해 해당 좌표가 가능한지 불가능한지 검사 if(board[point.first][i]){ auto check = board; check[point.first][i] = false; // 현재 좌표에 다음퀸이 올때, 보드에서 불가능한 부분 체크 int right = i; int left = i; for(auto y = point.first + 1 ; y &amp;lt; n ; ++y){ check[y][i] = false; if(right + 1 &amp;lt; n) check[y][++right] = false; if(0 &amp;lt;= left - 1) check[y][--left] = false; } // 퀸을 위치 시킨후 다음 행으로 이동 BackTracking(res, n, check, {point.first+1, 0}); } }}int solution(int n) { int answer = 0; vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; board(n, vector&amp;lt;bool&amp;gt;(n, true)); BackTracking(answer, n ,board, {0, 0}); return answer;}" }, { "title": "Programmers - 라면공장", "url": "/posts/ps-programmers-002/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Heap", "date": "2020-02-02 20:15:00 +0900", "snippet": " 라면공장 - lv.2문제라면 공장에서는 하루에 밀가루를 1톤씩 사용합니다. 원래 밀가루를 공급받던 공장의 고장으로 앞으로 k일 이후에야 밀가루를 공급받을 수 있기 때문에 해외 공장에서 밀가루를 수입해야 합니다.해외 공장에서는 향후 밀가루를 공급할 수 있는 날짜와 수량을 알려주었고, 라면 공장에서는 운송비를 줄이기 위해 최소한의 횟수로 밀가루를 공급받고 싶습니다.현재 공장에 남아있는 밀가루 수량 stock, 밀가루 공급 일정(dates)과 해당 시점에 공급 가능한 밀가루 수량(supplies), 원래 공장으로부터 공급받을 수 있는 시점 k가 주어질 때, 밀가루가 떨어지지 않고 공장을 운영하기 위해서 최소한 몇 번 해외 공장으로부터 밀가루를 공급받아야 하는지를 return 하도록 solution 함수를 완성하세요.dates[i]에는 i번째 공급 가능일이 들어있으며, supplies[i]에는 dates[i] 날짜에 공급 가능한 밀가루 수량이 들어 있습니다.제한사항 stock에 있는 밀가루는 오늘(0일 이후)부터 사용됩니다. stock과 k는 2 이상 100,000 이하입니다. dates의 각 원소는 1 이상 k 이하입니다. supplies의 각 원소는 1 이상 1,000 이하입니다. dates와 supplies의 길이는 1 이상 20,000 이하입니다. k일 째에는 밀가루가 충분히 공급되기 때문에 k-1일에 사용할 수량까지만 확보하면 됩니다. dates에 들어있는 날짜는 오름차순 정렬되어 있습니다. dates에 들어있는 날짜에 공급되는 밀가루는 작업 시작 전 새벽에 공급되는 것을 기준으로 합니다. 예를 들어 9일째에 밀가루가 바닥나더라도, 10일째에 공급받으면 10일째에는 공장을 운영할 수 있습니다. 밀가루가 바닥나는 경우는 주어지지 않습니다.입출력 예 stock dates supplies k return 4 [4,10,15] [20,5,10] 30 2 입출력 예 #1 - 현재 밀가루가 4톤 남아 있기 때문에 오늘과 1일 후~3일 후까지 사용하고 나면 모든 밀가루를 다 사용합니다. 따라서 4일 후에는 반드시 밀가루를 공급받아야 합니다. - 4일째 공급받고 나면 15일 이후 아침에는 9톤의 밀가루가 남아있게 되고, 이때 10톤을 더 공급받으면 19톤이 남아있게 됩니다. 15일 이후부터 29일 이후까지 필요한 밀가루는 15톤이므로 더 이상의 공급은 필요 없습니다. - 따라서 총 2회의 밀가루를 공급받으면 됩니다.풀이 Heapint solution(int stock, vector&amp;lt;int&amp;gt; dates, vector&amp;lt;int&amp;gt; supplies, int k) { int answer = 0; int index = 0; priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, less&amp;lt;int&amp;gt;&amp;gt; pq; // 하루씩 k일 까지 날짜를 증가시킴 // heap을 통해, 보급받은 수량이 가장 큰 것을 선택해 나감 for(auto day = 0 ; day &amp;lt; k ; ++day){ // 현재 날짜가 dates[index]의 날짜와 같다면 // heap에 해당 날짜의 공급량을 저장하며 index를 하나 증가 if(dates[index] == day){ pq.push(supplies[index]); ++index; } // 현재 남아있는 수량이 바닥나면, // heap에 저장되어 있는 최대 수량만큼 채움고, // 보급받은 횟수 +1 if(stock == 0){ stock = pq.top(); pq.pop(); ++answer; } --stock; } return answer;}" }, { "title": "Programmers - 길 찾기 게임", "url": "/posts/ps-programmers-001/", "categories": "Problem Solving, Programmers", "tags": "PS, Programmers, Tree", "date": "2020-02-02 20:15:00 +0900", "snippet": " 길 찾기 게임 - lv.3문제전무로 승진한 라이언은 기분이 너무 좋아 프렌즈를 이끌고 특별 휴가를 가기로 했다. 내친김에 여행 계획까지 구상하던 라이언은 재미있는 게임을 생각해냈고 역시 전무로 승진할만한 인재라고 스스로에게 감탄했다.라이언이 구상한(그리고 아마도 라이언만 즐거울만한) 게임은, 카카오 프렌즈를 두 팀으로 나누고, 각 팀이 같은 곳을 다른 순서로 방문하도록 해서 먼저 순회를 마친 팀이 승리하는 것이다.그냥 지도를 주고 게임을 시작하면 재미가 덜해지므로, 라이언은 방문할 곳의 2차원 좌표 값을 구하고 각 장소를 이진트리의 노드가 되도록 구성한 후, 순회 방법을 힌트로 주어 각 팀이 스스로 경로를 찾도록 할 계획이다.라이언은 아래와 같은 특별한 규칙으로 트리 노드들을 구성한다. 트리를 구성하는 모든 노드의 x, y 좌표 값은 정수이다. 모든 노드는 서로 다른 x값을 가진다. 같은 레벨(level)에 있는 노드는 같은 y 좌표를 가진다. 자식 노드의 y 값은 항상 부모 노드보다 작다. 임의의 노드 V의 왼쪽 서브 트리(left subtree)에 있는 모든 노드의 x값은 V의 x값보다 작다. 임의의 노드 V의 오른쪽 서브 트리(right subtree)에 있는 모든 노드의 x값은 V의 x값보다 크다.아래 예시를 확인해보자.라이언의 규칙에 맞게 이진트리의 노드만 좌표 평면에 그리면 다음과 같다. (이진트리의 각 노드에는 1부터 N까지 순서대로 번호가 붙어있다.)이제, 노드를 잇는 간선(edge)을 모두 그리면 아래와 같은 모양이 된다.위 이진트리에서 전위 순회(preorder), 후위 순회(postorder)를 한 결과는 다음과 같고, 이것은 각 팀이 방문해야 할 순서를 의미한다. 전위 순회 : 7, 4, 6, 9, 1, 8, 5, 2, 3 후위 순회 : 9, 6, 5, 8, 1, 4, 3, 2, 7다행히 두 팀 모두 머리를 모아 분석한 끝에 라이언의 의도를 간신히 알아차렸다.그러나 여전히 문제는 남아있다. 노드의 수가 예시처럼 적다면 쉽게 해결할 수 있겠지만, 예상대로 라이언은 그렇게 할 생각이 전혀 없었다.이제 당신이 나설 때가 되었다.곤경에 빠진 카카오 프렌즈를 위해 이진트리를 구성하는 노드들의 좌표가 담긴 배열 nodeinfo가 매개변수로 주어질 때, 노드들로 구성된 이진트리를 전위 순회, 후위 순회한 결과를 2차원 배열에 순서대로 담아 return 하도록 solution 함수를 완성하자.제한사항 nodeinfo는 이진트리를 구성하는 각 노드의 좌표가 1번 노드부터 순서대로 들어있는 2차원 배열이다. nodeinfo의 길이는 1 이상 10,000 이하이다. nodeinfo[i] 는 i + 1번 노드의 좌표이며, [x축 좌표, y축 좌표] 순으로 들어있다. 모든 노드의 좌표 값은 0 이상 100,000 이하인 정수이다. 트리의 깊이가 1,000 이하인 경우만 입력으로 주어진다. 모든 노드의 좌표는 문제에 주어진 규칙을 따르며, 잘못된 노드 위치가 주어지는 경우는 없다. 입출력 예 nodeinfo return [[5,3],[11,5],[13,3],[3,5],[6,1],[1,3],[8,6],[7,2],[2,2]] [[7,4,6,9,1,8,5,2,3],[9,6,5,8,1,4,3,2,7]] 풀이1 Treeclass TreeNode{ friend class Tree;public: TreeNode(int val = 0, int x = 0, int y = 0, TreeNode* left = nullptr, TreeNode* right = nullptr) : val(val), x(x), y(y), left(left), right(right) {} private: int val; int x, y; TreeNode* left; TreeNode* right;};class Tree{public: Tree(int data = 0, int x = 0, int y = 0) : root(new TreeNode(data, x, y)) {} void insert(TreeNode* node){ TreeNode* parentNode = nullptr; TreeNode* currentNode = root; // 삽입할 노드의 부모노드를 찾기위해, // 현재가리키는 노드가 리프노드가 될때 까지 검사 while (currentNode != nullptr) { parentNode = currentNode; // 삽입할 노드의 x좌표가 현재 가리키는 부모노드 보다 작으면 left // 삽입할 노드의 x좌표가 현재 가리키는 부모노드 보다 크면 right if (node-&amp;gt;x &amp;lt; parentNode-&amp;gt;x) currentNode = currentNode-&amp;gt;left; else currentNode = currentNode-&amp;gt;right; } // 부모노드를 찾았으므로 조건을 검사하여 left, right위치에 삽입 if (node-&amp;gt;x &amp;lt; parentNode-&amp;gt;x) parentNode-&amp;gt;left = node; else parentNode-&amp;gt;right = node; } // PreOrder 조회 void preOrder(vector&amp;lt;int&amp;gt;&amp;amp; ans, const TreeNode* const node){ if(node == nullptr) return; ans.push_back(node-&amp;gt;val); preOrder(ans, node-&amp;gt;left); preOrder(ans, node-&amp;gt;right); } // PostOrder 조회 void postOrder(vector&amp;lt;int&amp;gt;&amp;amp; ans, const TreeNode* const node){ if(node == nullptr) return; postOrder(ans, node-&amp;gt;left); postOrder(ans, node-&amp;gt;right); ans.push_back(node-&amp;gt;val); } const TreeNode* getRoot() const { return root; } private: TreeNode* root;};bool comp(vector&amp;lt;int&amp;gt;&amp;amp; a, vector&amp;lt;int&amp;gt;&amp;amp; b){ if(a[1] == b[1]) return a[0] &amp;lt; b[0]; return a[1] &amp;gt; b[1];}vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; solution(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; nodeinfo) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; answer(2); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; item; // 각 노드의 번호 삽입 for(auto i = 0 ; i &amp;lt; nodeinfo.size() ; ++i) item.push_back({nodeinfo[i][0], nodeinfo[i][1], i+1}); // 좌표순으로 정렬 sort(item.begin(), item.end(), comp); // 트리에 삽입 Tree tree(item[0][2], item[0][0], item[0][1]); for(auto i = 1 ; i &amp;lt; item.size() ; ++i){ tree.insert(new TreeNode(item[i][2], item[i][0], item[i][1])); } // 조회 tree.preOrder(answer[0], tree.getRoot()); tree.postOrder(answer[1], tree.getRoot()); return answer;}" }, { "title": "Backjoon - 2798. 블랙잭", "url": "/posts/ps-backjoon-2798/", "categories": "Problem Solving, Backjoon", "tags": "PS, Backjoon, Brute Force", "date": "2020-02-02 08:40:00 +0900", "snippet": " 2798. 블랙잭 문제카지노에서 제일 인기 있는 게임 블랙잭의 규칙은 상당히 쉽다. 카드의 합이 21을 넘지 않는 한도 내에서, 카드의 합을 최대한 크게 만드는 게임이다. 블랙잭은 카지노마다 다양한 규정이 있다.한국 최고의 블랙잭 고수 김정인은 새로운 블랙잭 규칙을 만들어 상근, 창영이와 게임하려고 한다.김정인 버젼의 블랙잭에서 각 카드에는 양의 정수가 쓰여 있다. 그 다음, 딜러는 N장의 카드를 모두 숫자가 보이도록 바닥에 놓는다. 그런 후에 딜러는 숫자 M을 크게 외친다.이제 플레이어는 제한된 시간 안에 N장의 카드 중에서 3장의 카드를 골라야 한다. 블랙잭 변형 게임이기 때문에, 플레이어가 고른 카드의 합은 M을 넘지 않으면서 M과 최대한 가깝게 만들어야 한다.N장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 출력하시오.입력첫째 줄에 카드의 개수 N(3 ≤ N ≤ 100)과 M(10 ≤ M ≤ 300,000)이 주어진다. 둘째 줄에는 카드에 쓰여 있는 수가 주어지며, 이 값은 100,000을 넘지 않는다.합이 M을 넘지 않는 카드 3장을 찾을 수 있는 경우만 입력으로 주어진다.입출력 예예제 입력 15 215 6 7 8 9예제 출력 121풀이 BruteForceint main(){ int N = 0, M = 0; std::cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M; std::vector&amp;lt;int&amp;gt; card; for(auto i = 0 ; i &amp;lt; N ; ++i){ int temp = 0 ; std::cin &amp;gt;&amp;gt; temp; card.push_back(temp); } int max = 0; for(auto i = card.begin() ; i != card.end() - 2 ; ++i){ for(auto j = i+1 ; j != card.end() - 1 ; ++j){ for(auto k = j+1 ; k != card.end() ; ++k){ int sum = *i + *j + *k; if(max &amp;lt; sum &amp;amp;&amp;amp; sum &amp;lt;= M) max = sum; } } } std::cout &amp;lt;&amp;lt; max &amp;lt;&amp;lt; &#39;\\n&#39;;}" }, { "title": "Backjoon - 2164. 카드2", "url": "/posts/ps-backjoon-2164/", "categories": "Problem Solving, Backjoon", "tags": "PS, Backjoon, Queue", "date": "2020-02-02 08:40:00 +0900", "snippet": " 2164. 카드2 문제N장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.예를 들어 N=4인 경우를 생각해 보자. 카드는 제일 위에서부터 1234 의 순서로 놓여있다. 1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. 마지막으로 2를 버리고 나면, 남는 카드는 4가 된다.N이 주어졌을 때, 제일 마지막에 남게 되는 카드를 구하는 프로그램을 작성하시오.입력첫째 줄에 정수 N(1≤N≤500,000)이 주어진다.입출력 예예제 입력 16예제 출력 14풀이 Queueint main(){ int N = 0; std::cin &amp;gt;&amp;gt; N; std::queue&amp;lt;int&amp;gt; q; for(auto i = 1 ; i &amp;lt;= N ; ++i) q.push(i); while(q.size() != 1){ q.pop(); q.push(q.front()); q.pop(); } std::cout &amp;lt;&amp;lt; q.front() &amp;lt;&amp;lt; &#39;\\n&#39;;}" }, { "title": "Backjoon - 1712. 손익분기점", "url": "/posts/ps-backjoon-1712/", "categories": "Problem Solving, Backjoon", "tags": "PS, Backjoon, Math", "date": "2020-02-02 08:40:00 +0900", "snippet": " 1712. 손익분기점 문제월드전자는 노트북을 제조하고 판매하는 회사이다. 노트북 판매 대수에 상관없이 매년 임대료, 재산세, 보험료, 급여 등 A만원의 고정 비용이 들며, 한 대의 노트북을 생산하는 데에는 재료비와 인건비 등 총 B만원의 가변 비용이 든다고 한다.예를 들어 A=1,000, B=70이라고 하자. 이 경우 노트북을 한 대 생산하는 데는 총 1,070만원이 들며, 열 대 생산하는 데는 총 1,700만원이 든다.노트북 가격이 C만원으로 책정되었다고 한다. 일반적으로 생산 대수를 늘려 가다 보면 어느 순간 총 수입(판매비용)이 총 비용(=고정비용+가변비용)보다 많아지게 된다. 최초로 총 수입이 총 비용보다 많아져 이익이 발생하는 지점을 손익분기점(BREAK-EVEN POINT)이라고 한다.A, B, C가 주어졌을 때, 손익분기점을 구하는 프로그램을 작성하시오.입력첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. A, B, C는 21억 이하의 자연수이다.입출력 예예제 입력 11000 70 170예제 출력 111풀이 Mathint main(){ double A = 0, B = 0, C = 0; std::cin &amp;gt;&amp;gt; A &amp;gt;&amp;gt; B &amp;gt;&amp;gt; C; if(B &amp;gt;= C) std::cout &amp;lt;&amp;lt; &quot;-1&quot; &amp;lt;&amp;lt; &#39;\\n&#39;; else printf(&quot;%.0lf&quot;, floor(A/(C-B)) + 1);}" }, { "title": "Backjoon - 1476. 날짜 계산", "url": "/posts/ps-backjoon-1476/", "categories": "Problem Solving, Backjoon", "tags": "PS, Backjoon, Brute Force", "date": "2020-02-02 08:40:00 +0900", "snippet": " 1476. 날짜 계산 문제준규가 사는 나라는 우리가 사용하는 연도와 다른 방식을 이용한다. 준규가 사는 나라에서는 수 3개를 이용해서 연도를 나타낸다. 각각의 수는 지구, 태양, 그리고 달을 나타낸다.지구를 나타내는 수를 E, 태양을 나타내는 수를 S, 달을 나타내는 수를 M이라고 했을 때, 이 세 수는 서로 다른 범위를 가진다. (1 ≤ E ≤ 15, 1 ≤ S ≤ 28, 1 ≤ M ≤ 19)우리가 알고있는 1년은 준규가 살고있는 나라에서는 1 1 1로 나타낼 수 있다. 1년이 지날 때마다, 세 수는 모두 1씩 증가한다. 만약, 어떤 수가 범위를 넘어가는 경우에는 1이 된다.예를 들어, 15년은 15 15 15로 나타낼 수 있다. 하지만, 1년이 지나서 16년이 되면 16 16 16이 아니라 1 16 16이 된다. 이유는 1 ≤ E ≤ 15 라서 범위를 넘어가기 때문이다.E, S, M이 주어졌고, 1년이 준규가 사는 나라에서 1 1 1일때, 준규가 사는 나라에서 E S M이 우리가 알고 있는 연도로 몇 년인지 구하는 프로그램을 작성하시오.입력첫째 줄에 세 수 E, S, M이 주어진다. 문제에 나와있는 범위를 지키는 입력만 주어진다.입출력 예예제 입력 11 16 16예제 출력 116예제 입력 21 1 1예제 출력 21예제 입력 31 2 3예제 출력 35266예제 입력 415 28 19예제 출력 47980풀이 Brute Forceif __name__==&#39;__main__&#39; : E,S,M = map(int,raw_input().split(&#39; &#39;)) x = 1 while True : if (x-E)%15 == 0 and (x-S)%28 == 0 and (x-M)%19 == 0 : break x += 1 print(x)" }, { "title": "Backjoon - 13418. 학교 탐방하기", "url": "/posts/ps-backjoon-13418/", "categories": "Problem Solving, Backjoon", "tags": "PS, Backjoon, Greedy, MST, Kruskal", "date": "2020-02-02 08:40:00 +0900", "snippet": " 13418. 학교 탐방하기 문제국민대학교 홍보대사 국희는 여름방학을 맞아 고등학생들을 대상으로 학교 내부에 있는 건물을 소개해주는 일을 하게 되어 학교 건물을 차례로 소개할 수 있는 이동 경로를 짜보기로 하였다. 국민대학교는 북한산의 정기를 받는 위치에 있어 건물 간 연결된 길이 험난한 오르막길일 수도 있고, 내리막길일 수도 있다. 국희는 먼저 입구를 기준으로 건물 간 연결된 도로가 오르막길인지, 내리막길인지를 파악하여 오르막길인 경우 점선, 내리막길인 경우 실선으로 표시하였다.건물을 구분하기 쉽도록 번호를 붙였고, 입구에는 숫자 0을 붙이기로 하였다. 그 다음 모든 건물을 방문하는 데 필요한 최소한의 길을 선택하여, 해당 길을 통해서만 건물들을 소개하기로 하였다. 이 과정은 굉장히 신중해야 하는데, 오르막길이 많이 포함되게 되면 굉장히 피곤해지기 때문이다.얼마나 피곤해지는지 알아보기 위해 피로도를 계산하기로 하였다. 오르막길을 k번 오를 때, 피로도는 k2이 된다. 피로도의 계산은 최초 조사된 길을 기준으로만 한다. 즉, 내리막길로 내려갔다 다시 올라올 때 오르막길이 되는 경우는 고려하지 않는다. 입구는 항상 1번 건물과 연결된 도로를 가지며, 출발은 항상 입구에서 한다.그림 1에서 모든 건물을 소개하기 위해 거쳐야 할 최소한의 도로는 4개임을 알 수 있다. 다음 2개의 그림은 그 4개의 도로를 뽑은 각각의 경우이다. 그림 2는 학교를 소개하는 데 총 3개의 오르막길을 오르게 되며 피로도가 9가 되는 최악의 코스가 된다. 그림 3은 오르막길을 1번만 오르게 되므로 학생들의 피로도는 1이 되는 최적의 코스가 된다. 이 경우 최악의 코스와 최적의 코스간 최종 피로도의 차이는 8이 된다. 국희는 최고의 프로그래머인 당신에게 위와 같은 방식으로 최악, 최선의 경로 간 피로도의 차이를 계산하는 프로그램의 제작을 부탁하였다. 프로그램을 작성하여 국희를 도와주자.입력입력 데이터는 표준 입력을 사용한다. 입력은 1개의 테스트 데이터로 구성된다. 입력의 첫 번째 줄에는 건물의 개수 N(1≤N≤1,000)과 도로의 개수 M(1≤M≤n*(n-1)/2) 이 주어진다. 입력의 두 번째 줄부터 M+1개의 줄에는 A, B(1≤ A,B ≤ N), C 가 주어진다. 이는 A와 B 건물에 연결된 도로가 있다는 뜻이며, C는 0(오르막길) 또는 1(내리막길)의 값을 가진다. 같은 경로 상에 2개 이상의 도로가 주어지는 경우는 없으며, 입구는 항상 1번 건물과 연결되어 있다. 입구와 1번 도로 간의 연결 관계는 항상 2번째 줄에 주어진다. 입구에서 모든 건물로 갈 수 있음이 보장된다.입출력 예#예제 입력 1 4 50 1 11 2 01 4 04 2 13 4 12 3 0#예제 출력 1 8풀이 Greedy, MST, Kruskalbool comp(vector&amp;lt;int&amp;gt;&amp;amp; a, vector&amp;lt;int&amp;gt;&amp;amp; b){ return a[2] &amp;lt; b[2];}// 해당 그래프의 root 찾기 int findRoot(vector&amp;lt;int&amp;gt;&amp;amp; root, int node){ if(root[node] == node) return node; return root[node] = findRoot(root, root[node]);}// 더 작은 root index로 합치기void mergeRoot(vector&amp;lt;int&amp;gt;&amp;amp; root, int a, int b){ a = findRoot(root, a); b = findRoot(root, b); int max = a &amp;gt; b ? a : b; int min = a &amp;lt;= b ? a : b; root[max] = min;}// kruskal 알고리즘 을 통해 Minimum Spanning Tree를 구함int solution(const int v, const int e, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; edge) { int maxVal = 0, minVal = 0; vector&amp;lt;int&amp;gt; root(v+1, 0); sort(edge.begin(), edge.end(), comp); for(auto i = 0 ; i &amp;lt;= v ; ++i) root[i] = i; for(auto iter = edge.begin() ; iter != edge.end() ; ++iter){ int strat = findRoot(root, (*iter)[0]); int end = findRoot(root, (*iter)[1]); if(strat != end){ root[end] = strat; minVal += (*iter)[2]; } } for(auto i = 0 ; i &amp;lt;= v ; ++i) root[i] = i; for(auto iter = edge.rbegin() ; iter != edge.rend() ; ++iter){ int strat = findRoot(root, (*iter)[0]); int end = findRoot(root, (*iter)[1]); if(strat != end){ root[end] = strat; maxVal += (*iter)[2]; } } return (maxVal*maxVal) - (minVal*minVal);}int main(int argc, char* argv[]) { int V = 0, E = 0; cin &amp;gt;&amp;gt; V &amp;gt;&amp;gt; E; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; edge; for(auto i = 0 ; i &amp;lt;= E ; ++i){ int s = 0, e = 0, v = 0; cin &amp;gt;&amp;gt; s &amp;gt;&amp;gt; e &amp;gt;&amp;gt; v; // 이해하기 쉽도록 // 내리막길을 0, 오르막길을 1로 바꿈 v = v ? 0 : 1; edge.push_back({s, e, v}); } std::cout &amp;lt;&amp;lt; solution(V, E, edge) &amp;lt;&amp;lt; std::endl; return 0;}" }, { "title": "Backjoon - 1197. 최소 스패닝 트리", "url": "/posts/ps-backjoon-1197/", "categories": "Problem Solving, Backjoon", "tags": "PS, Backjoon, Greedy, MST, Kruskal", "date": "2020-02-02 08:40:00 +0900", "snippet": " 1197. 최소 스패닝 트리 문제그래프가 주어졌을 때, 그 그래프의 최소 스패닝 트리를 구하는 프로그램을 작성하시오.최소 스패닝 트리는, 주어진 그래프의 모든 정점들을 연결하는 부분 그래프 중에서 그 가중치의 합이 최소인 트리를 말한다.입력첫째 줄에 정점의 개수 V(1 ≤ V ≤ 10,000)와 간선의 개수 E(1 ≤ E ≤ 100,000)가 주어진다. 다음 E개의 줄에는 각 간선에 대한 정보를 나타내는 세 정수 A, B, C가 주어진다. 이는 A번 정점과 B번 정점이 가중치 C인 간선으로 연결되어 있다는 의미이다. C는 음수일 수도 있으며, 절댓값이 1,000,000을 넘지 않는다.최소 스패닝 트리의 가중치가 -2147483648보다 크거나 같고, 2147483647보다 작거나 같은 데이터만 입력으로 주어진다.입출력 예예제 입력 1 3 31 2 12 3 21 3 3예제 출력 1 3풀이 Greedy, MST, Kruskalbool comp(const vector&amp;lt;int&amp;gt;&amp;amp; a, const vector&amp;lt;int&amp;gt;&amp;amp; b){ return a[2] &amp;lt; b[2];}// 해당 그래프의 root 찾기 int findRoot(vector&amp;lt;int&amp;gt;&amp;amp; root, int node){ if(root[node] == node) return node; root[node] = findRoot(root, root[node]); return root[node];}// kruskal 알고리즘 을 통해 Minimum Spanning Tree를 구함int solution(const int v, const int e, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; edge) { int answer = 0; vector&amp;lt;int&amp;gt; root(v+1, 0); for(auto i = 0 ; i &amp;lt;= v ; ++i) root[i] = i; sort(edge.begin(), edge.end(), comp); for(auto&amp;amp; item : edge){ int a = findRoot(root, item[0]); int b = findRoot(root, item[1]); if(a != b){ root[b] = a; answer += item[2]; } } return answer;}" }, { "title": "algospot - 출전 순서 정하기", "url": "/posts/ps-algospot-004/", "categories": "Problem Solving, Algospot", "tags": "PS, AlgoSpot, Greedy", "date": "2020-02-02 08:15:00 +0900", "snippet": " 출전 순서 정하기 - 하문제전세계 최대의 프로그래밍 대회 알고스팟 컵의 결승전이 이틀 앞으로 다가왔습니다. 각 팀은 n명씩의 프로 코더들로 구성되어 있으며, 결승전에서는 각 선수가 한 번씩 출전해 1:1 경기를 벌여 더 많은 승리를 가져가는 팀이 최종적으로 우승하게 됩니다. 각 팀의 감독은 대회 전날, 주최측에 각 선수를 출전시킬 순서를 알려 주어야 합니다.결승전 이틀 전, 한국팀의 유감독은 첩보를 통해 상대 러시아팀의 출전 순서를 알아냈습니다. 이 대회에서는 각 선수의 실력을 레이팅(rating)으로 표현합니다. 문제를 간단히 하기 위해 1:1 승부에서는 항상 레이팅이 더 높은 선수가 승리하고, 레이팅이 같을 경우 우리 선수가 승리한다고 가정합시다. 경기 1 2 3 4 5 6 러시아팀 3,000 2,700 2,800 2,200 2,500 1,900 한국팀 2,800 2,750 2,995 1,800 2,600 2,000 표와 같이 출전 순서를 정했다고 하면 한국팀은 2번, 3번, 5번, 6번 경기에서 승리해 전체 네 경기를 이기게 됩니다. 그러나 대신 4번 경기와 1번 경기에 나갈 선수를 바꾸면 1번 경기만을 제외하고 모든 경기에 승리할 수 있지요. 상대방 팀 선수들의 순서를 알고 있을 때, 어느 순서대로 선수들을 내보내야 승수를 최대화할 수 있을까요?입력입력의 첫 줄에는 테스트 케이스의 수 C (C≤50)가 주어집니다. 각 테스트 케이스의 첫 줄에는 각 팀 선수의 수 N(1≤N≤100)가 주어집니다. 그 다음 줄에는 N개의 정수로 러시아팀 각 선수의 레이팅이 출전 순서대로 주어지며, 그 다음 줄에는 N개의 정수로 한국팀 각 선수의 레이팅이 무순으로 주어집니다. 모든 레이팅은 1 이상 4000 이하의 정수입니다.입출력 예363000 2700 2800 2200 2500 19002800 2750 2995 1800 2600 200031 2 33 2 142 3 4 51 2 3 4풀이 Greedyint solution(int n, std::vector&amp;lt;int&amp;gt;&amp;amp; enermy, std::vector&amp;lt;int&amp;gt;&amp;amp; korea){ unsigned int count = 0; unsigned int korPlayer = 0, enrPlayer = 0; std::sort(enermy.begin(), enermy.end(), std::greater&amp;lt;int&amp;gt;()); std::sort(korea.begin(), korea.end(), std::greater&amp;lt;int&amp;gt;()); while(korPlayer &amp;lt; korea.size() &amp;amp;&amp;amp; enrPlayer &amp;lt; enermy.size()){ if(korea[korPlayer] &amp;lt; enermy[enrPlayer]){ ++enrPlayer; } else{ ++korPlayer; ++enrPlayer; ++count; } } return count;}" }, { "title": "algospot - Microwaving Lunch Boxes", "url": "/posts/ps-algospot-003/", "categories": "Problem Solving, Algospot", "tags": "PS, AlgoSpot, Greedy", "date": "2020-02-02 08:15:00 +0900", "snippet": " Microwaving Lunch Boxes - 하문제After suffering from the deficit in summer camp, Ainu7 decided to supply lunch boxes instead of eating outside for Algospot.com winter camp.He contacted the famous packed lunch company “Doosot” to prepare N lunch boxes for N participants. Due to the massive amount of order, Doosot was not able to prepare the same menu. Instead, they provided different N lunch boxes. Ainu7 put all the lunch boxes to a refrigerator.The lunch time has come, and suddenly Ainu7 noticed that there is only one microwave available. As all lunch boxes are not the same, they need a different amount of time to microwave and eat. Specifically, i-th lunch box needs Mi seconds to microwave and Ei seconds to eat.Ainu7 needs to schedule microwave usage order to minimize lunch time. Lunch time is defined as the duration from the beginning of microwaving of any lunch box to the end of eating for all participants. Write a computer program that finds minimum lunch time to help Ainu7. Note that substituting lunch while microwave is turned on is totally unnecessary, because the lunch will be cooled down.입력The first line of the input contains one integer T, the number of test cases.Each test case consists of three lines. The first line of each test case contains N(1≤N≤10000), the number of the participants.N integers will follow on the second line. They represent M1, M2, ⋯, MN.Similarly, N integers will follow on the third line, representing E1, E2, ⋯, EN입출력 예// Input232 2 22 2 231 2 31 2 1// Output87풀이 Greedybool comp(std::pair&amp;lt;int,int&amp;gt;&amp;amp; a, std::pair&amp;lt;int,int&amp;gt;&amp;amp; b){ return a.first &amp;gt; b.first;}int solution(int n, std::vector&amp;lt;int&amp;gt;&amp;amp; heating, std::vector&amp;lt;int&amp;gt;&amp;amp; eating){ unsigned int time = 0, vecSize = heating.size(); std::vector&amp;lt;std::pair&amp;lt;int,int&amp;gt;&amp;gt; sch; std::vector&amp;lt;int&amp;gt; reaminEat(eating); for(auto i = 0 ; i &amp;lt; vecSize ; ++i){ sch.push_back(std::make_pair(eating[i], heating[i])); } std::sort(sch.begin(), sch.end(), comp); for(auto i = 0; i &amp;lt; vecSize ; ++i){ time += sch[i].second; int sum = 0; for(auto j = i+1 ; j &amp;lt; vecSize ; ++j){ sum += sch[j].second; } int remainTime = sch[i].first - sum; reaminEat[i] = remainTime &amp;lt;= 0 ? 0 : remainTime; } return time + *std::max_element(reaminEat.begin(), reaminEat.end());}" }, { "title": "algospot - 문자열 합치기", "url": "/posts/ps-algospot-002/", "categories": "Problem Solving, Algospot", "tags": "PS, AlgoSpot, Greedy", "date": "2020-02-02 08:15:00 +0900", "snippet": " 문자열 합치기 - 중문제프로그래밍 언어 C 의 큰 문제점 중 하나는 언어 차원에서 문자열 변수형을 지원하지 않는다는 것입니다. C 에서는 문자 배열로 문자열을 표현하되 \\0 (NULL) 로 문자열의 끝을 지정하는데, 이래서는 문자열의 길이를 쉽게 알 수 있는 방법이 없기 때문에 여러 가지 문제가 발생하게 됩니다.void strcat(char* dest, const char* src) { // dest 의 마지막 위치를 찾는다 while(*dest) ++dest; // src 를 한 글자씩 dest 에 옮겨 붙인다 while(*src) *(dest++) = *(src++); // 문자열의 끝을 알리는 \\0 을 추가한다 *dest = 0;}이런 문제 중 하나로 문자열을 조작하는 함수들의 동작 시간이 불필요하게 커진다는 것이 있습니다. 앞에 주어진 함수 strcat() 은 문자열 dest 뒤에 src 를 붙이는 함수인데, 실행 과정에서 반복문을 두 문자열의 길이를 합한 만큼 수행해야 합니다. 이 함수를 사용해 두 개의 문자열을 합치는 비용은 두 문자열의 길이의 합이라고 합시다.이 함수를 이용해 n 개의 문자열을 순서와 상관없이 합쳐서 한 개의 문자열로 만들고 싶습니다. 순서가 상관 없다는 말은 {al,go,spot} 을 spotalgo 로 합치든 alspotgo 로 합치든 상관 없다는 의미입니다. 그러나 문자열을 합치는 순서에 따라 전체 비용이 달라질 수 있습니다. 예를 들어 먼저 al 과 go 를 합치고 (2+2=4), 이것을 spot 과 합치면 (4+4=8) 총 12 의 비용이 들지만 al 과 spot 을 합치고 (2+4=6) 이것을 다시 go 에 합치면 (6+2=8) 총 14 의 비용이 필요합니다.n 개의 문자열들의 길이가 주어질 때 필요한 최소 비용을 찾는 프로그램을 작성하세요.입력입력의 첫 줄에는 테스트 케이스의 수 c (c &amp;lt;= 50) 가 주어집니다. 각 테스트 케이스의 첫 줄에는 문자열의 수 n (1 &amp;lt;= n &amp;lt;= 100) 이 주어지며, 다음 줄에는 n 개의 정수로 각 문자열의 길이가 주어집니다. 각 문자열의 길이는 1,000 이하의 자연수입니다.입출력 예// Input332 2 453 1 3 4 181 1 1 1 1 1 1 2// Output122627풀이 Greedyint solution(int n, std::vector&amp;lt;int&amp;gt;&amp;amp; length){ int time = 0; std::sort(length.begin(), length.end()); while(length.size() &amp;gt; 2){ int sum = *length.begin() + *(length.begin()+1); time += sum; length.erase(length.begin()); length.erase(length.begin()); auto it = std::lower_bound(length.begin(), length.end() ,sum); length.insert(it, sum); } time += *length.begin() + *(length.begin()+1); return time;}" }, { "title": "algospot - 삼각형 위의 최대 경로", "url": "/posts/ps-algospot-001/", "categories": "Problem Solving, Algospot", "tags": "PS, AlgoSpot, DP", "date": "2020-02-02 08:15:00 +0900", "snippet": " 삼각형 위의 최대 경로 - 하문제61 23 7 49 4 1 72 7 5 9 4위 형태와 같이 삼각형 모양으로 배치된 자연수들이 있습니다. 맨 위의 숫자에서 시작해, 한 번에 한 칸씩 아래로 내려가 맨 아래 줄로 내려가는 경로를 만들려고 합니다. 경로는 아래 줄로 내려갈 때마다 바로 아래 숫자, 혹은 오른쪽 아래 숫자로 내려갈 수 있습니다. 이 때 모든 경로 중 포함된 숫자의 최대 합을 찾는 프로그램을 작성하세요입력입력의 첫 줄에는 테스트 케이스의 수 C(C &amp;lt;= 50)가 주어집니다. 각 테스트 케이스의 첫 줄에는 삼각형의 크기 n(2 &amp;lt;= n &amp;lt;= 100)이 주어지고, 그 후 n줄에는 각 1개~n개의 숫자로 삼각형 각 가로줄에 있는 숫자가 왼쪽부터 주어집니다. 각 숫자는 1 이상 100000 이하의 자연수입니다.입출력 예// Input2561 23 7 49 4 1 72 7 5 9 451 2 48 16 832 64 32 64128 256 128 256 128// Output28341풀이 DPint solution(const int n, const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; triangle) { auto sum = triangle; for(auto i = 0 ; i &amp;lt; n - 1 ; ++i){ for(auto j = 0 ; j &amp;lt; triangle[i].size() ; ++j){ int left = sum[i][j] + triangle[i+1][j]; int right = sum[i][j] + triangle[i+1][j+1]; if(sum[i+1][j] &amp;lt; left){ sum[i+1][j] = left; } if(sum[i+1][j+1] &amp;lt; right){ sum[i+1][j+1] = right; } } } return *max_element(sum[n-1].begin(), sum[n-1].end());}" }, { "title": "LeetCode - 700. Search in a Binary Search Tree", "url": "/posts/ps-leetcode-700/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Tree", "date": "2020-02-02 07:34:00 +0900", "snippet": " 700. Search in a Binary Search Tree - easy문제Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node’s value equals the given value. Return the subtree rooted with that node. If such node doesn’t exist, you should return NULL.For example,Given the tree: 4 / \\ 2 7 / \\ 1 3And the value to search: 2You should return this subtree: 2 / \\ 1 3In the example above, if we want to search the value 5, since there is no node with value 5, we should return NULL.Note that an empty tree is represented by NULL, therefore you would see the expected output (serialized tree format) as [], not null.제한사항입출력 예풀이 Tree/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* searchBST(TreeNode* root, int val) { while(root){ if(val == root-&amp;gt;val){ break; } else if(val &amp;lt; root-&amp;gt;val){ root = root-&amp;gt;left; } else{ root = root-&amp;gt;right; } } return root; }};" }, { "title": "LeetCode - 942. DI String Match", "url": "/posts/ps-leetcode-942/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Math", "date": "2020-02-02 07:33:00 +0900", "snippet": " 942. DI String Match - easy문제Given a string S that only contains “I” (increase) or “D” (decrease), let N = S.length.Return any permutation A of [0, 1, …, N] such that for all i = 0, …, N-1: If S[i] == “I”, then A[i] &amp;lt; A[i+1] If S[i] == “D”, then A[i] &amp;gt; A[i+1]제한사항 1 &amp;lt;= S.length &amp;lt;= 10000 S only contains characters “I” or “D”.입출력 예Example 1:Input: &quot;IDID&quot;Output: [0,4,1,3,2]Example 2:Input: &quot;III&quot;Output: [0,1,2,3]Example 3:Input: &quot;DDI&quot;Output: [3,2,0,1]풀이 Mathclass Solution {public: vector&amp;lt;int&amp;gt; diStringMatch(string S) { vector&amp;lt;int&amp;gt; item(S.size() + 1, 0); int low = 0, high = S.size(); for(auto i = 0 ; i &amp;lt; S.size() ; ++i){ if(S[i] == &#39;I&#39;){ item[i] = low++; } else{ item[i] = high--; } } item[S.size()] = low; return item; }};" }, { "title": "LeetCode - 94. Binary Tree Inorder Traversal", "url": "/posts/ps-leetcode-94/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Tree, Recursive", "date": "2020-02-02 07:33:00 +0900", "snippet": " 94. Binary Tree Inorder Traversal - medium문제Given a binary tree, return the inorder traversal of its nodes’ values.Example:Input: [1,null,2,3] 1 \\ 2 / 3Output: [1,3,2]제한사항입출력 예풀이 Tree, Recursive/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: // PreOrder : root -&amp;gt; left -&amp;gt; right void preOrder(vector&amp;lt;int&amp;gt;&amp;amp; answer, TreeNode* node){ if(node == nullptr) return; answer.push_back(node-&amp;gt;val); preOrder(answer, node-&amp;gt;left); preOrder(answer, node-&amp;gt;right); } // InOrder : left -&amp;gt; root -&amp;gt; right void inOrder(vector&amp;lt;int&amp;gt;&amp;amp; answer, TreeNode* node){ if(node == nullptr) return; inOrder(answer, node-&amp;gt;left); answer.push_back(node-&amp;gt;val); inOrder(answer, node-&amp;gt;right); } // PostOrder : left -&amp;gt; right -&amp;gt; root void postOrder(vector&amp;lt;int&amp;gt;&amp;amp; answer, TreeNode* node){ if(node == nullptr) return; postOrder(answer, node-&amp;gt;left); postOrder(answer, node-&amp;gt;right); answer.push_back(node-&amp;gt;val); } vector&amp;lt;int&amp;gt; inorderTraversal(TreeNode* root) { vector&amp;lt;int&amp;gt; answer; inOrder(answer, root); return answer; }};" }, { "title": "LeetCode - 78. Subsets", "url": "/posts/ps-leetcode-78/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Recursive, Bit Manipulate", "date": "2020-02-02 07:33:00 +0900", "snippet": " 78. Subsets - medium문제Given a set of distinct integers, nums, return all possible subsets (the power set).Note: The solution set must not contain duplicate subsets.제한사항입출력 예Input: nums = [1,2,3]Output:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []]풀이 Recursive, Bit Manipulateclass Solution {public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsets(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; answer; int max = 1 &amp;lt;&amp;lt; (nums.size()); for(auto i = 0 ; i &amp;lt; max ; ++i){ vector&amp;lt;int&amp;gt; sub; for(auto j = 0 ; j &amp;lt; nums.size() ; ++j){ if(i &amp;amp; (1 &amp;lt;&amp;lt; j)) sub.push_back(nums[j]); } answer.push_back(sub); } return answer; }};" }, { "title": "LeetCode - 746. Min Cost Climbing Stairs", "url": "/posts/ps-leetcode-746/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, DP", "date": "2020-02-02 07:33:00 +0900", "snippet": " 746. Min Cost Climbing Stairs - easy문제On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.제한사항 cost will have a length in the range [2, 1000]. Every cost[i] will be an integer in the range [0, 999]입출력 예Example 1:Input: cost = [10, 15, 20]Output: 15Explanation: Cheapest is start on cost[1], pay that cost and go to the top.Example 2:Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]Output: 6Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3]. 풀이 DP class Solution {public: int minCostClimbingStairs(vector&amp;lt;int&amp;gt;&amp;amp; cost) { vector&amp;lt;int&amp;gt; result(cost.size(), 0); int len = cost.size(); result[0] = cost[0]; result[1] = cost[1]; for(auto i = 2 ; i &amp;lt; len ; ++i){ result[i] = min(cost[i] + result[i-1], cost[i] + result[i-2]); } return result[len-1] &amp;lt; result[len-2] ? result[len-1] : result[len-2]; }};" }, { "title": "LeetCode - 64. Minimum Path Sum", "url": "/posts/ps-leetcode-64/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, DP", "date": "2020-02-02 07:33:00 +0900", "snippet": " 64. Minimum Path Sum - medium문제Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.Note: You can only move either down or right at any point in time.제한사항입출력 예Input:[ [1,3,1], [1,5,1], [4,2,1]]Output: 7Explanation: Because the path 1→3→1→1→1 minimizes the sum.풀이 DPclass Solution {public: int minPathSum(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { int m = grid.size(); int n = grid[0].size(); for(auto i = 0 ; i &amp;lt; m ; ++i){ for(auto j = 0 ; j &amp;lt; n ; ++j){ if(i == 0 &amp;amp;&amp;amp; j == 0) continue; // row, colum의 첫줄의 경로는 한가지 밖에 없음 if(i == 0 &amp;amp;&amp;amp; j != 0){ grid[i][j] += grid[i][j-1]; } else if(i !=0 &amp;amp;&amp;amp; j == 0){ grid[i][j] += grid[i-1][j]; } // 경로는 위 또는 왼쪽에서 밖에 올수 없으므로, // 둘중 작은 값을 선택 else{ grid[i][j] += min(grid[i][j-1], grid[i-1][j]); } } } return grid[m-1][n-1]; }};" }, { "title": "LeetCode - 62. Unique Paths", "url": "/posts/ps-leetcode-62/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, DP", "date": "2020-02-02 07:33:00 +0900", "snippet": " 62. Unique Paths - medium문제A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).How many possible unique paths are there?Above is a 7 x 3 grid. How many possible unique paths are there?제한사항 m and n will be at most 100.입출력 예Example 1:Input: m = 3, n = 2Output: 3Explanation:From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:1. Right -&amp;gt; Right -&amp;gt; Down2. Right -&amp;gt; Down -&amp;gt; Right3. Down -&amp;gt; Right -&amp;gt; RightExample 2:Input: m = 7, n = 3Output: 28풀이 DPclass Solution {public: int uniquePaths(int m, int n) { if(m == 1 || n == 1) return 1; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; item(m, vector&amp;lt;int&amp;gt;(n, 1)); for(auto i = 1 ; i &amp;lt; m ; ++i){ for(auto j = 1 ; j &amp;lt; n ; ++j){ item[i][j] = item[i-1][j] + item[i][j-1]; } } return item[m-1][n-1]; }};" }, { "title": "LeetCode - 60. Permutation Sequence", "url": "/posts/ps-leetcode-60/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, String, Recursive, BackTracking", "date": "2020-02-02 07:33:00 +0900", "snippet": " 60. Permutation Sequence - medium문제The set [1,2,3,…,n] contains a total of n! unique permutations.By listing and labeling all of the permutations in order, we get the following sequence for n = 3:1. &quot;123&quot;2. &quot;132&quot;3. &quot;213&quot;4. &quot;231&quot;5. &quot;312&quot;7. &quot;321&quot; Given n and k, return the kth permutation sequence.제한사항 Given n will be between 1 and 9 inclusive. Given k will be between 1 and n! inclusive.입출력 예Example 1:Input: n = 3, k = 3Output: &quot;213&quot;Example 2:Input: n = 4, k = 9Output: &quot;2314&quot;풀이 Recursive, BackTrackingclass Solution {public: int count = 0; bool backTracking(string&amp;amp; cur, int n, int k, vector&amp;lt;bool&amp;gt;&amp;amp; check){ // 현재 문자열 크기가 n이면 리턴이며, // count가 k가 되도록 순번을 증가시킴 // true로 리턴하여 답을 찾음을 알림 if(cur.size() == n){ ++count; if(count == k) return true; return false; } // 현재 check가 true인 것만 다음 탐색 시작 // 중간에 재귀로 true를 리턴받으면 답을 찾았다는 것이니 // 이후 계속해서 탐색할 필요가 없음 for(auto i = 1 ; i &amp;lt;= n ; ++i){ if(check[i]){ check[i] = false; cur.push_back(i + &#39;0&#39;); if(backTracking(cur, n, k, check)) return true; check[i] = true; cur.pop_back(); } } return false; } string getPermutation(int n, int k) { string answer; vector&amp;lt;bool&amp;gt; check(n+1, true); backTracking(answer, n, k, check); return answer; }};" }, { "title": "LeetCode - 590. N-ary Tree Postorder Traversal", "url": "/posts/ps-leetcode-590/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Tree", "date": "2020-02-02 07:33:00 +0900", "snippet": " 590. N-ary Tree Postorder Traversal - easy문제Given an n-ary tree, return the postorder traversal of its nodes’ values.Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).제한사항 The height of the n-ary tree is less than or equal to 1000 The total number of nodes is between [0, 10^4]입출력 예Input: root = [1,null,3,2,4,null,5,6]Output: [5,6,3,2,4,1]Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]Output: [2,6,14,11,7,3,12,8,4,13,9,10,5,1]풀이 Tree/*// Definition for a Node.class Node {public: int val; vector&amp;lt;Node*&amp;gt; children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector&amp;lt;Node*&amp;gt; _children) { val = _val; children = _children; }};*/class Solution {public: vector&amp;lt;int&amp;gt; postorder(Node* root) { if(root == nullptr) return {}; vector&amp;lt;int&amp;gt; item; for(auto i = 0 ; i &amp;lt; root-&amp;gt;children.size() ; ++i){ // 재귀로 Tree PostOrder 구현 auto temp = postorder(root-&amp;gt;children[i]); // 재귀적으로 PreOrder로 조회한 자식노드들을 현재 vector에 뒤에 붙임 item.insert(item.end(), temp.begin(), temp.end()); } // 자식 노드를 모두 조회한 후, 현재 노드 조회 item.push_back(root-&amp;gt;val); return item; }};" }, { "title": "LeetCode - 589. N-ary Tree Preorder Traversal", "url": "/posts/ps-leetcode-589/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Tree", "date": "2020-02-02 07:33:00 +0900", "snippet": " 589. N-ary Tree Preorder Traversal - easy문제Given an n-ary tree, return the preorder traversal of its nodes’ values.Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).제한사항 The height of the n-ary tree is less than or equal to 1000 The total number of nodes is between [0, 10^4]입출력 예Input: root = [1,null,3,2,4,null,5,6]Output: [1,3,5,6,2,4]Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]Output: [1,2,3,6,7,11,14,4,8,12,5,9,13,10]풀이 Tree/*// Definition for a Node.class Node {public: int val; vector&amp;lt;Node*&amp;gt; children; Node() {} Node(int _val, vector&amp;lt;Node*&amp;gt; _children) { val = _val; children = _children; }};*/class Solution {public: vector&amp;lt;int&amp;gt; preorder(Node* root) { if(root == nullptr) return {}; vector&amp;lt;int&amp;gt; item; // 자식노드 조회하기전 현재 노드 조회 item.push_back(root-&amp;gt;val); for(auto i = 0 ; i &amp;lt; root-&amp;gt;children.size() ; ++i){ // 재귀로 Tree PreOrder 구현 auto temp = preorder(root-&amp;gt;children[i]); // 재귀적으로 PreOrder로 조회한 자식노드들을 현재 vector에 뒤에 붙임 item.insert(item.end(), temp.begin(), temp.end()); } return item; }};" }, { "title": "LeetCode - 532. K-diff Pairs in an Array", "url": "/posts/ps-leetcode-532/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Hash", "date": "2020-02-02 07:33:00 +0900", "snippet": " 532. K-diff Pairs in an Array - easy문제Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.제한사항 The pairs (i, j) and (j, i) count as the same pair. The length of the array won’t exceed 10,000. All the integers in the given input belong to the range: [-1e7, 1e7].입출력 예Example 1:Input: [3, 1, 4, 1, 5], k = 2Output: 2Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs.Example 2:Input:[1, 2, 3, 4, 5], k = 1Output: 4Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).Example 3:Input: [1, 3, 1, 5, 4], k = 0Output: 1Explanation: There is one 0-diff pair in the array, (1, 1).풀이 hashclass Solution {public: int findPairs(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { if (k &amp;lt; 0) return 0; int count = 0; unordered_map&amp;lt;int,int&amp;gt; m; for(const auto&amp;amp; i : nums) ++m[i]; for(const auto&amp;amp; i : m){ if ((!k &amp;amp;&amp;amp; i.second &amp;gt; 1) || (k &amp;amp;&amp;amp; m.count(i.first + k))) ++count; } return count; }};" }, { "title": "LeetCode - 461. Hamming Distance", "url": "/posts/ps-leetcode-461/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Bit Manipulation", "date": "2020-02-02 07:33:00 +0900", "snippet": " 461. Hamming Distance - easy문제The Hamming distance between two integers is the number of positions at which the corresponding bits are different.Given two integers x and y, calculate the Hamming distance.제한사항 0 ≤ x, y &amp;lt; 231.입출력 예Input: x = 1, y = 4Output: 2Explanation:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑The above arrows point to positions where the corresponding bits are different.풀이 Bit Manipulationclass Solution {public: int hammingDistance(int x, int y) { int count = 0; int temp = x ^ y; while(temp){ temp = temp &amp;amp; (temp-1); ++count; } return count; }};" }, { "title": "LeetCode - 338. Counting Bits", "url": "/posts/ps-leetcode-338/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, DP", "date": "2020-02-02 07:33:00 +0900", "snippet": " 338. Counting Bits - medium문제Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.제한사항 It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n)/possibly in a single pass? Space complexity should be O(n). Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.입출력 예Example 1:Input: 2Output: [0,1,1]Example 2:Input: 5Output: [0,1,1,2,1,2]풀이 DPclass Solution {public: vector&amp;lt;int&amp;gt; countBits(int num) { if(num == 0) return {0}; else if(num == 1) return {0,1}; vector&amp;lt;int&amp;gt; res(num + 1, 0); int carry = 0; res[0] = 0; res[1] = 1; for(int i = 2 ; i &amp;lt;= num ; ++i){ // Pow of 2 는 비트에서 1의 개수가 무조건 1 if((i &amp;amp; (i - 1)) == 0){ res[i] = 1; carry = i; } else{ // i = carry + (i - carry) // 6 = 4 + 2 // 7 = 4 + 3 // 9 = 8 + 1 res[i] = res[carry] + res[i - carry]; } } return res; }};" }, { "title": "LeetCode - 303. Range Sum Query", "url": "/posts/ps-leetcode-303/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Sum", "date": "2020-02-02 07:33:00 +0900", "snippet": " 303. Range Sum Query - Immutable - easy문제Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.제한사항 You may assume that the array does not change. There are many calls to sumRange function.입출력 예Example 1:Given nums = [-2, 0, 3, -5, 2, -1]sumRange(0, 2) -&amp;gt; 1sumRange(2, 5) -&amp;gt; -1sumRange(0, 5) -&amp;gt; -3풀이 sumclass NumArray {private: const vector&amp;lt;int&amp;gt;&amp;amp; m_nums;public: NumArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) : m_nums(nums){} int sumRange(int i, int j) { int sum = 0; for(auto index = i ; index &amp;lt;= j ; ++index){ sum += m_nums[index]; } return sum; }};" }, { "title": "LeetCode - 39. Combination Sum", "url": "/posts/ps-leetcode-30/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Recursive, BackTracking", "date": "2020-02-02 07:33:00 +0900", "snippet": " 39. Combination Sum - medium문제Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.The same repeated number may be chosen from candidates unlimited number of times.제한사항 All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations.입출력 예Input: candidates = [2,3,6,7], target = 7,A solution set is:[ [7], [2,2,3]]Input: candidates = [2,3,5], target = 8,A solution set is:[ [2,2,2,2], [2,3,3], [3,5]]풀이 Recursive, BackTrackingclass Solution {public: void backTracking(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; ans, vector&amp;lt;int&amp;gt;&amp;amp; candidates, vector&amp;lt;int&amp;gt;&amp;amp; curItem, int target, int cur, int begin){ // 현재 값이 target과 같으면 리턴 if(cur == target){ ans.push_back(curItem); return; } // 같은 내용이 반복되지 않도록 candidates의 index를 0 부터 candidates.size() 까지 // candidates의 index를 매개변수로 하여 중복 방지 for(auto i = begin ; i &amp;lt; candidates.size() ; ++i){ // 현재 값 + candidates[i] 이 target보다 작거나 같아야 해당 candidates[i]를 추가 // 재귀로 BackTracking 수행후, pop을 하여 중복되는 원소 제거 if(candidates[i] + cur &amp;lt;= target){ curItem.push_back(candidates[i]); backTracking(ans, candidates, curItem, target, cur + candidates[i], i); curItem.pop_back(); } } } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combinationSum(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int target) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; answer; vector&amp;lt;int&amp;gt; item; backTracking(answer, candidates, item, target, 0, 0); return answer; }};" }, { "title": "LeetCode - 3. Longest Substring Without Repeating Characters", "url": "/posts/ps-leetcode-3/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, String, Brute Force, Hash", "date": "2020-02-02 07:33:00 +0900", "snippet": " 3. Longest Substring Without Repeating Characters - medium문제Given a string, find the length of the longest substring without repeating characters.제한사항입출력 예Example 1:Input: &quot;abcabcbb&quot;Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2:Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1.Example 3:Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.풀이 String, Brute Force, Hashclass Solution {public: int lengthOfLongestSubstring(string s) { if(s.size() == 1) return 1; set&amp;lt;char&amp;gt; sub; string subStr; // 문자열의 모든 경우를 검사하여 최대 길이를 검색 for(auto i = 0 ; i &amp;lt; s.size(); ++i){ for(auto j = i ; j &amp;lt; s.size() ; ++j){ // Set에 현재 문자가 없으면 추가 if(sub.find(s[j]) == sub.end()){ sub.insert(s[j]); } // Set에 현재 문자가 있으면 // 현재까지의 문자열과 이전의 문자열과 길이를 비교하여 문자열 저장 else{ string temp; for(auto&amp;amp; i : sub) temp.push_back(i); if(subStr.size() &amp;lt; temp.size()) subStr = temp; sub.clear(); break; } } } return subStr.size(); }};" }, { "title": "LeetCode - 292. Nim Game", "url": "/posts/ps-leetcode-292/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Math", "date": "2020-02-02 07:33:00 +0900", "snippet": " 292. Nim Game - easy문제You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.제한사항입출력 예Input: 4Output: false Explanation: If there are 4 stones in the heap, then you will never win the game; No matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.풀이 Mathclass Solution {public: bool canWinNim(int n) { if(n % 4 == 0) return false; return true; }};" }, { "title": "LeetCode - 290. Word Pattern", "url": "/posts/ps-leetcode-290/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Hash", "date": "2020-02-02 07:33:00 +0900", "snippet": " 290. Word Pattern - easy문제Given a pattern and a string str, find if str follows the same pattern.Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.제한사항 You may assume pattern contains only lowercase letters, and str contains lowercase letters that may be separated by a single space입출력 예Example 1:Input: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;Output: trueExample 2:Input:pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot;Output: falseExample 3:Input: pattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot;Output: falseExample 4:Input: pattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot;Output: false풀이 hashclass Solution {public: bool wordPattern(string pattern, string str) { vector&amp;lt;string&amp;gt; strVec; string token; stringstream ss(str); while (getline(ss, token, &#39; &#39;)) { strVec.push_back(token); } map&amp;lt;char, string&amp;gt; m; set&amp;lt;string&amp;gt; s; if(pattern.size() != strVec.size()) return false; for(auto i = 0 ; i &amp;lt; pattern.size() ; ++i){ if(m.find(pattern[i]) != m.end()){ if(m[pattern[i]] != strVec[i]) return false; } else{ m[pattern[i]] = strVec[i]; s.insert(m[pattern[i]]); } } if(s.size() == m.size()) return true; else return false; }};" }, { "title": "LeetCode - 289. Game of Life", "url": "/posts/ps-leetcode-289/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Array, Brute Force", "date": "2020-02-02 07:33:00 +0900", "snippet": " 289. Game of Life - medium문제According to the Wikipedia’s article: “The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.”Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):1. Any live cell with fewer than two live neighbors dies, as if caused by under-population.2. Any live cell with two or three live neighbors lives on to the next generation.3. Any live cell with more than three live neighbors dies, as if by over-population..4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.Write a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously.제한사항입출력 예Input: [ [0,1,0], [0,0,1], [1,1,1], [0,0,0]]Output: [ [0,0,0], [1,0,1], [0,1,1], [0,1,0]]풀이 Array, Brute Forceclass Solution {public: void gameOfLife(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; board) { auto newBoard = board; int row = board.size(); int col = board[0].size(); for(auto i = 0 ; i &amp;lt; row ; ++i){ for(auto j = 0 ; j &amp;lt; col ; ++j){ // 현재 cell의 주변 이웃의 생존 및 죽은 cell 수 검사 int liveCount = 0, deadCount = 0; for(auto m = -1 ; m &amp;lt; 2 ; ++m){ for(auto n = -1 ; n &amp;lt; 2 ; ++n){ if(m == 0 &amp;amp;&amp;amp; n == 0) continue; if(i + m &amp;lt; 0 || i + m &amp;gt;= row) continue; if(j + n &amp;lt; 0 || j + n &amp;gt;= col) continue; if(board[i + m][j + n]) ++liveCount; else ++deadCount; } } // 현재 cell이 생존했을때, if(board[i][j]){ // 1번 조건 if(liveCount &amp;lt; 2) newBoard[i][j] = 0; // 2번 조건 else if(2 &amp;lt;= liveCount &amp;amp;&amp;amp; liveCount &amp;lt;= 3) newBoard[i][j] = 1; // 3번 조건 else newBoard[i][j] = 0; } // 현재 cell이 죽은상태일때, else{ // 4번 조건 if(liveCount == 3) newBoard[i][j] = 1; } } } swap(newBoard, board); }};" }, { "title": "LeetCode - 283. Move Zeroes", "url": "/posts/ps-leetcode-283/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Array", "date": "2020-02-02 07:33:00 +0900", "snippet": " 283. Move Zeroes - easy문제Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.제한사항 You must do this in-place without making a copy of the array. Minimize the total number of operations.입출력 예Example 1:Input: [0,1,0,3,12]Output: [1,3,12,0,0]풀이 arrayclass Solution {public: void moveZeroes(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int numsSize = nums.size(), count = 0; for(int index = 0 ; index &amp;lt; numsSize - count;){ if(nums[index] == 0){ ++count; nums.push_back(0); nums.erase(nums.begin() + index); } else ++index; } }};" }, { "title": "LeetCode - 279. Perfect Squares", "url": "/posts/ps-leetcode-279/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, DP", "date": "2020-02-02 07:33:00 +0900", "snippet": " 279. Perfect Squares - medium문제Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, …) which sum to n.제한사항입출력 예Example 1:Input: n = 12Output: 3 Explanation: 12 = 4 + 4 + 4.Example 2:Input: n = 13Output: 2Explanation: 13 = 4 + 9.풀이 DPclass Solution {public: int numSquares(int n) { int digit = 1; vector&amp;lt;int&amp;gt; item(n+1, 1); item[0] = 0; // 1...n 까지 제곱수 끼리의 합을 만드는 방법은 // item[n] = item[n - sqrt(i)] + 1 이며, // 가장 수가 적게 만들어야 하므로 i를 1부터 최대 제곱근까지 검사 for(auto i = 1 ; i &amp;lt;= n ; ++i){ // 현재 i까지의 최대 제곱근 검사 int sr = sqrt(i); if((sr - floor(sr)) == 0){ digit = sr * sr; } // 1부터 현재 i까지의 최대 제곱근까지, // 제곱끼리의 합이 i를 만족하며 갯수가 최소인 갯수를 검사 int minVal = INT_MAX; for(auto j = 1 ; (j*j) &amp;lt;= digit ; ++j){ int val = item[i] + item[i - (j*j)]; minVal = min(minVal, val); } // 찾은 최소값을 현재 item[i] 에 저장 item[i] = minVal; } return item[n]; }};" }, { "title": "LeetCode - 230. Kth Smallest Element in a BST", "url": "/posts/ps-leetcode-230/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, BFS", "date": "2020-02-02 07:33:00 +0900", "snippet": " 230. Kth Smallest Element in a BST - medium문제Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.제한사항 You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.입출력 예Example 1:Input: root = [3,1,4,null,2], k = 1 3 / \\ 1 4 \\ 2Output: 1Example 2:Input: root = [5,3,6,2,4,null,null,1], k = 3 5 / \\ 3 6 / \\ 2 4 / 1Output: 3풀이 BFS/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int kthSmallest(TreeNode* root, int k) { set&amp;lt;int&amp;gt; s; queue&amp;lt;TreeNode*&amp;gt; q; q.push(root); // BFS로 전체 노드의 val 값을 저장 while(!q.empty()){ auto node = q.front(); q.pop(); s.insert(node-&amp;gt;val); if(node-&amp;gt;left) q.push(node-&amp;gt;left); if(node-&amp;gt;right) q.push(node-&amp;gt;right); } // k번째 작은수 검색 auto answer = s.begin(); for(auto i = 0 ; i &amp;lt; k - 1 ; ++i){ ++answer; } return *answer; }};" }, { "title": "LeetCode - 22. Generate Parentheses", "url": "/posts/ps-leetcode-22/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Back Tracking", "date": "2020-02-02 07:33:00 +0900", "snippet": " 22. Generate Parentheses - medium문제Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.For example, given n = 3, a solution set is:[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;]제한사항입출력 예풀이 Back Trackingclass Solution {public: // Back Tracking void OpenClose(vector&amp;lt;string&amp;gt;&amp;amp; ans, int n, string str, int open, int close){ // &#39;(&#39;, &#39;)&#39; 괄호가 2개가 한세트 이므로 2*n이 정답의 총 길이 if(str.size() == 2 * n){ ans.push_back(str); return; } // &#39;(&#39; 가 n개수보다 작으면 &#39;(&#39; 추가 if(open &amp;lt; n) OpenClose(ans, n, str+&#39;(&#39;, open+1, close); // &#39;)&#39; 가 현재 문자의 &#39;(&#39; 개수 보다 작으면 &#39;)&#39; 추가 if(close &amp;lt; open) OpenClose(ans, n, str+&#39;)&#39;, open, close+1); } vector&amp;lt;string&amp;gt; generateParenthesis(int n) { vector&amp;lt;string&amp;gt; answer; OpenClose(answer, n, &quot;&quot;,0 ,0); return answer; } };" }, { "title": "LeetCode - 215. Kth Largest Element in an Array", "url": "/posts/ps-leetcode-215/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Divide and Conquer, Heap, Sort", "date": "2020-02-02 07:33:00 +0900", "snippet": " 215. Kth Largest Element in an Array - medium문제Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.제한사항 You may assume k is always valid, 1 ≤ k ≤ array’s length.입출력 예Example 1:Input: [3,2,1,5,6,4] and k = 2Output: 5Example 2:Input: [3,2,3,1,2,4,5,5,6] and k = 4Output: 4풀이 Divide and Conquer, Heap, Sortclass Solution {public: int findKthLargest(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { sort(nums.begin(), nums.end(), greater&amp;lt;int&amp;gt;()); return nums[k - 1]; }};" }, { "title": "LeetCode - 142. Linked List Cycle II", "url": "/posts/ps-leetcode-142/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Linked List, Two pointer", "date": "2020-02-02 07:33:00 +0900", "snippet": " 142. Linked List Cycle II - medium문제Given a linked list, return the node where the cycle begins. If there is no cycle, return null.To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.Note: Do not modify the linked list.제한사항 Can you solve it without using extra space?입출력 예Input: head = [3,2,0,-4], pos = 1Output: tail connects to node index 1Explanation: There is a cycle in the linked list, where tail connects to the second node.Input: head = [1,2], pos = 0Output: tail connects to node index 0Explanation: There is a cycle in the linked list, where tail connects to the first node.Input: head = [1], pos = -1Output: no cycleExplanation: There is no cycle in the linked list.풀이 Linked List, two pointer/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode *detectCycle(ListNode *head) { if (head == NULL || head-&amp;gt;next == NULL) return NULL; ListNode *slower = head; ListNode *faster = head; ListNode *temper = head; // 항상 faster가 빠르므로, fastet-&amp;gt;next, fastet-&amp;gt;next-&amp;gt;next가 nullptr일때 nullptr을 리턴 while (faster-&amp;gt;next &amp;amp;&amp;amp; faster-&amp;gt;next-&amp;gt;next){ // slower는 한 노드씩 증가 // faster는 두 노드씩 증가 slower = slower-&amp;gt;next; faster = faster-&amp;gt;next-&amp;gt;next; // slower와 faster가 같다면 기본적으로 cycle이 형성된다고 볼수 있음 if(slower == faster){ // cycle이 형성된 상태에서 head부터 한 노드씩 증가하는 temper와 // 현재 slower에서 한 노드씩 증가할때, // temper와 slower가 같아지는 노드가 cycle 지점 while(slower != temper){ slower = slower-&amp;gt;next; temper = temper-&amp;gt;next; } return slower; } }; return nullptr; }};" }, { "title": "LeetCode - 1315. Sum of Nodes with Even-Valued Grandparent", "url": "/posts/ps-leetcode-1315/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Tree, BFS", "date": "2020-02-02 07:33:00 +0900", "snippet": " 1315. Sum of Nodes with Even-Valued Grandparent - medium문제Given a binary tree, return the sum of values of nodes with even-valued grandparent. (A grandparent of a node is the parent of its parent, if it exists.)If there are no nodes with an even-valued grandparent, return 0.제한사항 The number of nodes in the tree is between 1 and 10^4. The value of nodes is between 1 and 100.입출력 예Input: root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]Output: 18Explanation: The red nodes are the nodes with even-value grandparent while the blue nodes are the even-value grandparents.풀이 Tree, BFS/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int sumEvenGrandparent(TreeNode* root) { int sum = 0; queue&amp;lt;TreeNode*&amp;gt; q; q.push(root); while(!q.empty()){ auto node = q.front(); q.pop(); if(node-&amp;gt;val % 2 == 0){ if(node-&amp;gt;left){ if(node-&amp;gt;left-&amp;gt;left){ sum += node-&amp;gt;left-&amp;gt;left-&amp;gt;val; } if(node-&amp;gt;left-&amp;gt;right){ sum += node-&amp;gt;left-&amp;gt;right-&amp;gt;val; } } if(node-&amp;gt;right){ if(node-&amp;gt;right-&amp;gt;left){ sum += node-&amp;gt;right-&amp;gt;left-&amp;gt;val; } if(node-&amp;gt;right-&amp;gt;right){ sum += node-&amp;gt;right-&amp;gt;right-&amp;gt;val; } } } if(node-&amp;gt;left) q.push(node-&amp;gt;left); if(node-&amp;gt;right) q.push(node-&amp;gt;right); } return sum; }};" }, { "title": "LeetCode - 1277. Count Square Submatrices with All Ones", "url": "/posts/ps-leetcode-1277/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, DP", "date": "2020-02-02 07:33:00 +0900", "snippet": " 1277. Count Square Submatrices with All Ones - medium문제Given a m * n matrix of ones and zeros, return how many square submatrices have all ones.제한사항 1 &amp;lt;= arr.length &amp;lt;= 300 1 &amp;lt;= arr[0].length &amp;lt;= 300 0 &amp;lt;= arr[i][j] &amp;lt;= 1입출력 예Example 1:Input: matrix =[ [0,1,1,1], [1,1,1,1], [0,1,1,1]]Output: 15Explanation: There are 10 squares of side 1.There are 4 squares of side 2.There is 1 square of side 3.Total number of squares = 10 + 4 + 1 = 15.Example 2:Input: matrix = [ [1,0,1], [1,1,0], [1,1,0]]Output: 7Explanation: There are 6 squares of side 1. There is 1 square of side 2. Total number of squares = 6 + 1 = 7.풀이 DPclass Solution {public: int countSquares(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix) { int count = 0; int m = matrix.size(); int n = matrix[0].size(); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result = vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;(m, vector&amp;lt;int&amp;gt;(n, 0)); for(auto i = 0 ; i &amp;lt; m ; ++i){ for(auto j = 0 ; j &amp;lt; n ; ++j){ // 가로, 세로 첫줄은 그대로 저장 if(i == 0 || j == 0){ result[i][j] = matrix[i][j]; } // 0인 값은 그대로 0을 저장 else if(matrix[i][j] == 0){ result[i][j] = 0; } // 현재 index의 왼쪽, 위, 왼쪽 위 대각선, 이 세가지 값을 비교후 작은 값에 +1 // +1 하느 이유는 크기가 1인 사각형을 포함해야 하므로 else{ auto temp = min(matrix[i][j-1], result[i-1][j-1]); result[i][j] = min(result[i-1][j], min(result[i][j-1], result[i-1][j-1])) + 1; } count += result[i][j]; } } return count; }};" }, { "title": "LeetCode - 1207. Unique Number of Occurrences", "url": "/posts/ps-leetcode-1207/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Hash", "date": "2020-02-02 07:33:00 +0900", "snippet": " 1207. Unique Number of Occurrences - easy문제Given an array of integers arr, write a function that returns true if and only if the number of occurrences of each value in the array is unique.제한사항 1 &amp;lt;= arr.length &amp;lt;= 1000 -1000 &amp;lt;= arr[i] &amp;lt;= 1000입출력 예Example 1:Input: arr = [1,2,2,1,1,3]Output: trueExplanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.Example 2:Input: arr = [1,2]Output: falseExample 3:Input: arr = [-3,0,1,-3,1,1,1,-3,10,0]Output: true풀이 Hashclass Solution {public: bool uniqueOccurrences(vector&amp;lt;int&amp;gt;&amp;amp; arr) { map&amp;lt;int, int&amp;gt; m; set&amp;lt;int&amp;gt; s; for(auto&amp;amp; i : arr){ ++m[i]; } for(auto i = m.begin() ; i != m.end() ; ++i){ s.insert(i-&amp;gt;second); } return s.size() == m.size(); }};" }, { "title": "LeetCode - 1079. Letter Tile Possibilities", "url": "/posts/ps-leetcode-1079/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Recursive, BackTracking", "date": "2020-02-02 07:33:00 +0900", "snippet": " 1079. Letter Tile Possibilities - medium문제You have a set of tiles, where each tile has one letter tiles[i] printed on it. Return the number of possible non-empty sequences of letters you can make.제한사항 1 &amp;lt;= tiles.length &amp;lt;= 7 tiles consists of uppercase English letters.입출력 예Example 1:Input: &quot;AAB&quot;Output: 8Explanation: The possible sequences are &quot;A&quot;, &quot;B&quot;, &quot;AA&quot;, &quot;AB&quot;, &quot;BA&quot;, &quot;AAB&quot;, &quot;ABA&quot;, &quot;BAA&quot;.Example 2:Input: &quot;AAABBC&quot;Output: 188풀이 Recursive, BackTrackingclass Solution {public: void backTracking(set&amp;lt;string&amp;gt;&amp;amp; item, string&amp;amp; tiles, string&amp;amp; subStr, vector&amp;lt;bool&amp;gt;&amp;amp; check){ if(subStr.size() == tiles.size()){ return; } // 문자를 하나씩 추가하며 전체 경우를 찾아봄 for(auto i = 0 ; i &amp;lt; tiles.size() ; ++i){ // 현재 문자를 이미 추가했는지 체크 if(check[i]){ subStr.push_back(tiles[i]); // 추가한 문자가 이미 set에 있다면, // 이후 모든 조합은 이미 있게 되는 것이므로 탐색 중지 if(item.find(subStr) != item.end()){ subStr.pop_back(); continue; } check[i] = false; item.insert(subStr); backTracking(item, tiles, subStr, check); subStr.pop_back(); check[i] = true; } } } int numTilePossibilities(string tiles) { set&amp;lt;string&amp;gt; item; vector&amp;lt;bool&amp;gt; check(tiles.size(), true); string temp; backTracking(item, tiles, temp, check); return item.size(); }};" }, { "title": "LeetCode - 1048. Longest String Chain", "url": "/posts/ps-leetcode-1048/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, DP", "date": "2020-02-02 07:33:00 +0900", "snippet": " 1048. Longest String Chain - medium문제Given a list of words, each word consists of English lowercase letters.Let’s say word1 is a predecessor of word2 if and only if we can add exactly one letter anywhere in word1 to make it equal to word2. For example, “abc” is a predecessor of “abac”.A word chain is a sequence of words [word_1, word_2, …, word_k] with k &amp;gt;= 1, where word_1 is a predecessor of word_2, word_2 is a predecessor of word_3, and so on.Return the longest possible length of a word chain with words chosen from the given list of words.제한사항 1 &amp;lt;= words.length &amp;lt;= 1000 1 &amp;lt;= words[i].length &amp;lt;= 16 words[i] only consists of English lowercase letters.입출력 예Input: [&quot;a&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bca&quot;,&quot;bda&quot;,&quot;bdca&quot;]Output: 4Explanation: one of the longest word chain is &quot;a&quot;,&quot;ba&quot;,&quot;bda&quot;,&quot;bdca&quot;.풀이 DPbool comp(const string&amp;amp; a, const string&amp;amp; b){ return a.size() &amp;lt; b.size();}class Solution {public: int longestStrChain(vector&amp;lt;string&amp;gt;&amp;amp; words) { int len = words.size(); vector&amp;lt;int&amp;gt; res(len, 1); // 길이가 작은 단어순으로 정렬 sort(words.begin() , words.end(), comp); for(auto i = 1 ; i &amp;lt; len ; ++i){ // 단어의 길이가 1 이면 패스 if(words[i].size() == 1) continue; int max = 0; for(auto j = 0 ; j &amp;lt; i ; ++j){ // 단어의 길이가 하나 차이가 나야 word chain이 가능 if(words[j].size() != words[i].size() - 1) continue; // 첫번째 단어부터 현재단어 전까지 // 단어 하나 차이가 나는지 검사 int checkWordIndex = 0; for(auto k = 0 ; k &amp;lt; words[i].size() &amp;amp;&amp;amp; checkWordIndex &amp;lt; words[j].size(); ++k){ if(words[i][k] == words[j][checkWordIndex]){ ++checkWordIndex; } } /// word chain이 가능한 단어중 // 가장 긴 word chain의 수를 찾음 if(checkWordIndex == words[j].size()){ if(max &amp;lt; res[j]) max = res[j]; } } // 가장 긴 word chain의 수를 저장 res[i] += max; } return *max_element(res.begin(), res.end()); }};" }, { "title": "LeetCode - 1302. Deepest Leaves Sum", "url": "/posts/ps-leetcode-1302/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Tree, DFS", "date": "2020-02-02 07:32:00 +0900", "snippet": " 1302. Deepest Leaves Sum - medium문제Given a binary tree, return the sum of values of its deepest leaves.제한사항 The number of nodes in the tree is between 1 and 10^4. The value of nodes is between 1 and 100.입출력 예Input: root = [1,2,3,4,5,null,6,7,null,null,null,null,8]Output: 15풀이 Tree, DFS/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int deepestLeavesSum(TreeNode* root) { map&amp;lt;int, int&amp;gt; sumMap; stack&amp;lt;pair&amp;lt;TreeNode*, int&amp;gt;&amp;gt; s; s.push({root, 0}); // DFS로 트리의 깊이별 노드의 val값 합을 구함 while(!s.empty()){ auto node = s.top(); s.pop(); // 깊이별 합을 map에 저장 // sumMap[현재 노드의 깊이] += 현재 노드의 값 sumMap[node.second] += node.first-&amp;gt;val; if(node.first-&amp;gt;right){ s.push({node.first-&amp;gt;right, node.second + 1}); } if(node.first-&amp;gt;left){ s.push({node.first-&amp;gt;left, node.second + 1}); } } return sumMap.rbegin()-&amp;gt;second; }};" }, { "title": "LeetCode - 1282. Group the People Given the Group Size They Belong To", "url": "/posts/ps-leetcode-1282/", "categories": "Problem Solving, LeetCode", "tags": "PS, Leetcode, Hash, Greedy", "date": "2020-02-02 07:31:00 +0900", "snippet": " 1282. Group the People Given the Group Size They Belong To - medium문제There are n people whose IDs go from 0 to n - 1 and each person belongs exactly to one group. Given the array groupSizes of length n telling the group size each person belongs to, return the groups there are and the people’s IDs each group includes.You can return any solution in any order and the same applies for IDs. Also, it is guaranteed that there exists at least one solution.제한사항 groupSizes.length == n 1 &amp;lt;= n &amp;lt;= 500 1 &amp;lt;= groupSizes[i] &amp;lt;= n입출력 예Example 1:Input: groupSizes = [3,3,3,3,3,1,3]Output: [[5],[0,1,2],[3,4,6]]Explanation: Other possible solutions are [[2,1,6],[5],[0,4,3]] and [[5],[0,6,2],[4,3,1]].Example 2:Input: groupSizes = [2,1,3,3,3,2]Output: [[1],[0,5],[2,3,4]]풀이 Hash, Greedyclass Solution {public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; groupThePeople(vector&amp;lt;int&amp;gt;&amp;amp; groupSizes) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; answer; unordered_map&amp;lt;int, vector&amp;lt;int&amp;gt;&amp;gt; m; // hash를 이용해 같은 size별 인덱스끼리 나눔 for(auto i = 0 ; i &amp;lt; groupSizes.size() ; ++i){ m[groupSizes[i]].push_back(i); } // 사이즈별 인덱스를 해당 사이즈의 vector에 저장 for(auto&amp;amp; sub : m){ vector&amp;lt;int&amp;gt; subVec; for(auto i = 0 ; i &amp;lt; sub.second.size() ; ++i){ if(subVec.size() == sub.first){ answer.push_back(subVec); subVec.clear(); subVec.push_back(sub.second[i]); } else subVec.push_back(sub.second[i]); } answer.push_back(subVec); } return answer; }};" }, { "title": "About Me", "url": "/posts/experience_kor/", "categories": "", "tags": "", "date": "2020-01-01 00:00:00 +0900", "snippet": "Introduce 서인석 (InSeock Suh) Email : yoyus5@naver.com Github : github.com/ISSuh Resume : KOR / ENG 더 나은 소프트웨어를 위해Technical Experience Languages C C++ Python Platform Linux Development Domain Embeded system application Sensor integration Network Browser Media Tools Docker / Docker-compose Git Experience &amp;amp; Projects오비고 App Framework 1팀 / 연구원 자체 솔루션 개발 2020.03 ~Browser 및 Framework 개발Chromium 기반 차량용 Browser 및 HTML5 기반 Web App용 Framework 개발솔루션 개발 2020.03 ~ Chromium 기반 차량용 Browser 개발 각 고객사별 리눅스 기반 타겟 디바이스에 Browser 포팅 및 기능 개블 고객사의 사양에 맞춰 추가 기능 개발 Chromium upgreade시 이에 대응하여 각 feature 포팅 Browser의 graphic stack 타겟 디바이스 별 화면 출력 및 input 처리를 위한 window system(Wayland, X11) 연동 및 이슈 처리 타겟 디바이스 별 Browser의 GPU 버그등의 이슈 처리 Browser의 media stack 기존 FFMPEG 기반의 media stack 구현에 대하여 Gstreamer 기반의 media stack 으로 포팅 및 개발 DRM 컨텐츠 재생을 위한 CDM 연동 Widevine DRM(L3) 포팅 및 연동 개발 Playready DRM(SL3000) 포팅 및 연동 개발 CoreTrust DRM 연동을 위한 HLS proxy 서버 포팅 및 연동 개발 ASIO 기반의 HLS 서버 포팅 Browser의 network stack 타겟 디바이스의 CCU/DCU 네트워크 환경 연동 타겟 디바이스와 Browser의 network namespace 환견 연동 내부 DNS 서버 연동을 통한 네트워크 환경 연동 HTML5 기반 Web App용 Framework 개발 각 고객사별 요구사힝에 대하여 분석 및 기능 개발 사내 Application Framework의 QT 기반 SDK 개발 스프링클라우드 자율주행 솔루션 개발팀 / 매니저 시스템개발 2018.01 ~ 2020.03자율주행 AI 컴퓨팅모듈 검증 및 차량실증기술 개발자율주행 컴퓨팅 모듈을 탑재하여 자율주행 기능 실증 및 실험시스템 분석 및 개발 2019.05 ~ 2019.12 상용 자율주행 셔틀차량 분석 및 연동 자율주행 차량 운행 데이터 분석 사내 프로젝트인 차량 운행데이터 관제 연동 단말기 연동 특허 등록 자율주행시스템(등록번호:1022613060000) 센서데이터전송장치및방법(등록번호:1021977350000) 자율주행 부품 성능검증을 위한 자율셔틀 실증 기반기술 개발자율주행 셔틀 차량의 운영자 모니터링 시스템 개발시스템 개발 2019.03 ~ 2019.12 자율주행 셔틀차량의 운영자 모니터링 시스템의 일부 기능 개발 차량 데이터 관제 연동을 위한 데이터 전송 규격 설계 및 기능 개발 차량의 영상 전송을 위한 영상 스트리밍 서버(RTSP, RTP) 개발 네트웨크 모니터링(네트워크 인터페이스, 대역폭 등) 기능 개발 차량 운행데이터 관제 연동 단말기 개발관제 연동을 위한 차량정보 및 센서정보 연동 솔루션시스템 개발 2019.02 ~ 2019.11 자율주행 차량 센서데이터 획득 및 차량정보 연동 소프트웨어 개발 Camera, GNSS, LiDAR, Radar, IMU, CAN 데이터 연동 소프트웨어 개발 획득한 센서데이터 및 차량정보 관제 서버로 전송 소프트웨어 개발 JSON 및 Google Protobuf를 통한 데이터 전송 구조 및 규격 설계 TCP, MQTT, Websocket, Kafka등 관제 시스템 버전에 맞춰 다양한 통신 인터페이스 사용 획득한 Camera 영상 전송을 위한 RTSP 서버 개발 Multi Camera기반 RTSP 서버 개발 최적화를 위한 Multi Camera 영상 합성 및 이미지 프로세싱 정보 연동 소프트웨어 및 정보 전송 소프트웨어 Dockernize Docker를 통한 센서별 연동 드라이버 소프트웨어및 관리 Docker-compos를 통한 시스템 orchestration 대규모 실시간 비디오 분석에 의한 전역적 다중 관심객체 추적 및 상황 예측 기술 개발이동체에서(차량, 사람등)의 센서 연동 및 데이터 획득, 전송 시스템 개발시스템 개발 2018.03 ~ 2018.12 DrivePX2 보드 기반 Camera, GNSS 센서 연동 및 데이터 획득 QT5를 이용한 데이터 획득 및 전송 GUI 어플리케이션 개발 Camera, GNSS 데이터 저장기능 개발 RTSP 서버를 통한 Camera 영상 스트리밍 기능 개발 TCP 서버를 통한 GNSS 데이터 전송 기능 개발 개발된 소프트웨어 저작권 등록다산지앤지 인턴 테이터 분석 2017.07 ~ 2017.07AMI 데이터분석AMI(AdvancedMeteringInfrastructure) 데이터 분석데이터 분석 2017.07 ~ 2017.08 통계를 위한 데이터 전처리 통계 데이터 분석 및 시각화 SVM 알고리즘을 이용한 에너지 사용량 예측Personal ProjectsnLink범용 micro service framework runtime plugin 방식의 runtime user module load 환경 개발 task 기반의 async 환경 구현 network stack 기본 Socket 통신 및 HTTP 구현 개발중state_manchineCross Platform(Win, Linux) 기반 State Machine header only library C++ 11, standard library 기반으로 쉽게 포팅가능 Multi threading을 통해 cuncurrency state 지원remote_display_viewerlinux 환경에서 screen shring을 위한 screen capture server gtk을 이용한 screen capture module 구현 screen shring을 위한 Golang server 구현 screen capture 이미지를 mpeg로 압축Image2RTSPROS Image 스트림을 위한 멀티 세션 RTSP 서버 노드 ROS Image(sensor_msgs/Image)를 x264로 압축하여 h264로 인코딩 인코딩된 이미지를 live555기반 RTSP 서버에서 송출 Proxy를 내장하여 외부 접속 가능CUDA Image ProcessCUDA 기반 이미지 변환 ROS 노드 ROS Image(sensor_msgs/Image)를 CUDA 라이브러리를 이용하여 GPU기반 이미지 변환 이미지 크기 변환 Gray scale 변환 JPEG 압축 (sensor_msgs/Image -&amp;gt; sensor_msgs/CompressedImage) Education 고려대학교 세종캠퍼스 컴퓨터정보학과 졸업 (2011.03 ~ 2018.02)Certificate 정보처리기사 (2017.11.24) TOEIC 815점 (취득일 : 2016.10)" }, { "title": "About Me", "url": "/posts/experience_en/", "categories": "", "tags": "", "date": "2020-01-01 00:00:00 +0900", "snippet": "About Me 서인석 (InSeock Suh) Email : yoyus5@naver.com Github : github.com/ISSuh Resume : KOR / ENG For better SoftwareTechnical Experience Languages C C++ Python Platform Linux Development Domain Embeded system application Sensor integration Network Browser Media Tools Docker / Docker-compose Git Experience &amp;amp; ProjectsObiso App Framework 1 team / researcher Software Engineering 2020.03 ~Develoment Browser and FrameworkDeveloment chromium based browser for vehicle and Framework for HTML5 based web applicationSoftware Engineering 2020.03 ~ Develoment chromium based browser for vehicle 각 고객사별 리눅스 기반 타겟 디바이스에 Browser 포팅 및 기능 개블 고객사의 사양에 맞춰 추가 기능 개발 Chromium upgreade시 이에 대응하여 각 feature 포팅 Browser의 graphic stack 타겟 디바이스 별 화면 출력 및 input 처리를 위한 window system(Wayland, X11) 연동 및 이슈 처리 타겟 디바이스 별 Browser의 GPU 버그등의 이슈 처리 Browser의 media stack 기존 FFMPEG 기반의 media stack 구현에 대하여 Gstreamer 기반의 media stack 으로 포팅 및 개발 DRM 컨텐츠 재생을 위한 CDM 연동 Widevine DRM(L3) 포팅 및 연동 개발 Playready DRM(SL3000) 포팅 및 연동 개발 CoreTrust DRM 연동을 위한 HLS proxy 서버 포팅 및 연동 개발 ASIO 기반의 HLS 서버 포팅 Browser의 network stack 타겟 디바이스의 CCU/DCU 네트워크 환경 연동 타겟 디바이스와 Browser의 network namespace 환견 연동 내부 DNS 서버 연동을 통한 네트워크 환경 연동 Develoment Application Framework for HTML5 based web application Requirements Analysis for several customer and development feature Development QT based SDK for Application Framework product Springcloud Autonomous Solution Develpoment Team / manager System Development 2018.01 ~ 2020.02Develop autonomouse AI computing module and verify vehicle technologyVerify autonomouse function with autonomouse computing module at vehicleSystem Analysis and Engineering 2019.05 ~ 2019.12 Autonomouse shuttle ananlysus and linking Analysis operately data on autonomouse shuttle Linking between commertial autonomouse shuttle and Springcloud’s device for linking with control center Patent application (in South Korea) Autonomouse System (publish number : 1022613060000) Sensing Data transfer system and method (publish number : 1021977350000) Technology develop based verify autonomouse shuttle for verify parts of autonomous autonomouse shuttleDevelop operator’s monitoring system for autonomouse shuttleSystem Development 2019.03 ~ 2019.12 Develop function to autonomouse shuttle’s operator monitoring system Development of data transfer Function and Design data struct for linking control center Develop video streaming server(RTSP, RTP) for camera at vehicle Develop Network monitoring function(check interface, bandwidth, etc) Develop device for linking control center about vehicle infomationSolution develop for linking control center about vehicle data and sensor dataSystem Development 2019.02 ~ 2019.10 Develop getting autonomouse vehicle’s sensor data and autonomouse vehicle’s information Develop Sensor(Camera, GNSS, LiDAR, Radar, IMU, CAN) Driver for getting data Develop data transfer software about getting sensor data and vehicle infomation Design data structure for communication using JSON, Google Protobuf Using variouse communication protocol such as TCP/UDP, MQTT, Websocket, Kafka for communicating control center Develop RTSP server for image streaming at vehicle Develop multi Camera, multi session RTSP server multi Camera Image processing and fusion for optimzation Dockernize sensor driver software and data transfer software Manage several sensor driver software and version using Docker Docker Orchestration using Docker-compos DeepViewDevelop sensor data logging and data transfer system at moving object(vehicle, person, etc)System Development 2018.03 ~ 2018.12 Camera, GNSS sensor interface and getting sensor data on DrivePX2 enviroment Develop GUI application about Recording sensor data and transfer sensor data using QT5 Camera, GNSS data record Camera image streaming using RTSP, RTP GNSS data transfer using TCP Regist this software in South Korea다산지앤지 인턴 테이터 분석 2017.07 ~ 2017.07AMI 데이터분석AMI(AdvancedMeteringInfrastructure) 데이터 분석데이터 분석 2017.07 ~ 2017.08 통계를 위한 데이터 전처리 통계 데이터 분석 및 시각화 SVM 알고리즘을 이용한 에너지 사용량 예측Personal ProjectsnLinkgeneral micro service framework runtime implement plugin based user module load environment implement task based async environment network stack implement basic socket tracnfer implement HTTP stack in developmentstate_manchineState Machine header only library for Cross Platform C++ 11, easy port, standard library based libaray support concurrency state using multi theadingremote_display_viewerscreen capture server for screen shring on Linux platform implement screen capture module using gtk implement Golang server for screen shareing compressed screen capture image using MJPEGImage2RTSPRTSP server for multi session ros image Encoding ROS Image(sensor_msgs/Image) to h264 using x264 library Stream encoded image at live555 based RTSP server Access from external using Proxy serverCUDA Image ProcessROS node to CUDA based Image trasfortation GPU based ROS Image(sensor_msgs/Image) tranformation using CUDA library Resize image To gray scale Compressed image (sensor_msgs/Image -&amp;gt; sensor_msgs/CompressedImage) Education Bachelor of Sience in Computer and Information Science on Korea University Sejong Campus (2011.03 ~ 2018.03)Certificate 정보처리기사 (2017.11.24) TOEIC 815 (2016.10)" } ]

---
title: Spring Framework - 포인트컷
date: 2023-11-06 16:00:00 +0900
categories: [Backend, Spring Framework]
published: true
tags:
- Web
- Spring Framework
---

### 포인트컷 지시자
포인트컷 표현식은 AspectJ pointcut express 즉, AspectJ가 제공하는 포인트컷 표현식을 줄여서 말하는 것이다.

포인트컷 표현식은 execution과 같은 포인트컷 지시자(Pointcut Designator)로 시작한다.
  - execution
    - 메소드 실행 조인 포인트를 매칭
    - 스프링 AOP에서 가장 많이 사용하고, 기능도 복잡함
  - within
    - 특정 타입 내의 조인 포인트를 매칭
  - args
    - 인자가 주어진 타입의 인스턴스인 조인 포인트
  - this
    - 스프링 빈 객체(스프링 AOP 프록시)를 대상으로 하는 조인 포인트
  - target
    - Target 객체(스프링 AOP 프록시가 가르키는 실제 대상)를 대상으로 하는 조인 포인트
  - @target
    - 실행 객체의 클래스에 주어진 타입의 애노테이션이 있는 조인 포인트
  - @within
    - 주어진 애노테이션이 있는 타입 내 조인 포인트
  - @annotation
    - 메서드가 주어진 애노테이션을 가지고 있는 조인 포인트를 매칭
  - @args
    - 전달된 실제 인수의 런타임 타입이 주어진 타입의 애노테이션을 갖는 조인 포인트
  - bean
    - 빈의 이름으로 포인트컷을 지정
    - 스프링 전용 포인트컷 지시자

보통 execution을 가장 많이 사용하고 다른 지시자는 자주 사용되지 않는다.

### execution 기본 사용
```
execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)throws-pattern?)

execution(접근제어자? 반환타입 선언타입?메서드이름(파라미터) 예외?)
```
  - 메소드 실행 조인 포인트를 매칭
  - ?는 생략가능
  - *과 같은 패턴 지정 가능

**가장 정확한 포인트컷**
```java
  @Test
  void exactMatch() {
    //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String)
    pointcut.setExpression("execution(public String hello.aop.member.MemberServiceImpl.hello(String))");
    Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
  }
```
  - MemberServiceImpl.hello(String) 메소드와 가장 정확하게 모든 내용이 매칭되는 표현식
  - 매칭 조건
    - 접근제어자? : public
    - 반환타입 : String
    - 선언타입? : hello.aop.member.MemberServiceImpl
    - 메소드이름 : hello
    - 파라미터 : (String)
    - 예외? : 생략

**가장 많이 생략한 포인트컷**
```java
@Test
void allMatch() {
  pointcut.setExpression("execution(* *(..))");
  Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
}
```
  - '*'은 아무 값이 들어와도 된다라는 표현으로, 위 표현식은 모든 메소드에 대해 매칭이 성공함
  - 파라미터에서 '..'은 파라이터의 타입과 파라미터 수가 상관없타는 표현
  - 매칭 조건
    - 접근제어자? : 생략
    - 반환타입 : *
    - 선언타입? : 생략
    - 메소드이름 : *
    - 파라미터 : (..)
    - 예외? : 생략

**기본 매칭 예시**
```java
@Test
void nameMatch() {
  //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String)
  pointcut.setExpression("execution(* hello(..))");
  Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
}

@Test
void nameMatchStart1() {
  //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String)
  pointcut.setExpression("execution(* hel*(..))");
  Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
}

@Test
void nameMatchStart2() {
  //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String)
  pointcut.setExpression("execution(* *el*(..))");
  Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
}

@Test
void nameMatchFalse() {
  //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String)
  pointcut.setExpression("execution(* nono(..))");
  Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isFalse();
}

@Test
void packageExactMatch1() {
  //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String)
  pointcut.setExpression("execution(* hello.aop.member.MemberServiceImpl.hello(..))");
  Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
}

@Test
void packageExactMatch2() {
  //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String)
  pointcut.setExpression("execution(* hello.aop.member.*.*(..))");
  Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
}

@Test
void packageExactMatchFalse() {
  //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String)
  pointcut.setExpression("execution(* hello.aop.*.*(..))");
  Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isFalse();
}

@Test
void packageExactMatchSubPackage1() {
  //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String)
  pointcut.setExpression("execution(* hello.aop.member..*.*(..))");
  Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
}

@Test
void packageExactMatchSubPackage2() {
  //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String)
  pointcut.setExpression("execution(* hello.aop..*.*(..))");
  Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
}
```
  - hello.aop.member.*(1).*(2)
    - (1) : 타입
    - (2) : 메소드 이름
  - 패키지에서 '.' 과 '..'의 차이
    - '.' : 정학하게 해당 위치의 패키지
    - '..' : 해당 위치의 패키지와 그 하위 패키지도 포함

**타입 매칭**
```java
@Test
void superTypeExactMatchInternalFalse() throws NoSuchMethodException, SecurityException {
  //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String)
  pointcut.setExpression("execution(* hello.aop.member.MemberService.*(..))");

  Method internalMethod = MemberServiceImpl.class.getMethod("internal", String.class);
  Assertions.assertThat(pointcut.matches(internalMethod, MemberServiceImpl.class)).isFalse();
}
```
  - 부모 타입에 있는 메서드만 허용
    - 부모 타입을 표현식에 선언한 경우 부모 타입에서 선언한 메서드가 자식 타입에 있어야 매칭에 성공

**파라미터 매칭**
```java
// String 타입의 파라미터 허용
// (String)
@Test
void argsMatch() {
  //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String)
  pointcut.setExpression("execution(* *(String))");
  Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
}

// 파라미터가 없어야 함
// ()
@Test
void argsMatchNoArgs() {
  //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String)
  pointcut.setExpression("execution(* *())");
  Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isFalse();
}

// 정확히 하나의 모든 타입인 파라미터 허용
// (Xxx)
@Test
void argsMatchNoStar() {
  //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String)
  pointcut.setExpression("execution(* *(*))");
  Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
}

// 숫자와 무관하게 모든 타입의 모든 파라미터 허용
// 파라미터가 없어도 허용
// (), (Xxx), (Xxx, Xxx), ...
@Test
void argsMatchNoAll() {
  //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String)
  pointcut.setExpression("execution(* *(..))");
  Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
}

// String 타입으로 시작하고 이후 숫자와 무관하게 모든 타입의 모든 파라미터 허용
// (String), (String, Xxx), (String, Xxx, Xxx), ...
@Test
void argsMatchNoComplex() {
  //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String)
  pointcut.setExpression("execution(* *(String, ..))");
  Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
}
```
  - execution 파라미터 매칭 규칙
    - (String) : 정확하게 String 타입 파라미터
    - () : 파라미터가 없어야 함
    - (*) : 정확히 하나의 모든타입인 파라미터
    - (*, *) : 정확히 두개의 모든타입인 파라미터
    - (..) : 숫자와 무관하게 모든 타입인 모든 파라미터. 파라미터가 없어도 됨.
    - (String, ..) : String 타입으로 시작하고 이후 숫자와 무관하게 모든 타입인 모든 파라미터
      - (String), (String, Xxx), (String, Xxx, Xxx) 허용

### within
특정 타입 내의 조인 포인트들로 매칭을 제한한다. 즉, 해당 타입이 매칭되면 그 안의 메서드(조인 포인트)들이 자동으로 매칭된다.
기본 문법은 execution에서 타입부분과 사용한것과 유사하다.

```java
@Test
void withinExact() {
  pointcut.setExpression("within(hello.aop.member.MemberServiceImpl)");
  Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
}
```

주의 사항으로는 execution과는 달리 표현식에 부모 타입을 지정하면 안되고 정확하게 타입이 맞아야 한다.

### args
인자가 주어진 타입의 인스턴스인 조인 포인트로 매칭한다.
기본 문법은 execution의 args 부분과 같다.

**execution과 args의 차이점**
  - execution은 파라미터 타입이 정확하게 매칭되어야 함
    - execution은 클래스에 선언된 정보를 기반으로 판당(정적)
  - args는 부모 타입을 허용 함
    - args는 실제 넘어온 파라미터 객체 인스턴스를 보고 판단(동적)

```java
/**
 * execution(* *(java.io.Serializable)): 메서드의 시그니처로 판단 (정적)
 * args(java.io.Serializable): 런타임에 전달된 인수로 판단 (동적)
 */
@Test
void argsVsExecution() {
  //public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String)

  // args
  Assertions.assertThat(pointcut("args()")
    .matches(helloMethod, MemberServiceImpl.class)).isFalse();
  Assertions.assertThat(pointcut("args(..)")
    .matches(helloMethod, MemberServiceImpl.class)).isTrue();
  Assertions.assertThat(pointcut("args(*)")
    .matches(helloMethod, MemberServiceImpl.class)).isTrue();
  Assertions.assertThat(pointcut("args(String,..)")
    .matches(helloMethod, MemberServiceImpl.class)).isTrue();
  Assertions.assertThat(pointcut("args(String)")
    .matches(helloMethod, MemberServiceImpl.class)).isTrue();
  Assertions.assertThat(pointcut("args(java.io.Serializable)")
    .matches(helloMethod, MemberServiceImpl.class)).isTrue();
  Assertions.assertThat(pointcut("args(Object)")
    .matches(helloMethod, MemberServiceImpl.class)).isTrue();

  // execution
  Assertions.assertThat(pointcut("execution(* *(String))")
    .matches(helloMethod, MemberServiceImpl.class)).isTrue();
  Assertions.assertThat(pointcut("execution(* *(java.io.Serializable))") //매칭 실패
    .matches(helloMethod, MemberServiceImpl.class)).isFalse();
  Assertions.assertThat(pointcut("execution(* *(Object))")               //매칭 실패
    .matches(helloMethod, MemberServiceImpl.class)).isFalse();
}
```

agrs 지시자는 단독으로 사용되기 보다는 파라미터 바인딩에서 주로 사용된다.

### @target, @within
@target, @within은 다음과 같이 타입에 있는 어노테이션으로 AOP 정용 여부를 판단한다.
  - @target
    - 실행 객체의 클래스에 주어진 타입의 어노테이션이 있는 조인 포인트
    - 인스턴스의 모든 메소드를 조인 포인트로 적용
      - 부모 클래스의 메소드 까지 어드바이스를 적용
    - @target(MyAopAnnotation)
      - 예시) @target(hello.aop.member.annotation.ClassAop)
  - @within
    - 주어진 어노테이션이 있는 타입 내 조인 포인트
    - 해당 타입 내에 있는 메소드만 조인 포인트로 적용
      - 자기 자신의 클래스에 정의된 메소드에만 어드바이스를 적용
    - @within(MyAopAnnotation)
      - 예시) @within(hello.aop.member.annotation.ClassAop)

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface ClassAop { 
}
```

```java
@Slf4j
@SpringBootTest
public class AtTargetAtWithinTest {

  ...

  static class Parent {
      public void parentMethod() {} //부모에만 있는 메서드
  }

  @ClassAop
  static class Child extends Parent {
      public void childMethod() {}
  }

  @Slf4j
  @Aspect
  static class AtTargetAtWithinAspect {
    //@target: 인스턴스 기준으로 모든 메서드의 조인 포인트를 선정, 부모 타입의 메서드도 적용
    @Around("execution(* hello.aop..*(..)) && @target(hello.aop.member.annotation.ClassAop)")
    public Object atTarget(ProceedingJoinPoint joinPoint) throws Throwable {
      log.info("[@target] {}", joinPoint.getSignature());
      return joinPoint.proceed();
    }

    //@within: 선택된 클래스 내부에 있는 메서드만 조인 포인트로 선정, 부모 타입의 메서드는 적용되지 않음
    @Around("execution(* hello.aop..*(..)) && @within(hello.aop.member.annotation.ClassAop)")
    public Object atWithin(ProceedingJoinPoint joinPoint) throws Throwable {
      log.info("[@within] {}", joinPoint.getSignature());
      return joinPoint.proceed();
    }
  }
}
```

@target, @within 지시자는 파라미터 바인딩에서 함꼐 사용된다. 

> **주의**
> args, @args, @target은 보통 단독으로 사용하면 안된다.
> 위 예제를 보면 execution(* hello.app..*(..))을 통해 적용 대상을 제한하였다.
> 그 이유는,
> args, @args, @target 지시자는 실제 객체 인스턴스가 생성되고 실행 될떄 어드바이스 적용 여부를 확인할 수 있다.
> 실행 시점에 일어나는 포인트컷 적용 여부도 결국 프록시가 있어야 실행 시점에 판단할 수 있따.
> 프록시가 없다면 판단 자체가 불가능 하다. 그런데 스프링 컨테이너가 프록시를 생성하는 시점은 스프링 컨테이너가 만들어지는
> 어플리케이션 로딩 시점에 적용 할 수 있다. 따라서 args, @args, @target 같은 포인트컷 지시자가 있다면
> 스프링은 모든 스프링 빈에 AOP를 적용하려고 시도한다.
> 이와 같이 모든 스프링 빈에 AOP 프록시를 적용하려고 하면 스프링이 내부에서 사용하는 빈 중에서는 final로 지정된 빈들도 있기 떄문에
> 오류가 발생할 수 있다.
> 그러므로 args, @args, @target와 같은 표현식은 최대한 프록시 적용 대상을 축소하는 표현식과 함꼐 사용해야 한다.

### @annotation, @args
### @bean
### 매개변수 전달
### @this, @target

---
참고
 - 스프링 핵심 원리 - 고급편(김영한)

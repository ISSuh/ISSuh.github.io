---
title: Distributed Systems - concurrency control
date: 2024-06-12 22:56:00 +0900
categories: [System Design, Distributed Systems]
published: true
tags:
  - System Design
  - Distributed Systems
---

### 직렬화

적절하게 격리되지 않은 동시 트랜잭션으로 인해 몇가지 잠재적인 이상이 발생한다.
시스템을 이러한 이상 현상으로 부터 보호하기 위해 트랜잭션이 엄격히 직렬화가 되어야 한다.

### 동시성 제어 메커니즘

동시성 제어에는 두가지 주요 메커니즘이 존재한다.

- 비관적 동시성 제어(Pessimistic concurrency control)
  - 직렬화 가능성을 위반할 것으로 에상되는 경우 트랜잭션을 차단하고 안전하게 수행할 수 있을때 트랜잭션을 재개한다.
  - 일반적으로 다른 트랜잭션이 동일한 데이터를 동시에 처리하는 것을 방지하기 위해 트랜잭션이 처리하는 데이터에 대한 잠금을 획득함으로써 달성된다.
  - 거래 간 충돌이 많지 않은 경우에 좋은 성능을 발휘한다.
  - 읽기 전용 트랜잭션이 많고 쓰기 트랜잭션이 적은 경우나 대부분의 트랜잭션이 다른 데이터를 다루는 경우
- 낙관적 동시성 제어(Optimistic concurrency control)
  - 트랜잭션이 끝날때 까지 트랜잭션이 규칙을 준수하는지 확인하는 것을 지연시킨다.
  - 커밋이 직렬화 규칙을 위반하면 트랜잭션이 중단된 다음 다시 시작되어 처음부터 다시 실행된다.
  - 잠금으로 인해 약간의 오버헤드를 발생하지만, 출동하는 트랜잭션이 많이 포함된 워크로드에서 더 나은 성능을 발휘한다.

### 비관적 동시성 제어의 2-Phase locking (2PL)

2PL은 동시 트랜잭션이 방해받지 않도록 잠금을 사용하는 비관적 동시성 제어 프로토콜이다.
이러한 잠금은 트랜잭션에서 레코드를 사용하고 있음을 나타내므로 다른 트랜잭션에서 해당 레코드를 사용해도 안전한지 여부를 확인할 수 있다.

이 프로토콜에는 두가지 기본 유형의 잠금이 사용된다.

- 독점 쓰기 잠금(Write (exclusive) locks)
  - 레코드가 기록(삽입, 업데이트, 삭제) 될때 잠금을 획득
- 공유 읽기 잠금(Read (shared) locks)
  - 레코드를 읽을때 잠금 획득

#### 독점 쓰기 잠금과 공유 읽기 잠금 간의 상호 작용

읽기 잠금은 다른 트랜잭션의 읽기를 차단하지 않는다.
동시에 여러 읽기 잠금을 획득할 수 있기 때문에 공유 라고도 한다.

읽기 잠금은 다른 트랜잭션의 쓰기를 차단한다.
다른 트랜잭션은 읽기 작업이 완료되고 읽기 잠금이 해제될 때까지 기다려야 하며 이후 다음 쓰기 잠금을 획득하고 쓰기 작업을 수행해야 한다.

쓰기 잠금은 다른 트랜잭션의 읽기 및 쓰기를 모두 차단하므로 독점 잠금 이라고도 한다.
다른 트랜잭션은 쓰기 작업이 완료되고 쓰기 잠금이 해제될 때까지 기다려야 하며 이후 적절한 잠금을 획득하고 진행하려고 시도한다.

![image](https://cdn.educba.com/academy/wp-content/uploads/2020/03/Lock-Based-Protocols-in-DBMS-03.jpg)

### 낙관적 동시성 제어

낙관적 동시성 제어에서의 트랜잭션은 데이터 항목에 대한 잠금을 획득하지 않고도 데이터 항목에 접근할 수 있다.

이 방법에는 트랜잭션이 다음 세가지 단계로 실행된다.

- 시작
- 읽기 및 수정
- 검증 및 커밋/롤백

#### 시작 단계

이 단계에서는 트랜잭션에 시작 타임스탬프 라고 하는 트랜잭션의 시작을 표시하는 고유한 타임스탬프가 할당된다.

#### 읽기 및 수정

이 단계에서 트랜잭션은 읽기 및 쓰기 작업을 잠정적으로 실행한다. 즉, 항목이 수정되면 해당 항목의 복사본이 임시 로컬 저장 위치에 기록된다.
읽기 작업은 먼저 이 위치에 있는 항목의 복사본을 확인하고 해당 복사본이 있으면 반환한다.
그렇지 않으면 데이터베이스에서 일반 읽기 작업을 수행한다.

#### 검증 및 커밋/롤백 단계

모든 작업이 실행되면 트랜잭션이 이 단계로 들어갑니다.
이 단계에서 트랜잭션은 이 트랜잭션이 액세스한 데이터를 수정하고 이 트랜잭션의 시작 시간 이후에 시작된 다른 트랜잭션이 있는지 확인한다.
다른 트랜잭션이 있는 경우 트랜잭션이 중단되고 처음부터 다시 시작되어 새 타임스탬프를 획득한다.
다른 트랜잭션이 없는 경우 트랜잭션이 커밋될 수 있습니다.

트랜잭션 커밋은 쓰기 작업의 모든 값을 로컬 저장소에서 다른 트랜잭션이 액세스하는 공용 데이터베이스 저장소로 복사하여 수행된다.

#### 유효성 검사를 구현하는 방법

트랜잭션의 유효성을 검사하기 위해 두가지 방법을 사용할 수 있다.

- 버전 확인
  - 모든 데이터 항목에 버전을 할당하고 버전에 대한 확인을진행하는 방법
  - 트랜잭션이 항목에 액세스할 때마다 해당 시점의 버전 번호를 추적
- 타임스탬프 순서
  - 트랜잭션에 할당된 타임스탬프를 사용
  - 각 트랜잭션은 읽기 또는 쓰기 작업으로 액세스되는 항목을 추적
  - 트랜잭션은 유효하지 않으며 중단하고 새로운 타임스탬프를 사용하여 처음부터 다시 시작해야 함
  - 트랜잭션은 유효하면 트랜잭션이 커밋되고 다음 타임스탬프를 할당

---

참고

- [Distributed Systems for Practitioners](https://www.educative.io/courses/distributed-systems-practitioners)

---
title: Spring Framework DB - 스프링 트랜잭션 전파
date: 2023-10-18 16:00:00 +0900
categories: [Web, Spring Framework]
published: true
tags:
- Web
- Spring Framework
- DataBase
---

### 트랜잭션 전파(propagation)
트랜잭션을 각각 사용하는 것이 아닌 하나의 트랜잭션이 이미 진행중인 상황에서 또다른 트랜잭션이 수행될떄,
어떤식으로 동작할지 결졍하는 것을 트랜잭션 전파(propagation) 이라 함.

![Alt text](/assets/posts/img/spring/spring_db_1/spring_db_08_01.png)
  - 외부 트랜잭션이 수행중이고, 아직 끝나기 전 내부 트랜잭션이 수행
    - 먼저 실행된 트랜잭션이 상대적으로 밖에 있기 떄문에 외부 트랜잭션이라 함
    - 외부 트랜잭션이 실행되고 있는 도중 호출되기 떄문에 마치 내부에 있는것으로 보여 내부 트랜잭션이라 함
  - 이 경우 스프링에선 외부 트랜잭션과 내부 트랜잭션을 묶어서 하나의 트랜잭션을 만들어 줌
    - 내부 트랜잭션이 외부 트랜잭션에 참여
    - 위와 같은 방식이 기본동작이며 옵션을 통해 다른 동작방식으로 선탱할 수 있음

![Alt text](/assets/posts/img/spring/spring_db_1/spring_db_08_02.png)
  - 스프링에선 개념적으로 물리 트랜잭션, 논리 트랜잭션이라고 나눔
    - 물리 트랜잭션은 실제 데이터베이스에 적용되는 트랜잭션을 뜻함
      - 실제 커넥션을 통해 트랜잭션을 시작(setAutoCommit(false))하고, 실제 커넥션을 통해 커밋, 롤백하는 단위
    - 논리 트랜잭션은 트랜잭션 매니저를 통해 트랜잭션을 사용하는 단위
  - 논리 트랜잭션들은 하나의 물리 트랜잭션으로 묶임
    - 기본인 REQUIRED 전파옵션을 사용할 할시, 이러한 논리 트랜잭션 개념은 트랜잭션이 진행되는 중에 내부에 추가로 트랜잭션을 사용하는 경우에 나타남

이와 같이 물리 트랜잭션, 논리 트랜잭션으로 나누면 다음과 같은 단순한 원칙을 만들 수 있음
  - **모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋 됨**
  - **하나의 논리 트랜잭션이라도 롤백되면 물리 트랜잭션은 롤백 됨**

![Alt text](/assets/posts/img/spring/spring_db_1/spring_db_08_03.png)
  - 모든 논리 트랜잭션이 커밋되었으므로 물리 트랜잭션도 커밋

![Alt text](/assets/posts/img/spring/spring_db_1/spring_db_08_04.png)
  - 외부 트랜잭션이 롤백되었으므로 내부 트랜잭션이 커밋되어도 물리 트랜잭션은 롤백
  - 반대로 내부 트랜잭션이 롤백, 외부 트랜잭션이 커밋되어도 물리 트랜잭션은 롤백

이러한 외부 트랜잭션과 내부 트랜잭션에 대하여 테스트 코드로 확인해 볼 수 있음

```java
@Test
void inner_commit() {
  log.info("외부 트랜잭션 시작");
  TransactionStatus outer = txManager.getTransaction(new DefaultTransactionAttribute());
  log.info("outer.isNewTransaction()={}", outer.isNewTransaction());
  
  log.info("내부 트랜잭션 시작");
  TransactionStatus inner = txManager.getTransaction(new DefaultTransactionAttribute());
  log.info("inner.isNewTransaction()={}", inner.isNewTransaction());
  log.info("내부 트랜잭션 커밋");
  txManager.commit(inner);
  
  log.info("외부 트랜잭션 커밋");
  txManager.commit(outer);
}
```
 - 외부 트랜잭션 수행중 내부 트랜잭션을 추가로 수행
  - 외부 트랜잭션은 처음 수행된 트랜잭션이며 이 경우 신규 트랜잭션(isNewTransaction=true)가 됨
  - 내부 트랜잭션을 시작하는 시점에는 이미 외부 트랜잭션이 진행중인 상태이며 이 경우 내부 트랜잭션은 외부 트랜잭견에 참여하는 형태가 됨
  - 트랜잭션 참여
    - 내부 트랜잭션이 외부 트랜잭션에 참여한다는 뜻은 내부 트랜잭션이 외부 트랜잭션을 그대로 이어 받아 따른다는 뜻
    - 다른 관점으로 보면 외부 트랜잭션의 범위가 내부 트랜잭션까지 넓어진다는 뜻
    - 외부에서 시작된 물리적인 트랜잭션의 범위가 내부 트랜잭션까지 넓어진다는 뜻
    - 즉, **외부 트랜잭션과 내부 트랜잭션이 하나의 물리 트랜잭션으로 묶여버리게 됨**
  - 내부 트랜잭션은 이미 진행되고 있는 트랜잭션에 참여하므로 신규 트랜잭션이 아님(isNewTransaction=false)

```
# 실행 결과
외부 트랜잭션 시작
Creating new transaction with name [null]: 
PROPAGATION_REQUIRED,ISOLATION_DEFAULT
Acquired Connection [HikariProxyConnection@1943867171 wrapping conn0] for JDBC 
transaction
Switching JDBC Connection [HikariProxyConnection@1943867171 wrapping conn0] to 
manual commit
outer.isNewTransaction()=true

내부 트랜잭션 시작
Participating in existing transaction
inner.isNewTransaction()=false

내부 트랜잭션 커밋
외부 트랜잭션 커밋
Initiating transaction commit
Committing JDBC transaction on Connection [HikariProxyConnection@1943867171 
wrapping conn0]
Releasing JDBC Connection [HikariProxyConnection@1943867171 wrapping conn0] 
after transaction
```
  - 내부 트랜잭션을 시작할 때  Participating in existing transaction 이라는 메시지를 확인할 수  있음. 이 메시지는 내부 트랜잭션이 기존에 존재하는 외부 트랜잭션에 참여한다는 뜻
  - 외부 트랜잭션만 물리 트랜잭션을 시작하고, 커밋 함
  - 내부 트랜잭션이 실제 물리 트랜잭션을 커밋하면 트랜잭션이 끝나버리기 때문에, 트랜잭션을 처음 시작한 외부 트랜잭션 까지 이어갈 수 없음. 그러므로 내부 트랜잭션은 DB 커넥션을 통한 물리 트랜잭션을 커밋하면 안됨
  - 스프링은 이렇게 여러 트랜잭션이 함꼐 사용되는 경우, **처음 트랜잭션을 시작한 외부 트랜잭션이 실제 물리 트랜잭션을 관리**하도록 함. 이를 통해 트랜잭션 중복 커밋 문제를 해결 함

#### 트랜잭션 전파의 동작 흐름

![Alt text](/assets/posts/img/spring/spring_db_1/spring_db_08_05.png)
**요청 흐름 - 외부 트랜잭션**
  1.. txManager.getTransaction()을 호출하여 외부 트랙잭션을 시작
  2. 트랜잭션 매니저는 데이터소스를 통해 커넥션을 생성
  3. 생성한 커넥션을 수동 커밋 모드(setAutoCommit(false))로 설정(**물리 트랜잭션 시작**)
  4. 트랜잭션 매니저는 트랜잭션 동기화 매니저에 커넥션을 보관
  5. 트랜잭션 매니저는 트랜잭션을 생성하여 반환
    &nbsp;&nbsp;* 트랜잭션 매니저는 트랜잭션을 생성한 결과를 TransactionStatus에 담아서 반환하는데, 여기에 신규 트랜잭션의 여부가 담겨 있음.
  6. 로직 1이 수행되고, 커넥션이 필요한 경우 트랜잭션 동기화 매니저를 통해 트랜잭션이 적용된 커넥션을 획득하여 사용

**요청 흐름 - 내부 트랜잭션**
  7.  txManager.getTransaction() 를 호출해서 내부 트랜잭션을 시작
  8. 트랜잭션 매니저는 트랜잭션 동기화 매니저를 통해서 기존 트랜잭션이 존재하는지 확인
  9. 기존 트랜잭션이 존재하므로 기존 트랜잭션에 참여 함
    &nbsp;&nbsp;* 기존 트랜잭션에 참여한다는 뜻은 사실 아무것도 하지 않는다는 뜻
    &nbsp;&nbsp;* 이미 기존 트랜잭션인 외부 트랜잭션에서 물리 트랜잭션을 시작하였고 물리 트랜잭션이 시작된 커넥션을 트랜잭션 동기화 매니저에 담아두어 둔 상태
    &nbsp;&nbsp;* 이후 로직은 자연스럽게 트랜잭션 동기화 매니저에 보관된 기존 커넥션을 사용하게 됨
  10. 트랜잭션 매니저는 기존 생성되었던 트랜잭션을 찾아서 반환
    &nbsp;&nbsp;* 트랜잭션 매니저는 트랜잭션을 생성한 결과를 TransactionStatus 에 담아서 반환하는데, 여기에서  isNewTransaction 를 통해 신규 트랜잭션 여부를 확인할 수 있음. 여기서는 기존 트랜잭션에 참여했기  때문에 신규 트랜잭션이 아님(false)
  11. 로직2가 수행되고, 커넥션이 필요한 경우 트랜잭션 동기화 매니저를 통해 외부 트랜잭션이 보관한 커넥션을 획득해서 사용

![Alt text](/assets/posts/img/spring/spring_db_1/spring_db_08_06.png)
**응답 흐름 - 내부 트랜잭션**
  12. 로직2가 끝나고 트랜잭션 매니저를 통해 내부 트랜잭션을 커밋
  13. 트랜잭션 매니저는 커밋 시점에 신규 트랜잭션 여부에 따라 다르게 동작 함. 이 경우 신규 트랜잭션이 아니기 때문에 실제 커밋을 호출하지 않음.
    &nbsp;&nbsp;* 실제 커넥션에 커밋이나 롤백을 호출하면 물리 트랜잭션이 끝나버리기 때문에 아직 트랜잭션이 끝난 것이 아닌 이 시점에는 실제 커밋을 호출하면 안됨.
    &nbsp;&nbsp;* 물리 트랜잭션은 외부 트랜잭션을 종료할 때 까지 이어져야 함

**응답 흐름 - 외부 트랜잭션**
  14. 로직1이 끝나고 트랜잭션 매니저를 통해 외부 트랜잭션을 커밋
  15. 트랜잭션 매니저는 커밋 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다. 외부 트랜잭션은 신규 트랜잭션 이므로 DB 커넥션에 실제 커밋을 호출
  16. 트랜잭션 매니저에 커밋하는 것이 논리적인 커밋이라면, 실제 커넥션에 커밋하는 것을 물리 커밋이라 할 수 있음. 실제 데이터베이스에 커밋이 반영되고, 물리 트랜잭션도 끝난다

##### 트랜잭션 전파의 동작 흐름 정리
  - 주요 핵심은 트랜잭션 매니저에 커밋을 호출한다고 해서 항상 실제 커넥션에 물리 커밋이 발생하지 않는다는 것
  - 신규 트랜잭션인 경우에만 실제 커넥션을 사용하여 물리 커밋과 롤백을 수행함. 신규 트랜잭션이 아니면 실제 물리 커밋을 수행하지 않음
  - 트랜잭션이 내부에서 추가로 사용되면 트랜잭션 매니저에 커밋하는 것이 항상 물리 커밋으로 이어지지 않음. 그러므로 이러한 경우 논리 트랜잭션과 물리 트랜잭션으로 나뉘어 지게 됨. 또는 외부 트랜잭션과 내부 트랜잭션으로 나누어 설명하기도 함
  - 트랜잭션이 내부에서 추가로 사용되면 트랜잭션 매니저를 통해 논리 트랜잭션을 관리하고 모든 논리 트랜잭션이 커밋되면 물리 트랜잭션이 커밋 됨

#### 외부 롤백시 흐름
![Alt text](/assets/posts/img/spring/spring_db_1/spring_db_08_04.png)
내부 트랜잭션은 커밋이 되는데 외부에서 트랜잭션이 롤백이 된다면, 내부 트랜잭션안 에서 저장한 데이터도 모두 함께 롤백 됨

![Alt text](/assets/posts/img/spring/spring_db_1/spring_db_08_07.png)
**응답 흐름 - 내부 트랜잭션**
1, 로직2가 끝나고 트랜잭션 매니저를 통해 내부 트랜잭션을 커밋
2. 트랜잭션 매니저는 커밋 시점에 신규 트랜잭션 여부에 따라 다르게 동작 함. 이 경우 신규 트랜잭션이 아니기 때문에 실제 커밋을 호출하지 않음.
    &nbsp;&nbsp;* 실제 커넥션에 커밋이나 롤백을 호출하면 물리 트랜잭션이 끝나버리기 때문에 아직 트랜잭션이 끝난 것이 아닌 이 시점에는 실제 커밋을 호출하면 안됨.
    &nbsp;&nbsp;* 물리 트랜잭션은 외부 트랜잭션을 종료할 때 까지 이어져야 함

**응답 흐름 - 외부 트랜잭션**
3. 로직1이 끝나고 트랜잭션 매니저를 통해 외부 트랜잭션을 롤백
4. 트랜잭션 매니저는 롤백 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다. 외부 트랜잭션은 신규  트랜잭션이므로 DB 커넥션에 실제 롤백을 호출
5. 트랜잭션 매니저에 롤백하는 것이 논리적인 롤백이라면, 실제 커넥션에 롤백하는 것을 물리 롤백이라 할 수 있음. 실제 데이터베이스에 롤백이 반영되고, 물리 트랜잭션도 끝나게 됨

#### 내부 롤백시 흐름
![Alt text](/assets/posts/img/spring/spring_db_1/spring_db_08_08.png)
외부 롤백시의 흐름과 다르게 내부 트랜잭션은 롤백되고 외부 트랜잭션이 커밋되는 상황이라면 단순히 해결되지 않는 문제가 발생함.

이에 대하여 응답 흐름을 확인해보면 아래와 같음

![Alt text](/assets/posts/img/spring/spring_db_1/spring_db_08_09.png)
**응답 흐름 - 내부 트랜잭션**
1, 로직2가 끝나고 트랜잭션 매니저를 통해 내부 트랜잭션을 롤백
2. 트랜잭션 매니저는 롤백 시점에 신규 트랜잭션 여부에 따라 다르게 동작함. 이 경우 신규 트랜잭션이 아니기 때문에 실제 롤백을 호출하지 않음
  &nbsp;&nbsp;* 실제 커넥션에 커밋이나 롤백을 호출하면 물리 트랜잭션이 끝나버리기 때문에 아직 트랜잭션이 끝난 것이 아닌 이 시점에는 실제 커밋을 호출하면 안됨.
  &nbsp;&nbsp;* 물리 트랜잭션은 외부 트랜잭션을 종료할 때 까지 이어져야 함
3. 내부 트랜잭션은 물리 트랜잭션을 롤백하지 않는 대신에 트랜잭션 동기화 매니저에 **rollbackOnly=true** 라는 표시를 해둠

**응답 흐름 - 외부 트랜잭션**
4. 로직1이 끝나고 트랜잭션 매니저를 통해 외부 트랜잭션을 커밋
5. 트랜잭션 매니저는 커밋 시점에 신규 트랜잭션 여부에 따라 다르게 동작 함. 외부 트랜잭션은 신규 트랜잭션이므로 DB 커넥션에 실제 커밋을 호출해야 하지만, 트랜잭션 동기화 매니저에 **롤백 전용(*rollbackOnly=true*) 표시**가 있는지 확인화고, 롤백 전용 표시가 있으면 물리 트랜잭션을 커밋하는 것이 아니라 롤백을 진행 함
6. 실제 데이터베이스에 롤백이 반영되고, 물리 트랜잭션도 끝남
7. 트랜잭션 매니저에 커밋을 호출한 개발자 입장에서는 분명 커밋을 기대했는데 롤백 전용 표시로 인해 실제로는 롤백이 되었기 때문에 이를 **UnexpectedRollbackException** 런타임 예외를 통해 알림
  &nbsp;&nbsp;* 시스템 입장에서는 커밋을 호출했지만 롤백이 되었다는 것은 분명하게 알려주어야 함
  &nbsp;&nbsp;* 예를 들어서 고객은 주문이 성공했다고 생각했는데, 실제로는 롤백이 되어서 주문이 생성되지 않은 상황
  &nbsp;&nbsp;* 스프링은 이 경우 **UnexpectedRollbackException** 런타임 예외를 던져 커밋을 시도했지만 기대하지 않은 롤백이 발생했다는 것을 명확하게 알려줌

#### 트랜잭션 전파 흐름 정리
  - 논리 트랜잭션이 하나라도 롤백이 되면 물리 트랜잭션 또한 롤백을 진행함
  - 내부 논리 트랜잭션이 롤백되면 롤백 전용 마크를 표시함
  - 외부 트랜잭션을 커밋 할 떄 롤백 전용 마크를 확인하고, 롤백 전용 마크가 표시되어 있다면 물리 트랜잭션을 롤백한뒤, 만일 외부 트랜잭션이 롤백이 아닌 커밋을 한다면 UnexpectedRollbackException 예외를 던짐

### REQUIRES_NEW
### 다양한 전파 옵션

### 참고
 - 스프링 DB - 데이터 접근 활용 기술(김영한)
